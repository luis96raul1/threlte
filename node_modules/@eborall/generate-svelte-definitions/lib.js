/**
 * @file This file is all the functions that power "npm run magic" in our Svelte projects
 * @author Eborall
 */

/**
 * @typedef {import("@eborall/generate-definition-json").InputGroup} FieldTuple
 * @typedef {import("@eborall/generate-definition-json").Field} Field
 * */
import fs from 'fs'

import {DefaultValue, generateDefinitions, LinkSection, Toggle, ToggleOption} from '@eborall/generate-definition-json'

/**
 * @typedef {Object} Link
 * @description An object representing a hyperlink.
 * @property {string} url - The URL of the hyperlink.
 * @property {"_blank" | "_self"} target - The target of the hyperlink.
 * @property {string} [title] - The title of the hyperlink.
 */

/**
 * @typedef {Object} PropsExport
 * @description A Svelte statement like "export let isVisible: boolean = false" which we'll use to generate our JSON
 * @property {string} [keyword] - The keyword.
 * @property {*} [defaultValue] - The default value.
 * @property {string} [type] - The type.
 * @property {string} [tooltip] - The tooltip.
 */

/**
 * @typedef {Object} WebComponent
 * @description An object representing a Web Component.
 * @property {string} [componentName] - Name of the web-component (<rf-nav>)
 * @property {PropsExport[]} [props] - Keywords.
 */

// A regex to detect if "2Levels" or "3level" is used
const LEVEL_LIMIT_REGEX = /(\d+)levels?/i

/**
 * Function to convert camelCase to Sentence case
 * @param {string} str
 * @returns {string}
 */
function camelToSentenceCase(str) {
  if (!str) return ''

  return str
    .replace(/([A-Z])/g, ' \$1')
    .replace(/^./, function (str) { return str.toUpperCase() })
}

/**
 * Read the "main" file and see what .svelte files are being exported
 * @returns {string[]}
 */
const getSvelteImportsFromMain = () => {
  try {
    const mainFile = fs.readFileSync('./src/main.ts', 'utf-8')
    return mainFile.match(/['"].*?['"]/g)
  } catch {
    new Error('No main.ts file')

    return []
  }
}


/**
 * Get keyword from export statement
 * @param {string} exportStatement
 * @returns {string|null}
 */
export const getKeyword = (exportStatement) => exportStatement?.split(/[:=//]/)?.[0]?.trim() || null

/**
 * Get TypeScript type from export statement
 * @param {string} exportStatement
 * @returns {string|null}
 */
export const getType = (exportStatement) => exportStatement.includes(':')
  ? exportStatement.split(/[:=//]/)?.[1]?.trim()
  : null

/**
 * Turn JS comment into tooltip text
 * @param {string} exportStatement
 * @returns {string|null}
 */
export const getTooltip = (exportStatement) => {
  const doubleSlash = exportStatement.includes('//')

  if (!doubleSlash) return null

  // Split by //
  const doubleSlashSplit = exportStatement.split('//')

  // Get the last // which will be the comment. Trying to avoid https://
  return doubleSlashSplit?.[doubleSlashSplit.length - 1]?.replace('//', '')?.trim() || null
}

/**
 * Get the default value from the export statement
 * @param {string} exportStatement
 * @returns {string|null}
 */
export const getDefaultValue = (exportStatement) => {
  const equals = exportStatement.match(/\=/g)

  // No equals, no defaultValue assignment
  if (!equals) return null

  const equalsCount = equals?.length
  const equalsSplit = exportStatement.split('=')

  if (equalsCount === 1) return equalsSplit?.[1]?.replace(/[\'\"]/g, '')?.trim()

  // If there is more than 1 equal sign (like in a url with a query parameter),
  // we need get rid of the first and join the rest
  const [, ...rest] = equalsSplit
  return rest.join('=').replace(/[\'\"]/g, '').trim()
}

/**
 * Remove the tooltip from the string to make other functions easier
 * @param {string|null} tooltip
 * @param {string} cleanData
 * @returns {string}
 */
const removeTooltipFromString = (tooltip, cleanData ) => tooltip
  ? cleanData?.replace(new RegExp(`// ?${tooltip}`), '')
  : cleanData

/**
 * Turns Svelte export string into "props" we can parse
 * @param {string} exportStatement
 * @returns {PropsExport}
 */
export const parseExportStatement = (exportStatement) => {
  const cleanData = exportStatement.replace('export let ', '')

  const keyword = getKeyword(cleanData)
  const tooltip = getTooltip(cleanData)
  const defaultValue = getDefaultValue(removeTooltipFromString(tooltip, cleanData))
  const type = getType(cleanData)

  return {
    keyword,
    type,
    defaultValue,
    tooltip
  }
}

/**
 * Read .svelte files and scrape exposed props
 * @param {string[]} svelteSources
 * @return {WebComponent[]}
 */
export const processSvelteToWebComponents = (svelteSources) => (
  svelteSources.map(file => {
    const svelteContents = fs.readFileSync('./src/' + file.replace('./', '').replace(/['"]/g, ''), 'utf-8')
    const exportStatements = svelteContents.match(/export let [^\n]*/g)
    const customElement = getCustomElement(svelteContents)

    return {
      componentName: customElement,
      props: exportStatements?.map(exportStatement => parseExportStatement(exportStatement)) || []
    }
  })
)

/**
 * Convert to RainFocus keyword format
 * @param {string} keyword
 * @returns {string}
 */
const getFormattedKeyword = (keyword) => `[%${keyword}%]`

/**
 * Get the customElement from .svelte file
 * @param {string} fileInput
 * @returns {string|null} Returns the web-component, otherwise null
 */
export const getCustomElement = (fileInput) => {
  // Define a regex to find the customElement pattern
  const customElementStringRegex = /customElement=["']([^"]*)["']/
  const customElementStringMatch = customElementStringRegex.exec(fileInput)

  // If the customElement pattern is found as a string, return it
  if (customElementStringMatch) return customElementStringMatch[1]

  // Define a regex to find the customElement object pattern
  const customElementObjectRegex = /customElement=\{/
  const customElementObjectMatch = customElementObjectRegex.exec(fileInput)

  // If the customElement pattern is not found as an object, return null
  if (!customElementObjectMatch) return null

  // Define a regex to find the tag pattern within the customElement object
  const tagRegex = /tag: ?["'](.*?)["']/
  const tagMatch = tagRegex.exec(fileInput)

  // If the tag pattern is found, clean it up and return it
  if (tagMatch?.[1]) {
    // Remove spaces, single quotes, and double quotes from the tag
    return tagMatch[1].replace(/[ '"]/g, '')
  }

  // If the tag pattern is not found, return null
  return null
}

/**
 * Generate web-component HTML, and add keywords as the props
 * @param {string[]} keywords
 * @param {string} webComponent The web component name (i.e. <rf-nav>)
 * @returns {string}
 */
const generateWebComponentTemplate = (keywords, webComponent) => {
  if (!keywords) return ''

  const keywordData = keywords?.map(keyword => {
    const isLink =  keyword.toLowerCase().includes('link') || false
    const keywordOutput = getFormattedKeyword(keyword)

    // The JSON will contain double-quotes, so we need link attributes to be single quote
    const quoteType = isLink ? `'` : `"`

    return `${keyword}=${quoteType}${keywordOutput}${quoteType}`
  })

  return `<${webComponent} ${keywordData.join(' ')}></${webComponent}>`
}


/**
 * Generates the HTML output
 * @param {WebComponent[]} webComponents
 * @param {string|undefined} hostedScriptUrl
 * @returns {string}
 */
const generateHtmlOutput = (webComponents, hostedScriptUrl) => {
  const globalStyling = getGlobalStyling()
  const hostedSnippet = `<script type="module" src="${hostedScriptUrl || ''}"></script>`
  const embeddedSnippet = `<script type="module">${fs.readFileSync('./dist/main.min.js', 'utf-8').replace('\n', '')}</script>`

  return `${webComponents
    .map(
      ({ componentName, props }) =>
        generateWebComponentTemplate(props.map(item => item.keyword), componentName)
    )
    .join('\n')}
${hostedScriptUrl ? hostedSnippet : embeddedSnippet}
${globalStyling || ''}`
}

/**
 * Svelte CSS is scoped to the Shadow DOM. When we need to reach the real DOM, we throw it in this global CSS sheet
 * @returns {null|string}
 */
const getGlobalStyling = () => {
  try {
    const globalStyles = fs.readFileSync('./src/lib/global.css')
    return globalStyles ? `<style>\n${globalStyles}</style>` : null
  } catch {
    return null
  }
}

/**
 * Formats keyword into Field for JSON generation
 * @property {PropsExport} props
 * @returns {FieldTuple}
 */
const propsToFields = (props) => {
  const title = camelToSentenceCase(props.keyword?.replace(LEVEL_LIMIT_REGEX, '')) || ''
  const keyword = props?.keyword || ''
  const tooltip = props?.tooltip || ''
  const extraProps = getExtraProps(props)

  return [title, keyword, tooltip, {...extraProps}]
}

/**
 * Returns a RFToggle based on a TypeScript union type like "fixed"|"float"
 * @param {string} type
 * @returns {Toggle|{}}
 */
const tsUnionTypeToToggle = (type) => {
  // If it contains null. it's not a true type
  if (type.includes('null')) return {}

  const optionStrings = type.split('|').map(item => item.replace(/['"]+/g, '').trim())
  const options = optionStrings.map(option => new ToggleOption(camelToSentenceCase(option), option))

  return new Toggle(options)
}

/**
 * Automatically adds props to the Field object to make life easier
 * @property {PropsExport} props
 * @returns {Field}
 */
export const getExtraProps = (props) => {
  const { keyword, type, defaultValue } = props
  const lowercaseKeyword = props.keyword?.toLowerCase()

  // Link Section if keyword contains "link"
  if (lowercaseKeyword.includes('link')) {
    // Automatically set levelLimit
    const match = lowercaseKeyword.match(LEVEL_LIMIT_REGEX)
    const levelLimit = match ? Number(match[1]) : 1

    return new LinkSection(keyword + 'Data',null,35, true, levelLimit || 1)
  }

  return {
    ...(type?.includes('|') ? tsUnionTypeToToggle(type) : {}),
    ...(defaultValue && defaultValue !== "null" ? new DefaultValue(defaultValue.replace(/['"]+/g, '')): {})
  }
}

/**
 * Our main function. It creates the HTML document, as well as the JSON
 * @property {string|undefined} hostedScriptUrl
 */
export const main = (hostedScriptUrl) => {
  const webComponents = processSvelteToWebComponents(getSvelteImportsFromMain())

  webComponents.forEach(component => {
    const webComponentName = component.componentName || 'yeet'
    const jsonFields =  component.props.map(prop => propsToFields(prop))

    // Create HTML file
    fs.writeFileSync(`./dist/${webComponentName}.html`, generateHtmlOutput([component], hostedScriptUrl))

    // Create JSON file
    generateDefinitions([{ name: webComponentName, groups: [{ title: 'Options', defaultOpen: true, fields: jsonFields}] }], './dist/')
  })
}

export default main
