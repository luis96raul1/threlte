"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDefinitions = exports.toCamelCase = void 0;
const fs = require('fs');
const utils_1 = require("./utils");
const toCamelCase = (str) => (str
    .replace(/^\w|[A-Z]|\b\w|\s+/g, function (match, index) {
    if (+match === 0)
        return '';
    return index === 0 ? match.toLowerCase() : match.toUpperCase();
})
    .replace(/[^a-zA-Z0-9\s]/g, ''));
exports.toCamelCase = toCamelCase;
// All group names
const GROUP_NAMES = {
    0: 'groupOne',
    1: 'groupTwo',
    2: 'groupThree',
    3: 'groupFour',
    4: 'groupFive',
    5: 'groupSix',
    6: 'groupSeven',
    7: 'groupEight'
};
const mockData = {
    label: '',
    keyword: '',
    type: utils_1.FIELD_TYPES.TEXT
};
const getFieldType = (title, customData) => {
    if (customData === null || customData === void 0 ? void 0 : customData.type)
        return customData.type;
    if (customData === null || customData === void 0 ? void 0 : customData.options)
        return utils_1.FIELD_TYPES.TOGGLE;
    if (title && title.toLowerCase().includes('color'))
        return utils_1.FIELD_TYPES.COLOR;
    return utils_1.FIELD_TYPES.TEXT;
};
// Generate a Single Definition
const generateFieldsData = (fields) => {
    return fields.map(field => {
        const [label, keyword, tooltip, customData] = field;
        const fieldType = getFieldType(label, customData);
        return Object.assign(Object.assign(Object.assign({}, mockData), { keyword: keyword || (0, exports.toCamelCase)(label), label: label, type: fieldType, tooltip: tooltip, placeholder: !(customData === null || customData === void 0 ? void 0 : customData.placeholder) && fieldType === utils_1.FIELD_TYPES.COLOR ? '#f5f5f5 or rgb(25, 25, 25)' : customData === null || customData === void 0 ? void 0 : customData.placeholder }), customData);
    });
};
// Generate Multiple Definitions
const generateDefinitions = (definitionsToGenerate, folderName = 'branding-definitions') => {
    // Generate each definition
    for (const definition of definitionsToGenerate) {
        const { groups, name } = definition;
        const [firstItem] = groups;
        const isSingleGroup = firstItem && Array.isArray(firstItem);
        let definitionData = {};
        for (const [groupIndex, groupData] of Object.entries(groups)) {
            const groupName = isSingleGroup ? 'groupOne' : Object.entries(GROUP_NAMES)[Number(groupIndex)][1];
            const groupDataTyped = groupData;
            definitionData[groupName] = {
                title: groupDataTyped.title,
                subTitle: groupDataTyped.subTitle,
                defaultOpen: Number(groupIndex) === 1 ? true : groupDataTyped.defaultOpen,
                fields: generateFieldsData(groupDataTyped.fields) || []
            };
        }
        fs.writeFileSync(`${folderName}/${name}.json`, JSON.stringify(definitionData, null, 2));
    }
};
exports.generateDefinitions = generateDefinitions;
