var yM = Object.defineProperty;
var xM = (s, e, t) => e in s ? yM(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var qt = (s, e, t) => (xM(s, typeof e != "symbol" ? e + "" : e, t), t);
function rt() {
}
function We(s, e) {
  for (const t in e)
    s[t] = e[t];
  return (
    /** @type {T & S} */
    s
  );
}
function wM(s) {
  return !!s && (typeof s == "object" || typeof s == "function") && typeof /** @type {any} */
  s.then == "function";
}
function m1(s) {
  return s();
}
function t_() {
  return /* @__PURE__ */ Object.create(null);
}
function xa(s) {
  s.forEach(m1);
}
function id(s) {
  return typeof s == "function";
}
function _t(s, e) {
  return s != s ? e == e : s !== e || s && typeof s == "object" || typeof s == "function";
}
function EM(s) {
  return Object.keys(s).length === 0;
}
function Bu(s, ...e) {
  if (s == null) {
    for (const n of e)
      n(void 0);
    return rt;
  }
  const t = s.subscribe(...e);
  return t.unsubscribe ? () => t.unsubscribe() : t;
}
function lt(s, e, t) {
  s.$$.on_destroy.push(Bu(e, t));
}
function yt(s, e, t, n) {
  if (s) {
    const i = g1(s, e, t, n);
    return s[0](i);
  }
}
function g1(s, e, t, n) {
  return s[1] && n ? We(t.ctx.slice(), s[1](n(e))) : t.ctx;
}
function xt(s, e, t, n) {
  if (s[2] && n) {
    const i = s[2](n(t));
    if (e.dirty === void 0)
      return i;
    if (typeof i == "object") {
      const r = [], a = Math.max(e.dirty.length, i.length);
      for (let o = 0; o < a; o += 1)
        r[o] = e.dirty[o] | i[o];
      return r;
    }
    return e.dirty | i;
  }
  return e.dirty;
}
function wt(s, e, t, n, i, r) {
  if (i) {
    const a = g1(e, t, n, r);
    s.p(a, i);
  }
}
function Et(s) {
  if (s.ctx.length > 32) {
    const e = [], t = s.ctx.length / 32;
    for (let n = 0; n < t; n++)
      e[n] = -1;
    return e;
  }
  return -1;
}
function rn(s) {
  const e = {};
  for (const t in s)
    t[0] !== "$" && (e[t] = s[t]);
  return e;
}
function ft(s, e) {
  const t = {};
  e = new Set(e);
  for (const n in s)
    !e.has(n) && n[0] !== "$" && (t[n] = s[n]);
  return t;
}
function n_(s, e, t) {
  return s.set(t), e;
}
function Fh(s) {
  return s && id(s.destroy) ? s.destroy : rt;
}
const A1 = typeof window < "u";
let i_ = A1 ? () => window.performance.now() : () => Date.now(), _1 = A1 ? (s) => requestAnimationFrame(s) : rt;
const Ml = /* @__PURE__ */ new Set();
function b1(s) {
  Ml.forEach((e) => {
    e.c(s) || (Ml.delete(e), e.f());
  }), Ml.size !== 0 && _1(b1);
}
function CM(s) {
  let e;
  return Ml.size === 0 && _1(b1), {
    promise: new Promise((t) => {
      Ml.add(e = { c: s, f: t });
    }),
    abort() {
      Ml.delete(e);
    }
  };
}
function Oh(s, e) {
  s.appendChild(e);
}
function v1(s, e, t) {
  const n = SM(s);
  if (!n.getElementById(e)) {
    const i = Rs("style");
    i.id = e, i.textContent = t, MM(n, i);
  }
}
function SM(s) {
  if (!s)
    return document;
  const e = s.getRootNode ? s.getRootNode() : s.ownerDocument;
  return e && /** @type {ShadowRoot} */
  e.host ? (
    /** @type {ShadowRoot} */
    e
  ) : s.ownerDocument;
}
function MM(s, e) {
  return Oh(
    /** @type {Document} */
    s.head || s,
    e
  ), e.sheet;
}
function we(s, e, t) {
  s.insertBefore(e, t || null);
}
function xe(s) {
  s.parentNode && s.parentNode.removeChild(s);
}
function Rs(s) {
  return document.createElement(s);
}
function y1(s) {
  return document.createTextNode(s);
}
function Me() {
  return y1(" ");
}
function ji() {
  return y1("");
}
function Fr(s, e, t) {
  t == null ? s.removeAttribute(e) : s.getAttribute(e) !== t && s.setAttribute(e, t);
}
const IM = ["width", "height"];
function TM(s, e) {
  const t = Object.getOwnPropertyDescriptors(s.__proto__);
  for (const n in e)
    e[n] == null ? s.removeAttribute(n) : n === "style" ? s.style.cssText = e[n] : n === "__value" ? s.value = s[n] = e[n] : t[n] && t[n].set && IM.indexOf(n) === -1 ? s[n] = e[n] : Fr(s, n, e[n]);
}
function BM(s, e) {
  Object.keys(e).forEach((t) => {
    PM(s, t, e[t]);
  });
}
function PM(s, e, t) {
  const n = e.toLowerCase();
  n in s ? s[n] = typeof s[n] == "boolean" && t === "" ? !0 : t : e in s ? s[e] = typeof s[e] == "boolean" && t === "" ? !0 : t : Fr(s, e, t);
}
function Nh(s) {
  return /-/.test(s) ? BM : TM;
}
function RM(s) {
  return Array.from(s.childNodes);
}
function DM(s, e, { bubbles: t = !1, cancelable: n = !1 } = {}) {
  return new CustomEvent(s, { detail: e, bubbles: t, cancelable: n });
}
function LM(s) {
  const e = {};
  return s.childNodes.forEach(
    /** @param {Element} node */
    (t) => {
      e[t.slot || "default"] = !0;
    }
  ), e;
}
let cu;
function Is(s) {
  cu = s;
}
function Gr() {
  if (!cu)
    throw new Error("Function called outside component initialization");
  return cu;
}
function Us(s) {
  Gr().$$.on_mount.push(s);
}
function Sn(s) {
  Gr().$$.on_destroy.push(s);
}
function kM() {
  const s = Gr();
  return (e, t, { cancelable: n = !1 } = {}) => {
    const i = s.$$.callbacks[e];
    if (i) {
      const r = DM(
        /** @type {string} */
        e,
        t,
        { cancelable: n }
      );
      return i.slice().forEach((a) => {
        a.call(s, r);
      }), !r.defaultPrevented;
    }
    return !0;
  };
}
function xi(s, e) {
  return Gr().$$.context.set(s, e), e;
}
function wi(s) {
  return Gr().$$.context.get(s);
}
const bl = [], Ut = [];
let Il = [];
const Xm = [], x1 = /* @__PURE__ */ Promise.resolve();
let Ym = !1;
function w1() {
  Ym || (Ym = !0, x1.then(ne));
}
function rd() {
  return w1(), x1;
}
function Km(s) {
  Il.push(s);
}
function or(s) {
  Xm.push(s);
}
const gp = /* @__PURE__ */ new Set();
let Fa = 0;
function ne() {
  if (Fa !== 0)
    return;
  const s = cu;
  do {
    try {
      for (; Fa < bl.length; ) {
        const e = bl[Fa];
        Fa++, Is(e), UM(e.$$);
      }
    } catch (e) {
      throw bl.length = 0, Fa = 0, e;
    }
    for (Is(null), bl.length = 0, Fa = 0; Ut.length; )
      Ut.pop()();
    for (let e = 0; e < Il.length; e += 1) {
      const t = Il[e];
      gp.has(t) || (gp.add(t), t());
    }
    Il.length = 0;
  } while (bl.length);
  for (; Xm.length; )
    Xm.pop()();
  Ym = !1, gp.clear(), Is(s);
}
function UM(s) {
  if (s.fragment !== null) {
    s.update(), xa(s.before_update);
    const e = s.dirty;
    s.dirty = [-1], s.fragment && s.fragment.p(s.ctx, e), s.after_update.forEach(Km);
  }
}
function FM(s) {
  const e = [], t = [];
  Il.forEach((n) => s.indexOf(n) === -1 ? e.push(n) : t.push(n)), t.forEach((n) => n()), Il = e;
}
const Eh = /* @__PURE__ */ new Set();
let sa;
function Li() {
  sa = {
    r: 0,
    c: [],
    p: sa
    // parent group
  };
}
function ki() {
  sa.r || xa(sa.c), sa = sa.p;
}
function O(s, e) {
  s && s.i && (Eh.delete(s), s.i(e));
}
function N(s, e, t, n) {
  if (s && s.o) {
    if (Eh.has(s))
      return;
    Eh.add(s), sa.c.push(() => {
      Eh.delete(s), n && (t && s.d(1), n());
    }), s.o(e);
  } else
    n && n();
}
function rA(s, e) {
  const t = e.token = {};
  function n(i, r, a, o) {
    if (e.token !== t)
      return;
    e.resolved = o;
    let l = e.ctx;
    a !== void 0 && (l = l.slice(), l[a] = o);
    const c = i && (e.current = i)(l);
    let u = !1;
    e.block && (e.blocks ? e.blocks.forEach((f, h) => {
      h !== r && f && (Li(), N(f, 1, 1, () => {
        e.blocks[h] === f && (e.blocks[h] = null);
      }), ki());
    }) : e.block.d(1), c.c(), O(c, 1), c.m(e.mount(), e.anchor), u = !0), e.block = c, e.blocks && (e.blocks[r] = c), u && ne();
  }
  if (wM(s)) {
    const i = Gr();
    if (s.then(
      (r) => {
        Is(i), n(e.then, 1, e.value, r), Is(null);
      },
      (r) => {
        if (Is(i), n(e.catch, 2, e.error, r), Is(null), !e.hasCatch)
          throw r;
      }
    ), e.current !== e.pending)
      return n(e.pending, 0), !0;
  } else {
    if (e.current !== e.then)
      return n(e.then, 1, e.value, s), !0;
    e.resolved = /** @type {T} */
    s;
  }
}
function sA(s, e, t) {
  const n = e.slice(), { resolved: i } = s;
  s.current === s.then && (n[s.value] = i), s.current === s.catch && (n[s.error] = i), s.block.p(n, t);
}
function jt(s, e) {
  const t = {}, n = {}, i = { $$scope: 1 };
  let r = s.length;
  for (; r--; ) {
    const a = s[r], o = e[r];
    if (o) {
      for (const l in a)
        l in o || (n[l] = 1);
      for (const l in o)
        i[l] || (t[l] = o[l], i[l] = 1);
      s[r] = o;
    } else
      for (const l in a)
        i[l] = 1;
  }
  for (const a in n)
    a in t || (t[a] = void 0);
  return t;
}
function Kt(s) {
  return typeof s == "object" && s !== null ? s : {};
}
function ar(s, e, t) {
  const n = s.$$.props[e];
  n !== void 0 && (s.$$.bound[n] = t, t(s.$$.ctx[n]));
}
function Z(s) {
  s && s.c();
}
function K(s, e, t) {
  const { fragment: n, after_update: i } = s.$$;
  n && n.m(e, t), Km(() => {
    const r = s.$$.on_mount.map(m1).filter(id);
    s.$$.on_destroy ? s.$$.on_destroy.push(...r) : xa(r), s.$$.on_mount = [];
  }), i.forEach(Km);
}
function J(s, e) {
  const t = s.$$;
  t.fragment !== null && (FM(t.after_update), xa(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
}
function OM(s, e) {
  s.$$.dirty[0] === -1 && (bl.push(s), w1(), s.$$.dirty.fill(0)), s.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Ct(s, e, t, n, i, r, a = null, o = [-1]) {
  const l = cu;
  Is(s);
  const c = s.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: r,
    update: rt,
    not_equal: i,
    bound: t_(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (l ? l.$$.context : [])),
    // everything else
    callbacks: t_(),
    dirty: o,
    skip_bound: !1,
    root: e.target || l.$$.root
  };
  a && a(c.root);
  let u = !1;
  if (c.ctx = t ? t(s, e.props || {}, (f, h, ...d) => {
    const m = d.length ? d[0] : h;
    return c.ctx && i(c.ctx[f], c.ctx[f] = m) && (!c.skip_bound && c.bound[f] && c.bound[f](m), u && OM(s, f)), h;
  }) : [], c.update(), u = !0, xa(c.before_update), c.fragment = n ? n(c.ctx) : !1, e.target) {
    if (e.hydrate) {
      const f = RM(e.target);
      c.fragment && c.fragment.l(f), f.forEach(xe);
    } else
      c.fragment && c.fragment.c();
    e.intro && O(s.$$.fragment), K(s, e.target, e.anchor), ne();
  }
  Is(l);
}
let E1;
typeof HTMLElement == "function" && (E1 = class extends HTMLElement {
  constructor(e, t, n) {
    super();
    /** The Svelte component constructor */
    qt(this, "$$ctor");
    /** Slots */
    qt(this, "$$s");
    /** The Svelte component instance */
    qt(this, "$$c");
    /** Whether or not the custom element is connected */
    qt(this, "$$cn", !1);
    /** Component props data */
    qt(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    qt(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    qt(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    qt(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    qt(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = e, this.$$s = t, n && this.attachShadow({ mode: "open" });
  }
  addEventListener(e, t, n) {
    if (this.$$l[e] = this.$$l[e] || [], this.$$l[e].push(t), this.$$c) {
      const i = this.$$c.$on(e, t);
      this.$$l_u.set(t, i);
    }
    super.addEventListener(e, t, n);
  }
  removeEventListener(e, t, n) {
    if (super.removeEventListener(e, t, n), this.$$c) {
      const i = this.$$l_u.get(t);
      i && (i(), this.$$l_u.delete(t));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let t = function(a) {
        return () => {
          let o;
          return {
            c: function() {
              o = Rs("slot"), a !== "default" && Fr(o, "name", a);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(u, f) {
              we(u, o, f);
            },
            d: function(u) {
              u && xe(o);
            }
          };
        };
      };
      var e = t;
      if (await Promise.resolve(), !this.$$cn)
        return;
      const n = {}, i = LM(this);
      for (const a of this.$$s)
        a in i && (n[a] = [t(a)]);
      for (const a of this.attributes) {
        const o = this.$$g_p(a.name);
        o in this.$$d || (this.$$d[o] = Ch(o, a.value, this.$$p_d, "toProp"));
      }
      for (const a in this.$$p_d)
        !(a in this.$$d) && this[a] !== void 0 && (this.$$d[a] = this[a], delete this[a]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: n,
          $$scope: {
            ctx: []
          }
        }
      });
      const r = () => {
        this.$$r = !0;
        for (const a in this.$$p_d)
          if (this.$$d[a] = this.$$c.$$.ctx[this.$$c.$$.props[a]], this.$$p_d[a].reflect) {
            const o = Ch(
              a,
              this.$$d[a],
              this.$$p_d,
              "toAttribute"
            );
            o == null ? this.removeAttribute(this.$$p_d[a].attribute || a) : this.setAttribute(this.$$p_d[a].attribute || a, o);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(r), r();
      for (const a in this.$$l)
        for (const o of this.$$l[a]) {
          const l = this.$$c.$on(a, o);
          this.$$l_u.set(o, l);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(e, t, n) {
    var i;
    this.$$r || (e = this.$$g_p(e), this.$$d[e] = Ch(e, n, this.$$p_d, "toProp"), (i = this.$$c) == null || i.$set({ [e]: this.$$d[e] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(e) {
    return Object.keys(this.$$p_d).find(
      (t) => this.$$p_d[t].attribute === e || !this.$$p_d[t].attribute && t.toLowerCase() === e
    ) || e;
  }
});
function Ch(s, e, t, n) {
  var r;
  const i = (r = t[s]) == null ? void 0 : r.type;
  if (e = i === "Boolean" && typeof e != "boolean" ? e != null : e, !n || !t[s])
    return e;
  if (n === "toAttribute")
    switch (i) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (i) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function St(s, e, t, n, i, r) {
  let a = class extends E1 {
    constructor() {
      super(s, t, i), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Object.keys(e).map(
        (o) => (e[o].attribute || o).toLowerCase()
      );
    }
  };
  return Object.keys(e).forEach((o) => {
    Object.defineProperty(a.prototype, o, {
      get() {
        return this.$$c && o in this.$$c ? this.$$c[o] : this.$$d[o];
      },
      set(l) {
        var c;
        l = Ch(o, l, e), this.$$d[o] = l, (c = this.$$c) == null || c.$set({ [o]: l });
      }
    });
  }), n.forEach((o) => {
    Object.defineProperty(a.prototype, o, {
      get() {
        var l;
        return (l = this.$$c) == null ? void 0 : l[o];
      }
    });
  }), r && (a = r(a)), s.element = /** @type {any} */
  a, a;
}
class Mt {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    qt(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    qt(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    J(this, 1), this.$destroy = rt;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, t) {
    if (!id(t))
      return rt;
    const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return n.push(t), () => {
      const i = n.indexOf(t);
      i !== -1 && n.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !EM(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
const NM = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(NM);
const Oa = [];
function oA(s, e) {
  return {
    subscribe: Ft(s, e).subscribe
  };
}
function Ft(s, e = rt) {
  let t;
  const n = /* @__PURE__ */ new Set();
  function i(o) {
    if (_t(s, o) && (s = o, t)) {
      const l = !Oa.length;
      for (const c of n)
        c[1](), Oa.push(c, s);
      if (l) {
        for (let c = 0; c < Oa.length; c += 2)
          Oa[c][0](Oa[c + 1]);
        Oa.length = 0;
      }
    }
  }
  function r(o) {
    i(o(s));
  }
  function a(o, l = rt) {
    const c = [o, l];
    return n.add(c), n.size === 1 && (t = e(i, r) || rt), o(s), () => {
      n.delete(c), n.size === 0 && t && (t(), t = null);
    };
  }
  return { set: i, update: r, subscribe: a };
}
function hi(s, e, t) {
  const n = !Array.isArray(s), i = n ? [s] : s;
  if (!i.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const r = e.length < 2;
  return oA(t, (a, o) => {
    let l = !1;
    const c = [];
    let u = 0, f = rt;
    const h = () => {
      if (u)
        return;
      f();
      const m = e(n ? c[0] : c, a, o);
      r ? a(m) : f = id(m) ? m : rt;
    }, d = i.map(
      (m, _) => Bu(
        m,
        (g) => {
          c[_] = g, u &= ~(1 << _), l && h();
        },
        () => {
          u |= 1 << _;
        }
      )
    );
    return l = !0, h(), function() {
      xa(d), f(), l = !1;
    };
  });
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const $l = "164", ts = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, ea = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, C1 = 0, Jm = 1, S1 = 2, GM = 3, QM = 0, aA = 1, sd = 2, es = 3, Hi = 0, Kn = 1, zn = 2, Ds = 0, fa = 1, uu = 2, Zm = 3, eg = 4, M1 = 5, co = 100, I1 = 101, T1 = 102, B1 = 103, P1 = 104, R1 = 200, D1 = 201, L1 = 202, k1 = 203, Gh = 204, Qh = 205, U1 = 206, F1 = 207, O1 = 208, N1 = 209, G1 = 210, Q1 = 211, z1 = 212, $1 = 213, V1 = 214, H1 = 0, j1 = 1, W1 = 2, fu = 3, q1 = 4, X1 = 5, Y1 = 6, K1 = 7, Pu = 0, J1 = 1, Z1 = 2, Ls = 0, ex = 1, tx = 2, nx = 3, lA = 4, ix = 5, rx = 6, sx = 7, tg = "attached", ox = "detached", od = 300, as = 301, go = 302, kl = 303, hu = 304, Vl = 306, Or = 1e3, yi = 1001, Ul = 1002, nn = 1003, ad = 1004, zM = 1004, oa = 1005, $M = 1005, Yt = 1006, Tl = 1007, VM = 1007, Yi = 1008, HM = 1008, Un = 1009, zh = 1010, cA = 1011, ld = 1012, Bl = 1013, xr = 1014, hn = 1015, Ri = 1016, uA = 1017, fA = 1018, Hl = 1020, ax = 35902, lx = 1021, cx = 1022, vn = 1023, ux = 1024, fx = 1025, ha = 1026, Fl = 1027, Ts = 1028, cd = 1029, uo = 1030, Ru = 1031, Ol = 1033, Sh = 33776, Jc = 33777, Mh = 33778, Zc = 33779, $h = 35840, ng = 35841, Vh = 35842, ig = 35843, Hh = 36196, jh = 37492, Wh = 37496, qh = 37808, rg = 37809, sg = 37810, og = 37811, du = 37812, ag = 37813, lg = 37814, cg = 37815, ug = 37816, fg = 37817, hg = 37818, dg = 37819, pg = 37820, mg = 37821, eu = 36492, gg = 36494, Ag = 36495, hx = 36283, _g = 36284, bg = 36285, vg = 36286, dx = 2200, px = 2201, mx = 2202, Nl = 2300, ga = 2301, Ih = 2302, aa = 2400, la = 2401, pu = 2402, ud = 2500, hA = 2501, gx = 0, dA = 1, Xh = 2, Ax = 3200, jl = 3201, vo = 0, _x = 1, Ur = "", Qn = "srgb", Bn = "srgb-linear", Du = "display-p3", Wl = "display-p3-linear", mu = "linear", yn = "srgb", gu = "rec709", Au = "p3", jM = 0, ta = 7680, Th = 7681, WM = 7682, qM = 7683, XM = 34055, YM = 34056, KM = 5386, JM = 512, ZM = 513, e2 = 514, t2 = 515, n2 = 516, i2 = 517, r2 = 518, Yh = 519, bx = 512, vx = 513, yx = 514, pA = 515, xx = 516, wx = 517, Ex = 518, Cx = 519, _u = 35044, Pl = 35048, s2 = 35040, o2 = 35045, a2 = 35049, l2 = 35041, c2 = 35046, u2 = 35050, f2 = 35042, h2 = "100", yg = "300 es", is = 2e3, bu = 2001;
class Qr {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, a = i.length; r < a; r++)
        i[r].call(this, e);
      e.target = null;
    }
  }
}
const Mi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let r_ = 1234567;
const da = Math.PI / 180, Gl = 180 / Math.PI;
function ur() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Mi[s & 255] + Mi[s >> 8 & 255] + Mi[s >> 16 & 255] + Mi[s >> 24 & 255] + "-" + Mi[e & 255] + Mi[e >> 8 & 255] + "-" + Mi[e >> 16 & 15 | 64] + Mi[e >> 24 & 255] + "-" + Mi[t & 63 | 128] + Mi[t >> 8 & 255] + "-" + Mi[t >> 16 & 255] + Mi[t >> 24 & 255] + Mi[n & 255] + Mi[n >> 8 & 255] + Mi[n >> 16 & 255] + Mi[n >> 24 & 255]).toLowerCase();
}
function Fn(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function mA(s, e) {
  return (s % e + e) % e;
}
function d2(s, e, t, n, i) {
  return n + (s - e) * (i - n) / (t - e);
}
function p2(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function tu(s, e, t) {
  return (1 - t) * s + t * e;
}
function m2(s, e, t, n) {
  return tu(s, e, 1 - Math.exp(-t * n));
}
function g2(s, e = 1) {
  return e - Math.abs(mA(s, e * 2) - e);
}
function A2(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
}
function _2(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function b2(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function v2(s, e) {
  return s + Math.random() * (e - s);
}
function y2(s) {
  return s * (0.5 - Math.random());
}
function x2(s) {
  s !== void 0 && (r_ = s);
  let e = r_ += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function w2(s) {
  return s * da;
}
function E2(s) {
  return s * Gl;
}
function C2(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function S2(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function M2(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function I2(s, e, t, n, i) {
  const r = Math.cos, a = Math.sin, o = r(t / 2), l = a(t / 2), c = r((e + n) / 2), u = a((e + n) / 2), f = r((e - n) / 2), h = a((e - n) / 2), d = r((n - e) / 2), m = a((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(o * u, l * f, l * h, o * c);
      break;
    case "YZY":
      s.set(l * h, o * u, l * f, o * c);
      break;
    case "ZXZ":
      s.set(l * f, l * h, o * u, o * c);
      break;
    case "XZX":
      s.set(o * u, l * m, l * d, o * c);
      break;
    case "YXY":
      s.set(l * d, o * u, l * m, o * c);
      break;
    case "ZYZ":
      s.set(l * m, l * d, o * u, o * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function $i(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Nt(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ls = {
  DEG2RAD: da,
  RAD2DEG: Gl,
  generateUUID: ur,
  clamp: Fn,
  euclideanModulo: mA,
  mapLinear: d2,
  inverseLerp: p2,
  lerp: tu,
  damp: m2,
  pingpong: g2,
  smoothstep: A2,
  smootherstep: _2,
  randInt: b2,
  randFloat: v2,
  randFloatSpread: y2,
  seededRandom: x2,
  degToRad: w2,
  radToDeg: E2,
  isPowerOfTwo: C2,
  ceilPowerOfTwo: S2,
  floorPowerOfTwo: M2,
  setQuaternionFromProperEuler: I2,
  normalize: Nt,
  denormalize: $i
};
class ke {
  constructor(e = 0, t = 0) {
    ke.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Fn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
    return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ot {
  constructor(e, t, n, i, r, a, o, l, c) {
    Ot.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, a, o, l, c);
  }
  set(e, t, n, i, r, a, o, l, c) {
    const u = this.elements;
    return u[0] = e, u[1] = i, u[2] = o, u[3] = t, u[4] = r, u[5] = l, u[6] = n, u[7] = a, u[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, a = n[0], o = n[3], l = n[6], c = n[1], u = n[4], f = n[7], h = n[2], d = n[5], m = n[8], _ = i[0], g = i[3], A = i[6], v = i[1], y = i[4], w = i[7], E = i[2], I = i[5], C = i[8];
    return r[0] = a * _ + o * v + l * E, r[3] = a * g + o * y + l * I, r[6] = a * A + o * w + l * C, r[1] = c * _ + u * v + f * E, r[4] = c * g + u * y + f * I, r[7] = c * A + u * w + f * C, r[2] = h * _ + d * v + m * E, r[5] = h * g + d * y + m * I, r[8] = h * A + d * w + m * C, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8];
    return t * a * u - t * o * c - n * r * u + n * o * l + i * r * c - i * a * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8], f = u * a - o * c, h = o * l - u * r, d = c * r - a * l, m = t * f + n * h + i * d;
    if (m === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / m;
    return e[0] = f * _, e[1] = (i * c - u * n) * _, e[2] = (o * n - i * a) * _, e[3] = h * _, e[4] = (u * t - i * l) * _, e[5] = (i * r - o * t) * _, e[6] = d * _, e[7] = (n * l - c * t) * _, e[8] = (a * t - n * r) * _, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, r, a, o) {
    const l = Math.cos(r), c = Math.sin(r);
    return this.set(
      n * l,
      n * c,
      -n * (l * a + c * o) + a + e,
      -i * c,
      i * l,
      -i * (-c * a + l * o) + o + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Ap.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Ap.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Ap.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ap = /* @__PURE__ */ new Ot();
function Sx(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535)
      return !0;
  return !1;
}
const T2 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function yl(s, e) {
  return new T2[s](e);
}
function vu(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function Mx() {
  const s = vu("canvas");
  return s.style.display = "block", s;
}
const s_ = {};
function Ix(s) {
  s in s_ || (s_[s] = !0, console.warn(s));
}
const o_ = /* @__PURE__ */ new Ot().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), a_ = /* @__PURE__ */ new Ot().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), af = {
  [Bn]: {
    transfer: mu,
    primaries: gu,
    toReference: (s) => s,
    fromReference: (s) => s
  },
  [Qn]: {
    transfer: yn,
    primaries: gu,
    toReference: (s) => s.convertSRGBToLinear(),
    fromReference: (s) => s.convertLinearToSRGB()
  },
  [Wl]: {
    transfer: mu,
    primaries: Au,
    toReference: (s) => s.applyMatrix3(a_),
    fromReference: (s) => s.applyMatrix3(o_)
  },
  [Du]: {
    transfer: yn,
    primaries: Au,
    toReference: (s) => s.convertSRGBToLinear().applyMatrix3(a_),
    fromReference: (s) => s.applyMatrix3(o_).convertLinearToSRGB()
  }
}, B2 = /* @__PURE__ */ new Set([Bn, Wl]), cn = {
  enabled: !0,
  _workingColorSpace: Bn,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(s) {
    if (!B2.has(s))
      throw new Error(`Unsupported working color space, "${s}".`);
    this._workingColorSpace = s;
  },
  convert: function(s, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return s;
    const n = af[e].toReference, i = af[t].fromReference;
    return i(n(s));
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this._workingColorSpace);
  },
  getPrimaries: function(s) {
    return af[s].primaries;
  },
  getTransfer: function(s) {
    return s === Ur ? mu : af[s].transfer;
  }
};
function Rl(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function _p(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let Na;
class Tx {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Na === void 0 && (Na = vu("canvas")), Na.width = e.width, Na.height = e.height;
      const n = Na.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Na;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = vu("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
      for (let a = 0; a < r.length; a++)
        r[a] = Rl(r[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Rl(t[n] / 255) * 255) : t[n] = Rl(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let P2 = 0;
class ca {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: P2++ }), this.uuid = ur(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let a = 0, o = i.length; a < o; a++)
          i[a].isDataTexture ? r.push(bp(i[a].image)) : r.push(bp(i[a]));
      } else
        r = bp(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function bp(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Tx.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let R2 = 0;
class wn extends Qr {
  constructor(e = wn.DEFAULT_IMAGE, t = wn.DEFAULT_MAPPING, n = yi, i = yi, r = Yt, a = Yi, o = vn, l = Un, c = wn.DEFAULT_ANISOTROPY, u = Ur) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: R2++ }), this.uuid = ur(), this.name = "", this.source = new ca(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new ke(0, 0), this.repeat = new ke(1, 1), this.center = new ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ot(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== od)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Or:
          e.x = e.x - Math.floor(e.x);
          break;
        case yi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Ul:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Or:
          e.y = e.y - Math.floor(e.y);
          break;
        case yi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Ul:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
wn.DEFAULT_IMAGE = null;
wn.DEFAULT_MAPPING = od;
wn.DEFAULT_ANISOTROPY = 1;
class Xt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    Xt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const l = e.elements, c = l[0], u = l[4], f = l[8], h = l[1], d = l[5], m = l[9], _ = l[2], g = l[6], A = l[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(f - _) < 0.01 && Math.abs(m - g) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(f + _) < 0.1 && Math.abs(m + g) < 0.1 && Math.abs(c + d + A - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const y = (c + 1) / 2, w = (d + 1) / 2, E = (A + 1) / 2, I = (u + h) / 4, C = (f + _) / 4, B = (m + g) / 4;
      return y > w && y > E ? y < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(y), i = I / n, r = C / n) : w > E ? w < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(w), n = I / i, r = B / i) : E < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(E), n = C / r, i = B / r), this.set(n, i, r, t), this;
    }
    let v = Math.sqrt((g - m) * (g - m) + (f - _) * (f - _) + (h - u) * (h - u));
    return Math.abs(v) < 1e-3 && (v = 1), this.x = (g - m) / v, this.y = (f - _) / v, this.z = (h - u) / v, this.w = Math.acos((c + d + A - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Bx extends Qr {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Xt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Xt(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Yt,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const r = new wn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
    const a = n.count;
    for (let o = 0; o < a; o++)
      this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, r = this.textures.length; i < r; i++)
        this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let n = 0, i = e.textures.length; n < i; n++)
      this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ca(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ji extends Bx {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class fd extends wn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = nn, this.minFilter = nn, this.wrapR = yi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class D2 extends Ji {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new fd(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class hd extends wn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = nn, this.minFilter = nn, this.wrapR = yi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class L2 extends Ji {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new hd(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class en {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, r, a, o) {
    let l = n[i + 0], c = n[i + 1], u = n[i + 2], f = n[i + 3];
    const h = r[a + 0], d = r[a + 1], m = r[a + 2], _ = r[a + 3];
    if (o === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = f;
      return;
    }
    if (o === 1) {
      e[t + 0] = h, e[t + 1] = d, e[t + 2] = m, e[t + 3] = _;
      return;
    }
    if (f !== _ || l !== h || c !== d || u !== m) {
      let g = 1 - o;
      const A = l * h + c * d + u * m + f * _, v = A >= 0 ? 1 : -1, y = 1 - A * A;
      if (y > Number.EPSILON) {
        const E = Math.sqrt(y), I = Math.atan2(E, A * v);
        g = Math.sin(g * I) / E, o = Math.sin(o * I) / E;
      }
      const w = o * v;
      if (l = l * g + h * w, c = c * g + d * w, u = u * g + m * w, f = f * g + _ * w, g === 1 - o) {
        const E = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
        l *= E, c *= E, u *= E, f *= E;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = f;
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, a) {
    const o = n[i], l = n[i + 1], c = n[i + 2], u = n[i + 3], f = r[a], h = r[a + 1], d = r[a + 2], m = r[a + 3];
    return e[t] = o * m + u * f + l * d - c * h, e[t + 1] = l * m + u * h + c * f - o * d, e[t + 2] = c * m + u * d + o * h - l * f, e[t + 3] = u * m - o * f - l * h - c * d, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, i = e._y, r = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(n / 2), u = o(i / 2), f = o(r / 2), h = l(n / 2), d = l(i / 2), m = l(r / 2);
    switch (a) {
      case "XYZ":
        this._x = h * u * f + c * d * m, this._y = c * d * f - h * u * m, this._z = c * u * m + h * d * f, this._w = c * u * f - h * d * m;
        break;
      case "YXZ":
        this._x = h * u * f + c * d * m, this._y = c * d * f - h * u * m, this._z = c * u * m - h * d * f, this._w = c * u * f + h * d * m;
        break;
      case "ZXY":
        this._x = h * u * f - c * d * m, this._y = c * d * f + h * u * m, this._z = c * u * m + h * d * f, this._w = c * u * f - h * d * m;
        break;
      case "ZYX":
        this._x = h * u * f - c * d * m, this._y = c * d * f + h * u * m, this._z = c * u * m - h * d * f, this._w = c * u * f + h * d * m;
        break;
      case "YZX":
        this._x = h * u * f + c * d * m, this._y = c * d * f + h * u * m, this._z = c * u * m - h * d * f, this._w = c * u * f - h * d * m;
        break;
      case "XZY":
        this._x = h * u * f - c * d * m, this._y = c * d * f - h * u * m, this._z = c * u * m + h * d * f, this._w = c * u * f + h * d * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], r = t[8], a = t[1], o = t[5], l = t[9], c = t[2], u = t[6], f = t[10], h = n + o + f;
    if (h > 0) {
      const d = 0.5 / Math.sqrt(h + 1);
      this._w = 0.25 / d, this._x = (u - l) * d, this._y = (r - c) * d, this._z = (a - i) * d;
    } else if (n > o && n > f) {
      const d = 2 * Math.sqrt(1 + n - o - f);
      this._w = (u - l) / d, this._x = 0.25 * d, this._y = (i + a) / d, this._z = (r + c) / d;
    } else if (o > f) {
      const d = 2 * Math.sqrt(1 + o - n - f);
      this._w = (r - c) / d, this._x = (i + a) / d, this._y = 0.25 * d, this._z = (l + u) / d;
    } else {
      const d = 2 * Math.sqrt(1 + f - n - o);
      this._w = (a - i) / d, this._x = (r + c) / d, this._y = (l + u) / d, this._z = 0.25 * d;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Fn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0)
      return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, r = e._z, a = e._w, o = t._x, l = t._y, c = t._z, u = t._w;
    return this._x = n * u + a * o + i * c - r * l, this._y = i * u + a * l + r * o - n * c, this._z = r * u + a * c + n * l - i * o, this._w = a * u - n * o - i * l - r * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const n = this._x, i = this._y, r = this._z, a = this._w;
    let o = a * e._w + n * e._x + i * e._y + r * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
      return this._w = a, this._x = n, this._y = i, this._z = r, this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const d = 1 - t;
      return this._w = d * a + t * this._w, this._x = d * n + t * this._x, this._y = d * i + t * this._y, this._z = d * r + t * this._z, this.normalize(), this;
    }
    const c = Math.sqrt(l), u = Math.atan2(c, o), f = Math.sin((1 - t) * u) / c, h = Math.sin(t * u) / c;
    return this._w = a * f + this._w * h, this._x = n * f + this._x * h, this._y = i * f + this._y * h, this._z = r * f + this._z * h, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), r = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      r * Math.sin(t),
      r * Math.cos(t)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class H {
  constructor(e = 0, t = 0, n = 0) {
    H.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(l_.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(l_.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, r = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * i - o * n), u = 2 * (o * t - r * i), f = 2 * (r * n - a * t);
    return this.x = t + l * c + a * f - o * u, this.y = n + l * u + o * c - r * f, this.z = i + l * f + r * u - a * c, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, r = e.z, a = t.x, o = t.y, l = t.z;
    return this.x = i * l - r * o, this.y = r * a - n * l, this.z = n * o - i * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return vp.copy(this).projectOnVector(e), this.sub(vp);
  }
  reflect(e) {
    return this.sub(vp.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Fn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const vp = /* @__PURE__ */ new H(), l_ = /* @__PURE__ */ new en();
class dn {
  constructor(e = new H(1 / 0, 1 / 0, 1 / 0), t = new H(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Rr.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Rr.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Rr.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = r.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Rr) : Rr.fromBufferAttribute(r, a), Rr.applyMatrix4(e.matrixWorld), this.expandByPoint(Rr);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), lf.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), lf.copy(n.boundingBox)), lf.applyMatrix4(e.matrixWorld), this.union(lf);
    }
    const i = e.children;
    for (let r = 0, a = i.length; r < a; r++)
      this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Rr), Rr.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(bc), cf.subVectors(this.max, bc), Ga.subVectors(e.a, bc), Qa.subVectors(e.b, bc), za.subVectors(e.c, bc), Xs.subVectors(Qa, Ga), Ys.subVectors(za, Qa), Uo.subVectors(Ga, za);
    let t = [
      0,
      -Xs.z,
      Xs.y,
      0,
      -Ys.z,
      Ys.y,
      0,
      -Uo.z,
      Uo.y,
      Xs.z,
      0,
      -Xs.x,
      Ys.z,
      0,
      -Ys.x,
      Uo.z,
      0,
      -Uo.x,
      -Xs.y,
      Xs.x,
      0,
      -Ys.y,
      Ys.x,
      0,
      -Uo.y,
      Uo.x,
      0
    ];
    return !yp(t, Ga, Qa, za, cf) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !yp(t, Ga, Qa, za, cf)) ? !1 : (uf.crossVectors(Xs, Ys), t = [uf.x, uf.y, uf.z], yp(t, Ga, Qa, za, cf));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Rr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Rr).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(As), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const As = [
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H(),
  /* @__PURE__ */ new H()
], Rr = /* @__PURE__ */ new H(), lf = /* @__PURE__ */ new dn(), Ga = /* @__PURE__ */ new H(), Qa = /* @__PURE__ */ new H(), za = /* @__PURE__ */ new H(), Xs = /* @__PURE__ */ new H(), Ys = /* @__PURE__ */ new H(), Uo = /* @__PURE__ */ new H(), bc = /* @__PURE__ */ new H(), cf = /* @__PURE__ */ new H(), uf = /* @__PURE__ */ new H(), Fo = /* @__PURE__ */ new H();
function yp(s, e, t, n, i) {
  for (let r = 0, a = s.length - 3; r <= a; r += 3) {
    Fo.fromArray(s, r);
    const o = i.x * Math.abs(Fo.x) + i.y * Math.abs(Fo.y) + i.z * Math.abs(Fo.z), l = e.dot(Fo), c = t.dot(Fo), u = n.dot(Fo);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o)
      return !1;
  }
  return !0;
}
const k2 = /* @__PURE__ */ new dn(), vc = /* @__PURE__ */ new H(), xp = /* @__PURE__ */ new H();
class Vn {
  constructor(e = new H(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : k2.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, a = e.length; r < a; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    vc.subVectors(e, this.center);
    const t = vc.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(vc, i / n), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (xp.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(vc.copy(e.center).add(xp)), this.expandByPoint(vc.copy(e.center).sub(xp))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _s = /* @__PURE__ */ new H(), wp = /* @__PURE__ */ new H(), ff = /* @__PURE__ */ new H(), Ks = /* @__PURE__ */ new H(), Ep = /* @__PURE__ */ new H(), hf = /* @__PURE__ */ new H(), Cp = /* @__PURE__ */ new H();
class wa {
  constructor(e = new H(), t = new H(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _s)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _s.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (_s.copy(this.origin).addScaledVector(this.direction, t), _s.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    wp.copy(e).add(t).multiplyScalar(0.5), ff.copy(t).sub(e).normalize(), Ks.copy(this.origin).sub(wp);
    const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(ff), o = Ks.dot(this.direction), l = -Ks.dot(ff), c = Ks.lengthSq(), u = Math.abs(1 - a * a);
    let f, h, d, m;
    if (u > 0)
      if (f = a * l - o, h = a * o - l, m = r * u, f >= 0)
        if (h >= -m)
          if (h <= m) {
            const _ = 1 / u;
            f *= _, h *= _, d = f * (f + a * h + 2 * o) + h * (a * f + h + 2 * l) + c;
          } else
            h = r, f = Math.max(0, -(a * h + o)), d = -f * f + h * (h + 2 * l) + c;
        else
          h = -r, f = Math.max(0, -(a * h + o)), d = -f * f + h * (h + 2 * l) + c;
      else
        h <= -m ? (f = Math.max(0, -(-a * r + o)), h = f > 0 ? -r : Math.min(Math.max(-r, -l), r), d = -f * f + h * (h + 2 * l) + c) : h <= m ? (f = 0, h = Math.min(Math.max(-r, -l), r), d = h * (h + 2 * l) + c) : (f = Math.max(0, -(a * r + o)), h = f > 0 ? r : Math.min(Math.max(-r, -l), r), d = -f * f + h * (h + 2 * l) + c);
    else
      h = a > 0 ? -r : r, f = Math.max(0, -(a * h + o)), d = -f * f + h * (h + 2 * l) + c;
    return n && n.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(wp).addScaledVector(ff, h), d;
  }
  intersectSphere(e, t) {
    _s.subVectors(e.center, this.origin);
    const n = _s.dot(this.direction), i = _s.dot(_s) - n * n, r = e.radius * e.radius;
    if (i > r)
      return null;
    const a = Math.sqrt(r - i), o = n - a, l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, a, o, l;
    const c = 1 / this.direction.x, u = 1 / this.direction.y, f = 1 / this.direction.z, h = this.origin;
    return c >= 0 ? (n = (e.min.x - h.x) * c, i = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c, i = (e.min.x - h.x) * c), u >= 0 ? (r = (e.min.y - h.y) * u, a = (e.max.y - h.y) * u) : (r = (e.max.y - h.y) * u, a = (e.min.y - h.y) * u), n > a || r > i || ((r > n || isNaN(n)) && (n = r), (a < i || isNaN(i)) && (i = a), f >= 0 ? (o = (e.min.z - h.z) * f, l = (e.max.z - h.z) * f) : (o = (e.max.z - h.z) * f, l = (e.min.z - h.z) * f), n > l || o > i) || ((o > n || n !== n) && (n = o), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, _s) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    Ep.subVectors(t, e), hf.subVectors(n, e), Cp.crossVectors(Ep, hf);
    let a = this.direction.dot(Cp), o;
    if (a > 0) {
      if (i)
        return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    Ks.subVectors(this.origin, e);
    const l = o * this.direction.dot(hf.crossVectors(Ks, hf));
    if (l < 0)
      return null;
    const c = o * this.direction.dot(Ep.cross(Ks));
    if (c < 0 || l + c > a)
      return null;
    const u = -o * Ks.dot(Cp);
    return u < 0 ? null : this.at(u / a, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class st {
  constructor(e, t, n, i, r, a, o, l, c, u, f, h, d, m, _, g) {
    st.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, a, o, l, c, u, f, h, d, m, _, g);
  }
  set(e, t, n, i, r, a, o, l, c, u, f, h, d, m, _, g) {
    const A = this.elements;
    return A[0] = e, A[4] = t, A[8] = n, A[12] = i, A[1] = r, A[5] = a, A[9] = o, A[13] = l, A[2] = c, A[6] = u, A[10] = f, A[14] = h, A[3] = d, A[7] = m, A[11] = _, A[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new st().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / $a.setFromMatrixColumn(e, 0).length(), r = 1 / $a.setFromMatrixColumn(e, 1).length(), a = 1 / $a.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z, a = Math.cos(n), o = Math.sin(n), l = Math.cos(i), c = Math.sin(i), u = Math.cos(r), f = Math.sin(r);
    if (e.order === "XYZ") {
      const h = a * u, d = a * f, m = o * u, _ = o * f;
      t[0] = l * u, t[4] = -l * f, t[8] = c, t[1] = d + m * c, t[5] = h - _ * c, t[9] = -o * l, t[2] = _ - h * c, t[6] = m + d * c, t[10] = a * l;
    } else if (e.order === "YXZ") {
      const h = l * u, d = l * f, m = c * u, _ = c * f;
      t[0] = h + _ * o, t[4] = m * o - d, t[8] = a * c, t[1] = a * f, t[5] = a * u, t[9] = -o, t[2] = d * o - m, t[6] = _ + h * o, t[10] = a * l;
    } else if (e.order === "ZXY") {
      const h = l * u, d = l * f, m = c * u, _ = c * f;
      t[0] = h - _ * o, t[4] = -a * f, t[8] = m + d * o, t[1] = d + m * o, t[5] = a * u, t[9] = _ - h * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
    } else if (e.order === "ZYX") {
      const h = a * u, d = a * f, m = o * u, _ = o * f;
      t[0] = l * u, t[4] = m * c - d, t[8] = h * c + _, t[1] = l * f, t[5] = _ * c + h, t[9] = d * c - m, t[2] = -c, t[6] = o * l, t[10] = a * l;
    } else if (e.order === "YZX") {
      const h = a * l, d = a * c, m = o * l, _ = o * c;
      t[0] = l * u, t[4] = _ - h * f, t[8] = m * f + d, t[1] = f, t[5] = a * u, t[9] = -o * u, t[2] = -c * u, t[6] = d * f + m, t[10] = h - _ * f;
    } else if (e.order === "XZY") {
      const h = a * l, d = a * c, m = o * l, _ = o * c;
      t[0] = l * u, t[4] = -f, t[8] = c * u, t[1] = h * f + _, t[5] = a * u, t[9] = d * f - m, t[2] = m * f - d, t[6] = o * u, t[10] = _ * f + h;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(U2, e, F2);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return ir.subVectors(e, t), ir.lengthSq() === 0 && (ir.z = 1), ir.normalize(), Js.crossVectors(n, ir), Js.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ir.x += 1e-4 : ir.z += 1e-4, ir.normalize(), Js.crossVectors(n, ir)), Js.normalize(), df.crossVectors(ir, Js), i[0] = Js.x, i[4] = df.x, i[8] = ir.x, i[1] = Js.y, i[5] = df.y, i[9] = ir.y, i[2] = Js.z, i[6] = df.z, i[10] = ir.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, a = n[0], o = n[4], l = n[8], c = n[12], u = n[1], f = n[5], h = n[9], d = n[13], m = n[2], _ = n[6], g = n[10], A = n[14], v = n[3], y = n[7], w = n[11], E = n[15], I = i[0], C = i[4], B = i[8], T = i[12], S = i[1], D = i[5], R = i[9], P = i[13], L = i[2], V = i[6], U = i[10], Q = i[14], q = i[3], oe = i[7], le = i[11], k = i[15];
    return r[0] = a * I + o * S + l * L + c * q, r[4] = a * C + o * D + l * V + c * oe, r[8] = a * B + o * R + l * U + c * le, r[12] = a * T + o * P + l * Q + c * k, r[1] = u * I + f * S + h * L + d * q, r[5] = u * C + f * D + h * V + d * oe, r[9] = u * B + f * R + h * U + d * le, r[13] = u * T + f * P + h * Q + d * k, r[2] = m * I + _ * S + g * L + A * q, r[6] = m * C + _ * D + g * V + A * oe, r[10] = m * B + _ * R + g * U + A * le, r[14] = m * T + _ * P + g * Q + A * k, r[3] = v * I + y * S + w * L + E * q, r[7] = v * C + y * D + w * V + E * oe, r[11] = v * B + y * R + w * U + E * le, r[15] = v * T + y * P + w * Q + E * k, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], a = e[1], o = e[5], l = e[9], c = e[13], u = e[2], f = e[6], h = e[10], d = e[14], m = e[3], _ = e[7], g = e[11], A = e[15];
    return m * (+r * l * f - i * c * f - r * o * h + n * c * h + i * o * d - n * l * d) + _ * (+t * l * d - t * c * h + r * a * h - i * a * d + i * c * u - r * l * u) + g * (+t * c * f - t * o * d - r * a * f + n * a * d + r * o * u - n * c * u) + A * (-i * o * u - t * l * f + t * o * h + i * a * f - n * a * h + n * l * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8], f = e[9], h = e[10], d = e[11], m = e[12], _ = e[13], g = e[14], A = e[15], v = f * g * c - _ * h * c + _ * l * d - o * g * d - f * l * A + o * h * A, y = m * h * c - u * g * c - m * l * d + a * g * d + u * l * A - a * h * A, w = u * _ * c - m * f * c + m * o * d - a * _ * d - u * o * A + a * f * A, E = m * f * l - u * _ * l - m * o * h + a * _ * h + u * o * g - a * f * g, I = t * v + n * y + i * w + r * E;
    if (I === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / I;
    return e[0] = v * C, e[1] = (_ * h * r - f * g * r - _ * i * d + n * g * d + f * i * A - n * h * A) * C, e[2] = (o * g * r - _ * l * r + _ * i * c - n * g * c - o * i * A + n * l * A) * C, e[3] = (f * l * r - o * h * r - f * i * c + n * h * c + o * i * d - n * l * d) * C, e[4] = y * C, e[5] = (u * g * r - m * h * r + m * i * d - t * g * d - u * i * A + t * h * A) * C, e[6] = (m * l * r - a * g * r - m * i * c + t * g * c + a * i * A - t * l * A) * C, e[7] = (a * h * r - u * l * r + u * i * c - t * h * c - a * i * d + t * l * d) * C, e[8] = w * C, e[9] = (m * f * r - u * _ * r - m * n * d + t * _ * d + u * n * A - t * f * A) * C, e[10] = (a * _ * r - m * o * r + m * n * c - t * _ * c - a * n * A + t * o * A) * C, e[11] = (u * o * r - a * f * r - u * n * c + t * f * c + a * n * d - t * o * d) * C, e[12] = E * C, e[13] = (u * _ * i - m * f * i + m * n * h - t * _ * h - u * n * g + t * f * g) * C, e[14] = (m * o * i - a * _ * i - m * n * l + t * _ * l + a * n * g - t * o * g) * C, e[15] = (a * f * i - u * o * i + u * n * l - t * f * l - a * n * h + t * o * h) * C, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = 1 - n, a = e.x, o = e.y, l = e.z, c = r * a, u = r * o;
    return this.set(
      c * a + n,
      c * o - i * l,
      c * l + i * o,
      0,
      c * o + i * l,
      u * o + n,
      u * l - i * a,
      0,
      c * l - i * o,
      u * l + i * a,
      r * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, r, a) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      a,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, r = t._x, a = t._y, o = t._z, l = t._w, c = r + r, u = a + a, f = o + o, h = r * c, d = r * u, m = r * f, _ = a * u, g = a * f, A = o * f, v = l * c, y = l * u, w = l * f, E = n.x, I = n.y, C = n.z;
    return i[0] = (1 - (_ + A)) * E, i[1] = (d + w) * E, i[2] = (m - y) * E, i[3] = 0, i[4] = (d - w) * I, i[5] = (1 - (h + A)) * I, i[6] = (g + v) * I, i[7] = 0, i[8] = (m + y) * C, i[9] = (g - v) * C, i[10] = (1 - (h + _)) * C, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = $a.set(i[0], i[1], i[2]).length();
    const a = $a.set(i[4], i[5], i[6]).length(), o = $a.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Dr.copy(this);
    const c = 1 / r, u = 1 / a, f = 1 / o;
    return Dr.elements[0] *= c, Dr.elements[1] *= c, Dr.elements[2] *= c, Dr.elements[4] *= u, Dr.elements[5] *= u, Dr.elements[6] *= u, Dr.elements[8] *= f, Dr.elements[9] *= f, Dr.elements[10] *= f, t.setFromRotationMatrix(Dr), n.x = r, n.y = a, n.z = o, this;
  }
  makePerspective(e, t, n, i, r, a, o = is) {
    const l = this.elements, c = 2 * r / (t - e), u = 2 * r / (n - i), f = (t + e) / (t - e), h = (n + i) / (n - i);
    let d, m;
    if (o === is)
      d = -(a + r) / (a - r), m = -2 * a * r / (a - r);
    else if (o === bu)
      d = -a / (a - r), m = -a * r / (a - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return l[0] = c, l[4] = 0, l[8] = f, l[12] = 0, l[1] = 0, l[5] = u, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = d, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, r, a, o = is) {
    const l = this.elements, c = 1 / (t - e), u = 1 / (n - i), f = 1 / (a - r), h = (t + e) * c, d = (n + i) * u;
    let m, _;
    if (o === is)
      m = (a + r) * f, _ = -2 * f;
    else if (o === bu)
      m = r * f, _ = -1 * f;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -d, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const $a = /* @__PURE__ */ new H(), Dr = /* @__PURE__ */ new st(), U2 = /* @__PURE__ */ new H(0, 0, 0), F2 = /* @__PURE__ */ new H(1, 1, 1), Js = /* @__PURE__ */ new H(), df = /* @__PURE__ */ new H(), ir = /* @__PURE__ */ new H(), c_ = /* @__PURE__ */ new st(), u_ = /* @__PURE__ */ new en();
class Ui {
  constructor(e = 0, t = 0, n = 0, i = Ui.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, r = i[0], a = i[4], o = i[8], l = i[1], c = i[5], u = i[9], f = i[2], h = i[6], d = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Fn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(h, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Fn(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-f, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Fn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-f, d), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-Fn(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-a, c));
        break;
      case "YZX":
        this._z = Math.asin(Fn(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-f, r)) : (this._x = 0, this._y = Math.atan2(o, d));
        break;
      case "XZY":
        this._z = Math.asin(-Fn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-u, d), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return c_.makeRotationFromQuaternion(e), this.setFromRotationMatrix(c_, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return u_.setFromEuler(this), this.setFromQuaternion(u_, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ui.DEFAULT_ORDER = "XYZ";
class dd {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let O2 = 0;
const f_ = /* @__PURE__ */ new H(), Va = /* @__PURE__ */ new en(), bs = /* @__PURE__ */ new st(), pf = /* @__PURE__ */ new H(), yc = /* @__PURE__ */ new H(), N2 = /* @__PURE__ */ new H(), G2 = /* @__PURE__ */ new en(), h_ = /* @__PURE__ */ new H(1, 0, 0), d_ = /* @__PURE__ */ new H(0, 1, 0), p_ = /* @__PURE__ */ new H(0, 0, 1), m_ = { type: "added" }, Q2 = { type: "removed" }, Ha = { type: "childadded", child: null }, Sp = { type: "childremoved", child: null };
class Gt extends Qr {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: O2++ }), this.uuid = ur(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Gt.DEFAULT_UP.clone();
    const e = new H(), t = new Ui(), n = new en(), i = new H(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r), n._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new st()
      },
      normalMatrix: {
        value: new Ot()
      }
    }), this.matrix = new st(), this.matrixWorld = new st(), this.matrixAutoUpdate = Gt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Gt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new dd(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Va.setFromAxisAngle(e, t), this.quaternion.multiply(Va), this;
  }
  rotateOnWorldAxis(e, t) {
    return Va.setFromAxisAngle(e, t), this.quaternion.premultiply(Va), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(h_, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(d_, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(p_, e);
  }
  translateOnAxis(e, t) {
    return f_.copy(e).applyQuaternion(this.quaternion), this.position.add(f_.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(h_, e);
  }
  translateY(e) {
    return this.translateOnAxis(d_, e);
  }
  translateZ(e) {
    return this.translateOnAxis(p_, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(bs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? pf.copy(e) : pf.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), yc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? bs.lookAt(yc, pf, this.up) : bs.lookAt(pf, yc, this.up), this.quaternion.setFromRotationMatrix(bs), i && (bs.extractRotation(i.matrixWorld), Va.setFromRotationMatrix(bs), this.quaternion.premultiply(Va.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(m_), Ha.child = e, this.dispatchEvent(Ha), Ha.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Q2), Sp.child = e, this.dispatchEvent(Sp), Sp.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), bs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), bs.multiply(e.parent.matrixWorld)), e.applyMatrix4(bs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(m_), Ha.child = e, this.dispatchEvent(Ha), Ha.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let r = 0, a = i.length; r < a; r++)
      i[r].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yc, e, N2), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yc, G2, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let r = 0, a = i.length; r < a; r++) {
        const o = i[r];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((o) => ({
      boxInitialized: o.boxInitialized,
      boxMin: o.box.min.toArray(),
      boxMax: o.box.max.toArray(),
      sphereInitialized: o.sphereInitialized,
      sphereRadius: o.sphere.radius,
      sphereCenter: o.sphere.center.toArray()
    })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function r(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const f = l[c];
            r(e.shapes, f);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(r(e.materials, this.material[l]));
        i.material = o;
      } else
        i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        i.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries), l = a(e.materials), c = a(e.textures), u = a(e.images), f = a(e.shapes), h = a(e.skeletons), d = a(e.animations), m = a(e.nodes);
      o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), f.length > 0 && (n.shapes = f), h.length > 0 && (n.skeletons = h), d.length > 0 && (n.animations = d), m.length > 0 && (n.nodes = m);
    }
    return n.object = i, n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Gt.DEFAULT_UP = /* @__PURE__ */ new H(0, 1, 0);
Gt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Gt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Lr = /* @__PURE__ */ new H(), vs = /* @__PURE__ */ new H(), Mp = /* @__PURE__ */ new H(), ys = /* @__PURE__ */ new H(), ja = /* @__PURE__ */ new H(), Wa = /* @__PURE__ */ new H(), g_ = /* @__PURE__ */ new H(), Ip = /* @__PURE__ */ new H(), Tp = /* @__PURE__ */ new H(), Bp = /* @__PURE__ */ new H();
class di {
  constructor(e = new H(), t = new H(), n = new H()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Lr.subVectors(e, t), i.cross(Lr);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, i, r) {
    Lr.subVectors(i, t), vs.subVectors(n, t), Mp.subVectors(e, t);
    const a = Lr.dot(Lr), o = Lr.dot(vs), l = Lr.dot(Mp), c = vs.dot(vs), u = vs.dot(Mp), f = a * c - o * o;
    if (f === 0)
      return r.set(0, 0, 0), null;
    const h = 1 / f, d = (c * l - o * u) * h, m = (a * u - o * l) * h;
    return r.set(1 - d - m, m, d);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, ys) === null ? !1 : ys.x >= 0 && ys.y >= 0 && ys.x + ys.y <= 1;
  }
  static getInterpolation(e, t, n, i, r, a, o, l) {
    return this.getBarycoord(e, t, n, i, ys) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, ys.x), l.addScaledVector(a, ys.y), l.addScaledVector(o, ys.z), l);
  }
  static isFrontFacing(e, t, n, i) {
    return Lr.subVectors(n, t), vs.subVectors(e, t), Lr.cross(vs).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Lr.subVectors(this.c, this.b), vs.subVectors(this.a, this.b), Lr.cross(vs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return di.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return di.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, r) {
    return di.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return di.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return di.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, r = this.c;
    let a, o;
    ja.subVectors(i, n), Wa.subVectors(r, n), Ip.subVectors(e, n);
    const l = ja.dot(Ip), c = Wa.dot(Ip);
    if (l <= 0 && c <= 0)
      return t.copy(n);
    Tp.subVectors(e, i);
    const u = ja.dot(Tp), f = Wa.dot(Tp);
    if (u >= 0 && f <= u)
      return t.copy(i);
    const h = l * f - u * c;
    if (h <= 0 && l >= 0 && u <= 0)
      return a = l / (l - u), t.copy(n).addScaledVector(ja, a);
    Bp.subVectors(e, r);
    const d = ja.dot(Bp), m = Wa.dot(Bp);
    if (m >= 0 && d <= m)
      return t.copy(r);
    const _ = d * c - l * m;
    if (_ <= 0 && c >= 0 && m <= 0)
      return o = c / (c - m), t.copy(n).addScaledVector(Wa, o);
    const g = u * m - d * f;
    if (g <= 0 && f - u >= 0 && d - m >= 0)
      return g_.subVectors(r, i), o = (f - u) / (f - u + (d - m)), t.copy(i).addScaledVector(g_, o);
    const A = 1 / (g + _ + h);
    return a = _ * A, o = h * A, t.copy(n).addScaledVector(ja, a).addScaledVector(Wa, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Px = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Zs = { h: 0, s: 0, l: 0 }, mf = { h: 0, s: 0, l: 0 };
function Pp(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class Je {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Qn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, cn.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = cn.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, cn.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = cn.workingColorSpace) {
    if (e = mA(e, 1), t = Fn(t, 0, 1), n = Fn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r;
      this.r = Pp(a, r, e + 1 / 3), this.g = Pp(a, r, e), this.b = Pp(a, r, e - 1 / 3);
    }
    return cn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Qn) {
    function n(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const a = i[1], o = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = i[1], a = r.length;
      if (a === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (a === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Qn) {
    const n = Px[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Rl(e.r), this.g = Rl(e.g), this.b = Rl(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = _p(e.r), this.g = _p(e.g), this.b = _p(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Qn) {
    return cn.fromWorkingColorSpace(Ii.copy(this), e), Math.round(Fn(Ii.r * 255, 0, 255)) * 65536 + Math.round(Fn(Ii.g * 255, 0, 255)) * 256 + Math.round(Fn(Ii.b * 255, 0, 255));
  }
  getHexString(e = Qn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = cn.workingColorSpace) {
    cn.fromWorkingColorSpace(Ii.copy(this), t);
    const n = Ii.r, i = Ii.g, r = Ii.b, a = Math.max(n, i, r), o = Math.min(n, i, r);
    let l, c;
    const u = (o + a) / 2;
    if (o === a)
      l = 0, c = 0;
    else {
      const f = a - o;
      switch (c = u <= 0.5 ? f / (a + o) : f / (2 - a - o), a) {
        case n:
          l = (i - r) / f + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - n) / f + 2;
          break;
        case r:
          l = (n - i) / f + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = u, e;
  }
  getRGB(e, t = cn.workingColorSpace) {
    return cn.fromWorkingColorSpace(Ii.copy(this), t), e.r = Ii.r, e.g = Ii.g, e.b = Ii.b, e;
  }
  getStyle(e = Qn) {
    cn.fromWorkingColorSpace(Ii.copy(this), e);
    const t = Ii.r, n = Ii.g, i = Ii.b;
    return e !== Qn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(Zs), this.setHSL(Zs.h + e, Zs.s + t, Zs.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Zs), e.getHSL(mf);
    const n = tu(Zs.h, mf.h, t), i = tu(Zs.s, mf.s, t), r = tu(Zs.l, mf.l, t);
    return this.setHSL(n, i, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Ii = /* @__PURE__ */ new Je();
Je.NAMES = Px;
let z2 = 0;
class ii extends Qr {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: z2++ }), this.uuid = ur(), this.name = "", this.type = "Material", this.blending = fa, this.side = Hi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Gh, this.blendDst = Qh, this.blendEquation = co, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Je(0, 0, 0), this.blendAlpha = 0, this.depthFunc = fu, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Yh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ta, this.stencilZFail = ta, this.stencilZPass = ta, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== fa && (n.blending = this.blending), this.side !== Hi && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Gh && (n.blendSrc = this.blendSrc), this.blendDst !== Qh && (n.blendDst = this.blendDst), this.blendEquation !== co && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== fu && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Yh && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ta && (n.stencilFail = this.stencilFail), this.stencilZFail !== ta && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== ta && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(r) {
      const a = [];
      for (const o in r) {
        const l = r[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const r = i(e.textures), a = i(e.images);
      r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r)
        n[r] = t[r].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class $n extends ii {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ui(), this.combine = Pu, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Ss = /* @__PURE__ */ $2();
function $2() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (n[l] = 0, n[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, i[l] = -c - 1, i[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, i[l] = 13, i[l | 256] = 13);
  }
  const r = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, u = 0;
    for (; !(c & 8388608); )
      c <<= 1, u -= 8388608;
    c &= -8388609, u += 947912704, r[l] = c | u;
  }
  for (let l = 1024; l < 2048; ++l)
    r[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    a[l] = l << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    a[l] = 2147483648 + (l - 32 << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (o[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: r,
    exponentTable: a,
    offsetTable: o
  };
}
function Xi(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Fn(s, -65504, 65504), Ss.floatView[0] = s;
  const e = Ss.uint32View[0], t = e >> 23 & 511;
  return Ss.baseTable[t] + ((e & 8388607) >> Ss.shiftTable[t]);
}
function jc(s) {
  const e = s >> 10;
  return Ss.uint32View[0] = Ss.mantissaTable[Ss.offsetTable[e] + (s & 1023)] + Ss.exponentTable[e], Ss.floatView[0];
}
const Wc = {
  toHalfFloat: Xi,
  fromHalfFloat: jc
}, jn = /* @__PURE__ */ new H(), gf = /* @__PURE__ */ new ke();
class Rt {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = _u, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = hn, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return Ix("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        gf.fromBufferAttribute(this, t), gf.applyMatrix3(e), this.setXY(t, gf.x, gf.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        jn.fromBufferAttribute(this, t), jn.applyMatrix3(e), this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      jn.fromBufferAttribute(this, t), jn.applyMatrix4(e), this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      jn.fromBufferAttribute(this, t), jn.applyNormalMatrix(e), this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      jn.fromBufferAttribute(this, t), jn.transformDirection(e), this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = $i(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = Nt(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array), i = Nt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array), i = Nt(i, this.array), r = Nt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== _u && (e.usage = this.usage), e;
  }
}
class V2 extends Rt {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class H2 extends Rt {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class j2 extends Rt {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class W2 extends Rt {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class gA extends Rt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class q2 extends Rt {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class AA extends Rt {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class X2 extends Rt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = jc(this.array[e * this.itemSize]);
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize] = Xi(t), this;
  }
  getY(e) {
    let t = jc(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize + 1] = Xi(t), this;
  }
  getZ(e) {
    let t = jc(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize + 2] = Xi(t), this;
  }
  getW(e) {
    let t = jc(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.array[e * this.itemSize + 3] = Xi(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array)), this.array[e + 0] = Xi(t), this.array[e + 1] = Xi(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array), i = Nt(i, this.array)), this.array[e + 0] = Xi(t), this.array[e + 1] = Xi(n), this.array[e + 2] = Xi(i), this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array), i = Nt(i, this.array), r = Nt(r, this.array)), this.array[e + 0] = Xi(t), this.array[e + 1] = Xi(n), this.array[e + 2] = Xi(i), this.array[e + 3] = Xi(r), this;
  }
}
class ht extends Rt {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let Y2 = 0;
const gr = /* @__PURE__ */ new st(), Rp = /* @__PURE__ */ new Gt(), qa = /* @__PURE__ */ new H(), rr = /* @__PURE__ */ new dn(), xc = /* @__PURE__ */ new dn(), fi = /* @__PURE__ */ new H();
class Dt extends Qr {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Y2++ }), this.uuid = ur(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Sx(e) ? AA : gA)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Ot().getNormalMatrix(e);
      n.applyNormalMatrix(r), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return gr.makeRotationFromQuaternion(e), this.applyMatrix4(gr), this;
  }
  rotateX(e) {
    return gr.makeRotationX(e), this.applyMatrix4(gr), this;
  }
  rotateY(e) {
    return gr.makeRotationY(e), this.applyMatrix4(gr), this;
  }
  rotateZ(e) {
    return gr.makeRotationZ(e), this.applyMatrix4(gr), this;
  }
  translate(e, t, n) {
    return gr.makeTranslation(e, t, n), this.applyMatrix4(gr), this;
  }
  scale(e, t, n) {
    return gr.makeScale(e, t, n), this.applyMatrix4(gr), this;
  }
  lookAt(e) {
    return Rp.lookAt(e), Rp.updateMatrix(), this.applyMatrix4(Rp.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(qa).negate(), this.translate(qa.x, qa.y, qa.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new ht(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new dn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new H(-1 / 0, -1 / 0, -1 / 0),
        new H(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          rr.setFromBufferAttribute(r), this.morphTargetsRelative ? (fi.addVectors(this.boundingBox.min, rr.min), this.boundingBox.expandByPoint(fi), fi.addVectors(this.boundingBox.max, rr.max), this.boundingBox.expandByPoint(fi)) : (this.boundingBox.expandByPoint(rr.min), this.boundingBox.expandByPoint(rr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Vn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new H(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (rr.setFromBufferAttribute(e), t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r];
          xc.setFromBufferAttribute(o), this.morphTargetsRelative ? (fi.addVectors(rr.min, xc.min), rr.expandByPoint(fi), fi.addVectors(rr.max, xc.max), rr.expandByPoint(fi)) : (rr.expandByPoint(xc.min), rr.expandByPoint(xc.max));
        }
      rr.getCenter(n);
      let i = 0;
      for (let r = 0, a = e.count; r < a; r++)
        fi.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(fi));
      if (t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r], l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            fi.fromBufferAttribute(o, c), l && (qa.fromBufferAttribute(e, c), fi.add(qa)), i = Math.max(i, n.distanceToSquared(fi));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = t.position, i = t.normal, r = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Rt(new Float32Array(4 * n.count), 4));
    const a = this.getAttribute("tangent"), o = [], l = [];
    for (let B = 0; B < n.count; B++)
      o[B] = new H(), l[B] = new H();
    const c = new H(), u = new H(), f = new H(), h = new ke(), d = new ke(), m = new ke(), _ = new H(), g = new H();
    function A(B, T, S) {
      c.fromBufferAttribute(n, B), u.fromBufferAttribute(n, T), f.fromBufferAttribute(n, S), h.fromBufferAttribute(r, B), d.fromBufferAttribute(r, T), m.fromBufferAttribute(r, S), u.sub(c), f.sub(c), d.sub(h), m.sub(h);
      const D = 1 / (d.x * m.y - m.x * d.y);
      isFinite(D) && (_.copy(u).multiplyScalar(m.y).addScaledVector(f, -d.y).multiplyScalar(D), g.copy(f).multiplyScalar(d.x).addScaledVector(u, -m.x).multiplyScalar(D), o[B].add(_), o[T].add(_), o[S].add(_), l[B].add(g), l[T].add(g), l[S].add(g));
    }
    let v = this.groups;
    v.length === 0 && (v = [{
      start: 0,
      count: e.count
    }]);
    for (let B = 0, T = v.length; B < T; ++B) {
      const S = v[B], D = S.start, R = S.count;
      for (let P = D, L = D + R; P < L; P += 3)
        A(
          e.getX(P + 0),
          e.getX(P + 1),
          e.getX(P + 2)
        );
    }
    const y = new H(), w = new H(), E = new H(), I = new H();
    function C(B) {
      E.fromBufferAttribute(i, B), I.copy(E);
      const T = o[B];
      y.copy(T), y.sub(E.multiplyScalar(E.dot(T))).normalize(), w.crossVectors(I, T);
      const D = w.dot(l[B]) < 0 ? -1 : 1;
      a.setXYZW(B, y.x, y.y, y.z, D);
    }
    for (let B = 0, T = v.length; B < T; ++B) {
      const S = v[B], D = S.start, R = S.count;
      for (let P = D, L = D + R; P < L; P += 3)
        C(e.getX(P + 0)), C(e.getX(P + 1)), C(e.getX(P + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Rt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let h = 0, d = n.count; h < d; h++)
          n.setXYZ(h, 0, 0, 0);
      const i = new H(), r = new H(), a = new H(), o = new H(), l = new H(), c = new H(), u = new H(), f = new H();
      if (e)
        for (let h = 0, d = e.count; h < d; h += 3) {
          const m = e.getX(h + 0), _ = e.getX(h + 1), g = e.getX(h + 2);
          i.fromBufferAttribute(t, m), r.fromBufferAttribute(t, _), a.fromBufferAttribute(t, g), u.subVectors(a, r), f.subVectors(i, r), u.cross(f), o.fromBufferAttribute(n, m), l.fromBufferAttribute(n, _), c.fromBufferAttribute(n, g), o.add(u), l.add(u), c.add(u), n.setXYZ(m, o.x, o.y, o.z), n.setXYZ(_, l.x, l.y, l.z), n.setXYZ(g, c.x, c.y, c.z);
        }
      else
        for (let h = 0, d = t.count; h < d; h += 3)
          i.fromBufferAttribute(t, h + 0), r.fromBufferAttribute(t, h + 1), a.fromBufferAttribute(t, h + 2), u.subVectors(a, r), f.subVectors(i, r), u.cross(f), n.setXYZ(h + 0, u.x, u.y, u.z), n.setXYZ(h + 1, u.x, u.y, u.z), n.setXYZ(h + 2, u.x, u.y, u.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      fi.fromBufferAttribute(e, t), fi.normalize(), e.setXYZ(t, fi.x, fi.y, fi.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array, u = o.itemSize, f = o.normalized, h = new c.constructor(l.length * u);
      let d = 0, m = 0;
      for (let _ = 0, g = l.length; _ < g; _++) {
        o.isInterleavedBufferAttribute ? d = l[_] * o.data.stride + o.offset : d = l[_] * u;
        for (let A = 0; A < u; A++)
          h[m++] = c[d++];
      }
      return new Rt(h, u, f);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Dt(), n = this.index.array, i = this.attributes;
    for (const o in i) {
      const l = i[o], c = e(l, n);
      t.setAttribute(o, c);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const l = [], c = r[o];
      for (let u = 0, f = c.length; u < f; u++) {
        const h = c[u], d = e(h, n);
        l.push(d);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], u = [];
      for (let f = 0, h = c.length; f < h; f++) {
        const d = c[f];
        u.push(d.toJSON(e.data));
      }
      u.length > 0 && (i[l] = u, r = !0);
    }
    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const u = [], f = r[c];
      for (let h = 0, d = f.length; h < d; h++)
        u.push(f[h].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const f = a[c];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const A_ = /* @__PURE__ */ new st(), Oo = /* @__PURE__ */ new wa(), Af = /* @__PURE__ */ new Vn(), __ = /* @__PURE__ */ new H(), Xa = /* @__PURE__ */ new H(), Ya = /* @__PURE__ */ new H(), Ka = /* @__PURE__ */ new H(), Dp = /* @__PURE__ */ new H(), _f = /* @__PURE__ */ new H(), bf = /* @__PURE__ */ new ke(), vf = /* @__PURE__ */ new ke(), yf = /* @__PURE__ */ new ke(), b_ = /* @__PURE__ */ new H(), v_ = /* @__PURE__ */ new H(), y_ = /* @__PURE__ */ new H(), xf = /* @__PURE__ */ new H(), wf = /* @__PURE__ */ new H();
class tt extends Gt {
  constructor(e = new Dt(), t = new $n()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const o = this.morphTargetInfluences;
    if (r && o) {
      _f.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const u = o[l], f = r[l];
        u !== 0 && (Dp.fromBufferAttribute(f, e), a ? _f.addScaledVector(Dp, u) : _f.addScaledVector(Dp.sub(t), u));
      }
      t.add(_f);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, r = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Af.copy(n.boundingSphere), Af.applyMatrix4(r), Oo.copy(e.ray).recast(e.near), !(Af.containsPoint(Oo.origin) === !1 && (Oo.intersectSphere(Af, __) === null || Oo.origin.distanceToSquared(__) > (e.far - e.near) ** 2)) && (A_.copy(r).invert(), Oo.copy(e.ray).applyMatrix4(A_), !(n.boundingBox !== null && Oo.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Oo)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const r = this.geometry, a = this.material, o = r.index, l = r.attributes.position, c = r.attributes.uv, u = r.attributes.uv1, f = r.attributes.normal, h = r.groups, d = r.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let m = 0, _ = h.length; m < _; m++) {
          const g = h[m], A = a[g.materialIndex], v = Math.max(g.start, d.start), y = Math.min(o.count, Math.min(g.start + g.count, d.start + d.count));
          for (let w = v, E = y; w < E; w += 3) {
            const I = o.getX(w), C = o.getX(w + 1), B = o.getX(w + 2);
            i = Ef(this, A, e, n, c, u, f, I, C, B), i && (i.faceIndex = Math.floor(w / 3), i.face.materialIndex = g.materialIndex, t.push(i));
          }
        }
      else {
        const m = Math.max(0, d.start), _ = Math.min(o.count, d.start + d.count);
        for (let g = m, A = _; g < A; g += 3) {
          const v = o.getX(g), y = o.getX(g + 1), w = o.getX(g + 2);
          i = Ef(this, a, e, n, c, u, f, v, y, w), i && (i.faceIndex = Math.floor(g / 3), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let m = 0, _ = h.length; m < _; m++) {
          const g = h[m], A = a[g.materialIndex], v = Math.max(g.start, d.start), y = Math.min(l.count, Math.min(g.start + g.count, d.start + d.count));
          for (let w = v, E = y; w < E; w += 3) {
            const I = w, C = w + 1, B = w + 2;
            i = Ef(this, A, e, n, c, u, f, I, C, B), i && (i.faceIndex = Math.floor(w / 3), i.face.materialIndex = g.materialIndex, t.push(i));
          }
        }
      else {
        const m = Math.max(0, d.start), _ = Math.min(l.count, d.start + d.count);
        for (let g = m, A = _; g < A; g += 3) {
          const v = g, y = g + 1, w = g + 2;
          i = Ef(this, a, e, n, c, u, f, v, y, w), i && (i.faceIndex = Math.floor(g / 3), t.push(i));
        }
      }
  }
}
function K2(s, e, t, n, i, r, a, o) {
  let l;
  if (e.side === Kn ? l = n.intersectTriangle(a, r, i, !0, o) : l = n.intersectTriangle(i, r, a, e.side === Hi, o), l === null)
    return null;
  wf.copy(o), wf.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(wf);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: wf.clone(),
    object: s
  };
}
function Ef(s, e, t, n, i, r, a, o, l, c) {
  s.getVertexPosition(o, Xa), s.getVertexPosition(l, Ya), s.getVertexPosition(c, Ka);
  const u = K2(s, e, t, n, Xa, Ya, Ka, xf);
  if (u) {
    i && (bf.fromBufferAttribute(i, o), vf.fromBufferAttribute(i, l), yf.fromBufferAttribute(i, c), u.uv = di.getInterpolation(xf, Xa, Ya, Ka, bf, vf, yf, new ke())), r && (bf.fromBufferAttribute(r, o), vf.fromBufferAttribute(r, l), yf.fromBufferAttribute(r, c), u.uv1 = di.getInterpolation(xf, Xa, Ya, Ka, bf, vf, yf, new ke())), a && (b_.fromBufferAttribute(a, o), v_.fromBufferAttribute(a, l), y_.fromBufferAttribute(a, c), u.normal = di.getInterpolation(xf, Xa, Ya, Ka, b_, v_, y_, new H()), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
    const f = {
      a: o,
      b: l,
      c,
      normal: new H(),
      materialIndex: 0
    };
    di.getNormal(Xa, Ya, Ka, f.normal), u.face = f;
  }
  return u;
}
class Pn extends Dt {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: a
    };
    const o = this;
    i = Math.floor(i), r = Math.floor(r), a = Math.floor(a);
    const l = [], c = [], u = [], f = [];
    let h = 0, d = 0;
    m("z", "y", "x", -1, -1, n, t, e, a, r, 0), m("z", "y", "x", 1, -1, n, t, -e, a, r, 1), m("x", "z", "y", 1, 1, e, n, t, i, a, 2), m("x", "z", "y", 1, -1, e, n, -t, i, a, 3), m("x", "y", "z", 1, -1, e, t, n, i, r, 4), m("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.setAttribute("position", new ht(c, 3)), this.setAttribute("normal", new ht(u, 3)), this.setAttribute("uv", new ht(f, 2));
    function m(_, g, A, v, y, w, E, I, C, B, T) {
      const S = w / C, D = E / B, R = w / 2, P = E / 2, L = I / 2, V = C + 1, U = B + 1;
      let Q = 0, q = 0;
      const oe = new H();
      for (let le = 0; le < U; le++) {
        const k = le * D - P;
        for (let X = 0; X < V; X++) {
          const fe = X * S - R;
          oe[_] = fe * v, oe[g] = k * y, oe[A] = L, c.push(oe.x, oe.y, oe.z), oe[_] = 0, oe[g] = 0, oe[A] = I > 0 ? 1 : -1, u.push(oe.x, oe.y, oe.z), f.push(X / C), f.push(1 - le / B), Q += 1;
        }
      }
      for (let le = 0; le < B; le++)
        for (let k = 0; k < C; k++) {
          const X = h + k + V * le, fe = h + k + V * (le + 1), te = h + (k + 1) + V * (le + 1), j = h + (k + 1) + V * le;
          l.push(X, fe, j), l.push(fe, te, j), q += 6;
        }
      o.addGroup(d, q, T), d += q, h += Q;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Pn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Ql(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function zi(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = Ql(s[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function J2(s) {
  const e = [];
  for (let t = 0; t < s.length; t++)
    e.push(s[t].clone());
  return e;
}
function Rx(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : cn.workingColorSpace;
}
const ql = { clone: Ql, merge: zi };
var Z2 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, eI = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Hn extends ii {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Z2, this.fragmentShader = eI, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ql(e.uniforms), this.uniformsGroups = J2(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture ? t.uniforms[i] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? t.uniforms[i] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: a.toArray()
      } : t.uniforms[i] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Lu extends Gt {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new st(), this.projectionMatrix = new st(), this.projectionMatrixInverse = new st(), this.coordinateSystem = is;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const eo = /* @__PURE__ */ new H(), x_ = /* @__PURE__ */ new ke(), w_ = /* @__PURE__ */ new ke();
class ni extends Lu {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Gl * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(da * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Gl * 2 * Math.atan(
      Math.tan(da * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, t, n) {
    eo.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(eo.x, eo.y).multiplyScalar(-e / eo.z), eo.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(eo.x, eo.y).multiplyScalar(-e / eo.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, x_, w_), t.subVectors(w_, x_);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, i, r, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(da * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth, c = a.fullHeight;
      r += a.offsetX * i / l, t -= a.offsetY * n / c, i *= a.width / l, n *= a.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Ja = -90, Za = 1;
class _A extends Gt {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new ni(Ja, Za, e, t);
    i.layers = this.layers, this.add(i);
    const r = new ni(Ja, Za, e, t);
    r.layers = this.layers, this.add(r);
    const a = new ni(Ja, Za, e, t);
    a.layers = this.layers, this.add(a);
    const o = new ni(Ja, Za, e, t);
    o.layers = this.layers, this.add(o);
    const l = new ni(Ja, Za, e, t);
    l.layers = this.layers, this.add(l);
    const c = new ni(Ja, Za, e, t);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, a, o, l] = t;
    for (const c of t)
      this.remove(c);
    if (e === is)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === bu)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const c of t)
      this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, a, o, l, c, u] = this.children, f = e.getRenderTarget(), h = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, a), e.setRenderTarget(n, 2, i), e.render(t, o), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, c), n.texture.generateMipmaps = _, e.setRenderTarget(n, 5, i), e.render(t, u), e.setRenderTarget(f, h, d), e.xr.enabled = m, n.texture.needsPMREMUpdate = !0;
  }
}
class Xl extends wn {
  constructor(e, t, n, i, r, a, o, l, c, u) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : as, super(e, t, n, i, r, a, o, l, c, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class bA extends Ji {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new Xl(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Yt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Pn(5, 5, 5), r = new Hn({
      name: "CubemapFromEquirect",
      uniforms: Ql(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Kn,
      blending: Ds
    });
    r.uniforms.tEquirect.value = t;
    const a = new tt(i, r), o = t.minFilter;
    return t.minFilter === Yi && (t.minFilter = Yt), new _A(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
const Lp = /* @__PURE__ */ new H(), tI = /* @__PURE__ */ new H(), nI = /* @__PURE__ */ new Ot();
class _r {
  constructor(e = new H(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = Lp.subVectors(n, t).cross(tI.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(Lp), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || nI.getNormalMatrix(e), i = this.coplanarPoint(Lp).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const No = /* @__PURE__ */ new Vn(), Cf = /* @__PURE__ */ new H();
class ku {
  constructor(e = new _r(), t = new _r(), n = new _r(), i = new _r(), r = new _r(), a = new _r()) {
    this.planes = [e, t, n, i, r, a];
  }
  set(e, t, n, i, r, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = is) {
    const n = this.planes, i = e.elements, r = i[0], a = i[1], o = i[2], l = i[3], c = i[4], u = i[5], f = i[6], h = i[7], d = i[8], m = i[9], _ = i[10], g = i[11], A = i[12], v = i[13], y = i[14], w = i[15];
    if (n[0].setComponents(l - r, h - c, g - d, w - A).normalize(), n[1].setComponents(l + r, h + c, g + d, w + A).normalize(), n[2].setComponents(l + a, h + u, g + m, w + v).normalize(), n[3].setComponents(l - a, h - u, g - m, w - v).normalize(), n[4].setComponents(l - o, h - f, g - _, w - y).normalize(), t === is)
      n[5].setComponents(l + o, h + f, g + _, w + y).normalize();
    else if (t === bu)
      n[5].setComponents(o, f, _, y).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), No.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), No.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(No);
  }
  intersectsSprite(e) {
    return No.center.set(0, 0, 0), No.radius = 0.7071067811865476, No.applyMatrix4(e.matrixWorld), this.intersectsSphere(No);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (Cf.x = i.normal.x > 0 ? e.max.x : e.min.x, Cf.y = i.normal.y > 0 ? e.max.y : e.min.y, Cf.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Cf) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Dx() {
  let s = null, e = !1, t = null, n = null;
  function i(r, a) {
    t(r, a), n = s.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = s.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      s = r;
    }
  };
}
function iI(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(o, l) {
    const c = o.array, u = o.usage, f = c.byteLength, h = s.createBuffer();
    s.bindBuffer(l, h), s.bufferData(l, c, u), o.onUploadCallback();
    let d;
    if (c instanceof Float32Array)
      d = s.FLOAT;
    else if (c instanceof Uint16Array)
      o.isFloat16BufferAttribute ? d = s.HALF_FLOAT : d = s.UNSIGNED_SHORT;
    else if (c instanceof Int16Array)
      d = s.SHORT;
    else if (c instanceof Uint32Array)
      d = s.UNSIGNED_INT;
    else if (c instanceof Int32Array)
      d = s.INT;
    else if (c instanceof Int8Array)
      d = s.BYTE;
    else if (c instanceof Uint8Array)
      d = s.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray)
      d = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return {
      buffer: h,
      type: d,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: o.version,
      size: f
    };
  }
  function n(o, l, c) {
    const u = l.array, f = l._updateRange, h = l.updateRanges;
    if (s.bindBuffer(c, o), f.count === -1 && h.length === 0 && s.bufferSubData(c, 0, u), h.length !== 0) {
      for (let d = 0, m = h.length; d < m; d++) {
        const _ = h[d];
        s.bufferSubData(
          c,
          _.start * u.BYTES_PER_ELEMENT,
          u,
          _.start,
          _.count
        );
      }
      l.clearUpdateRanges();
    }
    f.count !== -1 && (s.bufferSubData(
      c,
      f.offset * u.BYTES_PER_ELEMENT,
      u,
      f.offset,
      f.count
    ), f.count = -1), l.onUploadCallback();
  }
  function i(o) {
    return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
  }
  function r(o) {
    o.isInterleavedBufferAttribute && (o = o.data);
    const l = e.get(o);
    l && (s.deleteBuffer(l.buffer), e.delete(o));
  }
  function a(o, l) {
    if (o.isGLBufferAttribute) {
      const u = e.get(o);
      (!u || u.version < o.version) && e.set(o, {
        buffer: o.buffer,
        type: o.type,
        bytesPerElement: o.elementSize,
        version: o.version
      });
      return;
    }
    o.isInterleavedBufferAttribute && (o = o.data);
    const c = e.get(o);
    if (c === void 0)
      e.set(o, t(o, l));
    else if (c.version < o.version) {
      if (c.size !== o.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(c.buffer, o, l), c.version = o.version;
    }
  }
  return {
    get: i,
    remove: r,
    update: a
  };
}
class Fi extends Dt {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const r = e / 2, a = t / 2, o = Math.floor(n), l = Math.floor(i), c = o + 1, u = l + 1, f = e / o, h = t / l, d = [], m = [], _ = [], g = [];
    for (let A = 0; A < u; A++) {
      const v = A * h - a;
      for (let y = 0; y < c; y++) {
        const w = y * f - r;
        m.push(w, -v, 0), _.push(0, 0, 1), g.push(y / o), g.push(1 - A / l);
      }
    }
    for (let A = 0; A < l; A++)
      for (let v = 0; v < o; v++) {
        const y = v + c * A, w = v + c * (A + 1), E = v + 1 + c * (A + 1), I = v + 1 + c * A;
        d.push(y, w, I), d.push(w, E, I);
      }
    this.setIndex(d), this.setAttribute("position", new ht(m, 3)), this.setAttribute("normal", new ht(_, 3)), this.setAttribute("uv", new ht(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fi(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var rI = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, sI = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, oI = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, aI = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, lI = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, cI = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, uI = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, fI = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, hI = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, dI = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, pI = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, mI = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, gI = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, AI = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, _I = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, bI = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, vI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, yI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, xI = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, wI = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, EI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, CI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, SI = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, MI = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, II = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, TI = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, BI = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, PI = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, RI = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, DI = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, LI = "gl_FragColor = linearToOutputTexel( gl_FragColor );", kI = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, UI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, FI = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, OI = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, NI = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, GI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, QI = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, zI = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, $I = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, VI = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, HI = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, jI = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, WI = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, qI = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, XI = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, YI = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, KI = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, JI = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ZI = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, eT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, tT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, nT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, iT = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, rT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, sT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, oT = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, aT = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, lT = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, cT = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, uT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, fT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, hT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, dT = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, pT = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, mT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, gT = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, AT = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, _T = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, bT = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, vT = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, yT = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, xT = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, wT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, ET = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, CT = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, ST = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, MT = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, IT = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, TT = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, BT = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, PT = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, RT = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, DT = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, LT = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, kT = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, UT = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, FT = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, OT = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, NT = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, GT = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, QT = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, zT = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, $T = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, VT = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, HT = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, jT = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, WT = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, qT = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, XT = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, YT = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, KT = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, JT = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, ZT = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, eB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, tB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, nB = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const iB = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, rB = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, sB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, oB = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, aB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, lB = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, uB = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, fB = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, hB = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, dB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, pB = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, mB = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, gB = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, AB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, _B = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bB = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, vB = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, yB = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, xB = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, EB = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, CB = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, SB = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, MB = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, IB = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, TB = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, BB = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, PB = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, RB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, DB = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, LB = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, kB = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, UB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, gt = {
  alphahash_fragment: rI,
  alphahash_pars_fragment: sI,
  alphamap_fragment: oI,
  alphamap_pars_fragment: aI,
  alphatest_fragment: lI,
  alphatest_pars_fragment: cI,
  aomap_fragment: uI,
  aomap_pars_fragment: fI,
  batching_pars_vertex: hI,
  batching_vertex: dI,
  begin_vertex: pI,
  beginnormal_vertex: mI,
  bsdfs: gI,
  iridescence_fragment: AI,
  bumpmap_pars_fragment: _I,
  clipping_planes_fragment: bI,
  clipping_planes_pars_fragment: vI,
  clipping_planes_pars_vertex: yI,
  clipping_planes_vertex: xI,
  color_fragment: wI,
  color_pars_fragment: EI,
  color_pars_vertex: CI,
  color_vertex: SI,
  common: MI,
  cube_uv_reflection_fragment: II,
  defaultnormal_vertex: TI,
  displacementmap_pars_vertex: BI,
  displacementmap_vertex: PI,
  emissivemap_fragment: RI,
  emissivemap_pars_fragment: DI,
  colorspace_fragment: LI,
  colorspace_pars_fragment: kI,
  envmap_fragment: UI,
  envmap_common_pars_fragment: FI,
  envmap_pars_fragment: OI,
  envmap_pars_vertex: NI,
  envmap_physical_pars_fragment: YI,
  envmap_vertex: GI,
  fog_vertex: QI,
  fog_pars_vertex: zI,
  fog_fragment: $I,
  fog_pars_fragment: VI,
  gradientmap_pars_fragment: HI,
  lightmap_pars_fragment: jI,
  lights_lambert_fragment: WI,
  lights_lambert_pars_fragment: qI,
  lights_pars_begin: XI,
  lights_toon_fragment: KI,
  lights_toon_pars_fragment: JI,
  lights_phong_fragment: ZI,
  lights_phong_pars_fragment: eT,
  lights_physical_fragment: tT,
  lights_physical_pars_fragment: nT,
  lights_fragment_begin: iT,
  lights_fragment_maps: rT,
  lights_fragment_end: sT,
  logdepthbuf_fragment: oT,
  logdepthbuf_pars_fragment: aT,
  logdepthbuf_pars_vertex: lT,
  logdepthbuf_vertex: cT,
  map_fragment: uT,
  map_pars_fragment: fT,
  map_particle_fragment: hT,
  map_particle_pars_fragment: dT,
  metalnessmap_fragment: pT,
  metalnessmap_pars_fragment: mT,
  morphinstance_vertex: gT,
  morphcolor_vertex: AT,
  morphnormal_vertex: _T,
  morphtarget_pars_vertex: bT,
  morphtarget_vertex: vT,
  normal_fragment_begin: yT,
  normal_fragment_maps: xT,
  normal_pars_fragment: wT,
  normal_pars_vertex: ET,
  normal_vertex: CT,
  normalmap_pars_fragment: ST,
  clearcoat_normal_fragment_begin: MT,
  clearcoat_normal_fragment_maps: IT,
  clearcoat_pars_fragment: TT,
  iridescence_pars_fragment: BT,
  opaque_fragment: PT,
  packing: RT,
  premultiplied_alpha_fragment: DT,
  project_vertex: LT,
  dithering_fragment: kT,
  dithering_pars_fragment: UT,
  roughnessmap_fragment: FT,
  roughnessmap_pars_fragment: OT,
  shadowmap_pars_fragment: NT,
  shadowmap_pars_vertex: GT,
  shadowmap_vertex: QT,
  shadowmask_pars_fragment: zT,
  skinbase_vertex: $T,
  skinning_pars_vertex: VT,
  skinning_vertex: HT,
  skinnormal_vertex: jT,
  specularmap_fragment: WT,
  specularmap_pars_fragment: qT,
  tonemapping_fragment: XT,
  tonemapping_pars_fragment: YT,
  transmission_fragment: KT,
  transmission_pars_fragment: JT,
  uv_pars_fragment: ZT,
  uv_pars_vertex: eB,
  uv_vertex: tB,
  worldpos_vertex: nB,
  background_vert: iB,
  background_frag: rB,
  backgroundCube_vert: sB,
  backgroundCube_frag: oB,
  cube_vert: aB,
  cube_frag: lB,
  depth_vert: cB,
  depth_frag: uB,
  distanceRGBA_vert: fB,
  distanceRGBA_frag: hB,
  equirect_vert: dB,
  equirect_frag: pB,
  linedashed_vert: mB,
  linedashed_frag: gB,
  meshbasic_vert: AB,
  meshbasic_frag: _B,
  meshlambert_vert: bB,
  meshlambert_frag: vB,
  meshmatcap_vert: yB,
  meshmatcap_frag: xB,
  meshnormal_vert: wB,
  meshnormal_frag: EB,
  meshphong_vert: CB,
  meshphong_frag: SB,
  meshphysical_vert: MB,
  meshphysical_frag: IB,
  meshtoon_vert: TB,
  meshtoon_frag: BB,
  points_vert: PB,
  points_frag: RB,
  shadow_vert: DB,
  shadow_frag: LB,
  sprite_vert: kB,
  sprite_frag: UB
}, ot = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Je(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Ot() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Ot() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Ot() },
    normalScale: { value: /* @__PURE__ */ new ke(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Ot() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Ot() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Je(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Je(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Ot() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Je(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ke(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ot() },
    alphaTest: { value: 0 }
  }
}, br = {
  basic: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.specularmap,
      ot.envmap,
      ot.aomap,
      ot.lightmap,
      ot.fog
    ]),
    vertexShader: gt.meshbasic_vert,
    fragmentShader: gt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.specularmap,
      ot.envmap,
      ot.aomap,
      ot.lightmap,
      ot.emissivemap,
      ot.bumpmap,
      ot.normalmap,
      ot.displacementmap,
      ot.fog,
      ot.lights,
      {
        emissive: { value: /* @__PURE__ */ new Je(0) }
      }
    ]),
    vertexShader: gt.meshlambert_vert,
    fragmentShader: gt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.specularmap,
      ot.envmap,
      ot.aomap,
      ot.lightmap,
      ot.emissivemap,
      ot.bumpmap,
      ot.normalmap,
      ot.displacementmap,
      ot.fog,
      ot.lights,
      {
        emissive: { value: /* @__PURE__ */ new Je(0) },
        specular: { value: /* @__PURE__ */ new Je(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: gt.meshphong_vert,
    fragmentShader: gt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.envmap,
      ot.aomap,
      ot.lightmap,
      ot.emissivemap,
      ot.bumpmap,
      ot.normalmap,
      ot.displacementmap,
      ot.roughnessmap,
      ot.metalnessmap,
      ot.fog,
      ot.lights,
      {
        emissive: { value: /* @__PURE__ */ new Je(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: gt.meshphysical_vert,
    fragmentShader: gt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.aomap,
      ot.lightmap,
      ot.emissivemap,
      ot.bumpmap,
      ot.normalmap,
      ot.displacementmap,
      ot.gradientmap,
      ot.fog,
      ot.lights,
      {
        emissive: { value: /* @__PURE__ */ new Je(0) }
      }
    ]),
    vertexShader: gt.meshtoon_vert,
    fragmentShader: gt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.bumpmap,
      ot.normalmap,
      ot.displacementmap,
      ot.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: gt.meshmatcap_vert,
    fragmentShader: gt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ zi([
      ot.points,
      ot.fog
    ]),
    vertexShader: gt.points_vert,
    fragmentShader: gt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: gt.linedashed_vert,
    fragmentShader: gt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.displacementmap
    ]),
    vertexShader: gt.depth_vert,
    fragmentShader: gt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.bumpmap,
      ot.normalmap,
      ot.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: gt.meshnormal_vert,
    fragmentShader: gt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ zi([
      ot.sprite,
      ot.fog
    ]),
    vertexShader: gt.sprite_vert,
    fragmentShader: gt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Ot() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: gt.background_vert,
    fragmentShader: gt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Ot() }
    },
    vertexShader: gt.backgroundCube_vert,
    fragmentShader: gt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: gt.cube_vert,
    fragmentShader: gt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: gt.equirect_vert,
    fragmentShader: gt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ zi([
      ot.common,
      ot.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new H() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: gt.distanceRGBA_vert,
    fragmentShader: gt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ zi([
      ot.lights,
      ot.fog,
      {
        color: { value: /* @__PURE__ */ new Je(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: gt.shadow_vert,
    fragmentShader: gt.shadow_frag
  }
};
br.physical = {
  uniforms: /* @__PURE__ */ zi([
    br.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Ot() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Ot() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ke(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Ot() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Ot() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Ot() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Je(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Ot() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Ot() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Ot() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ke() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Ot() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Je(0) },
      specularColor: { value: /* @__PURE__ */ new Je(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Ot() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Ot() },
      anisotropyVector: { value: /* @__PURE__ */ new ke() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Ot() }
    }
  ]),
  vertexShader: gt.meshphysical_vert,
  fragmentShader: gt.meshphysical_frag
};
const Sf = { r: 0, b: 0, g: 0 }, Go = /* @__PURE__ */ new Ui(), FB = /* @__PURE__ */ new st();
function OB(s, e, t, n, i, r, a) {
  const o = new Je(0);
  let l = r === !0 ? 0 : 1, c, u, f = null, h = 0, d = null;
  function m(v) {
    let y = v.isScene === !0 ? v.background : null;
    return y && y.isTexture && (y = (v.backgroundBlurriness > 0 ? t : e).get(y)), y;
  }
  function _(v) {
    let y = !1;
    const w = m(v);
    w === null ? A(o, l) : w && w.isColor && (A(w, 1), y = !0);
    const E = s.xr.getEnvironmentBlendMode();
    E === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : E === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || y) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil);
  }
  function g(v, y) {
    const w = m(y);
    w && (w.isCubeTexture || w.mapping === Vl) ? (u === void 0 && (u = new tt(
      new Pn(1, 1, 1),
      new Hn({
        name: "BackgroundCubeMaterial",
        uniforms: Ql(br.backgroundCube.uniforms),
        vertexShader: br.backgroundCube.vertexShader,
        fragmentShader: br.backgroundCube.fragmentShader,
        side: Kn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(E, I, C) {
      this.matrixWorld.copyPosition(C.matrixWorld);
    }, Object.defineProperty(u.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(u)), Go.copy(y.backgroundRotation), Go.x *= -1, Go.y *= -1, Go.z *= -1, w.isCubeTexture && w.isRenderTargetTexture === !1 && (Go.y *= -1, Go.z *= -1), u.material.uniforms.envMap.value = w, u.material.uniforms.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(FB.makeRotationFromEuler(Go)), u.material.toneMapped = cn.getTransfer(w.colorSpace) !== yn, (f !== w || h !== w.version || d !== s.toneMapping) && (u.material.needsUpdate = !0, f = w, h = w.version, d = s.toneMapping), u.layers.enableAll(), v.unshift(u, u.geometry, u.material, 0, 0, null)) : w && w.isTexture && (c === void 0 && (c = new tt(
      new Fi(2, 2),
      new Hn({
        name: "BackgroundMaterial",
        uniforms: Ql(br.background.uniforms),
        vertexShader: br.background.vertexShader,
        fragmentShader: br.background.fragmentShader,
        side: Hi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(c)), c.material.uniforms.t2D.value = w, c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, c.material.toneMapped = cn.getTransfer(w.colorSpace) !== yn, w.matrixAutoUpdate === !0 && w.updateMatrix(), c.material.uniforms.uvTransform.value.copy(w.matrix), (f !== w || h !== w.version || d !== s.toneMapping) && (c.material.needsUpdate = !0, f = w, h = w.version, d = s.toneMapping), c.layers.enableAll(), v.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function A(v, y) {
    v.getRGB(Sf, Rx(s)), n.buffers.color.setClear(Sf.r, Sf.g, Sf.b, y, a);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(v, y = 1) {
      o.set(v), l = y, A(o, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(v) {
      l = v, A(o, l);
    },
    render: _,
    addToRenderList: g
  };
}
function NB(s, e) {
  const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), n = {}, i = h(null);
  let r = i, a = !1;
  function o(S, D, R, P, L) {
    let V = !1;
    const U = f(P, R, D);
    r !== U && (r = U, c(r.object)), V = d(S, P, R, L), V && m(S, P, R, L), L !== null && e.update(L, s.ELEMENT_ARRAY_BUFFER), (V || a) && (a = !1, w(S, D, R, P), L !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(L).buffer));
  }
  function l() {
    return s.createVertexArray();
  }
  function c(S) {
    return s.bindVertexArray(S);
  }
  function u(S) {
    return s.deleteVertexArray(S);
  }
  function f(S, D, R) {
    const P = R.wireframe === !0;
    let L = n[S.id];
    L === void 0 && (L = {}, n[S.id] = L);
    let V = L[D.id];
    V === void 0 && (V = {}, L[D.id] = V);
    let U = V[P];
    return U === void 0 && (U = h(l()), V[P] = U), U;
  }
  function h(S) {
    const D = [], R = [], P = [];
    for (let L = 0; L < t; L++)
      D[L] = 0, R[L] = 0, P[L] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: D,
      enabledAttributes: R,
      attributeDivisors: P,
      object: S,
      attributes: {},
      index: null
    };
  }
  function d(S, D, R, P) {
    const L = r.attributes, V = D.attributes;
    let U = 0;
    const Q = R.getAttributes();
    for (const q in Q)
      if (Q[q].location >= 0) {
        const le = L[q];
        let k = V[q];
        if (k === void 0 && (q === "instanceMatrix" && S.instanceMatrix && (k = S.instanceMatrix), q === "instanceColor" && S.instanceColor && (k = S.instanceColor)), le === void 0 || le.attribute !== k || k && le.data !== k.data)
          return !0;
        U++;
      }
    return r.attributesNum !== U || r.index !== P;
  }
  function m(S, D, R, P) {
    const L = {}, V = D.attributes;
    let U = 0;
    const Q = R.getAttributes();
    for (const q in Q)
      if (Q[q].location >= 0) {
        let le = V[q];
        le === void 0 && (q === "instanceMatrix" && S.instanceMatrix && (le = S.instanceMatrix), q === "instanceColor" && S.instanceColor && (le = S.instanceColor));
        const k = {};
        k.attribute = le, le && le.data && (k.data = le.data), L[q] = k, U++;
      }
    r.attributes = L, r.attributesNum = U, r.index = P;
  }
  function _() {
    const S = r.newAttributes;
    for (let D = 0, R = S.length; D < R; D++)
      S[D] = 0;
  }
  function g(S) {
    A(S, 0);
  }
  function A(S, D) {
    const R = r.newAttributes, P = r.enabledAttributes, L = r.attributeDivisors;
    R[S] = 1, P[S] === 0 && (s.enableVertexAttribArray(S), P[S] = 1), L[S] !== D && (s.vertexAttribDivisor(S, D), L[S] = D);
  }
  function v() {
    const S = r.newAttributes, D = r.enabledAttributes;
    for (let R = 0, P = D.length; R < P; R++)
      D[R] !== S[R] && (s.disableVertexAttribArray(R), D[R] = 0);
  }
  function y(S, D, R, P, L, V, U) {
    U === !0 ? s.vertexAttribIPointer(S, D, R, L, V) : s.vertexAttribPointer(S, D, R, P, L, V);
  }
  function w(S, D, R, P) {
    _();
    const L = P.attributes, V = R.getAttributes(), U = D.defaultAttributeValues;
    for (const Q in V) {
      const q = V[Q];
      if (q.location >= 0) {
        let oe = L[Q];
        if (oe === void 0 && (Q === "instanceMatrix" && S.instanceMatrix && (oe = S.instanceMatrix), Q === "instanceColor" && S.instanceColor && (oe = S.instanceColor)), oe !== void 0) {
          const le = oe.normalized, k = oe.itemSize, X = e.get(oe);
          if (X === void 0)
            continue;
          const fe = X.buffer, te = X.type, j = X.bytesPerElement, Ae = te === s.INT || te === s.UNSIGNED_INT || oe.gpuType === Bl;
          if (oe.isInterleavedBufferAttribute) {
            const Y = oe.data, pe = Y.stride, me = oe.offset;
            if (Y.isInstancedInterleavedBuffer) {
              for (let re = 0; re < q.locationSize; re++)
                A(q.location + re, Y.meshPerAttribute);
              S.isInstancedMesh !== !0 && P._maxInstanceCount === void 0 && (P._maxInstanceCount = Y.meshPerAttribute * Y.count);
            } else
              for (let re = 0; re < q.locationSize; re++)
                g(q.location + re);
            s.bindBuffer(s.ARRAY_BUFFER, fe);
            for (let re = 0; re < q.locationSize; re++)
              y(
                q.location + re,
                k / q.locationSize,
                te,
                le,
                pe * j,
                (me + k / q.locationSize * re) * j,
                Ae
              );
          } else {
            if (oe.isInstancedBufferAttribute) {
              for (let Y = 0; Y < q.locationSize; Y++)
                A(q.location + Y, oe.meshPerAttribute);
              S.isInstancedMesh !== !0 && P._maxInstanceCount === void 0 && (P._maxInstanceCount = oe.meshPerAttribute * oe.count);
            } else
              for (let Y = 0; Y < q.locationSize; Y++)
                g(q.location + Y);
            s.bindBuffer(s.ARRAY_BUFFER, fe);
            for (let Y = 0; Y < q.locationSize; Y++)
              y(
                q.location + Y,
                k / q.locationSize,
                te,
                le,
                k * j,
                k / q.locationSize * Y * j,
                Ae
              );
          }
        } else if (U !== void 0) {
          const le = U[Q];
          if (le !== void 0)
            switch (le.length) {
              case 2:
                s.vertexAttrib2fv(q.location, le);
                break;
              case 3:
                s.vertexAttrib3fv(q.location, le);
                break;
              case 4:
                s.vertexAttrib4fv(q.location, le);
                break;
              default:
                s.vertexAttrib1fv(q.location, le);
            }
        }
      }
    }
    v();
  }
  function E() {
    B();
    for (const S in n) {
      const D = n[S];
      for (const R in D) {
        const P = D[R];
        for (const L in P)
          u(P[L].object), delete P[L];
        delete D[R];
      }
      delete n[S];
    }
  }
  function I(S) {
    if (n[S.id] === void 0)
      return;
    const D = n[S.id];
    for (const R in D) {
      const P = D[R];
      for (const L in P)
        u(P[L].object), delete P[L];
      delete D[R];
    }
    delete n[S.id];
  }
  function C(S) {
    for (const D in n) {
      const R = n[D];
      if (R[S.id] === void 0)
        continue;
      const P = R[S.id];
      for (const L in P)
        u(P[L].object), delete P[L];
      delete R[S.id];
    }
  }
  function B() {
    T(), a = !0, r !== i && (r = i, c(r.object));
  }
  function T() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return {
    setup: o,
    reset: B,
    resetDefaultState: T,
    dispose: E,
    releaseStatesOfGeometry: I,
    releaseStatesOfProgram: C,
    initAttributes: _,
    enableAttribute: g,
    disableUnusedAttributes: v
  };
}
function GB(s, e, t) {
  let n;
  function i(c) {
    n = c;
  }
  function r(c, u) {
    s.drawArrays(n, c, u), t.update(u, n, 1);
  }
  function a(c, u, f) {
    f !== 0 && (s.drawArraysInstanced(n, c, u, f), t.update(u, n, f));
  }
  function o(c, u, f) {
    if (f === 0)
      return;
    const h = e.get("WEBGL_multi_draw");
    if (h === null)
      for (let d = 0; d < f; d++)
        this.render(c[d], u[d]);
    else {
      h.multiDrawArraysWEBGL(n, c, 0, u, 0, f);
      let d = 0;
      for (let m = 0; m < f; m++)
        d += u[m];
      t.update(d, n, 1);
    }
  }
  function l(c, u, f, h) {
    if (f === 0)
      return;
    const d = e.get("WEBGL_multi_draw");
    if (d === null)
      for (let m = 0; m < c.length; m++)
        a(c[m], u[m], h[m]);
    else {
      d.multiDrawArraysInstancedWEBGL(n, c, 0, u, 0, h, 0, f);
      let m = 0;
      for (let _ = 0; _ < f; _++)
        m += u[_];
      for (let _ = 0; _ < h.length; _++)
        t.update(m, n, h[_]);
    }
  }
  this.setMode = i, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = l;
}
function QB(s, e, t, n) {
  let i;
  function r() {
    if (i !== void 0)
      return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const I = e.get("EXT_texture_filter_anisotropic");
      i = s.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function a(I) {
    return !(I !== vn && n.convert(I) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function o(I) {
    const C = I === Ri && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(I !== Un && n.convert(I) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    I !== hn && !C);
  }
  function l(I) {
    if (I === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      I = "mediump";
    }
    return I === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const u = l(c);
  u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
  const f = t.logarithmicDepthBuffer === !0, h = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), d = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_TEXTURE_SIZE), _ = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), g = s.getParameter(s.MAX_VERTEX_ATTRIBS), A = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), v = s.getParameter(s.MAX_VARYING_VECTORS), y = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), w = d > 0, E = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: r,
    getMaxPrecision: l,
    textureFormatReadable: a,
    textureTypeReadable: o,
    precision: c,
    logarithmicDepthBuffer: f,
    maxTextures: h,
    maxVertexTextures: d,
    maxTextureSize: m,
    maxCubemapSize: _,
    maxAttributes: g,
    maxVertexUniforms: A,
    maxVaryings: v,
    maxFragmentUniforms: y,
    vertexTextures: w,
    maxSamples: E
  };
}
function zB(s) {
  const e = this;
  let t = null, n = 0, i = !1, r = !1;
  const a = new _r(), o = new Ot(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, h) {
    const d = f.length !== 0 || h || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = h, n = f.length, d;
  }, this.beginShadows = function() {
    r = !0, u(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(f, h) {
    t = u(f, h, 0);
  }, this.setState = function(f, h, d) {
    const m = f.clippingPlanes, _ = f.clipIntersection, g = f.clipShadows, A = s.get(f);
    if (!i || m === null || m.length === 0 || r && !g)
      r ? u(null) : c();
    else {
      const v = r ? 0 : n, y = v * 4;
      let w = A.clippingState || null;
      l.value = w, w = u(m, h, y, d);
      for (let E = 0; E !== y; ++E)
        w[E] = t[E];
      A.clippingState = w, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += v;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function u(f, h, d, m) {
    const _ = f !== null ? f.length : 0;
    let g = null;
    if (_ !== 0) {
      if (g = l.value, m !== !0 || g === null) {
        const A = d + _ * 4, v = h.matrixWorldInverse;
        o.getNormalMatrix(v), (g === null || g.length < A) && (g = new Float32Array(A));
        for (let y = 0, w = d; y !== _; ++y, w += 4)
          a.copy(f[y]).applyMatrix4(v, o), a.normal.toArray(g, w), g[w + 3] = a.constant;
      }
      l.value = g, l.needsUpdate = !0;
    }
    return e.numPlanes = _, e.numIntersection = 0, g;
  }
}
function $B(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(a, o) {
    return o === kl ? a.mapping = as : o === hu && (a.mapping = go), a;
  }
  function n(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === kl || o === hu)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new bA(l.height);
            return c.fromEquirectangularTexture(s, a), e.set(a, c), a.addEventListener("dispose", i), t(c.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function i(a) {
    const o = a.target;
    o.removeEventListener("dispose", i);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class yo extends Lu {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, r, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let r = n - e, a = n + e, o = i + t, l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += c * this.view.offsetX, a = r + c * this.view.width, o -= u * this.view.offsetY, l = o - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const xl = 4, E_ = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], ra = 20, kp = /* @__PURE__ */ new yo(), C_ = /* @__PURE__ */ new Je();
let Up = null, Fp = 0, Op = 0, Np = !1;
const na = (1 + Math.sqrt(5)) / 2, el = 1 / na, S_ = [
  /* @__PURE__ */ new H(-na, el, 0),
  /* @__PURE__ */ new H(na, el, 0),
  /* @__PURE__ */ new H(-el, 0, na),
  /* @__PURE__ */ new H(el, 0, na),
  /* @__PURE__ */ new H(0, na, -el),
  /* @__PURE__ */ new H(0, na, el),
  /* @__PURE__ */ new H(-1, 1, -1),
  /* @__PURE__ */ new H(1, 1, -1),
  /* @__PURE__ */ new H(-1, 1, 1),
  /* @__PURE__ */ new H(1, 1, 1)
];
class xg {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, i = 100) {
    Up = this._renderer.getRenderTarget(), Fp = this._renderer.getActiveCubeFace(), Op = this._renderer.getActiveMipmapLevel(), Np = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = T_(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = I_(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Up, Fp, Op), this._renderer.xr.enabled = Np, e.scissorTest = !1, Mf(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === as || e.mapping === go ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Up = this._renderer.getRenderTarget(), Fp = this._renderer.getActiveCubeFace(), Op = this._renderer.getActiveMipmapLevel(), Np = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: Yt,
      minFilter: Yt,
      generateMipmaps: !1,
      type: Ri,
      format: vn,
      colorSpace: Bn,
      depthBuffer: !1
    }, i = M_(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = M_(e, t, n);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = VB(r)), this._blurMaterial = HB(r, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new tt(this._lodPlanes[0], e);
    this._renderer.compile(t, kp);
  }
  _sceneToCubeUV(e, t, n, i) {
    const o = new ni(90, 1, t, n), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], u = this._renderer, f = u.autoClear, h = u.toneMapping;
    u.getClearColor(C_), u.toneMapping = Ls, u.autoClear = !1;
    const d = new $n({
      name: "PMREM.Background",
      side: Kn,
      depthWrite: !1,
      depthTest: !1
    }), m = new tt(new Pn(), d);
    let _ = !1;
    const g = e.background;
    g ? g.isColor && (d.color.copy(g), e.background = null, _ = !0) : (d.color.copy(C_), _ = !0);
    for (let A = 0; A < 6; A++) {
      const v = A % 3;
      v === 0 ? (o.up.set(0, l[A], 0), o.lookAt(c[A], 0, 0)) : v === 1 ? (o.up.set(0, 0, l[A]), o.lookAt(0, c[A], 0)) : (o.up.set(0, l[A], 0), o.lookAt(0, 0, c[A]));
      const y = this._cubeSize;
      Mf(i, v * y, A > 2 ? y : 0, y, y), u.setRenderTarget(i), _ && u.render(m, o), u.render(e, o);
    }
    m.geometry.dispose(), m.material.dispose(), u.toneMapping = h, u.autoClear = f, e.background = g;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === as || e.mapping === go;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = T_()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = I_());
    const r = i ? this._cubemapMaterial : this._equirectMaterial, a = new tt(this._lodPlanes[0], r), o = r.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    Mf(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, kp);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let r = 1; r < i; r++) {
      const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = S_[(i - r - 1) % S_.length];
      this._blur(e, r - 1, r, a, o);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, i, r) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      t,
      n,
      i,
      "latitudinal",
      r
    ), this._halfBlur(
      a,
      e,
      n,
      n,
      i,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, n, i, r, a, o) {
    const l = this._renderer, c = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const u = 3, f = new tt(this._lodPlanes[i], c), h = c.uniforms, d = this._sizeLods[n] - 1, m = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * ra - 1), _ = r / m, g = isFinite(r) ? 1 + Math.floor(u * _) : ra;
    g > ra && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${ra}`);
    const A = [];
    let v = 0;
    for (let C = 0; C < ra; ++C) {
      const B = C / _, T = Math.exp(-B * B / 2);
      A.push(T), C === 0 ? v += T : C < g && (v += 2 * T);
    }
    for (let C = 0; C < A.length; C++)
      A[C] = A[C] / v;
    h.envMap.value = e.texture, h.samples.value = g, h.weights.value = A, h.latitudinal.value = a === "latitudinal", o && (h.poleAxis.value = o);
    const { _lodMax: y } = this;
    h.dTheta.value = m, h.mipInt.value = y - n;
    const w = this._sizeLods[i], E = 3 * w * (i > y - xl ? i - y + xl : 0), I = 4 * (this._cubeSize - w);
    Mf(t, E, I, 3 * w, 2 * w), l.setRenderTarget(t), l.render(f, kp);
  }
}
function VB(s) {
  const e = [], t = [], n = [];
  let i = s;
  const r = s - xl + 1 + E_.length;
  for (let a = 0; a < r; a++) {
    const o = Math.pow(2, i);
    t.push(o);
    let l = 1 / o;
    a > s - xl ? l = E_[a - s + xl - 1] : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2), u = -c, f = 1 + c, h = [u, u, f, u, f, f, u, u, f, f, u, f], d = 6, m = 6, _ = 3, g = 2, A = 1, v = new Float32Array(_ * m * d), y = new Float32Array(g * m * d), w = new Float32Array(A * m * d);
    for (let I = 0; I < d; I++) {
      const C = I % 3 * 2 / 3 - 1, B = I > 2 ? 0 : -1, T = [
        C,
        B,
        0,
        C + 2 / 3,
        B,
        0,
        C + 2 / 3,
        B + 1,
        0,
        C,
        B,
        0,
        C + 2 / 3,
        B + 1,
        0,
        C,
        B + 1,
        0
      ];
      v.set(T, _ * m * I), y.set(h, g * m * I);
      const S = [I, I, I, I, I, I];
      w.set(S, A * m * I);
    }
    const E = new Dt();
    E.setAttribute("position", new Rt(v, _)), E.setAttribute("uv", new Rt(y, g)), E.setAttribute("faceIndex", new Rt(w, A)), e.push(E), i > xl && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function M_(s, e, t) {
  const n = new Ji(s, e, t);
  return n.texture.mapping = Vl, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Mf(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function HB(s, e, t) {
  const n = new Float32Array(ra), i = new H(0, 1, 0);
  return new Hn({
    name: "SphericalGaussianBlur",
    defines: {
      n: ra,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: vA(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Ds,
    depthTest: !1,
    depthWrite: !1
  });
}
function I_() {
  return new Hn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: vA(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Ds,
    depthTest: !1,
    depthWrite: !1
  });
}
function T_() {
  return new Hn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: vA(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Ds,
    depthTest: !1,
    depthWrite: !1
  });
}
function vA() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function jB(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping, c = l === kl || l === hu, u = l === as || l === go;
      if (c || u) {
        let f = e.get(o);
        const h = f !== void 0 ? f.texture.pmremVersion : 0;
        if (o.isRenderTargetTexture && o.pmremVersion !== h)
          return t === null && (t = new xg(s)), f = c ? t.fromEquirectangular(o, f) : t.fromCubemap(o, f), f.texture.pmremVersion = o.pmremVersion, e.set(o, f), f.texture;
        if (f !== void 0)
          return f.texture;
        {
          const d = o.image;
          return c && d && d.height > 0 || u && d && i(d) ? (t === null && (t = new xg(s)), f = c ? t.fromEquirectangular(o) : t.fromCubemap(o), f.texture.pmremVersion = o.pmremVersion, e.set(o, f), o.addEventListener("dispose", r), f.texture) : null;
        }
      }
    }
    return o;
  }
  function i(o) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++)
      o[u] !== void 0 && l++;
    return l === c;
  }
  function r(o) {
    const l = o.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: a
  };
}
function WB(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const i = t(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function qB(s, e, t, n) {
  const i = {}, r = /* @__PURE__ */ new WeakMap();
  function a(f) {
    const h = f.target;
    h.index !== null && e.remove(h.index);
    for (const m in h.attributes)
      e.remove(h.attributes[m]);
    for (const m in h.morphAttributes) {
      const _ = h.morphAttributes[m];
      for (let g = 0, A = _.length; g < A; g++)
        e.remove(_[g]);
    }
    h.removeEventListener("dispose", a), delete i[h.id];
    const d = r.get(h);
    d && (e.remove(d), r.delete(h)), n.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount, t.memory.geometries--;
  }
  function o(f, h) {
    return i[h.id] === !0 || (h.addEventListener("dispose", a), i[h.id] = !0, t.memory.geometries++), h;
  }
  function l(f) {
    const h = f.attributes;
    for (const m in h)
      e.update(h[m], s.ARRAY_BUFFER);
    const d = f.morphAttributes;
    for (const m in d) {
      const _ = d[m];
      for (let g = 0, A = _.length; g < A; g++)
        e.update(_[g], s.ARRAY_BUFFER);
    }
  }
  function c(f) {
    const h = [], d = f.index, m = f.attributes.position;
    let _ = 0;
    if (d !== null) {
      const v = d.array;
      _ = d.version;
      for (let y = 0, w = v.length; y < w; y += 3) {
        const E = v[y + 0], I = v[y + 1], C = v[y + 2];
        h.push(E, I, I, C, C, E);
      }
    } else if (m !== void 0) {
      const v = m.array;
      _ = m.version;
      for (let y = 0, w = v.length / 3 - 1; y < w; y += 3) {
        const E = y + 0, I = y + 1, C = y + 2;
        h.push(E, I, I, C, C, E);
      }
    } else
      return;
    const g = new (Sx(h) ? AA : gA)(h, 1);
    g.version = _;
    const A = r.get(f);
    A && e.remove(A), r.set(f, g);
  }
  function u(f) {
    const h = r.get(f);
    if (h) {
      const d = f.index;
      d !== null && h.version < d.version && c(f);
    } else
      c(f);
    return r.get(f);
  }
  return {
    get: o,
    update: l,
    getWireframeAttribute: u
  };
}
function XB(s, e, t) {
  let n;
  function i(h) {
    n = h;
  }
  let r, a;
  function o(h) {
    r = h.type, a = h.bytesPerElement;
  }
  function l(h, d) {
    s.drawElements(n, d, r, h * a), t.update(d, n, 1);
  }
  function c(h, d, m) {
    m !== 0 && (s.drawElementsInstanced(n, d, r, h * a, m), t.update(d, n, m));
  }
  function u(h, d, m) {
    if (m === 0)
      return;
    const _ = e.get("WEBGL_multi_draw");
    if (_ === null)
      for (let g = 0; g < m; g++)
        this.render(h[g] / a, d[g]);
    else {
      _.multiDrawElementsWEBGL(n, d, 0, r, h, 0, m);
      let g = 0;
      for (let A = 0; A < m; A++)
        g += d[A];
      t.update(g, n, 1);
    }
  }
  function f(h, d, m, _) {
    if (m === 0)
      return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null)
      for (let A = 0; A < h.length; A++)
        c(h[A] / a, d[A], _[A]);
    else {
      g.multiDrawElementsInstancedWEBGL(n, d, 0, r, h, 0, _, 0, m);
      let A = 0;
      for (let v = 0; v < m; v++)
        A += d[v];
      for (let v = 0; v < _.length; v++)
        t.update(A, n, _[v]);
    }
  }
  this.setMode = i, this.setIndex = o, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = f;
}
function YB(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(r, a, o) {
    switch (t.calls++, a) {
      case s.TRIANGLES:
        t.triangles += o * (r / 3);
        break;
      case s.LINES:
        t.lines += o * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += o * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += o * r;
        break;
      case s.POINTS:
        t.points += o * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function KB(s, e, t) {
  const n = /* @__PURE__ */ new WeakMap(), i = new Xt();
  function r(a, o, l) {
    const c = a.morphTargetInfluences, u = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, f = u !== void 0 ? u.length : 0;
    let h = n.get(o);
    if (h === void 0 || h.count !== f) {
      let S = function() {
        B.dispose(), n.delete(o), o.removeEventListener("dispose", S);
      };
      var d = S;
      h !== void 0 && h.texture.dispose();
      const m = o.morphAttributes.position !== void 0, _ = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, A = o.morphAttributes.position || [], v = o.morphAttributes.normal || [], y = o.morphAttributes.color || [];
      let w = 0;
      m === !0 && (w = 1), _ === !0 && (w = 2), g === !0 && (w = 3);
      let E = o.attributes.position.count * w, I = 1;
      E > e.maxTextureSize && (I = Math.ceil(E / e.maxTextureSize), E = e.maxTextureSize);
      const C = new Float32Array(E * I * 4 * f), B = new fd(C, E, I, f);
      B.type = hn, B.needsUpdate = !0;
      const T = w * 4;
      for (let D = 0; D < f; D++) {
        const R = A[D], P = v[D], L = y[D], V = E * I * 4 * D;
        for (let U = 0; U < R.count; U++) {
          const Q = U * T;
          m === !0 && (i.fromBufferAttribute(R, U), C[V + Q + 0] = i.x, C[V + Q + 1] = i.y, C[V + Q + 2] = i.z, C[V + Q + 3] = 0), _ === !0 && (i.fromBufferAttribute(P, U), C[V + Q + 4] = i.x, C[V + Q + 5] = i.y, C[V + Q + 6] = i.z, C[V + Q + 7] = 0), g === !0 && (i.fromBufferAttribute(L, U), C[V + Q + 8] = i.x, C[V + Q + 9] = i.y, C[V + Q + 10] = i.z, C[V + Q + 11] = L.itemSize === 4 ? i.w : 1);
        }
      }
      h = {
        count: f,
        texture: B,
        size: new ke(E, I)
      }, n.set(o, h), o.addEventListener("dispose", S);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      l.getUniforms().setValue(s, "morphTexture", a.morphTexture, t);
    else {
      let m = 0;
      for (let g = 0; g < c.length; g++)
        m += c[g];
      const _ = o.morphTargetsRelative ? 1 : 1 - m;
      l.getUniforms().setValue(s, "morphTargetBaseInfluence", _), l.getUniforms().setValue(s, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(s, "morphTargetsTexture", h.texture, t), l.getUniforms().setValue(s, "morphTargetsTextureSize", h.size);
  }
  return {
    update: r
  };
}
function JB(s, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const c = n.render.frame, u = l.geometry, f = e.get(l, u);
    if (i.get(f) !== c && (e.update(f), i.set(f, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), i.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
      const h = l.skeleton;
      i.get(h) !== c && (h.update(), i.set(h, c));
    }
    return f;
  }
  function a() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: r,
    dispose: a
  };
}
class yA extends wn {
  constructor(e, t, n, i, r, a, o, l, c, u) {
    if (u = u !== void 0 ? u : ha, u !== ha && u !== Fl)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && u === ha && (n = xr), n === void 0 && u === Fl && (n = Hl), super(null, i, r, a, o, l, u, n, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : nn, this.minFilter = l !== void 0 ? l : nn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const Lx = /* @__PURE__ */ new wn(), kx = /* @__PURE__ */ new yA(1, 1);
kx.compareFunction = pA;
const Ux = /* @__PURE__ */ new fd(), Fx = /* @__PURE__ */ new hd(), Ox = /* @__PURE__ */ new Xl(), B_ = [], P_ = [], R_ = new Float32Array(16), D_ = new Float32Array(9), L_ = new Float32Array(4);
function Yl(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0)
    return s;
  const i = e * t;
  let r = B_[i];
  if (r === void 0 && (r = new Float32Array(i), B_[i] = r), e !== 0) {
    n.toArray(r, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, s[a].toArray(r, o);
  }
  return r;
}
function si(s, e) {
  if (s.length !== e.length)
    return !1;
  for (let t = 0, n = s.length; t < n; t++)
    if (s[t] !== e[t])
      return !1;
  return !0;
}
function oi(s, e) {
  for (let t = 0, n = e.length; t < n; t++)
    s[t] = e[t];
}
function pd(s, e) {
  let t = P_[e];
  t === void 0 && (t = new Int32Array(e), P_[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = s.allocateTextureUnit();
  return t;
}
function ZB(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function eP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (si(t, e))
      return;
    s.uniform2fv(this.addr, e), oi(t, e);
  }
}
function tP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (si(t, e))
      return;
    s.uniform3fv(this.addr, e), oi(t, e);
  }
}
function nP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (si(t, e))
      return;
    s.uniform4fv(this.addr, e), oi(t, e);
  }
}
function iP(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (si(t, e))
      return;
    s.uniformMatrix2fv(this.addr, !1, e), oi(t, e);
  } else {
    if (si(t, n))
      return;
    L_.set(n), s.uniformMatrix2fv(this.addr, !1, L_), oi(t, n);
  }
}
function rP(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (si(t, e))
      return;
    s.uniformMatrix3fv(this.addr, !1, e), oi(t, e);
  } else {
    if (si(t, n))
      return;
    D_.set(n), s.uniformMatrix3fv(this.addr, !1, D_), oi(t, n);
  }
}
function sP(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (si(t, e))
      return;
    s.uniformMatrix4fv(this.addr, !1, e), oi(t, e);
  } else {
    if (si(t, n))
      return;
    R_.set(n), s.uniformMatrix4fv(this.addr, !1, R_), oi(t, n);
  }
}
function oP(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function aP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (si(t, e))
      return;
    s.uniform2iv(this.addr, e), oi(t, e);
  }
}
function lP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (si(t, e))
      return;
    s.uniform3iv(this.addr, e), oi(t, e);
  }
}
function cP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (si(t, e))
      return;
    s.uniform4iv(this.addr, e), oi(t, e);
  }
}
function uP(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function fP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (si(t, e))
      return;
    s.uniform2uiv(this.addr, e), oi(t, e);
  }
}
function hP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (si(t, e))
      return;
    s.uniform3uiv(this.addr, e), oi(t, e);
  }
}
function dP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (si(t, e))
      return;
    s.uniform4uiv(this.addr, e), oi(t, e);
  }
}
function pP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
  const r = this.type === s.SAMPLER_2D_SHADOW ? kx : Lx;
  t.setTexture2D(e || r, i);
}
function mP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || Fx, i);
}
function gP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || Ox, i);
}
function AP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || Ux, i);
}
function _P(s) {
  switch (s) {
    case 5126:
      return ZB;
    case 35664:
      return eP;
    case 35665:
      return tP;
    case 35666:
      return nP;
    case 35674:
      return iP;
    case 35675:
      return rP;
    case 35676:
      return sP;
    case 5124:
    case 35670:
      return oP;
    case 35667:
    case 35671:
      return aP;
    case 35668:
    case 35672:
      return lP;
    case 35669:
    case 35673:
      return cP;
    case 5125:
      return uP;
    case 36294:
      return fP;
    case 36295:
      return hP;
    case 36296:
      return dP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return pP;
    case 35679:
    case 36299:
    case 36307:
      return mP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return gP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return AP;
  }
}
function bP(s, e) {
  s.uniform1fv(this.addr, e);
}
function vP(s, e) {
  const t = Yl(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function yP(s, e) {
  const t = Yl(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function xP(s, e) {
  const t = Yl(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function wP(s, e) {
  const t = Yl(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function EP(s, e) {
  const t = Yl(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function CP(s, e) {
  const t = Yl(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function SP(s, e) {
  s.uniform1iv(this.addr, e);
}
function MP(s, e) {
  s.uniform2iv(this.addr, e);
}
function IP(s, e) {
  s.uniform3iv(this.addr, e);
}
function TP(s, e) {
  s.uniform4iv(this.addr, e);
}
function BP(s, e) {
  s.uniform1uiv(this.addr, e);
}
function PP(s, e) {
  s.uniform2uiv(this.addr, e);
}
function RP(s, e) {
  s.uniform3uiv(this.addr, e);
}
function DP(s, e) {
  s.uniform4uiv(this.addr, e);
}
function LP(s, e, t) {
  const n = this.cache, i = e.length, r = pd(t, i);
  si(n, r) || (s.uniform1iv(this.addr, r), oi(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTexture2D(e[a] || Lx, r[a]);
}
function kP(s, e, t) {
  const n = this.cache, i = e.length, r = pd(t, i);
  si(n, r) || (s.uniform1iv(this.addr, r), oi(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTexture3D(e[a] || Fx, r[a]);
}
function UP(s, e, t) {
  const n = this.cache, i = e.length, r = pd(t, i);
  si(n, r) || (s.uniform1iv(this.addr, r), oi(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTextureCube(e[a] || Ox, r[a]);
}
function FP(s, e, t) {
  const n = this.cache, i = e.length, r = pd(t, i);
  si(n, r) || (s.uniform1iv(this.addr, r), oi(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTexture2DArray(e[a] || Ux, r[a]);
}
function OP(s) {
  switch (s) {
    case 5126:
      return bP;
    case 35664:
      return vP;
    case 35665:
      return yP;
    case 35666:
      return xP;
    case 35674:
      return wP;
    case 35675:
      return EP;
    case 35676:
      return CP;
    case 5124:
    case 35670:
      return SP;
    case 35667:
    case 35671:
      return MP;
    case 35668:
    case 35672:
      return IP;
    case 35669:
    case 35673:
      return TP;
    case 5125:
      return BP;
    case 36294:
      return PP;
    case 36295:
      return RP;
    case 36296:
      return DP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return LP;
    case 35679:
    case 36299:
    case 36307:
      return kP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return UP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return FP;
  }
}
class NP {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = _P(t.type);
  }
}
class GP {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = OP(t.type);
  }
}
class QP {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let r = 0, a = i.length; r !== a; ++r) {
      const o = i[r];
      o.setValue(e, t[o.id], n);
    }
  }
}
const Gp = /(\w+)(\])?(\[|\.)?/g;
function k_(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function zP(s, e, t) {
  const n = s.name, i = n.length;
  for (Gp.lastIndex = 0; ; ) {
    const r = Gp.exec(n), a = Gp.lastIndex;
    let o = r[1];
    const l = r[2] === "]", c = r[3];
    if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === i) {
      k_(t, c === void 0 ? new NP(o, s, e) : new GP(o, s, e));
      break;
    } else {
      let f = t.map[o];
      f === void 0 && (f = new QP(o), k_(t, f)), t = f;
    }
  }
}
class Bh {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const r = e.getActiveUniform(t, i), a = e.getUniformLocation(t, r.name);
      zP(r, a, this);
    }
  }
  setValue(e, t, n, i) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let r = 0, a = t.length; r !== a; ++r) {
      const o = t[r], l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function U_(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
const $P = 37297;
let VP = 0;
function HP(s, e) {
  const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let a = i; a < r; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
function jP(s) {
  const e = cn.getPrimaries(cn.workingColorSpace), t = cn.getPrimaries(s);
  let n;
  switch (e === t ? n = "" : e === Au && t === gu ? n = "LinearDisplayP3ToLinearSRGB" : e === gu && t === Au && (n = "LinearSRGBToLinearDisplayP3"), s) {
    case Bn:
    case Wl:
      return [n, "LinearTransferOETF"];
    case Qn:
    case Du:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [n, "LinearTransferOETF"];
  }
}
function F_(s, e, t) {
  const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
  if (n && i === "")
    return "";
  const r = /ERROR: 0:(\d+)/.exec(i);
  if (r) {
    const a = parseInt(r[1]);
    return t.toUpperCase() + `

` + i + `

` + HP(s.getShaderSource(e), a);
  } else
    return i;
}
function WP(s, e) {
  const t = jP(e);
  return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function qP(s, e) {
  let t;
  switch (e) {
    case ex:
      t = "Linear";
      break;
    case tx:
      t = "Reinhard";
      break;
    case nx:
      t = "OptimizedCineon";
      break;
    case lA:
      t = "ACESFilmic";
      break;
    case rx:
      t = "AgX";
      break;
    case sx:
      t = "Neutral";
      break;
    case ix:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function XP(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(qc).join(`
`);
}
function YP(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function KP(s, e) {
  const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i), a = r.name;
    let o = 1;
    r.type === s.FLOAT_MAT2 && (o = 2), r.type === s.FLOAT_MAT3 && (o = 3), r.type === s.FLOAT_MAT4 && (o = 4), t[a] = {
      type: r.type,
      location: s.getAttribLocation(e, a),
      locationSize: o
    };
  }
  return t;
}
function qc(s) {
  return s !== "";
}
function O_(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function N_(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const JP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wg(s) {
  return s.replace(JP, eR);
}
const ZP = /* @__PURE__ */ new Map();
function eR(s, e) {
  let t = gt[e];
  if (t === void 0) {
    const n = ZP.get(e);
    if (n !== void 0)
      t = gt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return wg(t);
}
const tR = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function G_(s) {
  return s.replace(tR, nR);
}
function nR(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function Q_(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function iR(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === aA ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === sd ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === es && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function rR(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case as:
      case go:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Vl:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function sR(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case go:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function oR(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case Pu:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case J1:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Z1:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function aR(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function lR(s, e, t, n) {
  const i = s.getContext(), r = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const l = iR(t), c = rR(t), u = sR(t), f = oR(t), h = aR(t), d = XP(t), m = YP(r), _ = i.createProgram();
  let g, A, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (g = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(qc).join(`
`), g.length > 0 && (g += `
`), A = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m
  ].filter(qc).join(`
`), A.length > 0 && (A += `
`)) : (g = [
    Q_(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + u : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(qc).join(`
`), A = [
    Q_(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    m,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + u : "",
    t.envMap ? "#define " + f : "",
    h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
    h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
    h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== Ls ? "#define TONE_MAPPING" : "",
    t.toneMapping !== Ls ? gt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== Ls ? qP("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    gt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    WP("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(qc).join(`
`)), a = wg(a), a = O_(a, t), a = N_(a, t), o = wg(o), o = O_(o, t), o = N_(o, t), a = G_(a), o = G_(o), t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, g = [
    d,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + g, A = [
    "#define varying in",
    t.glslVersion === yg ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === yg ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + A);
  const y = v + g + a, w = v + A + o, E = U_(i, i.VERTEX_SHADER, y), I = U_(i, i.FRAGMENT_SHADER, w);
  i.attachShader(_, E), i.attachShader(_, I), t.index0AttributeName !== void 0 ? i.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(_, 0, "position"), i.linkProgram(_);
  function C(D) {
    if (s.debug.checkShaderErrors) {
      const R = i.getProgramInfoLog(_).trim(), P = i.getShaderInfoLog(E).trim(), L = i.getShaderInfoLog(I).trim();
      let V = !0, U = !0;
      if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
        if (V = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(i, _, E, I);
        else {
          const Q = F_(i, E, "vertex"), q = F_(i, I, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(_, i.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + R + `
` + Q + `
` + q
          );
        }
      else
        R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (P === "" || L === "") && (U = !1);
      U && (D.diagnostics = {
        runnable: V,
        programLog: R,
        vertexShader: {
          log: P,
          prefix: g
        },
        fragmentShader: {
          log: L,
          prefix: A
        }
      });
    }
    i.deleteShader(E), i.deleteShader(I), B = new Bh(i, _), T = KP(i, _);
  }
  let B;
  this.getUniforms = function() {
    return B === void 0 && C(this), B;
  };
  let T;
  this.getAttributes = function() {
    return T === void 0 && C(this), T;
  };
  let S = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return S === !1 && (S = i.getProgramParameter(_, $P)), S;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(_), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = VP++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = E, this.fragmentShader = I, this;
}
let cR = 0;
class uR {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
    return a.has(i) === !1 && (a.add(i), i.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new fR(e), t.set(e, n)), n;
  }
}
class fR {
  constructor(e) {
    this.id = cR++, this.code = e, this.usedTimes = 0;
  }
}
function hR(s, e, t, n, i, r, a) {
  const o = new dd(), l = new uR(), c = /* @__PURE__ */ new Set(), u = [], f = i.logarithmicDepthBuffer, h = i.vertexTextures;
  let d = i.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function _(T) {
    return c.add(T), T === 0 ? "uv" : `uv${T}`;
  }
  function g(T, S, D, R, P) {
    const L = R.fog, V = P.geometry, U = T.isMeshStandardMaterial ? R.environment : null, Q = (T.isMeshStandardMaterial ? t : e).get(T.envMap || U), q = Q && Q.mapping === Vl ? Q.image.height : null, oe = m[T.type];
    T.precision !== null && (d = i.getMaxPrecision(T.precision), d !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", d, "instead."));
    const le = V.morphAttributes.position || V.morphAttributes.normal || V.morphAttributes.color, k = le !== void 0 ? le.length : 0;
    let X = 0;
    V.morphAttributes.position !== void 0 && (X = 1), V.morphAttributes.normal !== void 0 && (X = 2), V.morphAttributes.color !== void 0 && (X = 3);
    let fe, te, j, Ae;
    if (oe) {
      const Xe = br[oe];
      fe = Xe.vertexShader, te = Xe.fragmentShader;
    } else
      fe = T.vertexShader, te = T.fragmentShader, l.update(T), j = l.getVertexShaderID(T), Ae = l.getFragmentShaderID(T);
    const Y = s.getRenderTarget(), pe = P.isInstancedMesh === !0, me = P.isBatchedMesh === !0, re = !!T.map, ye = !!T.matcap, ae = !!Q, De = !!T.aoMap, Ee = !!T.lightMap, Ie = !!T.bumpMap, Ce = !!T.normalMap, ze = !!T.displacementMap, Fe = !!T.emissiveMap, W = !!T.metalnessMap, G = !!T.roughnessMap, se = T.anisotropy > 0, _e = T.clearcoat > 0, ve = T.dispersion > 0, ue = T.iridescence > 0, Te = T.sheen > 0, Ge = T.transmission > 0, Pe = se && !!T.anisotropyMap, he = _e && !!T.clearcoatMap, Se = _e && !!T.clearcoatNormalMap, Ve = _e && !!T.clearcoatRoughnessMap, Ye = ue && !!T.iridescenceMap, $e = ue && !!T.iridescenceThicknessMap, Ne = Te && !!T.sheenColorMap, He = Te && !!T.sheenRoughnessMap, Qe = !!T.specularMap, Ze = !!T.specularColorMap, Ke = !!T.specularIntensityMap, $ = Ge && !!T.transmissionMap, ge = Ge && !!T.thicknessMap, be = !!T.gradientMap, Ue = !!T.alphaMap, je = T.alphaTest > 0, it = !!T.alphaHash, nt = !!T.extensions;
    let mt = Ls;
    T.toneMapped && (Y === null || Y.isXRRenderTarget === !0) && (mt = s.toneMapping);
    const bt = {
      shaderID: oe,
      shaderType: T.type,
      shaderName: T.name,
      vertexShader: fe,
      fragmentShader: te,
      defines: T.defines,
      customVertexShaderID: j,
      customFragmentShaderID: Ae,
      isRawShaderMaterial: T.isRawShaderMaterial === !0,
      glslVersion: T.glslVersion,
      precision: d,
      batching: me,
      instancing: pe,
      instancingColor: pe && P.instanceColor !== null,
      instancingMorph: pe && P.morphTexture !== null,
      supportsVertexTextures: h,
      outputColorSpace: Y === null ? s.outputColorSpace : Y.isXRRenderTarget === !0 ? Y.texture.colorSpace : Bn,
      alphaToCoverage: !!T.alphaToCoverage,
      map: re,
      matcap: ye,
      envMap: ae,
      envMapMode: ae && Q.mapping,
      envMapCubeUVHeight: q,
      aoMap: De,
      lightMap: Ee,
      bumpMap: Ie,
      normalMap: Ce,
      displacementMap: h && ze,
      emissiveMap: Fe,
      normalMapObjectSpace: Ce && T.normalMapType === _x,
      normalMapTangentSpace: Ce && T.normalMapType === vo,
      metalnessMap: W,
      roughnessMap: G,
      anisotropy: se,
      anisotropyMap: Pe,
      clearcoat: _e,
      clearcoatMap: he,
      clearcoatNormalMap: Se,
      clearcoatRoughnessMap: Ve,
      dispersion: ve,
      iridescence: ue,
      iridescenceMap: Ye,
      iridescenceThicknessMap: $e,
      sheen: Te,
      sheenColorMap: Ne,
      sheenRoughnessMap: He,
      specularMap: Qe,
      specularColorMap: Ze,
      specularIntensityMap: Ke,
      transmission: Ge,
      transmissionMap: $,
      thicknessMap: ge,
      gradientMap: be,
      opaque: T.transparent === !1 && T.blending === fa && T.alphaToCoverage === !1,
      alphaMap: Ue,
      alphaTest: je,
      alphaHash: it,
      combine: T.combine,
      //
      mapUv: re && _(T.map.channel),
      aoMapUv: De && _(T.aoMap.channel),
      lightMapUv: Ee && _(T.lightMap.channel),
      bumpMapUv: Ie && _(T.bumpMap.channel),
      normalMapUv: Ce && _(T.normalMap.channel),
      displacementMapUv: ze && _(T.displacementMap.channel),
      emissiveMapUv: Fe && _(T.emissiveMap.channel),
      metalnessMapUv: W && _(T.metalnessMap.channel),
      roughnessMapUv: G && _(T.roughnessMap.channel),
      anisotropyMapUv: Pe && _(T.anisotropyMap.channel),
      clearcoatMapUv: he && _(T.clearcoatMap.channel),
      clearcoatNormalMapUv: Se && _(T.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ve && _(T.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ye && _(T.iridescenceMap.channel),
      iridescenceThicknessMapUv: $e && _(T.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ne && _(T.sheenColorMap.channel),
      sheenRoughnessMapUv: He && _(T.sheenRoughnessMap.channel),
      specularMapUv: Qe && _(T.specularMap.channel),
      specularColorMapUv: Ze && _(T.specularColorMap.channel),
      specularIntensityMapUv: Ke && _(T.specularIntensityMap.channel),
      transmissionMapUv: $ && _(T.transmissionMap.channel),
      thicknessMapUv: ge && _(T.thicknessMap.channel),
      alphaMapUv: Ue && _(T.alphaMap.channel),
      //
      vertexTangents: !!V.attributes.tangent && (Ce || se),
      vertexColors: T.vertexColors,
      vertexAlphas: T.vertexColors === !0 && !!V.attributes.color && V.attributes.color.itemSize === 4,
      pointsUvs: P.isPoints === !0 && !!V.attributes.uv && (re || Ue),
      fog: !!L,
      useFog: T.fog === !0,
      fogExp2: !!L && L.isFogExp2,
      flatShading: T.flatShading === !0,
      sizeAttenuation: T.sizeAttenuation === !0,
      logarithmicDepthBuffer: f,
      skinning: P.isSkinnedMesh === !0,
      morphTargets: V.morphAttributes.position !== void 0,
      morphNormals: V.morphAttributes.normal !== void 0,
      morphColors: V.morphAttributes.color !== void 0,
      morphTargetsCount: k,
      morphTextureStride: X,
      numDirLights: S.directional.length,
      numPointLights: S.point.length,
      numSpotLights: S.spot.length,
      numSpotLightMaps: S.spotLightMap.length,
      numRectAreaLights: S.rectArea.length,
      numHemiLights: S.hemi.length,
      numDirLightShadows: S.directionalShadowMap.length,
      numPointLightShadows: S.pointShadowMap.length,
      numSpotLightShadows: S.spotShadowMap.length,
      numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
      numLightProbes: S.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: T.dithering,
      shadowMapEnabled: s.shadowMap.enabled && D.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: mt,
      useLegacyLights: s._useLegacyLights,
      decodeVideoTexture: re && T.map.isVideoTexture === !0 && cn.getTransfer(T.map.colorSpace) === yn,
      premultipliedAlpha: T.premultipliedAlpha,
      doubleSided: T.side === zn,
      flipSided: T.side === Kn,
      useDepthPacking: T.depthPacking >= 0,
      depthPacking: T.depthPacking || 0,
      index0AttributeName: T.index0AttributeName,
      extensionClipCullDistance: nt && T.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: nt && T.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: T.customProgramCacheKey()
    };
    return bt.vertexUv1s = c.has(1), bt.vertexUv2s = c.has(2), bt.vertexUv3s = c.has(3), c.clear(), bt;
  }
  function A(T) {
    const S = [];
    if (T.shaderID ? S.push(T.shaderID) : (S.push(T.customVertexShaderID), S.push(T.customFragmentShaderID)), T.defines !== void 0)
      for (const D in T.defines)
        S.push(D), S.push(T.defines[D]);
    return T.isRawShaderMaterial === !1 && (v(S, T), y(S, T), S.push(s.outputColorSpace)), S.push(T.customProgramCacheKey), S.join();
  }
  function v(T, S) {
    T.push(S.precision), T.push(S.outputColorSpace), T.push(S.envMapMode), T.push(S.envMapCubeUVHeight), T.push(S.mapUv), T.push(S.alphaMapUv), T.push(S.lightMapUv), T.push(S.aoMapUv), T.push(S.bumpMapUv), T.push(S.normalMapUv), T.push(S.displacementMapUv), T.push(S.emissiveMapUv), T.push(S.metalnessMapUv), T.push(S.roughnessMapUv), T.push(S.anisotropyMapUv), T.push(S.clearcoatMapUv), T.push(S.clearcoatNormalMapUv), T.push(S.clearcoatRoughnessMapUv), T.push(S.iridescenceMapUv), T.push(S.iridescenceThicknessMapUv), T.push(S.sheenColorMapUv), T.push(S.sheenRoughnessMapUv), T.push(S.specularMapUv), T.push(S.specularColorMapUv), T.push(S.specularIntensityMapUv), T.push(S.transmissionMapUv), T.push(S.thicknessMapUv), T.push(S.combine), T.push(S.fogExp2), T.push(S.sizeAttenuation), T.push(S.morphTargetsCount), T.push(S.morphAttributeCount), T.push(S.numDirLights), T.push(S.numPointLights), T.push(S.numSpotLights), T.push(S.numSpotLightMaps), T.push(S.numHemiLights), T.push(S.numRectAreaLights), T.push(S.numDirLightShadows), T.push(S.numPointLightShadows), T.push(S.numSpotLightShadows), T.push(S.numSpotLightShadowsWithMaps), T.push(S.numLightProbes), T.push(S.shadowMapType), T.push(S.toneMapping), T.push(S.numClippingPlanes), T.push(S.numClipIntersection), T.push(S.depthPacking);
  }
  function y(T, S) {
    o.disableAll(), S.supportsVertexTextures && o.enable(0), S.instancing && o.enable(1), S.instancingColor && o.enable(2), S.instancingMorph && o.enable(3), S.matcap && o.enable(4), S.envMap && o.enable(5), S.normalMapObjectSpace && o.enable(6), S.normalMapTangentSpace && o.enable(7), S.clearcoat && o.enable(8), S.iridescence && o.enable(9), S.alphaTest && o.enable(10), S.vertexColors && o.enable(11), S.vertexAlphas && o.enable(12), S.vertexUv1s && o.enable(13), S.vertexUv2s && o.enable(14), S.vertexUv3s && o.enable(15), S.vertexTangents && o.enable(16), S.anisotropy && o.enable(17), S.alphaHash && o.enable(18), S.batching && o.enable(19), S.dispersion && o.enable(20), T.push(o.mask), o.disableAll(), S.fog && o.enable(0), S.useFog && o.enable(1), S.flatShading && o.enable(2), S.logarithmicDepthBuffer && o.enable(3), S.skinning && o.enable(4), S.morphTargets && o.enable(5), S.morphNormals && o.enable(6), S.morphColors && o.enable(7), S.premultipliedAlpha && o.enable(8), S.shadowMapEnabled && o.enable(9), S.useLegacyLights && o.enable(10), S.doubleSided && o.enable(11), S.flipSided && o.enable(12), S.useDepthPacking && o.enable(13), S.dithering && o.enable(14), S.transmission && o.enable(15), S.sheen && o.enable(16), S.opaque && o.enable(17), S.pointsUvs && o.enable(18), S.decodeVideoTexture && o.enable(19), S.alphaToCoverage && o.enable(20), T.push(o.mask);
  }
  function w(T) {
    const S = m[T.type];
    let D;
    if (S) {
      const R = br[S];
      D = ql.clone(R.uniforms);
    } else
      D = T.uniforms;
    return D;
  }
  function E(T, S) {
    let D;
    for (let R = 0, P = u.length; R < P; R++) {
      const L = u[R];
      if (L.cacheKey === S) {
        D = L, ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && (D = new lR(s, S, T, r), u.push(D)), D;
  }
  function I(T) {
    if (--T.usedTimes === 0) {
      const S = u.indexOf(T);
      u[S] = u[u.length - 1], u.pop(), T.destroy();
    }
  }
  function C(T) {
    l.remove(T);
  }
  function B() {
    l.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: A,
    getUniforms: w,
    acquireProgram: E,
    releaseProgram: I,
    releaseShaderCache: C,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: u,
    dispose: B
  };
}
function dR() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let a = s.get(r);
    return a === void 0 && (a = {}, s.set(r, a)), a;
  }
  function t(r) {
    s.delete(r);
  }
  function n(r, a, o) {
    s.get(r)[a] = o;
  }
  function i() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function pR(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function z_(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function $_() {
  const s = [];
  let e = 0;
  const t = [], n = [], i = [];
  function r() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function a(f, h, d, m, _, g) {
    let A = s[e];
    return A === void 0 ? (A = {
      id: f.id,
      object: f,
      geometry: h,
      material: d,
      groupOrder: m,
      renderOrder: f.renderOrder,
      z: _,
      group: g
    }, s[e] = A) : (A.id = f.id, A.object = f, A.geometry = h, A.material = d, A.groupOrder = m, A.renderOrder = f.renderOrder, A.z = _, A.group = g), e++, A;
  }
  function o(f, h, d, m, _, g) {
    const A = a(f, h, d, m, _, g);
    d.transmission > 0 ? n.push(A) : d.transparent === !0 ? i.push(A) : t.push(A);
  }
  function l(f, h, d, m, _, g) {
    const A = a(f, h, d, m, _, g);
    d.transmission > 0 ? n.unshift(A) : d.transparent === !0 ? i.unshift(A) : t.unshift(A);
  }
  function c(f, h) {
    t.length > 1 && t.sort(f || pR), n.length > 1 && n.sort(h || z_), i.length > 1 && i.sort(h || z_);
  }
  function u() {
    for (let f = e, h = s.length; f < h; f++) {
      const d = s[f];
      if (d.id === null)
        break;
      d.id = null, d.object = null, d.geometry = null, d.material = null, d.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: o,
    unshift: l,
    finish: u,
    sort: c
  };
}
function mR() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    const r = s.get(n);
    let a;
    return r === void 0 ? (a = new $_(), s.set(n, [a])) : i >= r.length ? (a = new $_(), r.push(a)) : a = r[i], a;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function gR() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new H(),
            color: new Je()
          };
          break;
        case "SpotLight":
          t = {
            position: new H(),
            direction: new H(),
            color: new Je(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new H(),
            color: new Je(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new H(),
            skyColor: new Je(),
            groundColor: new Je()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Je(),
            position: new H(),
            halfWidth: new H(),
            halfHeight: new H()
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
function AR() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
let _R = 0;
function bR(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function vR(s) {
  const e = new gR(), t = AR(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let c = 0; c < 9; c++)
    n.probe.push(new H());
  const i = new H(), r = new st(), a = new st();
  function o(c, u) {
    let f = 0, h = 0, d = 0;
    for (let D = 0; D < 9; D++)
      n.probe[D].set(0, 0, 0);
    let m = 0, _ = 0, g = 0, A = 0, v = 0, y = 0, w = 0, E = 0, I = 0, C = 0, B = 0;
    c.sort(bR);
    const T = u === !0 ? Math.PI : 1;
    for (let D = 0, R = c.length; D < R; D++) {
      const P = c[D], L = P.color, V = P.intensity, U = P.distance, Q = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
      if (P.isAmbientLight)
        f += L.r * V * T, h += L.g * V * T, d += L.b * V * T;
      else if (P.isLightProbe) {
        for (let q = 0; q < 9; q++)
          n.probe[q].addScaledVector(P.sh.coefficients[q], V);
        B++;
      } else if (P.isDirectionalLight) {
        const q = e.get(P);
        if (q.color.copy(P.color).multiplyScalar(P.intensity * T), P.castShadow) {
          const oe = P.shadow, le = t.get(P);
          le.shadowBias = oe.bias, le.shadowNormalBias = oe.normalBias, le.shadowRadius = oe.radius, le.shadowMapSize = oe.mapSize, n.directionalShadow[m] = le, n.directionalShadowMap[m] = Q, n.directionalShadowMatrix[m] = P.shadow.matrix, y++;
        }
        n.directional[m] = q, m++;
      } else if (P.isSpotLight) {
        const q = e.get(P);
        q.position.setFromMatrixPosition(P.matrixWorld), q.color.copy(L).multiplyScalar(V * T), q.distance = U, q.coneCos = Math.cos(P.angle), q.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)), q.decay = P.decay, n.spot[g] = q;
        const oe = P.shadow;
        if (P.map && (n.spotLightMap[I] = P.map, I++, oe.updateMatrices(P), P.castShadow && C++), n.spotLightMatrix[g] = oe.matrix, P.castShadow) {
          const le = t.get(P);
          le.shadowBias = oe.bias, le.shadowNormalBias = oe.normalBias, le.shadowRadius = oe.radius, le.shadowMapSize = oe.mapSize, n.spotShadow[g] = le, n.spotShadowMap[g] = Q, E++;
        }
        g++;
      } else if (P.isRectAreaLight) {
        const q = e.get(P);
        q.color.copy(L).multiplyScalar(V), q.halfWidth.set(P.width * 0.5, 0, 0), q.halfHeight.set(0, P.height * 0.5, 0), n.rectArea[A] = q, A++;
      } else if (P.isPointLight) {
        const q = e.get(P);
        if (q.color.copy(P.color).multiplyScalar(P.intensity * T), q.distance = P.distance, q.decay = P.decay, P.castShadow) {
          const oe = P.shadow, le = t.get(P);
          le.shadowBias = oe.bias, le.shadowNormalBias = oe.normalBias, le.shadowRadius = oe.radius, le.shadowMapSize = oe.mapSize, le.shadowCameraNear = oe.camera.near, le.shadowCameraFar = oe.camera.far, n.pointShadow[_] = le, n.pointShadowMap[_] = Q, n.pointShadowMatrix[_] = P.shadow.matrix, w++;
        }
        n.point[_] = q, _++;
      } else if (P.isHemisphereLight) {
        const q = e.get(P);
        q.skyColor.copy(P.color).multiplyScalar(V * T), q.groundColor.copy(P.groundColor).multiplyScalar(V * T), n.hemi[v] = q, v++;
      }
    }
    A > 0 && (s.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = ot.LTC_FLOAT_1, n.rectAreaLTC2 = ot.LTC_FLOAT_2) : (n.rectAreaLTC1 = ot.LTC_HALF_1, n.rectAreaLTC2 = ot.LTC_HALF_2)), n.ambient[0] = f, n.ambient[1] = h, n.ambient[2] = d;
    const S = n.hash;
    (S.directionalLength !== m || S.pointLength !== _ || S.spotLength !== g || S.rectAreaLength !== A || S.hemiLength !== v || S.numDirectionalShadows !== y || S.numPointShadows !== w || S.numSpotShadows !== E || S.numSpotMaps !== I || S.numLightProbes !== B) && (n.directional.length = m, n.spot.length = g, n.rectArea.length = A, n.point.length = _, n.hemi.length = v, n.directionalShadow.length = y, n.directionalShadowMap.length = y, n.pointShadow.length = w, n.pointShadowMap.length = w, n.spotShadow.length = E, n.spotShadowMap.length = E, n.directionalShadowMatrix.length = y, n.pointShadowMatrix.length = w, n.spotLightMatrix.length = E + I - C, n.spotLightMap.length = I, n.numSpotLightShadowsWithMaps = C, n.numLightProbes = B, S.directionalLength = m, S.pointLength = _, S.spotLength = g, S.rectAreaLength = A, S.hemiLength = v, S.numDirectionalShadows = y, S.numPointShadows = w, S.numSpotShadows = E, S.numSpotMaps = I, S.numLightProbes = B, n.version = _R++);
  }
  function l(c, u) {
    let f = 0, h = 0, d = 0, m = 0, _ = 0;
    const g = u.matrixWorldInverse;
    for (let A = 0, v = c.length; A < v; A++) {
      const y = c[A];
      if (y.isDirectionalLight) {
        const w = n.directional[f];
        w.direction.setFromMatrixPosition(y.matrixWorld), i.setFromMatrixPosition(y.target.matrixWorld), w.direction.sub(i), w.direction.transformDirection(g), f++;
      } else if (y.isSpotLight) {
        const w = n.spot[d];
        w.position.setFromMatrixPosition(y.matrixWorld), w.position.applyMatrix4(g), w.direction.setFromMatrixPosition(y.matrixWorld), i.setFromMatrixPosition(y.target.matrixWorld), w.direction.sub(i), w.direction.transformDirection(g), d++;
      } else if (y.isRectAreaLight) {
        const w = n.rectArea[m];
        w.position.setFromMatrixPosition(y.matrixWorld), w.position.applyMatrix4(g), a.identity(), r.copy(y.matrixWorld), r.premultiply(g), a.extractRotation(r), w.halfWidth.set(y.width * 0.5, 0, 0), w.halfHeight.set(0, y.height * 0.5, 0), w.halfWidth.applyMatrix4(a), w.halfHeight.applyMatrix4(a), m++;
      } else if (y.isPointLight) {
        const w = n.point[h];
        w.position.setFromMatrixPosition(y.matrixWorld), w.position.applyMatrix4(g), h++;
      } else if (y.isHemisphereLight) {
        const w = n.hemi[_];
        w.direction.setFromMatrixPosition(y.matrixWorld), w.direction.transformDirection(g), _++;
      }
    }
  }
  return {
    setup: o,
    setupView: l,
    state: n
  };
}
function V_(s) {
  const e = new vR(s), t = [], n = [];
  function i(u) {
    c.camera = u, t.length = 0, n.length = 0;
  }
  function r(u) {
    t.push(u);
  }
  function a(u) {
    n.push(u);
  }
  function o(u) {
    e.setup(t, u);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: c,
    setupLights: o,
    setupLightsView: l,
    pushLight: r,
    pushShadow: a
  };
}
function yR(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(i, r = 0) {
    const a = e.get(i);
    let o;
    return a === void 0 ? (o = new V_(s), e.set(i, [o])) : r >= a.length ? (o = new V_(s), a.push(o)) : o = a[r], o;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: n
  };
}
class Ea extends ii {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Ax, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Kl extends ii {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const xR = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, wR = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function ER(s, e, t) {
  let n = new ku();
  const i = new ke(), r = new ke(), a = new Xt(), o = new Ea({ depthPacking: jl }), l = new Kl(), c = {}, u = t.maxTextureSize, f = { [Hi]: Kn, [Kn]: Hi, [zn]: zn }, h = new Hn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ke() },
      radius: { value: 4 }
    },
    vertexShader: xR,
    fragmentShader: wR
  }), d = h.clone();
  d.defines.HORIZONTAL_PASS = 1;
  const m = new Dt();
  m.setAttribute(
    "position",
    new Rt(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const _ = new tt(m, h), g = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = aA;
  let A = this.type;
  this.render = function(I, C, B) {
    if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || I.length === 0)
      return;
    const T = s.getRenderTarget(), S = s.getActiveCubeFace(), D = s.getActiveMipmapLevel(), R = s.state;
    R.setBlending(Ds), R.buffers.color.setClear(1, 1, 1, 1), R.buffers.depth.setTest(!0), R.setScissorTest(!1);
    const P = A !== es && this.type === es, L = A === es && this.type !== es;
    for (let V = 0, U = I.length; V < U; V++) {
      const Q = I[V], q = Q.shadow;
      if (q === void 0) {
        console.warn("THREE.WebGLShadowMap:", Q, "has no shadow.");
        continue;
      }
      if (q.autoUpdate === !1 && q.needsUpdate === !1)
        continue;
      i.copy(q.mapSize);
      const oe = q.getFrameExtents();
      if (i.multiply(oe), r.copy(q.mapSize), (i.x > u || i.y > u) && (i.x > u && (r.x = Math.floor(u / oe.x), i.x = r.x * oe.x, q.mapSize.x = r.x), i.y > u && (r.y = Math.floor(u / oe.y), i.y = r.y * oe.y, q.mapSize.y = r.y)), q.map === null || P === !0 || L === !0) {
        const k = this.type !== es ? { minFilter: nn, magFilter: nn } : {};
        q.map !== null && q.map.dispose(), q.map = new Ji(i.x, i.y, k), q.map.texture.name = Q.name + ".shadowMap", q.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(q.map), s.clear();
      const le = q.getViewportCount();
      for (let k = 0; k < le; k++) {
        const X = q.getViewport(k);
        a.set(
          r.x * X.x,
          r.y * X.y,
          r.x * X.z,
          r.y * X.w
        ), R.viewport(a), q.updateMatrices(Q, k), n = q.getFrustum(), w(C, B, q.camera, Q, this.type);
      }
      q.isPointLightShadow !== !0 && this.type === es && v(q, B), q.needsUpdate = !1;
    }
    A = this.type, g.needsUpdate = !1, s.setRenderTarget(T, S, D);
  };
  function v(I, C) {
    const B = e.update(_);
    h.defines.VSM_SAMPLES !== I.blurSamples && (h.defines.VSM_SAMPLES = I.blurSamples, d.defines.VSM_SAMPLES = I.blurSamples, h.needsUpdate = !0, d.needsUpdate = !0), I.mapPass === null && (I.mapPass = new Ji(i.x, i.y)), h.uniforms.shadow_pass.value = I.map.texture, h.uniforms.resolution.value = I.mapSize, h.uniforms.radius.value = I.radius, s.setRenderTarget(I.mapPass), s.clear(), s.renderBufferDirect(C, null, B, h, _, null), d.uniforms.shadow_pass.value = I.mapPass.texture, d.uniforms.resolution.value = I.mapSize, d.uniforms.radius.value = I.radius, s.setRenderTarget(I.map), s.clear(), s.renderBufferDirect(C, null, B, d, _, null);
  }
  function y(I, C, B, T) {
    let S = null;
    const D = B.isPointLight === !0 ? I.customDistanceMaterial : I.customDepthMaterial;
    if (D !== void 0)
      S = D;
    else if (S = B.isPointLight === !0 ? l : o, s.localClippingEnabled && C.clipShadows === !0 && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0) {
      const R = S.uuid, P = C.uuid;
      let L = c[R];
      L === void 0 && (L = {}, c[R] = L);
      let V = L[P];
      V === void 0 && (V = S.clone(), L[P] = V, C.addEventListener("dispose", E)), S = V;
    }
    if (S.visible = C.visible, S.wireframe = C.wireframe, T === es ? S.side = C.shadowSide !== null ? C.shadowSide : C.side : S.side = C.shadowSide !== null ? C.shadowSide : f[C.side], S.alphaMap = C.alphaMap, S.alphaTest = C.alphaTest, S.map = C.map, S.clipShadows = C.clipShadows, S.clippingPlanes = C.clippingPlanes, S.clipIntersection = C.clipIntersection, S.displacementMap = C.displacementMap, S.displacementScale = C.displacementScale, S.displacementBias = C.displacementBias, S.wireframeLinewidth = C.wireframeLinewidth, S.linewidth = C.linewidth, B.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
      const R = s.properties.get(S);
      R.light = B;
    }
    return S;
  }
  function w(I, C, B, T, S) {
    if (I.visible === !1)
      return;
    if (I.layers.test(C.layers) && (I.isMesh || I.isLine || I.isPoints) && (I.castShadow || I.receiveShadow && S === es) && (!I.frustumCulled || n.intersectsObject(I))) {
      I.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, I.matrixWorld);
      const P = e.update(I), L = I.material;
      if (Array.isArray(L)) {
        const V = P.groups;
        for (let U = 0, Q = V.length; U < Q; U++) {
          const q = V[U], oe = L[q.materialIndex];
          if (oe && oe.visible) {
            const le = y(I, oe, T, S);
            I.onBeforeShadow(s, I, C, B, P, le, q), s.renderBufferDirect(B, null, P, le, I, q), I.onAfterShadow(s, I, C, B, P, le, q);
          }
        }
      } else if (L.visible) {
        const V = y(I, L, T, S);
        I.onBeforeShadow(s, I, C, B, P, V, null), s.renderBufferDirect(B, null, P, V, I, null), I.onAfterShadow(s, I, C, B, P, V, null);
      }
    }
    const R = I.children;
    for (let P = 0, L = R.length; P < L; P++)
      w(R[P], C, B, T, S);
  }
  function E(I) {
    I.target.removeEventListener("dispose", E);
    for (const B in c) {
      const T = c[B], S = I.target.uuid;
      S in T && (T[S].dispose(), delete T[S]);
    }
  }
}
function CR(s) {
  function e() {
    let $ = !1;
    const ge = new Xt();
    let be = null;
    const Ue = new Xt(0, 0, 0, 0);
    return {
      setMask: function(je) {
        be !== je && !$ && (s.colorMask(je, je, je, je), be = je);
      },
      setLocked: function(je) {
        $ = je;
      },
      setClear: function(je, it, nt, mt, bt) {
        bt === !0 && (je *= mt, it *= mt, nt *= mt), ge.set(je, it, nt, mt), Ue.equals(ge) === !1 && (s.clearColor(je, it, nt, mt), Ue.copy(ge));
      },
      reset: function() {
        $ = !1, be = null, Ue.set(-1, 0, 0, 0);
      }
    };
  }
  function t() {
    let $ = !1, ge = null, be = null, Ue = null;
    return {
      setTest: function(je) {
        je ? Ae(s.DEPTH_TEST) : Y(s.DEPTH_TEST);
      },
      setMask: function(je) {
        ge !== je && !$ && (s.depthMask(je), ge = je);
      },
      setFunc: function(je) {
        if (be !== je) {
          switch (je) {
            case H1:
              s.depthFunc(s.NEVER);
              break;
            case j1:
              s.depthFunc(s.ALWAYS);
              break;
            case W1:
              s.depthFunc(s.LESS);
              break;
            case fu:
              s.depthFunc(s.LEQUAL);
              break;
            case q1:
              s.depthFunc(s.EQUAL);
              break;
            case X1:
              s.depthFunc(s.GEQUAL);
              break;
            case Y1:
              s.depthFunc(s.GREATER);
              break;
            case K1:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          be = je;
        }
      },
      setLocked: function(je) {
        $ = je;
      },
      setClear: function(je) {
        Ue !== je && (s.clearDepth(je), Ue = je);
      },
      reset: function() {
        $ = !1, ge = null, be = null, Ue = null;
      }
    };
  }
  function n() {
    let $ = !1, ge = null, be = null, Ue = null, je = null, it = null, nt = null, mt = null, bt = null;
    return {
      setTest: function(Xe) {
        $ || (Xe ? Ae(s.STENCIL_TEST) : Y(s.STENCIL_TEST));
      },
      setMask: function(Xe) {
        ge !== Xe && !$ && (s.stencilMask(Xe), ge = Xe);
      },
      setFunc: function(Xe, dt, at) {
        (be !== Xe || Ue !== dt || je !== at) && (s.stencilFunc(Xe, dt, at), be = Xe, Ue = dt, je = at);
      },
      setOp: function(Xe, dt, at) {
        (it !== Xe || nt !== dt || mt !== at) && (s.stencilOp(Xe, dt, at), it = Xe, nt = dt, mt = at);
      },
      setLocked: function(Xe) {
        $ = Xe;
      },
      setClear: function(Xe) {
        bt !== Xe && (s.clearStencil(Xe), bt = Xe);
      },
      reset: function() {
        $ = !1, ge = null, be = null, Ue = null, je = null, it = null, nt = null, mt = null, bt = null;
      }
    };
  }
  const i = new e(), r = new t(), a = new n(), o = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
  let c = {}, u = {}, f = /* @__PURE__ */ new WeakMap(), h = [], d = null, m = !1, _ = null, g = null, A = null, v = null, y = null, w = null, E = null, I = new Je(0, 0, 0), C = 0, B = !1, T = null, S = null, D = null, R = null, P = null;
  const L = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1, U = 0;
  const Q = s.getParameter(s.VERSION);
  Q.indexOf("WebGL") !== -1 ? (U = parseFloat(/^WebGL (\d)/.exec(Q)[1]), V = U >= 1) : Q.indexOf("OpenGL ES") !== -1 && (U = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), V = U >= 2);
  let q = null, oe = {};
  const le = s.getParameter(s.SCISSOR_BOX), k = s.getParameter(s.VIEWPORT), X = new Xt().fromArray(le), fe = new Xt().fromArray(k);
  function te($, ge, be, Ue) {
    const je = new Uint8Array(4), it = s.createTexture();
    s.bindTexture($, it), s.texParameteri($, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri($, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let nt = 0; nt < be; nt++)
      $ === s.TEXTURE_3D || $ === s.TEXTURE_2D_ARRAY ? s.texImage3D(ge, 0, s.RGBA, 1, 1, Ue, 0, s.RGBA, s.UNSIGNED_BYTE, je) : s.texImage2D(ge + nt, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, je);
    return it;
  }
  const j = {};
  j[s.TEXTURE_2D] = te(s.TEXTURE_2D, s.TEXTURE_2D, 1), j[s.TEXTURE_CUBE_MAP] = te(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), j[s.TEXTURE_2D_ARRAY] = te(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), j[s.TEXTURE_3D] = te(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), r.setClear(1), a.setClear(0), Ae(s.DEPTH_TEST), r.setFunc(fu), Ie(!1), Ce(Jm), Ae(s.CULL_FACE), De(Ds);
  function Ae($) {
    c[$] !== !0 && (s.enable($), c[$] = !0);
  }
  function Y($) {
    c[$] !== !1 && (s.disable($), c[$] = !1);
  }
  function pe($, ge) {
    return u[$] !== ge ? (s.bindFramebuffer($, ge), u[$] = ge, $ === s.DRAW_FRAMEBUFFER && (u[s.FRAMEBUFFER] = ge), $ === s.FRAMEBUFFER && (u[s.DRAW_FRAMEBUFFER] = ge), !0) : !1;
  }
  function me($, ge) {
    let be = h, Ue = !1;
    if ($) {
      be = f.get(ge), be === void 0 && (be = [], f.set(ge, be));
      const je = $.textures;
      if (be.length !== je.length || be[0] !== s.COLOR_ATTACHMENT0) {
        for (let it = 0, nt = je.length; it < nt; it++)
          be[it] = s.COLOR_ATTACHMENT0 + it;
        be.length = je.length, Ue = !0;
      }
    } else
      be[0] !== s.BACK && (be[0] = s.BACK, Ue = !0);
    Ue && s.drawBuffers(be);
  }
  function re($) {
    return d !== $ ? (s.useProgram($), d = $, !0) : !1;
  }
  const ye = {
    [co]: s.FUNC_ADD,
    [I1]: s.FUNC_SUBTRACT,
    [T1]: s.FUNC_REVERSE_SUBTRACT
  };
  ye[B1] = s.MIN, ye[P1] = s.MAX;
  const ae = {
    [R1]: s.ZERO,
    [D1]: s.ONE,
    [L1]: s.SRC_COLOR,
    [Gh]: s.SRC_ALPHA,
    [G1]: s.SRC_ALPHA_SATURATE,
    [O1]: s.DST_COLOR,
    [U1]: s.DST_ALPHA,
    [k1]: s.ONE_MINUS_SRC_COLOR,
    [Qh]: s.ONE_MINUS_SRC_ALPHA,
    [N1]: s.ONE_MINUS_DST_COLOR,
    [F1]: s.ONE_MINUS_DST_ALPHA,
    [Q1]: s.CONSTANT_COLOR,
    [z1]: s.ONE_MINUS_CONSTANT_COLOR,
    [$1]: s.CONSTANT_ALPHA,
    [V1]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function De($, ge, be, Ue, je, it, nt, mt, bt, Xe) {
    if ($ === Ds) {
      m === !0 && (Y(s.BLEND), m = !1);
      return;
    }
    if (m === !1 && (Ae(s.BLEND), m = !0), $ !== M1) {
      if ($ !== _ || Xe !== B) {
        if ((g !== co || y !== co) && (s.blendEquation(s.FUNC_ADD), g = co, y = co), Xe)
          switch ($) {
            case fa:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case uu:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case Zm:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case eg:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", $);
              break;
          }
        else
          switch ($) {
            case fa:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case uu:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case Zm:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case eg:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", $);
              break;
          }
        A = null, v = null, w = null, E = null, I.set(0, 0, 0), C = 0, _ = $, B = Xe;
      }
      return;
    }
    je = je || ge, it = it || be, nt = nt || Ue, (ge !== g || je !== y) && (s.blendEquationSeparate(ye[ge], ye[je]), g = ge, y = je), (be !== A || Ue !== v || it !== w || nt !== E) && (s.blendFuncSeparate(ae[be], ae[Ue], ae[it], ae[nt]), A = be, v = Ue, w = it, E = nt), (mt.equals(I) === !1 || bt !== C) && (s.blendColor(mt.r, mt.g, mt.b, bt), I.copy(mt), C = bt), _ = $, B = !1;
  }
  function Ee($, ge) {
    $.side === zn ? Y(s.CULL_FACE) : Ae(s.CULL_FACE);
    let be = $.side === Kn;
    ge && (be = !be), Ie(be), $.blending === fa && $.transparent === !1 ? De(Ds) : De($.blending, $.blendEquation, $.blendSrc, $.blendDst, $.blendEquationAlpha, $.blendSrcAlpha, $.blendDstAlpha, $.blendColor, $.blendAlpha, $.premultipliedAlpha), r.setFunc($.depthFunc), r.setTest($.depthTest), r.setMask($.depthWrite), i.setMask($.colorWrite);
    const Ue = $.stencilWrite;
    a.setTest(Ue), Ue && (a.setMask($.stencilWriteMask), a.setFunc($.stencilFunc, $.stencilRef, $.stencilFuncMask), a.setOp($.stencilFail, $.stencilZFail, $.stencilZPass)), Fe($.polygonOffset, $.polygonOffsetFactor, $.polygonOffsetUnits), $.alphaToCoverage === !0 ? Ae(s.SAMPLE_ALPHA_TO_COVERAGE) : Y(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ie($) {
    T !== $ && ($ ? s.frontFace(s.CW) : s.frontFace(s.CCW), T = $);
  }
  function Ce($) {
    $ !== C1 ? (Ae(s.CULL_FACE), $ !== S && ($ === Jm ? s.cullFace(s.BACK) : $ === S1 ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Y(s.CULL_FACE), S = $;
  }
  function ze($) {
    $ !== D && (V && s.lineWidth($), D = $);
  }
  function Fe($, ge, be) {
    $ ? (Ae(s.POLYGON_OFFSET_FILL), (R !== ge || P !== be) && (s.polygonOffset(ge, be), R = ge, P = be)) : Y(s.POLYGON_OFFSET_FILL);
  }
  function W($) {
    $ ? Ae(s.SCISSOR_TEST) : Y(s.SCISSOR_TEST);
  }
  function G($) {
    $ === void 0 && ($ = s.TEXTURE0 + L - 1), q !== $ && (s.activeTexture($), q = $);
  }
  function se($, ge, be) {
    be === void 0 && (q === null ? be = s.TEXTURE0 + L - 1 : be = q);
    let Ue = oe[be];
    Ue === void 0 && (Ue = { type: void 0, texture: void 0 }, oe[be] = Ue), (Ue.type !== $ || Ue.texture !== ge) && (q !== be && (s.activeTexture(be), q = be), s.bindTexture($, ge || j[$]), Ue.type = $, Ue.texture = ge);
  }
  function _e() {
    const $ = oe[q];
    $ !== void 0 && $.type !== void 0 && (s.bindTexture($.type, null), $.type = void 0, $.texture = void 0);
  }
  function ve() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function ue() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Te() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Ge() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Pe() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function he() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Se() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Ve() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Ye() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function $e() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch ($) {
      console.error("THREE.WebGLState:", $);
    }
  }
  function Ne($) {
    X.equals($) === !1 && (s.scissor($.x, $.y, $.z, $.w), X.copy($));
  }
  function He($) {
    fe.equals($) === !1 && (s.viewport($.x, $.y, $.z, $.w), fe.copy($));
  }
  function Qe($, ge) {
    let be = l.get(ge);
    be === void 0 && (be = /* @__PURE__ */ new WeakMap(), l.set(ge, be));
    let Ue = be.get($);
    Ue === void 0 && (Ue = s.getUniformBlockIndex(ge, $.name), be.set($, Ue));
  }
  function Ze($, ge) {
    const Ue = l.get(ge).get($);
    o.get(ge) !== Ue && (s.uniformBlockBinding(ge, Ue, $.__bindingPointIndex), o.set(ge, Ue));
  }
  function Ke() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), c = {}, q = null, oe = {}, u = {}, f = /* @__PURE__ */ new WeakMap(), h = [], d = null, m = !1, _ = null, g = null, A = null, v = null, y = null, w = null, E = null, I = new Je(0, 0, 0), C = 0, B = !1, T = null, S = null, D = null, R = null, P = null, X.set(0, 0, s.canvas.width, s.canvas.height), fe.set(0, 0, s.canvas.width, s.canvas.height), i.reset(), r.reset(), a.reset();
  }
  return {
    buffers: {
      color: i,
      depth: r,
      stencil: a
    },
    enable: Ae,
    disable: Y,
    bindFramebuffer: pe,
    drawBuffers: me,
    useProgram: re,
    setBlending: De,
    setMaterial: Ee,
    setFlipSided: Ie,
    setCullFace: Ce,
    setLineWidth: ze,
    setPolygonOffset: Fe,
    setScissorTest: W,
    activeTexture: G,
    bindTexture: se,
    unbindTexture: _e,
    compressedTexImage2D: ve,
    compressedTexImage3D: ue,
    texImage2D: Ye,
    texImage3D: $e,
    updateUBOMapping: Qe,
    uniformBlockBinding: Ze,
    texStorage2D: Se,
    texStorage3D: Ve,
    texSubImage2D: Te,
    texSubImage3D: Ge,
    compressedTexSubImage2D: Pe,
    compressedTexSubImage3D: he,
    scissor: Ne,
    viewport: He,
    reset: Ke
  };
}
function SR(s, e, t, n, i, r, a) {
  const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), c = new ke(), u = /* @__PURE__ */ new WeakMap();
  let f;
  const h = /* @__PURE__ */ new WeakMap();
  let d = !1;
  try {
    d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(W, G) {
    return d ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(W, G)
    ) : vu("canvas");
  }
  function _(W, G, se) {
    let _e = 1;
    const ve = Fe(W);
    if ((ve.width > se || ve.height > se) && (_e = se / Math.max(ve.width, ve.height)), _e < 1)
      if (typeof HTMLImageElement < "u" && W instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && W instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && W instanceof ImageBitmap || typeof VideoFrame < "u" && W instanceof VideoFrame) {
        const ue = Math.floor(_e * ve.width), Te = Math.floor(_e * ve.height);
        f === void 0 && (f = m(ue, Te));
        const Ge = G ? m(ue, Te) : f;
        return Ge.width = ue, Ge.height = Te, Ge.getContext("2d").drawImage(W, 0, 0, ue, Te), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ve.width + "x" + ve.height + ") to (" + ue + "x" + Te + ")."), Ge;
      } else
        return "data" in W && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ve.width + "x" + ve.height + ")."), W;
    return W;
  }
  function g(W) {
    return W.generateMipmaps && W.minFilter !== nn && W.minFilter !== Yt;
  }
  function A(W) {
    s.generateMipmap(W);
  }
  function v(W, G, se, _e, ve = !1) {
    if (W !== null) {
      if (s[W] !== void 0)
        return s[W];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + W + "'");
    }
    let ue = G;
    if (G === s.RED && (se === s.FLOAT && (ue = s.R32F), se === s.HALF_FLOAT && (ue = s.R16F), se === s.UNSIGNED_BYTE && (ue = s.R8)), G === s.RED_INTEGER && (se === s.UNSIGNED_BYTE && (ue = s.R8UI), se === s.UNSIGNED_SHORT && (ue = s.R16UI), se === s.UNSIGNED_INT && (ue = s.R32UI), se === s.BYTE && (ue = s.R8I), se === s.SHORT && (ue = s.R16I), se === s.INT && (ue = s.R32I)), G === s.RG && (se === s.FLOAT && (ue = s.RG32F), se === s.HALF_FLOAT && (ue = s.RG16F), se === s.UNSIGNED_BYTE && (ue = s.RG8)), G === s.RG_INTEGER && (se === s.UNSIGNED_BYTE && (ue = s.RG8UI), se === s.UNSIGNED_SHORT && (ue = s.RG16UI), se === s.UNSIGNED_INT && (ue = s.RG32UI), se === s.BYTE && (ue = s.RG8I), se === s.SHORT && (ue = s.RG16I), se === s.INT && (ue = s.RG32I)), G === s.RGB && se === s.UNSIGNED_INT_5_9_9_9_REV && (ue = s.RGB9_E5), G === s.RGBA) {
      const Te = ve ? mu : cn.getTransfer(_e);
      se === s.FLOAT && (ue = s.RGBA32F), se === s.HALF_FLOAT && (ue = s.RGBA16F), se === s.UNSIGNED_BYTE && (ue = Te === yn ? s.SRGB8_ALPHA8 : s.RGBA8), se === s.UNSIGNED_SHORT_4_4_4_4 && (ue = s.RGBA4), se === s.UNSIGNED_SHORT_5_5_5_1 && (ue = s.RGB5_A1);
    }
    return (ue === s.R16F || ue === s.R32F || ue === s.RG16F || ue === s.RG32F || ue === s.RGBA16F || ue === s.RGBA32F) && e.get("EXT_color_buffer_float"), ue;
  }
  function y(W, G) {
    return g(W) === !0 || W.isFramebufferTexture && W.minFilter !== nn && W.minFilter !== Yt ? Math.log2(Math.max(G.width, G.height)) + 1 : W.mipmaps !== void 0 && W.mipmaps.length > 0 ? W.mipmaps.length : W.isCompressedTexture && Array.isArray(W.image) ? G.mipmaps.length : 1;
  }
  function w(W) {
    const G = W.target;
    G.removeEventListener("dispose", w), I(G), G.isVideoTexture && u.delete(G);
  }
  function E(W) {
    const G = W.target;
    G.removeEventListener("dispose", E), B(G);
  }
  function I(W) {
    const G = n.get(W);
    if (G.__webglInit === void 0)
      return;
    const se = W.source, _e = h.get(se);
    if (_e) {
      const ve = _e[G.__cacheKey];
      ve.usedTimes--, ve.usedTimes === 0 && C(W), Object.keys(_e).length === 0 && h.delete(se);
    }
    n.remove(W);
  }
  function C(W) {
    const G = n.get(W);
    s.deleteTexture(G.__webglTexture);
    const se = W.source, _e = h.get(se);
    delete _e[G.__cacheKey], a.memory.textures--;
  }
  function B(W) {
    const G = n.get(W);
    if (W.depthTexture && W.depthTexture.dispose(), W.isWebGLCubeRenderTarget)
      for (let _e = 0; _e < 6; _e++) {
        if (Array.isArray(G.__webglFramebuffer[_e]))
          for (let ve = 0; ve < G.__webglFramebuffer[_e].length; ve++)
            s.deleteFramebuffer(G.__webglFramebuffer[_e][ve]);
        else
          s.deleteFramebuffer(G.__webglFramebuffer[_e]);
        G.__webglDepthbuffer && s.deleteRenderbuffer(G.__webglDepthbuffer[_e]);
      }
    else {
      if (Array.isArray(G.__webglFramebuffer))
        for (let _e = 0; _e < G.__webglFramebuffer.length; _e++)
          s.deleteFramebuffer(G.__webglFramebuffer[_e]);
      else
        s.deleteFramebuffer(G.__webglFramebuffer);
      if (G.__webglDepthbuffer && s.deleteRenderbuffer(G.__webglDepthbuffer), G.__webglMultisampledFramebuffer && s.deleteFramebuffer(G.__webglMultisampledFramebuffer), G.__webglColorRenderbuffer)
        for (let _e = 0; _e < G.__webglColorRenderbuffer.length; _e++)
          G.__webglColorRenderbuffer[_e] && s.deleteRenderbuffer(G.__webglColorRenderbuffer[_e]);
      G.__webglDepthRenderbuffer && s.deleteRenderbuffer(G.__webglDepthRenderbuffer);
    }
    const se = W.textures;
    for (let _e = 0, ve = se.length; _e < ve; _e++) {
      const ue = n.get(se[_e]);
      ue.__webglTexture && (s.deleteTexture(ue.__webglTexture), a.memory.textures--), n.remove(se[_e]);
    }
    n.remove(W);
  }
  let T = 0;
  function S() {
    T = 0;
  }
  function D() {
    const W = T;
    return W >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + W + " texture units while this GPU supports only " + i.maxTextures), T += 1, W;
  }
  function R(W) {
    const G = [];
    return G.push(W.wrapS), G.push(W.wrapT), G.push(W.wrapR || 0), G.push(W.magFilter), G.push(W.minFilter), G.push(W.anisotropy), G.push(W.internalFormat), G.push(W.format), G.push(W.type), G.push(W.generateMipmaps), G.push(W.premultiplyAlpha), G.push(W.flipY), G.push(W.unpackAlignment), G.push(W.colorSpace), G.join();
  }
  function P(W, G) {
    const se = n.get(W);
    if (W.isVideoTexture && Ce(W), W.isRenderTargetTexture === !1 && W.version > 0 && se.__version !== W.version) {
      const _e = W.image;
      if (_e === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (_e.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        X(se, W, G);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, se.__webglTexture, s.TEXTURE0 + G);
  }
  function L(W, G) {
    const se = n.get(W);
    if (W.version > 0 && se.__version !== W.version) {
      X(se, W, G);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, se.__webglTexture, s.TEXTURE0 + G);
  }
  function V(W, G) {
    const se = n.get(W);
    if (W.version > 0 && se.__version !== W.version) {
      X(se, W, G);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, se.__webglTexture, s.TEXTURE0 + G);
  }
  function U(W, G) {
    const se = n.get(W);
    if (W.version > 0 && se.__version !== W.version) {
      fe(se, W, G);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, se.__webglTexture, s.TEXTURE0 + G);
  }
  const Q = {
    [Or]: s.REPEAT,
    [yi]: s.CLAMP_TO_EDGE,
    [Ul]: s.MIRRORED_REPEAT
  }, q = {
    [nn]: s.NEAREST,
    [ad]: s.NEAREST_MIPMAP_NEAREST,
    [oa]: s.NEAREST_MIPMAP_LINEAR,
    [Yt]: s.LINEAR,
    [Tl]: s.LINEAR_MIPMAP_NEAREST,
    [Yi]: s.LINEAR_MIPMAP_LINEAR
  }, oe = {
    [bx]: s.NEVER,
    [Cx]: s.ALWAYS,
    [vx]: s.LESS,
    [pA]: s.LEQUAL,
    [yx]: s.EQUAL,
    [Ex]: s.GEQUAL,
    [xx]: s.GREATER,
    [wx]: s.NOTEQUAL
  };
  function le(W, G) {
    if (G.type === hn && e.has("OES_texture_float_linear") === !1 && (G.magFilter === Yt || G.magFilter === Tl || G.magFilter === oa || G.magFilter === Yi || G.minFilter === Yt || G.minFilter === Tl || G.minFilter === oa || G.minFilter === Yi) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(W, s.TEXTURE_WRAP_S, Q[G.wrapS]), s.texParameteri(W, s.TEXTURE_WRAP_T, Q[G.wrapT]), (W === s.TEXTURE_3D || W === s.TEXTURE_2D_ARRAY) && s.texParameteri(W, s.TEXTURE_WRAP_R, Q[G.wrapR]), s.texParameteri(W, s.TEXTURE_MAG_FILTER, q[G.magFilter]), s.texParameteri(W, s.TEXTURE_MIN_FILTER, q[G.minFilter]), G.compareFunction && (s.texParameteri(W, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(W, s.TEXTURE_COMPARE_FUNC, oe[G.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (G.magFilter === nn || G.minFilter !== oa && G.minFilter !== Yi || G.type === hn && e.has("OES_texture_float_linear") === !1)
        return;
      if (G.anisotropy > 1 || n.get(G).__currentAnisotropy) {
        const se = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(W, se.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, i.getMaxAnisotropy())), n.get(G).__currentAnisotropy = G.anisotropy;
      }
    }
  }
  function k(W, G) {
    let se = !1;
    W.__webglInit === void 0 && (W.__webglInit = !0, G.addEventListener("dispose", w));
    const _e = G.source;
    let ve = h.get(_e);
    ve === void 0 && (ve = {}, h.set(_e, ve));
    const ue = R(G);
    if (ue !== W.__cacheKey) {
      ve[ue] === void 0 && (ve[ue] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, se = !0), ve[ue].usedTimes++;
      const Te = ve[W.__cacheKey];
      Te !== void 0 && (ve[W.__cacheKey].usedTimes--, Te.usedTimes === 0 && C(G)), W.__cacheKey = ue, W.__webglTexture = ve[ue].texture;
    }
    return se;
  }
  function X(W, G, se) {
    let _e = s.TEXTURE_2D;
    (G.isDataArrayTexture || G.isCompressedArrayTexture) && (_e = s.TEXTURE_2D_ARRAY), G.isData3DTexture && (_e = s.TEXTURE_3D);
    const ve = k(W, G), ue = G.source;
    t.bindTexture(_e, W.__webglTexture, s.TEXTURE0 + se);
    const Te = n.get(ue);
    if (ue.version !== Te.__version || ve === !0) {
      t.activeTexture(s.TEXTURE0 + se);
      const Ge = cn.getPrimaries(cn.workingColorSpace), Pe = G.colorSpace === Ur ? null : cn.getPrimaries(G.colorSpace), he = G.colorSpace === Ur || Ge === Pe ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, G.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, G.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, he);
      let Se = _(G.image, !1, i.maxTextureSize);
      Se = ze(G, Se);
      const Ve = r.convert(G.format, G.colorSpace), Ye = r.convert(G.type);
      let $e = v(G.internalFormat, Ve, Ye, G.colorSpace, G.isVideoTexture);
      le(_e, G);
      let Ne;
      const He = G.mipmaps, Qe = G.isVideoTexture !== !0, Ze = Te.__version === void 0 || ve === !0, Ke = ue.dataReady, $ = y(G, Se);
      if (G.isDepthTexture)
        $e = s.DEPTH_COMPONENT16, G.type === hn ? $e = s.DEPTH_COMPONENT32F : G.type === xr ? $e = s.DEPTH_COMPONENT24 : G.type === Hl && ($e = s.DEPTH24_STENCIL8), Ze && (Qe ? t.texStorage2D(s.TEXTURE_2D, 1, $e, Se.width, Se.height) : t.texImage2D(s.TEXTURE_2D, 0, $e, Se.width, Se.height, 0, Ve, Ye, null));
      else if (G.isDataTexture)
        if (He.length > 0) {
          Qe && Ze && t.texStorage2D(s.TEXTURE_2D, $, $e, He[0].width, He[0].height);
          for (let ge = 0, be = He.length; ge < be; ge++)
            Ne = He[ge], Qe ? Ke && t.texSubImage2D(s.TEXTURE_2D, ge, 0, 0, Ne.width, Ne.height, Ve, Ye, Ne.data) : t.texImage2D(s.TEXTURE_2D, ge, $e, Ne.width, Ne.height, 0, Ve, Ye, Ne.data);
          G.generateMipmaps = !1;
        } else
          Qe ? (Ze && t.texStorage2D(s.TEXTURE_2D, $, $e, Se.width, Se.height), Ke && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Se.width, Se.height, Ve, Ye, Se.data)) : t.texImage2D(s.TEXTURE_2D, 0, $e, Se.width, Se.height, 0, Ve, Ye, Se.data);
      else if (G.isCompressedTexture)
        if (G.isCompressedArrayTexture) {
          Qe && Ze && t.texStorage3D(s.TEXTURE_2D_ARRAY, $, $e, He[0].width, He[0].height, Se.depth);
          for (let ge = 0, be = He.length; ge < be; ge++)
            Ne = He[ge], G.format !== vn ? Ve !== null ? Qe ? Ke && t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ge, 0, 0, 0, Ne.width, Ne.height, Se.depth, Ve, Ne.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, ge, $e, Ne.width, Ne.height, Se.depth, 0, Ne.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Qe ? Ke && t.texSubImage3D(s.TEXTURE_2D_ARRAY, ge, 0, 0, 0, Ne.width, Ne.height, Se.depth, Ve, Ye, Ne.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, ge, $e, Ne.width, Ne.height, Se.depth, 0, Ve, Ye, Ne.data);
        } else {
          Qe && Ze && t.texStorage2D(s.TEXTURE_2D, $, $e, He[0].width, He[0].height);
          for (let ge = 0, be = He.length; ge < be; ge++)
            Ne = He[ge], G.format !== vn ? Ve !== null ? Qe ? Ke && t.compressedTexSubImage2D(s.TEXTURE_2D, ge, 0, 0, Ne.width, Ne.height, Ve, Ne.data) : t.compressedTexImage2D(s.TEXTURE_2D, ge, $e, Ne.width, Ne.height, 0, Ne.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Qe ? Ke && t.texSubImage2D(s.TEXTURE_2D, ge, 0, 0, Ne.width, Ne.height, Ve, Ye, Ne.data) : t.texImage2D(s.TEXTURE_2D, ge, $e, Ne.width, Ne.height, 0, Ve, Ye, Ne.data);
        }
      else if (G.isDataArrayTexture)
        Qe ? (Ze && t.texStorage3D(s.TEXTURE_2D_ARRAY, $, $e, Se.width, Se.height, Se.depth), Ke && t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Se.width, Se.height, Se.depth, Ve, Ye, Se.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, $e, Se.width, Se.height, Se.depth, 0, Ve, Ye, Se.data);
      else if (G.isData3DTexture)
        Qe ? (Ze && t.texStorage3D(s.TEXTURE_3D, $, $e, Se.width, Se.height, Se.depth), Ke && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, Se.width, Se.height, Se.depth, Ve, Ye, Se.data)) : t.texImage3D(s.TEXTURE_3D, 0, $e, Se.width, Se.height, Se.depth, 0, Ve, Ye, Se.data);
      else if (G.isFramebufferTexture) {
        if (Ze)
          if (Qe)
            t.texStorage2D(s.TEXTURE_2D, $, $e, Se.width, Se.height);
          else {
            let ge = Se.width, be = Se.height;
            for (let Ue = 0; Ue < $; Ue++)
              t.texImage2D(s.TEXTURE_2D, Ue, $e, ge, be, 0, Ve, Ye, null), ge >>= 1, be >>= 1;
          }
      } else if (He.length > 0) {
        if (Qe && Ze) {
          const ge = Fe(He[0]);
          t.texStorage2D(s.TEXTURE_2D, $, $e, ge.width, ge.height);
        }
        for (let ge = 0, be = He.length; ge < be; ge++)
          Ne = He[ge], Qe ? Ke && t.texSubImage2D(s.TEXTURE_2D, ge, 0, 0, Ve, Ye, Ne) : t.texImage2D(s.TEXTURE_2D, ge, $e, Ve, Ye, Ne);
        G.generateMipmaps = !1;
      } else if (Qe) {
        if (Ze) {
          const ge = Fe(Se);
          t.texStorage2D(s.TEXTURE_2D, $, $e, ge.width, ge.height);
        }
        Ke && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Ve, Ye, Se);
      } else
        t.texImage2D(s.TEXTURE_2D, 0, $e, Ve, Ye, Se);
      g(G) && A(_e), Te.__version = ue.version, G.onUpdate && G.onUpdate(G);
    }
    W.__version = G.version;
  }
  function fe(W, G, se) {
    if (G.image.length !== 6)
      return;
    const _e = k(W, G), ve = G.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, W.__webglTexture, s.TEXTURE0 + se);
    const ue = n.get(ve);
    if (ve.version !== ue.__version || _e === !0) {
      t.activeTexture(s.TEXTURE0 + se);
      const Te = cn.getPrimaries(cn.workingColorSpace), Ge = G.colorSpace === Ur ? null : cn.getPrimaries(G.colorSpace), Pe = G.colorSpace === Ur || Te === Ge ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, G.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, G.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pe);
      const he = G.isCompressedTexture || G.image[0].isCompressedTexture, Se = G.image[0] && G.image[0].isDataTexture, Ve = [];
      for (let be = 0; be < 6; be++)
        !he && !Se ? Ve[be] = _(G.image[be], !0, i.maxCubemapSize) : Ve[be] = Se ? G.image[be].image : G.image[be], Ve[be] = ze(G, Ve[be]);
      const Ye = Ve[0], $e = r.convert(G.format, G.colorSpace), Ne = r.convert(G.type), He = v(G.internalFormat, $e, Ne, G.colorSpace), Qe = G.isVideoTexture !== !0, Ze = ue.__version === void 0 || _e === !0, Ke = ve.dataReady;
      let $ = y(G, Ye);
      le(s.TEXTURE_CUBE_MAP, G);
      let ge;
      if (he) {
        Qe && Ze && t.texStorage2D(s.TEXTURE_CUBE_MAP, $, He, Ye.width, Ye.height);
        for (let be = 0; be < 6; be++) {
          ge = Ve[be].mipmaps;
          for (let Ue = 0; Ue < ge.length; Ue++) {
            const je = ge[Ue];
            G.format !== vn ? $e !== null ? Qe ? Ke && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue, 0, 0, je.width, je.height, $e, je.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue, He, je.width, je.height, 0, je.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Qe ? Ke && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue, 0, 0, je.width, je.height, $e, Ne, je.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue, He, je.width, je.height, 0, $e, Ne, je.data);
          }
        }
      } else {
        if (ge = G.mipmaps, Qe && Ze) {
          ge.length > 0 && $++;
          const be = Fe(Ve[0]);
          t.texStorage2D(s.TEXTURE_CUBE_MAP, $, He, be.width, be.height);
        }
        for (let be = 0; be < 6; be++)
          if (Se) {
            Qe ? Ke && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, 0, 0, 0, Ve[be].width, Ve[be].height, $e, Ne, Ve[be].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, 0, He, Ve[be].width, Ve[be].height, 0, $e, Ne, Ve[be].data);
            for (let Ue = 0; Ue < ge.length; Ue++) {
              const it = ge[Ue].image[be].image;
              Qe ? Ke && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue + 1, 0, 0, it.width, it.height, $e, Ne, it.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue + 1, He, it.width, it.height, 0, $e, Ne, it.data);
            }
          } else {
            Qe ? Ke && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, 0, 0, 0, $e, Ne, Ve[be]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, 0, He, $e, Ne, Ve[be]);
            for (let Ue = 0; Ue < ge.length; Ue++) {
              const je = ge[Ue];
              Qe ? Ke && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue + 1, 0, 0, $e, Ne, je.image[be]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + be, Ue + 1, He, $e, Ne, je.image[be]);
            }
          }
      }
      g(G) && A(s.TEXTURE_CUBE_MAP), ue.__version = ve.version, G.onUpdate && G.onUpdate(G);
    }
    W.__version = G.version;
  }
  function te(W, G, se, _e, ve, ue) {
    const Te = r.convert(se.format, se.colorSpace), Ge = r.convert(se.type), Pe = v(se.internalFormat, Te, Ge, se.colorSpace);
    if (!n.get(G).__hasExternalTextures) {
      const Se = Math.max(1, G.width >> ue), Ve = Math.max(1, G.height >> ue);
      ve === s.TEXTURE_3D || ve === s.TEXTURE_2D_ARRAY ? t.texImage3D(ve, ue, Pe, Se, Ve, G.depth, 0, Te, Ge, null) : t.texImage2D(ve, ue, Pe, Se, Ve, 0, Te, Ge, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, W), Ie(G) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, _e, ve, n.get(se).__webglTexture, 0, Ee(G)) : (ve === s.TEXTURE_2D || ve >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ve <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, _e, ve, n.get(se).__webglTexture, ue), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function j(W, G, se) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, W), G.depthBuffer && !G.stencilBuffer) {
      let _e = s.DEPTH_COMPONENT24;
      if (se || Ie(G)) {
        const ve = G.depthTexture;
        ve && ve.isDepthTexture && (ve.type === hn ? _e = s.DEPTH_COMPONENT32F : ve.type === xr && (_e = s.DEPTH_COMPONENT24));
        const ue = Ee(G);
        Ie(G) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, ue, _e, G.width, G.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, ue, _e, G.width, G.height);
      } else
        s.renderbufferStorage(s.RENDERBUFFER, _e, G.width, G.height);
      s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, W);
    } else if (G.depthBuffer && G.stencilBuffer) {
      const _e = Ee(G);
      se && Ie(G) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, _e, s.DEPTH24_STENCIL8, G.width, G.height) : Ie(G) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, _e, s.DEPTH24_STENCIL8, G.width, G.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, G.width, G.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, W);
    } else {
      const _e = G.textures;
      for (let ve = 0; ve < _e.length; ve++) {
        const ue = _e[ve], Te = r.convert(ue.format, ue.colorSpace), Ge = r.convert(ue.type), Pe = v(ue.internalFormat, Te, Ge, ue.colorSpace), he = Ee(G);
        se && Ie(G) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, he, Pe, G.width, G.height) : Ie(G) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, he, Pe, G.width, G.height) : s.renderbufferStorage(s.RENDERBUFFER, Pe, G.width, G.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Ae(W, G) {
    if (G && G.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, W), !(G.depthTexture && G.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(G.depthTexture).__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width, G.depthTexture.image.height = G.height, G.depthTexture.needsUpdate = !0), P(G.depthTexture, 0);
    const _e = n.get(G.depthTexture).__webglTexture, ve = Ee(G);
    if (G.depthTexture.format === ha)
      Ie(G) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, _e, 0, ve) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, _e, 0);
    else if (G.depthTexture.format === Fl)
      Ie(G) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, _e, 0, ve) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, _e, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Y(W) {
    const G = n.get(W), se = W.isWebGLCubeRenderTarget === !0;
    if (W.depthTexture && !G.__autoAllocateDepthBuffer) {
      if (se)
        throw new Error("target.depthTexture not supported in Cube render targets");
      Ae(G.__webglFramebuffer, W);
    } else if (se) {
      G.__webglDepthbuffer = [];
      for (let _e = 0; _e < 6; _e++)
        t.bindFramebuffer(s.FRAMEBUFFER, G.__webglFramebuffer[_e]), G.__webglDepthbuffer[_e] = s.createRenderbuffer(), j(G.__webglDepthbuffer[_e], W, !1);
    } else
      t.bindFramebuffer(s.FRAMEBUFFER, G.__webglFramebuffer), G.__webglDepthbuffer = s.createRenderbuffer(), j(G.__webglDepthbuffer, W, !1);
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function pe(W, G, se) {
    const _e = n.get(W);
    G !== void 0 && te(_e.__webglFramebuffer, W, W.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), se !== void 0 && Y(W);
  }
  function me(W) {
    const G = W.texture, se = n.get(W), _e = n.get(G);
    W.addEventListener("dispose", E);
    const ve = W.textures, ue = W.isWebGLCubeRenderTarget === !0, Te = ve.length > 1;
    if (Te || (_e.__webglTexture === void 0 && (_e.__webglTexture = s.createTexture()), _e.__version = G.version, a.memory.textures++), ue) {
      se.__webglFramebuffer = [];
      for (let Ge = 0; Ge < 6; Ge++)
        if (G.mipmaps && G.mipmaps.length > 0) {
          se.__webglFramebuffer[Ge] = [];
          for (let Pe = 0; Pe < G.mipmaps.length; Pe++)
            se.__webglFramebuffer[Ge][Pe] = s.createFramebuffer();
        } else
          se.__webglFramebuffer[Ge] = s.createFramebuffer();
    } else {
      if (G.mipmaps && G.mipmaps.length > 0) {
        se.__webglFramebuffer = [];
        for (let Ge = 0; Ge < G.mipmaps.length; Ge++)
          se.__webglFramebuffer[Ge] = s.createFramebuffer();
      } else
        se.__webglFramebuffer = s.createFramebuffer();
      if (Te)
        for (let Ge = 0, Pe = ve.length; Ge < Pe; Ge++) {
          const he = n.get(ve[Ge]);
          he.__webglTexture === void 0 && (he.__webglTexture = s.createTexture(), a.memory.textures++);
        }
      if (W.samples > 0 && Ie(W) === !1) {
        se.__webglMultisampledFramebuffer = s.createFramebuffer(), se.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, se.__webglMultisampledFramebuffer);
        for (let Ge = 0; Ge < ve.length; Ge++) {
          const Pe = ve[Ge];
          se.__webglColorRenderbuffer[Ge] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, se.__webglColorRenderbuffer[Ge]);
          const he = r.convert(Pe.format, Pe.colorSpace), Se = r.convert(Pe.type), Ve = v(Pe.internalFormat, he, Se, Pe.colorSpace, W.isXRRenderTarget === !0), Ye = Ee(W);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Ye, Ve, W.width, W.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ge, s.RENDERBUFFER, se.__webglColorRenderbuffer[Ge]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), W.depthBuffer && (se.__webglDepthRenderbuffer = s.createRenderbuffer(), j(se.__webglDepthRenderbuffer, W, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (ue) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, _e.__webglTexture), le(s.TEXTURE_CUBE_MAP, G);
      for (let Ge = 0; Ge < 6; Ge++)
        if (G.mipmaps && G.mipmaps.length > 0)
          for (let Pe = 0; Pe < G.mipmaps.length; Pe++)
            te(se.__webglFramebuffer[Ge][Pe], W, G, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Pe);
        else
          te(se.__webglFramebuffer[Ge], W, G, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0);
      g(G) && A(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Te) {
      for (let Ge = 0, Pe = ve.length; Ge < Pe; Ge++) {
        const he = ve[Ge], Se = n.get(he);
        t.bindTexture(s.TEXTURE_2D, Se.__webglTexture), le(s.TEXTURE_2D, he), te(se.__webglFramebuffer, W, he, s.COLOR_ATTACHMENT0 + Ge, s.TEXTURE_2D, 0), g(he) && A(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Ge = s.TEXTURE_2D;
      if ((W.isWebGL3DRenderTarget || W.isWebGLArrayRenderTarget) && (Ge = W.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), t.bindTexture(Ge, _e.__webglTexture), le(Ge, G), G.mipmaps && G.mipmaps.length > 0)
        for (let Pe = 0; Pe < G.mipmaps.length; Pe++)
          te(se.__webglFramebuffer[Pe], W, G, s.COLOR_ATTACHMENT0, Ge, Pe);
      else
        te(se.__webglFramebuffer, W, G, s.COLOR_ATTACHMENT0, Ge, 0);
      g(G) && A(Ge), t.unbindTexture();
    }
    W.depthBuffer && Y(W);
  }
  function re(W) {
    const G = W.textures;
    for (let se = 0, _e = G.length; se < _e; se++) {
      const ve = G[se];
      if (g(ve)) {
        const ue = W.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, Te = n.get(ve).__webglTexture;
        t.bindTexture(ue, Te), A(ue), t.unbindTexture();
      }
    }
  }
  const ye = [], ae = [];
  function De(W) {
    if (W.samples > 0) {
      if (Ie(W) === !1) {
        const G = W.textures, se = W.width, _e = W.height;
        let ve = s.COLOR_BUFFER_BIT;
        const ue = W.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Te = n.get(W), Ge = G.length > 1;
        if (Ge)
          for (let Pe = 0; Pe < G.length; Pe++)
            t.bindFramebuffer(s.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Pe, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Te.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Pe, s.TEXTURE_2D, null, 0);
        t.bindFramebuffer(s.READ_FRAMEBUFFER, Te.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Te.__webglFramebuffer);
        for (let Pe = 0; Pe < G.length; Pe++) {
          if (W.resolveDepthBuffer && (W.depthBuffer && (ve |= s.DEPTH_BUFFER_BIT), W.stencilBuffer && W.resolveStencilBuffer && (ve |= s.STENCIL_BUFFER_BIT)), Ge) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Te.__webglColorRenderbuffer[Pe]);
            const he = n.get(G[Pe]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, he, 0);
          }
          s.blitFramebuffer(0, 0, se, _e, 0, 0, se, _e, ve, s.NEAREST), l === !0 && (ye.length = 0, ae.length = 0, ye.push(s.COLOR_ATTACHMENT0 + Pe), W.depthBuffer && W.resolveDepthBuffer === !1 && (ye.push(ue), ae.push(ue), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, ae)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, ye));
        }
        if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Ge)
          for (let Pe = 0; Pe < G.length; Pe++) {
            t.bindFramebuffer(s.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Pe, s.RENDERBUFFER, Te.__webglColorRenderbuffer[Pe]);
            const he = n.get(G[Pe]).__webglTexture;
            t.bindFramebuffer(s.FRAMEBUFFER, Te.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Pe, s.TEXTURE_2D, he, 0);
          }
        t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Te.__webglMultisampledFramebuffer);
      } else if (W.depthBuffer && W.resolveDepthBuffer === !1 && l) {
        const G = W.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [G]);
      }
    }
  }
  function Ee(W) {
    return Math.min(i.maxSamples, W.samples);
  }
  function Ie(W) {
    const G = n.get(W);
    return W.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && G.__useRenderToTexture !== !1;
  }
  function Ce(W) {
    const G = a.render.frame;
    u.get(W) !== G && (u.set(W, G), W.update());
  }
  function ze(W, G) {
    const se = W.colorSpace, _e = W.format, ve = W.type;
    return W.isCompressedTexture === !0 || W.isVideoTexture === !0 || se !== Bn && se !== Ur && (cn.getTransfer(se) === yn ? (_e !== vn || ve !== Un) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", se)), G;
  }
  function Fe(W) {
    return typeof HTMLImageElement < "u" && W instanceof HTMLImageElement ? (c.width = W.naturalWidth || W.width, c.height = W.naturalHeight || W.height) : typeof VideoFrame < "u" && W instanceof VideoFrame ? (c.width = W.displayWidth, c.height = W.displayHeight) : (c.width = W.width, c.height = W.height), c;
  }
  this.allocateTextureUnit = D, this.resetTextureUnits = S, this.setTexture2D = P, this.setTexture2DArray = L, this.setTexture3D = V, this.setTextureCube = U, this.rebindTextures = pe, this.setupRenderTarget = me, this.updateRenderTargetMipmap = re, this.updateMultisampleRenderTarget = De, this.setupDepthRenderbuffer = Y, this.setupFrameBufferTexture = te, this.useMultisampledRTT = Ie;
}
function Nx(s, e) {
  function t(n, i = Ur) {
    let r;
    const a = cn.getTransfer(i);
    if (n === Un)
      return s.UNSIGNED_BYTE;
    if (n === uA)
      return s.UNSIGNED_SHORT_4_4_4_4;
    if (n === fA)
      return s.UNSIGNED_SHORT_5_5_5_1;
    if (n === ax)
      return s.UNSIGNED_INT_5_9_9_9_REV;
    if (n === zh)
      return s.BYTE;
    if (n === cA)
      return s.SHORT;
    if (n === ld)
      return s.UNSIGNED_SHORT;
    if (n === Bl)
      return s.INT;
    if (n === xr)
      return s.UNSIGNED_INT;
    if (n === hn)
      return s.FLOAT;
    if (n === Ri)
      return s.HALF_FLOAT;
    if (n === lx)
      return s.ALPHA;
    if (n === cx)
      return s.RGB;
    if (n === vn)
      return s.RGBA;
    if (n === ux)
      return s.LUMINANCE;
    if (n === fx)
      return s.LUMINANCE_ALPHA;
    if (n === ha)
      return s.DEPTH_COMPONENT;
    if (n === Fl)
      return s.DEPTH_STENCIL;
    if (n === Ts)
      return s.RED;
    if (n === cd)
      return s.RED_INTEGER;
    if (n === uo)
      return s.RG;
    if (n === Ru)
      return s.RG_INTEGER;
    if (n === Ol)
      return s.RGBA_INTEGER;
    if (n === Sh || n === Jc || n === Mh || n === Zc)
      if (a === yn)
        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
          if (n === Sh)
            return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Jc)
            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Mh)
            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Zc)
            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
        if (n === Sh)
          return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Jc)
          return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Mh)
          return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Zc)
          return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === $h || n === ng || n === Vh || n === ig)
      if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
        if (n === $h)
          return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === ng)
          return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === Vh)
          return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === ig)
          return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === Hh || n === jh || n === Wh)
      if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
        if (n === Hh || n === jh)
          return a === yn ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (n === Wh)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === qh || n === rg || n === sg || n === og || n === du || n === ag || n === lg || n === cg || n === ug || n === fg || n === hg || n === dg || n === pg || n === mg)
      if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
        if (n === qh)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === rg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === sg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === og)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === du)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === ag)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === lg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === cg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === ug)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === fg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === hg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === dg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === pg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === mg)
          return a === yn ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === eu || n === gg || n === Ag)
      if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
        if (n === eu)
          return a === yn ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === gg)
          return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Ag)
          return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === hx || n === _g || n === bg || n === vg)
      if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
        if (n === eu)
          return r.COMPRESSED_RED_RGTC1_EXT;
        if (n === _g)
          return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === bg)
          return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === vg)
          return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === Hl ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null;
  }
  return { convert: t };
}
class Gx extends ni {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Xn extends Gt {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const MR = { type: "move" };
class Qp {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Xn(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Xn(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new H(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new H()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Xn(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new H(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new H()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, r = null, a = null;
    const o = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const _ of e.hand.values()) {
          const g = t.getJointPose(_, n), A = this._getHandJoint(c, _);
          g !== null && (A.matrix.fromArray(g.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.matrixWorldNeedsUpdate = !0, A.jointRadius = g.radius), A.visible = g !== null;
        }
        const u = c.joints["index-finger-tip"], f = c.joints["thumb-tip"], h = u.position.distanceTo(f.position), d = 0.02, m = 5e-3;
        c.inputState.pinching && h > d + m ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && h <= d - m && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
      o !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(MR)));
    }
    return o !== null && (o.visible = i !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Xn();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
const IR = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, TR = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class BR {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new wn(), r = e.properties.get(i);
      r.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
    }
  }
  render(e, t) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const n = t.cameras[0].viewport, i = new Hn({
          vertexShader: IR,
          fragmentShader: TR,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: n.z },
            depthHeight: { value: n.w }
          }
        });
        this.mesh = new tt(new Fi(20, 20), i);
      }
      e.render(this.mesh, t);
    }
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class PR extends Qr {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, r = 1, a = null, o = "local-floor", l = 1, c = null, u = null, f = null, h = null, d = null, m = null;
    const _ = new BR(), g = t.getContextAttributes();
    let A = null, v = null;
    const y = [], w = [], E = new ke();
    let I = null;
    const C = new ni();
    C.layers.enable(1), C.viewport = new Xt();
    const B = new ni();
    B.layers.enable(2), B.viewport = new Xt();
    const T = [C, B], S = new Gx();
    S.layers.enable(1), S.layers.enable(2);
    let D = null, R = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(te) {
      let j = y[te];
      return j === void 0 && (j = new Qp(), y[te] = j), j.getTargetRaySpace();
    }, this.getControllerGrip = function(te) {
      let j = y[te];
      return j === void 0 && (j = new Qp(), y[te] = j), j.getGripSpace();
    }, this.getHand = function(te) {
      let j = y[te];
      return j === void 0 && (j = new Qp(), y[te] = j), j.getHandSpace();
    };
    function P(te) {
      const j = w.indexOf(te.inputSource);
      if (j === -1)
        return;
      const Ae = y[j];
      Ae !== void 0 && (Ae.update(te.inputSource, te.frame, c || a), Ae.dispatchEvent({ type: te.type, data: te.inputSource }));
    }
    function L() {
      i.removeEventListener("select", P), i.removeEventListener("selectstart", P), i.removeEventListener("selectend", P), i.removeEventListener("squeeze", P), i.removeEventListener("squeezestart", P), i.removeEventListener("squeezeend", P), i.removeEventListener("end", L), i.removeEventListener("inputsourceschange", V);
      for (let te = 0; te < y.length; te++) {
        const j = w[te];
        j !== null && (w[te] = null, y[te].disconnect(j));
      }
      D = null, R = null, _.reset(), e.setRenderTarget(A), d = null, h = null, f = null, i = null, v = null, fe.stop(), n.isPresenting = !1, e.setPixelRatio(I), e.setSize(E.width, E.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(te) {
      r = te, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(te) {
      o = te, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a;
    }, this.setReferenceSpace = function(te) {
      c = te;
    }, this.getBaseLayer = function() {
      return h !== null ? h : d;
    }, this.getBinding = function() {
      return f;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(te) {
      if (i = te, i !== null) {
        if (A = e.getRenderTarget(), i.addEventListener("select", P), i.addEventListener("selectstart", P), i.addEventListener("selectend", P), i.addEventListener("squeeze", P), i.addEventListener("squeezestart", P), i.addEventListener("squeezeend", P), i.addEventListener("end", L), i.addEventListener("inputsourceschange", V), g.xrCompatible !== !0 && await t.makeXRCompatible(), I = e.getPixelRatio(), e.getSize(E), i.renderState.layers === void 0) {
          const j = {
            antialias: g.antialias,
            alpha: !0,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: r
          };
          d = new XRWebGLLayer(i, t, j), i.updateRenderState({ baseLayer: d }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), v = new Ji(
            d.framebufferWidth,
            d.framebufferHeight,
            {
              format: vn,
              type: Un,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            }
          );
        } else {
          let j = null, Ae = null, Y = null;
          g.depth && (Y = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, j = g.stencil ? Fl : ha, Ae = g.stencil ? Hl : xr);
          const pe = {
            colorFormat: t.RGBA8,
            depthFormat: Y,
            scaleFactor: r
          };
          f = new XRWebGLBinding(i, t), h = f.createProjectionLayer(pe), i.updateRenderState({ layers: [h] }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), v = new Ji(
            h.textureWidth,
            h.textureHeight,
            {
              format: vn,
              type: Un,
              depthTexture: new yA(h.textureWidth, h.textureHeight, Ae, void 0, void 0, void 0, void 0, void 0, void 0, j),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0,
              resolveDepthBuffer: h.ignoreDepthValues === !1
            }
          );
        }
        v.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await i.requestReferenceSpace(o), fe.setContext(i), fe.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function V(te) {
      for (let j = 0; j < te.removed.length; j++) {
        const Ae = te.removed[j], Y = w.indexOf(Ae);
        Y >= 0 && (w[Y] = null, y[Y].disconnect(Ae));
      }
      for (let j = 0; j < te.added.length; j++) {
        const Ae = te.added[j];
        let Y = w.indexOf(Ae);
        if (Y === -1) {
          for (let me = 0; me < y.length; me++)
            if (me >= w.length) {
              w.push(Ae), Y = me;
              break;
            } else if (w[me] === null) {
              w[me] = Ae, Y = me;
              break;
            }
          if (Y === -1)
            break;
        }
        const pe = y[Y];
        pe && pe.connect(Ae);
      }
    }
    const U = new H(), Q = new H();
    function q(te, j, Ae) {
      U.setFromMatrixPosition(j.matrixWorld), Q.setFromMatrixPosition(Ae.matrixWorld);
      const Y = U.distanceTo(Q), pe = j.projectionMatrix.elements, me = Ae.projectionMatrix.elements, re = pe[14] / (pe[10] - 1), ye = pe[14] / (pe[10] + 1), ae = (pe[9] + 1) / pe[5], De = (pe[9] - 1) / pe[5], Ee = (pe[8] - 1) / pe[0], Ie = (me[8] + 1) / me[0], Ce = re * Ee, ze = re * Ie, Fe = Y / (-Ee + Ie), W = Fe * -Ee;
      j.matrixWorld.decompose(te.position, te.quaternion, te.scale), te.translateX(W), te.translateZ(Fe), te.matrixWorld.compose(te.position, te.quaternion, te.scale), te.matrixWorldInverse.copy(te.matrixWorld).invert();
      const G = re + Fe, se = ye + Fe, _e = Ce - W, ve = ze + (Y - W), ue = ae * ye / se * G, Te = De * ye / se * G;
      te.projectionMatrix.makePerspective(_e, ve, ue, Te, G, se), te.projectionMatrixInverse.copy(te.projectionMatrix).invert();
    }
    function oe(te, j) {
      j === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(j.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert();
    }
    this.updateCamera = function(te) {
      if (i === null)
        return;
      _.texture !== null && (te.near = _.depthNear, te.far = _.depthFar), S.near = B.near = C.near = te.near, S.far = B.far = C.far = te.far, (D !== S.near || R !== S.far) && (i.updateRenderState({
        depthNear: S.near,
        depthFar: S.far
      }), D = S.near, R = S.far, C.near = D, C.far = R, B.near = D, B.far = R, C.updateProjectionMatrix(), B.updateProjectionMatrix(), te.updateProjectionMatrix());
      const j = te.parent, Ae = S.cameras;
      oe(S, j);
      for (let Y = 0; Y < Ae.length; Y++)
        oe(Ae[Y], j);
      Ae.length === 2 ? q(S, C, B) : S.projectionMatrix.copy(C.projectionMatrix), le(te, S, j);
    };
    function le(te, j, Ae) {
      Ae === null ? te.matrix.copy(j.matrixWorld) : (te.matrix.copy(Ae.matrixWorld), te.matrix.invert(), te.matrix.multiply(j.matrixWorld)), te.matrix.decompose(te.position, te.quaternion, te.scale), te.updateMatrixWorld(!0), te.projectionMatrix.copy(j.projectionMatrix), te.projectionMatrixInverse.copy(j.projectionMatrixInverse), te.isPerspectiveCamera && (te.fov = Gl * 2 * Math.atan(1 / te.projectionMatrix.elements[5]), te.zoom = 1);
    }
    this.getCamera = function() {
      return S;
    }, this.getFoveation = function() {
      if (!(h === null && d === null))
        return l;
    }, this.setFoveation = function(te) {
      l = te, h !== null && (h.fixedFoveation = te), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = te);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    };
    let k = null;
    function X(te, j) {
      if (u = j.getViewerPose(c || a), m = j, u !== null) {
        const Ae = u.views;
        d !== null && (e.setRenderTargetFramebuffer(v, d.framebuffer), e.setRenderTarget(v));
        let Y = !1;
        Ae.length !== S.cameras.length && (S.cameras.length = 0, Y = !0);
        for (let me = 0; me < Ae.length; me++) {
          const re = Ae[me];
          let ye = null;
          if (d !== null)
            ye = d.getViewport(re);
          else {
            const De = f.getViewSubImage(h, re);
            ye = De.viewport, me === 0 && (e.setRenderTargetTextures(
              v,
              De.colorTexture,
              h.ignoreDepthValues ? void 0 : De.depthStencilTexture
            ), e.setRenderTarget(v));
          }
          let ae = T[me];
          ae === void 0 && (ae = new ni(), ae.layers.enable(me), ae.viewport = new Xt(), T[me] = ae), ae.matrix.fromArray(re.transform.matrix), ae.matrix.decompose(ae.position, ae.quaternion, ae.scale), ae.projectionMatrix.fromArray(re.projectionMatrix), ae.projectionMatrixInverse.copy(ae.projectionMatrix).invert(), ae.viewport.set(ye.x, ye.y, ye.width, ye.height), me === 0 && (S.matrix.copy(ae.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), Y === !0 && S.cameras.push(ae);
        }
        const pe = i.enabledFeatures;
        if (pe && pe.includes("depth-sensing")) {
          const me = f.getDepthInformation(Ae[0]);
          me && me.isValid && me.texture && _.init(e, me, i.renderState);
        }
      }
      for (let Ae = 0; Ae < y.length; Ae++) {
        const Y = w[Ae], pe = y[Ae];
        Y !== null && pe !== void 0 && pe.update(Y, j, c || a);
      }
      _.render(e, S), k && k(te, j), j.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: j }), m = null;
    }
    const fe = new Dx();
    fe.setAnimationLoop(X), this.setAnimationLoop = function(te) {
      k = te;
    }, this.dispose = function() {
    };
  }
}
const Qo = /* @__PURE__ */ new Ui(), RR = /* @__PURE__ */ new st();
function DR(s, e) {
  function t(g, A) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), A.value.copy(g.matrix);
  }
  function n(g, A) {
    A.color.getRGB(g.fogColor.value, Rx(s)), A.isFog ? (g.fogNear.value = A.near, g.fogFar.value = A.far) : A.isFogExp2 && (g.fogDensity.value = A.density);
  }
  function i(g, A, v, y, w) {
    A.isMeshBasicMaterial || A.isMeshLambertMaterial ? r(g, A) : A.isMeshToonMaterial ? (r(g, A), f(g, A)) : A.isMeshPhongMaterial ? (r(g, A), u(g, A)) : A.isMeshStandardMaterial ? (r(g, A), h(g, A), A.isMeshPhysicalMaterial && d(g, A, w)) : A.isMeshMatcapMaterial ? (r(g, A), m(g, A)) : A.isMeshDepthMaterial ? r(g, A) : A.isMeshDistanceMaterial ? (r(g, A), _(g, A)) : A.isMeshNormalMaterial ? r(g, A) : A.isLineBasicMaterial ? (a(g, A), A.isLineDashedMaterial && o(g, A)) : A.isPointsMaterial ? l(g, A, v, y) : A.isSpriteMaterial ? c(g, A) : A.isShadowMaterial ? (g.color.value.copy(A.color), g.opacity.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = !1);
  }
  function r(g, A) {
    g.opacity.value = A.opacity, A.color && g.diffuse.value.copy(A.color), A.emissive && g.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity), A.map && (g.map.value = A.map, t(A.map, g.mapTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, t(A.alphaMap, g.alphaMapTransform)), A.bumpMap && (g.bumpMap.value = A.bumpMap, t(A.bumpMap, g.bumpMapTransform), g.bumpScale.value = A.bumpScale, A.side === Kn && (g.bumpScale.value *= -1)), A.normalMap && (g.normalMap.value = A.normalMap, t(A.normalMap, g.normalMapTransform), g.normalScale.value.copy(A.normalScale), A.side === Kn && g.normalScale.value.negate()), A.displacementMap && (g.displacementMap.value = A.displacementMap, t(A.displacementMap, g.displacementMapTransform), g.displacementScale.value = A.displacementScale, g.displacementBias.value = A.displacementBias), A.emissiveMap && (g.emissiveMap.value = A.emissiveMap, t(A.emissiveMap, g.emissiveMapTransform)), A.specularMap && (g.specularMap.value = A.specularMap, t(A.specularMap, g.specularMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
    const v = e.get(A), y = v.envMap, w = v.envMapRotation;
    if (y && (g.envMap.value = y, Qo.copy(w), Qo.x *= -1, Qo.y *= -1, Qo.z *= -1, y.isCubeTexture && y.isRenderTargetTexture === !1 && (Qo.y *= -1, Qo.z *= -1), g.envMapRotation.value.setFromMatrix4(RR.makeRotationFromEuler(Qo)), g.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = A.reflectivity, g.ior.value = A.ior, g.refractionRatio.value = A.refractionRatio), A.lightMap) {
      g.lightMap.value = A.lightMap;
      const E = s._useLegacyLights === !0 ? Math.PI : 1;
      g.lightMapIntensity.value = A.lightMapIntensity * E, t(A.lightMap, g.lightMapTransform);
    }
    A.aoMap && (g.aoMap.value = A.aoMap, g.aoMapIntensity.value = A.aoMapIntensity, t(A.aoMap, g.aoMapTransform));
  }
  function a(g, A) {
    g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, A.map && (g.map.value = A.map, t(A.map, g.mapTransform));
  }
  function o(g, A) {
    g.dashSize.value = A.dashSize, g.totalSize.value = A.dashSize + A.gapSize, g.scale.value = A.scale;
  }
  function l(g, A, v, y) {
    g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, g.size.value = A.size * v, g.scale.value = y * 0.5, A.map && (g.map.value = A.map, t(A.map, g.uvTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, t(A.alphaMap, g.alphaMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
  }
  function c(g, A) {
    g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, g.rotation.value = A.rotation, A.map && (g.map.value = A.map, t(A.map, g.mapTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, t(A.alphaMap, g.alphaMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
  }
  function u(g, A) {
    g.specular.value.copy(A.specular), g.shininess.value = Math.max(A.shininess, 1e-4);
  }
  function f(g, A) {
    A.gradientMap && (g.gradientMap.value = A.gradientMap);
  }
  function h(g, A) {
    g.metalness.value = A.metalness, A.metalnessMap && (g.metalnessMap.value = A.metalnessMap, t(A.metalnessMap, g.metalnessMapTransform)), g.roughness.value = A.roughness, A.roughnessMap && (g.roughnessMap.value = A.roughnessMap, t(A.roughnessMap, g.roughnessMapTransform)), A.envMap && (g.envMapIntensity.value = A.envMapIntensity);
  }
  function d(g, A, v) {
    g.ior.value = A.ior, A.sheen > 0 && (g.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), g.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (g.sheenColorMap.value = A.sheenColorMap, t(A.sheenColorMap, g.sheenColorMapTransform)), A.sheenRoughnessMap && (g.sheenRoughnessMap.value = A.sheenRoughnessMap, t(A.sheenRoughnessMap, g.sheenRoughnessMapTransform))), A.clearcoat > 0 && (g.clearcoat.value = A.clearcoat, g.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (g.clearcoatMap.value = A.clearcoatMap, t(A.clearcoatMap, g.clearcoatMapTransform)), A.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap, t(A.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), A.clearcoatNormalMap && (g.clearcoatNormalMap.value = A.clearcoatNormalMap, t(A.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), A.side === Kn && g.clearcoatNormalScale.value.negate())), A.dispersion > 0 && (g.dispersion.value = A.dispersion), A.iridescence > 0 && (g.iridescence.value = A.iridescence, g.iridescenceIOR.value = A.iridescenceIOR, g.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (g.iridescenceMap.value = A.iridescenceMap, t(A.iridescenceMap, g.iridescenceMapTransform)), A.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = A.iridescenceThicknessMap, t(A.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), A.transmission > 0 && (g.transmission.value = A.transmission, g.transmissionSamplerMap.value = v.texture, g.transmissionSamplerSize.value.set(v.width, v.height), A.transmissionMap && (g.transmissionMap.value = A.transmissionMap, t(A.transmissionMap, g.transmissionMapTransform)), g.thickness.value = A.thickness, A.thicknessMap && (g.thicknessMap.value = A.thicknessMap, t(A.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = A.attenuationDistance, g.attenuationColor.value.copy(A.attenuationColor)), A.anisotropy > 0 && (g.anisotropyVector.value.set(A.anisotropy * Math.cos(A.anisotropyRotation), A.anisotropy * Math.sin(A.anisotropyRotation)), A.anisotropyMap && (g.anisotropyMap.value = A.anisotropyMap, t(A.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = A.specularIntensity, g.specularColor.value.copy(A.specularColor), A.specularColorMap && (g.specularColorMap.value = A.specularColorMap, t(A.specularColorMap, g.specularColorMapTransform)), A.specularIntensityMap && (g.specularIntensityMap.value = A.specularIntensityMap, t(A.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function m(g, A) {
    A.matcap && (g.matcap.value = A.matcap);
  }
  function _(g, A) {
    const v = e.get(A).light;
    g.referencePosition.value.setFromMatrixPosition(v.matrixWorld), g.nearDistance.value = v.shadow.camera.near, g.farDistance.value = v.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function LR(s, e, t, n) {
  let i = {}, r = {}, a = [];
  const o = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(v, y) {
    const w = y.program;
    n.uniformBlockBinding(v, w);
  }
  function c(v, y) {
    let w = i[v.id];
    w === void 0 && (m(v), w = u(v), i[v.id] = w, v.addEventListener("dispose", g));
    const E = y.program;
    n.updateUBOMapping(v, E);
    const I = e.render.frame;
    r[v.id] !== I && (h(v), r[v.id] = I);
  }
  function u(v) {
    const y = f();
    v.__bindingPointIndex = y;
    const w = s.createBuffer(), E = v.__size, I = v.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, w), s.bufferData(s.UNIFORM_BUFFER, E, I), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, y, w), w;
  }
  function f() {
    for (let v = 0; v < o; v++)
      if (a.indexOf(v) === -1)
        return a.push(v), v;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function h(v) {
    const y = i[v.id], w = v.uniforms, E = v.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, y);
    for (let I = 0, C = w.length; I < C; I++) {
      const B = Array.isArray(w[I]) ? w[I] : [w[I]];
      for (let T = 0, S = B.length; T < S; T++) {
        const D = B[T];
        if (d(D, I, T, E) === !0) {
          const R = D.__offset, P = Array.isArray(D.value) ? D.value : [D.value];
          let L = 0;
          for (let V = 0; V < P.length; V++) {
            const U = P[V], Q = _(U);
            typeof U == "number" || typeof U == "boolean" ? (D.__data[0] = U, s.bufferSubData(s.UNIFORM_BUFFER, R + L, D.__data)) : U.isMatrix3 ? (D.__data[0] = U.elements[0], D.__data[1] = U.elements[1], D.__data[2] = U.elements[2], D.__data[3] = 0, D.__data[4] = U.elements[3], D.__data[5] = U.elements[4], D.__data[6] = U.elements[5], D.__data[7] = 0, D.__data[8] = U.elements[6], D.__data[9] = U.elements[7], D.__data[10] = U.elements[8], D.__data[11] = 0) : (U.toArray(D.__data, L), L += Q.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, R, D.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function d(v, y, w, E) {
    const I = v.value, C = y + "_" + w;
    if (E[C] === void 0)
      return typeof I == "number" || typeof I == "boolean" ? E[C] = I : E[C] = I.clone(), !0;
    {
      const B = E[C];
      if (typeof I == "number" || typeof I == "boolean") {
        if (B !== I)
          return E[C] = I, !0;
      } else if (B.equals(I) === !1)
        return B.copy(I), !0;
    }
    return !1;
  }
  function m(v) {
    const y = v.uniforms;
    let w = 0;
    const E = 16;
    for (let C = 0, B = y.length; C < B; C++) {
      const T = Array.isArray(y[C]) ? y[C] : [y[C]];
      for (let S = 0, D = T.length; S < D; S++) {
        const R = T[S], P = Array.isArray(R.value) ? R.value : [R.value];
        for (let L = 0, V = P.length; L < V; L++) {
          const U = P[L], Q = _(U), q = w % E;
          q !== 0 && E - q < Q.boundary && (w += E - q), R.__data = new Float32Array(Q.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = w, w += Q.storage;
        }
      }
    }
    const I = w % E;
    return I > 0 && (w += E - I), v.__size = w, v.__cache = {}, this;
  }
  function _(v) {
    const y = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof v == "number" || typeof v == "boolean" ? (y.boundary = 4, y.storage = 4) : v.isVector2 ? (y.boundary = 8, y.storage = 8) : v.isVector3 || v.isColor ? (y.boundary = 16, y.storage = 12) : v.isVector4 ? (y.boundary = 16, y.storage = 16) : v.isMatrix3 ? (y.boundary = 48, y.storage = 48) : v.isMatrix4 ? (y.boundary = 64, y.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), y;
  }
  function g(v) {
    const y = v.target;
    y.removeEventListener("dispose", g);
    const w = a.indexOf(y.__bindingPointIndex);
    a.splice(w, 1), s.deleteBuffer(i[y.id]), delete i[y.id], delete r[y.id];
  }
  function A() {
    for (const v in i)
      s.deleteBuffer(i[v]);
    a = [], i = {}, r = {};
  }
  return {
    bind: l,
    update: c,
    dispose: A
  };
}
class xA {
  constructor(e = {}) {
    const {
      canvas: t = Mx(),
      context: n = null,
      depth: i = !0,
      stencil: r = !1,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: f = !1
    } = e;
    this.isWebGLRenderer = !0;
    let h;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      h = n.getContextAttributes().alpha;
    } else
      h = a;
    const d = new Uint32Array(4), m = new Int32Array(4);
    let _ = null, g = null;
    const A = [], v = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Qn, this._useLegacyLights = !1, this.toneMapping = Ls, this.toneMappingExposure = 1;
    const y = this;
    let w = !1, E = 0, I = 0, C = null, B = -1, T = null;
    const S = new Xt(), D = new Xt();
    let R = null;
    const P = new Je(0);
    let L = 0, V = t.width, U = t.height, Q = 1, q = null, oe = null;
    const le = new Xt(0, 0, V, U), k = new Xt(0, 0, V, U);
    let X = !1;
    const fe = new ku();
    let te = !1, j = !1;
    const Ae = new st(), Y = new H(), pe = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function me() {
      return C === null ? Q : 1;
    }
    let re = n;
    function ye(ie, Be) {
      return t.getContext(ie, Be);
    }
    try {
      const ie = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: f
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${$l}`), t.addEventListener("webglcontextlost", $, !1), t.addEventListener("webglcontextrestored", ge, !1), t.addEventListener("webglcontextcreationerror", be, !1), re === null) {
        const Be = "webgl2";
        if (re = ye(Be, ie), re === null)
          throw ye(Be) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (ie) {
      throw console.error("THREE.WebGLRenderer: " + ie.message), ie;
    }
    let ae, De, Ee, Ie, Ce, ze, Fe, W, G, se, _e, ve, ue, Te, Ge, Pe, he, Se, Ve, Ye, $e, Ne, He, Qe;
    function Ze() {
      ae = new WB(re), ae.init(), Ne = new Nx(re, ae), De = new QB(re, ae, e, Ne), Ee = new CR(re), Ie = new YB(re), Ce = new dR(), ze = new SR(re, ae, Ee, Ce, De, Ne, Ie), Fe = new $B(y), W = new jB(y), G = new iI(re), He = new NB(re, G), se = new qB(re, G, Ie, He), _e = new JB(re, se, G, Ie), Ve = new KB(re, De, ze), Pe = new zB(Ce), ve = new hR(y, Fe, W, ae, De, He, Pe), ue = new DR(y, Ce), Te = new mR(), Ge = new yR(ae), Se = new OB(y, Fe, W, Ee, _e, h, l), he = new ER(y, _e, De), Qe = new LR(re, Ie, De, Ee), Ye = new GB(re, ae, Ie), $e = new XB(re, ae, Ie), Ie.programs = ve.programs, y.capabilities = De, y.extensions = ae, y.properties = Ce, y.renderLists = Te, y.shadowMap = he, y.state = Ee, y.info = Ie;
    }
    Ze();
    const Ke = new PR(y, re);
    this.xr = Ke, this.getContext = function() {
      return re;
    }, this.getContextAttributes = function() {
      return re.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ie = ae.get("WEBGL_lose_context");
      ie && ie.loseContext();
    }, this.forceContextRestore = function() {
      const ie = ae.get("WEBGL_lose_context");
      ie && ie.restoreContext();
    }, this.getPixelRatio = function() {
      return Q;
    }, this.setPixelRatio = function(ie) {
      ie !== void 0 && (Q = ie, this.setSize(V, U, !1));
    }, this.getSize = function(ie) {
      return ie.set(V, U);
    }, this.setSize = function(ie, Be, Oe = !0) {
      if (Ke.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      V = ie, U = Be, t.width = Math.floor(ie * Q), t.height = Math.floor(Be * Q), Oe === !0 && (t.style.width = ie + "px", t.style.height = Be + "px"), this.setViewport(0, 0, ie, Be);
    }, this.getDrawingBufferSize = function(ie) {
      return ie.set(V * Q, U * Q).floor();
    }, this.setDrawingBufferSize = function(ie, Be, Oe) {
      V = ie, U = Be, Q = Oe, t.width = Math.floor(ie * Oe), t.height = Math.floor(Be * Oe), this.setViewport(0, 0, ie, Be);
    }, this.getCurrentViewport = function(ie) {
      return ie.copy(S);
    }, this.getViewport = function(ie) {
      return ie.copy(le);
    }, this.setViewport = function(ie, Be, Oe, Le) {
      ie.isVector4 ? le.set(ie.x, ie.y, ie.z, ie.w) : le.set(ie, Be, Oe, Le), Ee.viewport(S.copy(le).multiplyScalar(Q).round());
    }, this.getScissor = function(ie) {
      return ie.copy(k);
    }, this.setScissor = function(ie, Be, Oe, Le) {
      ie.isVector4 ? k.set(ie.x, ie.y, ie.z, ie.w) : k.set(ie, Be, Oe, Le), Ee.scissor(D.copy(k).multiplyScalar(Q).round());
    }, this.getScissorTest = function() {
      return X;
    }, this.setScissorTest = function(ie) {
      Ee.setScissorTest(X = ie);
    }, this.setOpaqueSort = function(ie) {
      q = ie;
    }, this.setTransparentSort = function(ie) {
      oe = ie;
    }, this.getClearColor = function(ie) {
      return ie.copy(Se.getClearColor());
    }, this.setClearColor = function() {
      Se.setClearColor.apply(Se, arguments);
    }, this.getClearAlpha = function() {
      return Se.getClearAlpha();
    }, this.setClearAlpha = function() {
      Se.setClearAlpha.apply(Se, arguments);
    }, this.clear = function(ie = !0, Be = !0, Oe = !0) {
      let Le = 0;
      if (ie) {
        let F = !1;
        if (C !== null) {
          const ce = C.texture.format;
          F = ce === Ol || ce === Ru || ce === cd;
        }
        if (F) {
          const ce = C.texture.type, ct = ce === Un || ce === xr || ce === ld || ce === Hl || ce === uA || ce === fA, ut = Se.getClearColor(), pt = Se.getClearAlpha(), Bt = ut.r, qe = ut.g, Lt = ut.b;
          ct ? (d[0] = Bt, d[1] = qe, d[2] = Lt, d[3] = pt, re.clearBufferuiv(re.COLOR, 0, d)) : (m[0] = Bt, m[1] = qe, m[2] = Lt, m[3] = pt, re.clearBufferiv(re.COLOR, 0, m));
        } else
          Le |= re.COLOR_BUFFER_BIT;
      }
      Be && (Le |= re.DEPTH_BUFFER_BIT), Oe && (Le |= re.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), re.clear(Le);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", $, !1), t.removeEventListener("webglcontextrestored", ge, !1), t.removeEventListener("webglcontextcreationerror", be, !1), Te.dispose(), Ge.dispose(), Ce.dispose(), Fe.dispose(), W.dispose(), _e.dispose(), He.dispose(), Qe.dispose(), ve.dispose(), Ke.dispose(), Ke.removeEventListener("sessionstart", Xe), Ke.removeEventListener("sessionend", dt), at.stop();
    };
    function $(ie) {
      ie.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), w = !0;
    }
    function ge() {
      console.log("THREE.WebGLRenderer: Context Restored."), w = !1;
      const ie = Ie.autoReset, Be = he.enabled, Oe = he.autoUpdate, Le = he.needsUpdate, F = he.type;
      Ze(), Ie.autoReset = ie, he.enabled = Be, he.autoUpdate = Oe, he.needsUpdate = Le, he.type = F;
    }
    function be(ie) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ie.statusMessage);
    }
    function Ue(ie) {
      const Be = ie.target;
      Be.removeEventListener("dispose", Ue), je(Be);
    }
    function je(ie) {
      it(ie), Ce.remove(ie);
    }
    function it(ie) {
      const Be = Ce.get(ie).programs;
      Be !== void 0 && (Be.forEach(function(Oe) {
        ve.releaseProgram(Oe);
      }), ie.isShaderMaterial && ve.releaseShaderCache(ie));
    }
    this.renderBufferDirect = function(ie, Be, Oe, Le, F, ce) {
      Be === null && (Be = pe);
      const ct = F.isMesh && F.matrixWorld.determinant() < 0, ut = an(ie, Be, Oe, Le, F);
      Ee.setMaterial(Le, ct);
      let pt = Oe.index, Bt = 1;
      if (Le.wireframe === !0) {
        if (pt = se.getWireframeAttribute(Oe), pt === void 0)
          return;
        Bt = 2;
      }
      const qe = Oe.drawRange, Lt = Oe.attributes.position;
      let pn = qe.start * Bt, mn = (qe.start + qe.count) * Bt;
      ce !== null && (pn = Math.max(pn, ce.start * Bt), mn = Math.min(mn, (ce.start + ce.count) * Bt)), pt !== null ? (pn = Math.max(pn, 0), mn = Math.min(mn, pt.count)) : Lt != null && (pn = Math.max(pn, 0), mn = Math.min(mn, Lt.count));
      const _n = mn - pn;
      if (_n < 0 || _n === 1 / 0)
        return;
      He.setup(F, Le, ut, Oe, pt);
      let pi, zt = Ye;
      if (pt !== null && (pi = G.get(pt), zt = $e, zt.setIndex(pi)), F.isMesh)
        Le.wireframe === !0 ? (Ee.setLineWidth(Le.wireframeLinewidth * me()), zt.setMode(re.LINES)) : zt.setMode(re.TRIANGLES);
      else if (F.isLine) {
        let vt = Le.linewidth;
        vt === void 0 && (vt = 1), Ee.setLineWidth(vt * me()), F.isLineSegments ? zt.setMode(re.LINES) : F.isLineLoop ? zt.setMode(re.LINE_LOOP) : zt.setMode(re.LINE_STRIP);
      } else
        F.isPoints ? zt.setMode(re.POINTS) : F.isSprite && zt.setMode(re.TRIANGLES);
      if (F.isBatchedMesh)
        F._multiDrawInstances !== null ? zt.renderMultiDrawInstances(F._multiDrawStarts, F._multiDrawCounts, F._multiDrawCount, F._multiDrawInstances) : zt.renderMultiDraw(F._multiDrawStarts, F._multiDrawCounts, F._multiDrawCount);
      else if (F.isInstancedMesh)
        zt.renderInstances(pn, _n, F.count);
      else if (Oe.isInstancedBufferGeometry) {
        const vt = Oe._maxInstanceCount !== void 0 ? Oe._maxInstanceCount : 1 / 0, Ei = Math.min(Oe.instanceCount, vt);
        zt.renderInstances(pn, _n, Ei);
      } else
        zt.render(pn, _n);
    };
    function nt(ie, Be, Oe) {
      ie.transparent === !0 && ie.side === zn && ie.forceSinglePass === !1 ? (ie.side = Kn, ie.needsUpdate = !0, Jt(ie, Be, Oe), ie.side = Hi, ie.needsUpdate = !0, Jt(ie, Be, Oe), ie.side = zn) : Jt(ie, Be, Oe);
    }
    this.compile = function(ie, Be, Oe = null) {
      Oe === null && (Oe = ie), g = Ge.get(Oe), g.init(Be), v.push(g), Oe.traverseVisible(function(F) {
        F.isLight && F.layers.test(Be.layers) && (g.pushLight(F), F.castShadow && g.pushShadow(F));
      }), ie !== Oe && ie.traverseVisible(function(F) {
        F.isLight && F.layers.test(Be.layers) && (g.pushLight(F), F.castShadow && g.pushShadow(F));
      }), g.setupLights(y._useLegacyLights);
      const Le = /* @__PURE__ */ new Set();
      return ie.traverse(function(F) {
        const ce = F.material;
        if (ce)
          if (Array.isArray(ce))
            for (let ct = 0; ct < ce.length; ct++) {
              const ut = ce[ct];
              nt(ut, Oe, F), Le.add(ut);
            }
          else
            nt(ce, Oe, F), Le.add(ce);
      }), v.pop(), g = null, Le;
    }, this.compileAsync = function(ie, Be, Oe = null) {
      const Le = this.compile(ie, Be, Oe);
      return new Promise((F) => {
        function ce() {
          if (Le.forEach(function(ct) {
            Ce.get(ct).currentProgram.isReady() && Le.delete(ct);
          }), Le.size === 0) {
            F(ie);
            return;
          }
          setTimeout(ce, 10);
        }
        ae.get("KHR_parallel_shader_compile") !== null ? ce() : setTimeout(ce, 10);
      });
    };
    let mt = null;
    function bt(ie) {
      mt && mt(ie);
    }
    function Xe() {
      at.stop();
    }
    function dt() {
      at.start();
    }
    const at = new Dx();
    at.setAnimationLoop(bt), typeof self < "u" && at.setContext(self), this.setAnimationLoop = function(ie) {
      mt = ie, Ke.setAnimationLoop(ie), ie === null ? at.stop() : at.start();
    }, Ke.addEventListener("sessionstart", Xe), Ke.addEventListener("sessionend", dt), this.render = function(ie, Be) {
      if (Be !== void 0 && Be.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (w === !0)
        return;
      ie.matrixWorldAutoUpdate === !0 && ie.updateMatrixWorld(), Be.parent === null && Be.matrixWorldAutoUpdate === !0 && Be.updateMatrixWorld(), Ke.enabled === !0 && Ke.isPresenting === !0 && (Ke.cameraAutoUpdate === !0 && Ke.updateCamera(Be), Be = Ke.getCamera()), ie.isScene === !0 && ie.onBeforeRender(y, ie, Be, C), g = Ge.get(ie, v.length), g.init(Be), v.push(g), Ae.multiplyMatrices(Be.projectionMatrix, Be.matrixWorldInverse), fe.setFromProjectionMatrix(Ae), j = this.localClippingEnabled, te = Pe.init(this.clippingPlanes, j), _ = Te.get(ie, A.length), _.init(), A.push(_), At(ie, Be, 0, y.sortObjects), _.finish(), y.sortObjects === !0 && _.sort(q, oe);
      const Oe = Ke.enabled === !1 || Ke.isPresenting === !1 || Ke.hasDepthSensing() === !1;
      Oe && Se.addToRenderList(_, ie), this.info.render.frame++, te === !0 && Pe.beginShadows();
      const Le = g.state.shadowsArray;
      he.render(Le, ie, Be), te === !0 && Pe.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const F = _.opaque, ce = _.transmissive;
      if (g.setupLights(y._useLegacyLights), Be.isArrayCamera) {
        const ct = Be.cameras;
        if (ce.length > 0)
          for (let ut = 0, pt = ct.length; ut < pt; ut++) {
            const Bt = ct[ut];
            Qt(F, ce, ie, Bt);
          }
        Oe && Se.render(ie);
        for (let ut = 0, pt = ct.length; ut < pt; ut++) {
          const Bt = ct[ut];
          It(_, ie, Bt, Bt.viewport);
        }
      } else
        ce.length > 0 && Qt(F, ce, ie, Be), Oe && Se.render(ie), It(_, ie, Be);
      C !== null && (ze.updateMultisampleRenderTarget(C), ze.updateRenderTargetMipmap(C)), ie.isScene === !0 && ie.onAfterRender(y, ie, Be), He.resetDefaultState(), B = -1, T = null, v.pop(), v.length > 0 ? (g = v[v.length - 1], te === !0 && Pe.setGlobalState(y.clippingPlanes, g.state.camera)) : g = null, A.pop(), A.length > 0 ? _ = A[A.length - 1] : _ = null;
    };
    function At(ie, Be, Oe, Le) {
      if (ie.visible === !1)
        return;
      if (ie.layers.test(Be.layers)) {
        if (ie.isGroup)
          Oe = ie.renderOrder;
        else if (ie.isLOD)
          ie.autoUpdate === !0 && ie.update(Be);
        else if (ie.isLight)
          g.pushLight(ie), ie.castShadow && g.pushShadow(ie);
        else if (ie.isSprite) {
          if (!ie.frustumCulled || fe.intersectsSprite(ie)) {
            Le && Y.setFromMatrixPosition(ie.matrixWorld).applyMatrix4(Ae);
            const ct = _e.update(ie), ut = ie.material;
            ut.visible && _.push(ie, ct, ut, Oe, Y.z, null);
          }
        } else if ((ie.isMesh || ie.isLine || ie.isPoints) && (!ie.frustumCulled || fe.intersectsObject(ie))) {
          const ct = _e.update(ie), ut = ie.material;
          if (Le && (ie.boundingSphere !== void 0 ? (ie.boundingSphere === null && ie.computeBoundingSphere(), Y.copy(ie.boundingSphere.center)) : (ct.boundingSphere === null && ct.computeBoundingSphere(), Y.copy(ct.boundingSphere.center)), Y.applyMatrix4(ie.matrixWorld).applyMatrix4(Ae)), Array.isArray(ut)) {
            const pt = ct.groups;
            for (let Bt = 0, qe = pt.length; Bt < qe; Bt++) {
              const Lt = pt[Bt], pn = ut[Lt.materialIndex];
              pn && pn.visible && _.push(ie, ct, pn, Oe, Y.z, Lt);
            }
          } else
            ut.visible && _.push(ie, ct, ut, Oe, Y.z, null);
        }
      }
      const ce = ie.children;
      for (let ct = 0, ut = ce.length; ct < ut; ct++)
        At(ce[ct], Be, Oe, Le);
    }
    function It(ie, Be, Oe, Le) {
      const F = ie.opaque, ce = ie.transmissive, ct = ie.transparent;
      g.setupLightsView(Oe), te === !0 && Pe.setGlobalState(y.clippingPlanes, Oe), Le && Ee.viewport(S.copy(Le)), F.length > 0 && Tt(F, Be, Oe), ce.length > 0 && Tt(ce, Be, Oe), ct.length > 0 && Tt(ct, Be, Oe), Ee.buffers.depth.setTest(!0), Ee.buffers.depth.setMask(!0), Ee.buffers.color.setMask(!0), Ee.setPolygonOffset(!1);
    }
    function Qt(ie, Be, Oe, Le) {
      if ((Oe.isScene === !0 ? Oe.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[Le.id] === void 0 && (g.state.transmissionRenderTarget[Le.id] = new Ji(1, 1, {
        generateMipmaps: !0,
        type: ae.has("EXT_color_buffer_half_float") || ae.has("EXT_color_buffer_float") ? Ri : Un,
        minFilter: Yi,
        samples: 4,
        stencilBuffer: r,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }));
      const ce = g.state.transmissionRenderTarget[Le.id], ct = Le.viewport || S;
      ce.setSize(ct.z, ct.w);
      const ut = y.getRenderTarget();
      y.setRenderTarget(ce), y.getClearColor(P), L = y.getClearAlpha(), L < 1 && y.setClearColor(16777215, 0.5), y.clear();
      const pt = y.toneMapping;
      y.toneMapping = Ls;
      const Bt = Le.viewport;
      if (Le.viewport !== void 0 && (Le.viewport = void 0), g.setupLightsView(Le), te === !0 && Pe.setGlobalState(y.clippingPlanes, Le), Tt(ie, Oe, Le), ze.updateMultisampleRenderTarget(ce), ze.updateRenderTargetMipmap(ce), ae.has("WEBGL_multisampled_render_to_texture") === !1) {
        let qe = !1;
        for (let Lt = 0, pn = Be.length; Lt < pn; Lt++) {
          const mn = Be[Lt], _n = mn.object, pi = mn.geometry, zt = mn.material, vt = mn.group;
          if (zt.side === zn && _n.layers.test(Le.layers)) {
            const Ei = zt.side;
            zt.side = Kn, zt.needsUpdate = !0, $t(_n, Oe, Le, pi, zt, vt), zt.side = Ei, zt.needsUpdate = !0, qe = !0;
          }
        }
        qe === !0 && (ze.updateMultisampleRenderTarget(ce), ze.updateRenderTargetMipmap(ce));
      }
      y.setRenderTarget(ut), y.setClearColor(P, L), Bt !== void 0 && (Le.viewport = Bt), y.toneMapping = pt;
    }
    function Tt(ie, Be, Oe) {
      const Le = Be.isScene === !0 ? Be.overrideMaterial : null;
      for (let F = 0, ce = ie.length; F < ce; F++) {
        const ct = ie[F], ut = ct.object, pt = ct.geometry, Bt = Le === null ? ct.material : Le, qe = ct.group;
        ut.layers.test(Oe.layers) && $t(ut, Be, Oe, pt, Bt, qe);
      }
    }
    function $t(ie, Be, Oe, Le, F, ce) {
      ie.onBeforeRender(y, Be, Oe, Le, F, ce), ie.modelViewMatrix.multiplyMatrices(Oe.matrixWorldInverse, ie.matrixWorld), ie.normalMatrix.getNormalMatrix(ie.modelViewMatrix), F.onBeforeRender(y, Be, Oe, Le, ie, ce), F.transparent === !0 && F.side === zn && F.forceSinglePass === !1 ? (F.side = Kn, F.needsUpdate = !0, y.renderBufferDirect(Oe, Be, Le, F, ie, ce), F.side = Hi, F.needsUpdate = !0, y.renderBufferDirect(Oe, Be, Le, F, ie, ce), F.side = zn) : y.renderBufferDirect(Oe, Be, Le, F, ie, ce), ie.onAfterRender(y, Be, Oe, Le, F, ce);
    }
    function Jt(ie, Be, Oe) {
      Be.isScene !== !0 && (Be = pe);
      const Le = Ce.get(ie), F = g.state.lights, ce = g.state.shadowsArray, ct = F.state.version, ut = ve.getParameters(ie, F.state, ce, Be, Oe), pt = ve.getProgramCacheKey(ut);
      let Bt = Le.programs;
      Le.environment = ie.isMeshStandardMaterial ? Be.environment : null, Le.fog = Be.fog, Le.envMap = (ie.isMeshStandardMaterial ? W : Fe).get(ie.envMap || Le.environment), Le.envMapRotation = Le.environment !== null && ie.envMap === null ? Be.environmentRotation : ie.envMapRotation, Bt === void 0 && (ie.addEventListener("dispose", Ue), Bt = /* @__PURE__ */ new Map(), Le.programs = Bt);
      let qe = Bt.get(pt);
      if (qe !== void 0) {
        if (Le.currentProgram === qe && Le.lightsStateVersion === ct)
          return Wt(ie, ut), qe;
      } else
        ut.uniforms = ve.getUniforms(ie), ie.onBuild(Oe, ut, y), ie.onBeforeCompile(ut, y), qe = ve.acquireProgram(ut, pt), Bt.set(pt, qe), Le.uniforms = ut.uniforms;
      const Lt = Le.uniforms;
      return (!ie.isShaderMaterial && !ie.isRawShaderMaterial || ie.clipping === !0) && (Lt.clippingPlanes = Pe.uniform), Wt(ie, ut), Le.needsLights = Zn(ie), Le.lightsStateVersion = ct, Le.needsLights && (Lt.ambientLightColor.value = F.state.ambient, Lt.lightProbe.value = F.state.probe, Lt.directionalLights.value = F.state.directional, Lt.directionalLightShadows.value = F.state.directionalShadow, Lt.spotLights.value = F.state.spot, Lt.spotLightShadows.value = F.state.spotShadow, Lt.rectAreaLights.value = F.state.rectArea, Lt.ltc_1.value = F.state.rectAreaLTC1, Lt.ltc_2.value = F.state.rectAreaLTC2, Lt.pointLights.value = F.state.point, Lt.pointLightShadows.value = F.state.pointShadow, Lt.hemisphereLights.value = F.state.hemi, Lt.directionalShadowMap.value = F.state.directionalShadowMap, Lt.directionalShadowMatrix.value = F.state.directionalShadowMatrix, Lt.spotShadowMap.value = F.state.spotShadowMap, Lt.spotLightMatrix.value = F.state.spotLightMatrix, Lt.spotLightMap.value = F.state.spotLightMap, Lt.pointShadowMap.value = F.state.pointShadowMap, Lt.pointShadowMatrix.value = F.state.pointShadowMatrix), Le.currentProgram = qe, Le.uniformsList = null, qe;
    }
    function on(ie) {
      if (ie.uniformsList === null) {
        const Be = ie.currentProgram.getUniforms();
        ie.uniformsList = Bh.seqWithValue(Be.seq, ie.uniforms);
      }
      return ie.uniformsList;
    }
    function Wt(ie, Be) {
      const Oe = Ce.get(ie);
      Oe.outputColorSpace = Be.outputColorSpace, Oe.batching = Be.batching, Oe.instancing = Be.instancing, Oe.instancingColor = Be.instancingColor, Oe.instancingMorph = Be.instancingMorph, Oe.skinning = Be.skinning, Oe.morphTargets = Be.morphTargets, Oe.morphNormals = Be.morphNormals, Oe.morphColors = Be.morphColors, Oe.morphTargetsCount = Be.morphTargetsCount, Oe.numClippingPlanes = Be.numClippingPlanes, Oe.numIntersection = Be.numClipIntersection, Oe.vertexAlphas = Be.vertexAlphas, Oe.vertexTangents = Be.vertexTangents, Oe.toneMapping = Be.toneMapping;
    }
    function an(ie, Be, Oe, Le, F) {
      Be.isScene !== !0 && (Be = pe), ze.resetTextureUnits();
      const ce = Be.fog, ct = Le.isMeshStandardMaterial ? Be.environment : null, ut = C === null ? y.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : Bn, pt = (Le.isMeshStandardMaterial ? W : Fe).get(Le.envMap || ct), Bt = Le.vertexColors === !0 && !!Oe.attributes.color && Oe.attributes.color.itemSize === 4, qe = !!Oe.attributes.tangent && (!!Le.normalMap || Le.anisotropy > 0), Lt = !!Oe.morphAttributes.position, pn = !!Oe.morphAttributes.normal, mn = !!Oe.morphAttributes.color;
      let _n = Ls;
      Le.toneMapped && (C === null || C.isXRRenderTarget === !0) && (_n = y.toneMapping);
      const pi = Oe.morphAttributes.position || Oe.morphAttributes.normal || Oe.morphAttributes.color, zt = pi !== void 0 ? pi.length : 0, vt = Ce.get(Le), Ei = g.state.lights;
      if (te === !0 && (j === !0 || ie !== T)) {
        const Nn = ie === T && Le.id === B;
        Pe.setState(Le, ie, Nn);
      }
      let sn = !1;
      Le.version === vt.__version ? (vt.needsLights && vt.lightsStateVersion !== Ei.state.version || vt.outputColorSpace !== ut || F.isBatchedMesh && vt.batching === !1 || !F.isBatchedMesh && vt.batching === !0 || F.isInstancedMesh && vt.instancing === !1 || !F.isInstancedMesh && vt.instancing === !0 || F.isSkinnedMesh && vt.skinning === !1 || !F.isSkinnedMesh && vt.skinning === !0 || F.isInstancedMesh && vt.instancingColor === !0 && F.instanceColor === null || F.isInstancedMesh && vt.instancingColor === !1 && F.instanceColor !== null || F.isInstancedMesh && vt.instancingMorph === !0 && F.morphTexture === null || F.isInstancedMesh && vt.instancingMorph === !1 && F.morphTexture !== null || vt.envMap !== pt || Le.fog === !0 && vt.fog !== ce || vt.numClippingPlanes !== void 0 && (vt.numClippingPlanes !== Pe.numPlanes || vt.numIntersection !== Pe.numIntersection) || vt.vertexAlphas !== Bt || vt.vertexTangents !== qe || vt.morphTargets !== Lt || vt.morphNormals !== pn || vt.morphColors !== mn || vt.toneMapping !== _n || vt.morphTargetsCount !== zt) && (sn = !0) : (sn = !0, vt.__version = Le.version);
      let li = vt.currentProgram;
      sn === !0 && (li = Jt(Le, Be, F));
      let Hr = !1, ci = !1, Cr = !1;
      const gn = li.getUniforms(), ui = vt.uniforms;
      if (Ee.useProgram(li.program) && (Hr = !0, ci = !0, Cr = !0), Le.id !== B && (B = Le.id, ci = !0), Hr || T !== ie) {
        gn.setValue(re, "projectionMatrix", ie.projectionMatrix), gn.setValue(re, "viewMatrix", ie.matrixWorldInverse);
        const Nn = gn.map.cameraPosition;
        Nn !== void 0 && Nn.setValue(re, Y.setFromMatrixPosition(ie.matrixWorld)), De.logarithmicDepthBuffer && gn.setValue(
          re,
          "logDepthBufFC",
          2 / (Math.log(ie.far + 1) / Math.LN2)
        ), (Le.isMeshPhongMaterial || Le.isMeshToonMaterial || Le.isMeshLambertMaterial || Le.isMeshBasicMaterial || Le.isMeshStandardMaterial || Le.isShaderMaterial) && gn.setValue(re, "isOrthographic", ie.isOrthographicCamera === !0), T !== ie && (T = ie, ci = !0, Cr = !0);
      }
      if (F.isSkinnedMesh) {
        gn.setOptional(re, F, "bindMatrix"), gn.setOptional(re, F, "bindMatrixInverse");
        const Nn = F.skeleton;
        Nn && (Nn.boneTexture === null && Nn.computeBoneTexture(), gn.setValue(re, "boneTexture", Nn.boneTexture, ze));
      }
      F.isBatchedMesh && (gn.setOptional(re, F, "batchingTexture"), gn.setValue(re, "batchingTexture", F._matricesTexture, ze));
      const Oi = Oe.morphAttributes;
      if ((Oi.position !== void 0 || Oi.normal !== void 0 || Oi.color !== void 0) && Ve.update(F, Oe, li), (ci || vt.receiveShadow !== F.receiveShadow) && (vt.receiveShadow = F.receiveShadow, gn.setValue(re, "receiveShadow", F.receiveShadow)), Le.isMeshGouraudMaterial && Le.envMap !== null && (ui.envMap.value = pt, ui.flipEnvMap.value = pt.isCubeTexture && pt.isRenderTargetTexture === !1 ? -1 : 1), Le.isMeshStandardMaterial && Le.envMap === null && Be.environment !== null && (ui.envMapIntensity.value = Be.environmentIntensity), ci && (gn.setValue(re, "toneMappingExposure", y.toneMappingExposure), vt.needsLights && Mn(ui, Cr), ce && Le.fog === !0 && ue.refreshFogUniforms(ui, ce), ue.refreshMaterialUniforms(ui, Le, Q, U, g.state.transmissionRenderTarget[ie.id]), Bh.upload(re, on(vt), ui, ze)), Le.isShaderMaterial && Le.uniformsNeedUpdate === !0 && (Bh.upload(re, on(vt), ui, ze), Le.uniformsNeedUpdate = !1), Le.isSpriteMaterial && gn.setValue(re, "center", F.center), gn.setValue(re, "modelViewMatrix", F.modelViewMatrix), gn.setValue(re, "normalMatrix", F.normalMatrix), gn.setValue(re, "modelMatrix", F.matrixWorld), Le.isShaderMaterial || Le.isRawShaderMaterial) {
        const Nn = Le.uniformsGroups;
        for (let fr = 0, jr = Nn.length; fr < jr; fr++) {
          const ei = Nn[fr];
          Qe.update(ei, li), Qe.bind(ei, li);
        }
      }
      return li;
    }
    function Mn(ie, Be) {
      ie.ambientLightColor.needsUpdate = Be, ie.lightProbe.needsUpdate = Be, ie.directionalLights.needsUpdate = Be, ie.directionalLightShadows.needsUpdate = Be, ie.pointLights.needsUpdate = Be, ie.pointLightShadows.needsUpdate = Be, ie.spotLights.needsUpdate = Be, ie.spotLightShadows.needsUpdate = Be, ie.rectAreaLights.needsUpdate = Be, ie.hemisphereLights.needsUpdate = Be;
    }
    function Zn(ie) {
      return ie.isMeshLambertMaterial || ie.isMeshToonMaterial || ie.isMeshPhongMaterial || ie.isMeshStandardMaterial || ie.isShadowMaterial || ie.isShaderMaterial && ie.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return E;
    }, this.getActiveMipmapLevel = function() {
      return I;
    }, this.getRenderTarget = function() {
      return C;
    }, this.setRenderTargetTextures = function(ie, Be, Oe) {
      Ce.get(ie.texture).__webglTexture = Be, Ce.get(ie.depthTexture).__webglTexture = Oe;
      const Le = Ce.get(ie);
      Le.__hasExternalTextures = !0, Le.__autoAllocateDepthBuffer = Oe === void 0, Le.__autoAllocateDepthBuffer || ae.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Le.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(ie, Be) {
      const Oe = Ce.get(ie);
      Oe.__webglFramebuffer = Be, Oe.__useDefaultFramebuffer = Be === void 0;
    }, this.setRenderTarget = function(ie, Be = 0, Oe = 0) {
      C = ie, E = Be, I = Oe;
      let Le = !0, F = null, ce = !1, ct = !1;
      if (ie) {
        const pt = Ce.get(ie);
        pt.__useDefaultFramebuffer !== void 0 ? (Ee.bindFramebuffer(re.FRAMEBUFFER, null), Le = !1) : pt.__webglFramebuffer === void 0 ? ze.setupRenderTarget(ie) : pt.__hasExternalTextures && ze.rebindTextures(ie, Ce.get(ie.texture).__webglTexture, Ce.get(ie.depthTexture).__webglTexture);
        const Bt = ie.texture;
        (Bt.isData3DTexture || Bt.isDataArrayTexture || Bt.isCompressedArrayTexture) && (ct = !0);
        const qe = Ce.get(ie).__webglFramebuffer;
        ie.isWebGLCubeRenderTarget ? (Array.isArray(qe[Be]) ? F = qe[Be][Oe] : F = qe[Be], ce = !0) : ie.samples > 0 && ze.useMultisampledRTT(ie) === !1 ? F = Ce.get(ie).__webglMultisampledFramebuffer : Array.isArray(qe) ? F = qe[Oe] : F = qe, S.copy(ie.viewport), D.copy(ie.scissor), R = ie.scissorTest;
      } else
        S.copy(le).multiplyScalar(Q).floor(), D.copy(k).multiplyScalar(Q).floor(), R = X;
      if (Ee.bindFramebuffer(re.FRAMEBUFFER, F) && Le && Ee.drawBuffers(ie, F), Ee.viewport(S), Ee.scissor(D), Ee.setScissorTest(R), ce) {
        const pt = Ce.get(ie.texture);
        re.framebufferTexture2D(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0, re.TEXTURE_CUBE_MAP_POSITIVE_X + Be, pt.__webglTexture, Oe);
      } else if (ct) {
        const pt = Ce.get(ie.texture), Bt = Be || 0;
        re.framebufferTextureLayer(re.FRAMEBUFFER, re.COLOR_ATTACHMENT0, pt.__webglTexture, Oe || 0, Bt);
      }
      B = -1;
    }, this.readRenderTargetPixels = function(ie, Be, Oe, Le, F, ce, ct) {
      if (!(ie && ie.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let ut = Ce.get(ie).__webglFramebuffer;
      if (ie.isWebGLCubeRenderTarget && ct !== void 0 && (ut = ut[ct]), ut) {
        Ee.bindFramebuffer(re.FRAMEBUFFER, ut);
        try {
          const pt = ie.texture, Bt = pt.format, qe = pt.type;
          if (!De.textureFormatReadable(Bt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!De.textureTypeReadable(qe)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          Be >= 0 && Be <= ie.width - Le && Oe >= 0 && Oe <= ie.height - F && re.readPixels(Be, Oe, Le, F, Ne.convert(Bt), Ne.convert(qe), ce);
        } finally {
          const pt = C !== null ? Ce.get(C).__webglFramebuffer : null;
          Ee.bindFramebuffer(re.FRAMEBUFFER, pt);
        }
      }
    }, this.copyFramebufferToTexture = function(ie, Be, Oe = 0) {
      const Le = Math.pow(2, -Oe), F = Math.floor(Be.image.width * Le), ce = Math.floor(Be.image.height * Le);
      ze.setTexture2D(Be, 0), re.copyTexSubImage2D(re.TEXTURE_2D, Oe, 0, 0, ie.x, ie.y, F, ce), Ee.unbindTexture();
    }, this.copyTextureToTexture = function(ie, Be, Oe, Le = 0) {
      const F = Be.image.width, ce = Be.image.height, ct = Ne.convert(Oe.format), ut = Ne.convert(Oe.type);
      ze.setTexture2D(Oe, 0), re.pixelStorei(re.UNPACK_FLIP_Y_WEBGL, Oe.flipY), re.pixelStorei(re.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Oe.premultiplyAlpha), re.pixelStorei(re.UNPACK_ALIGNMENT, Oe.unpackAlignment), Be.isDataTexture ? re.texSubImage2D(re.TEXTURE_2D, Le, ie.x, ie.y, F, ce, ct, ut, Be.image.data) : Be.isCompressedTexture ? re.compressedTexSubImage2D(re.TEXTURE_2D, Le, ie.x, ie.y, Be.mipmaps[0].width, Be.mipmaps[0].height, ct, Be.mipmaps[0].data) : re.texSubImage2D(re.TEXTURE_2D, Le, ie.x, ie.y, ct, ut, Be.image), Le === 0 && Oe.generateMipmaps && re.generateMipmap(re.TEXTURE_2D), Ee.unbindTexture();
    }, this.copyTextureToTexture3D = function(ie, Be, Oe, Le, F = 0) {
      const ce = ie.max.x - ie.min.x, ct = ie.max.y - ie.min.y, ut = ie.max.z - ie.min.z, pt = Ne.convert(Le.format), Bt = Ne.convert(Le.type);
      let qe;
      if (Le.isData3DTexture)
        ze.setTexture3D(Le, 0), qe = re.TEXTURE_3D;
      else if (Le.isDataArrayTexture || Le.isCompressedArrayTexture)
        ze.setTexture2DArray(Le, 0), qe = re.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      re.pixelStorei(re.UNPACK_FLIP_Y_WEBGL, Le.flipY), re.pixelStorei(re.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Le.premultiplyAlpha), re.pixelStorei(re.UNPACK_ALIGNMENT, Le.unpackAlignment);
      const Lt = re.getParameter(re.UNPACK_ROW_LENGTH), pn = re.getParameter(re.UNPACK_IMAGE_HEIGHT), mn = re.getParameter(re.UNPACK_SKIP_PIXELS), _n = re.getParameter(re.UNPACK_SKIP_ROWS), pi = re.getParameter(re.UNPACK_SKIP_IMAGES), zt = Oe.isCompressedTexture ? Oe.mipmaps[F] : Oe.image;
      re.pixelStorei(re.UNPACK_ROW_LENGTH, zt.width), re.pixelStorei(re.UNPACK_IMAGE_HEIGHT, zt.height), re.pixelStorei(re.UNPACK_SKIP_PIXELS, ie.min.x), re.pixelStorei(re.UNPACK_SKIP_ROWS, ie.min.y), re.pixelStorei(re.UNPACK_SKIP_IMAGES, ie.min.z), Oe.isDataTexture || Oe.isData3DTexture ? re.texSubImage3D(qe, F, Be.x, Be.y, Be.z, ce, ct, ut, pt, Bt, zt.data) : Le.isCompressedArrayTexture ? re.compressedTexSubImage3D(qe, F, Be.x, Be.y, Be.z, ce, ct, ut, pt, zt.data) : re.texSubImage3D(qe, F, Be.x, Be.y, Be.z, ce, ct, ut, pt, Bt, zt), re.pixelStorei(re.UNPACK_ROW_LENGTH, Lt), re.pixelStorei(re.UNPACK_IMAGE_HEIGHT, pn), re.pixelStorei(re.UNPACK_SKIP_PIXELS, mn), re.pixelStorei(re.UNPACK_SKIP_ROWS, _n), re.pixelStorei(re.UNPACK_SKIP_IMAGES, pi), F === 0 && Le.generateMipmaps && re.generateMipmap(qe), Ee.unbindTexture();
    }, this.initTexture = function(ie) {
      ie.isCubeTexture ? ze.setTextureCube(ie, 0) : ie.isData3DTexture ? ze.setTexture3D(ie, 0) : ie.isDataArrayTexture || ie.isCompressedArrayTexture ? ze.setTexture2DArray(ie, 0) : ze.setTexture2D(ie, 0), Ee.unbindTexture();
    }, this.resetState = function() {
      E = 0, I = 0, C = null, Ee.reset(), He.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return is;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === Du ? "display-p3" : "srgb", t.unpackColorSpace = cn.workingColorSpace === Wl ? "display-p3" : "srgb";
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class md {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Je(e), this.density = t;
  }
  clone() {
    return new md(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class gd {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Je(e), this.near = t, this.far = n;
  }
  clone() {
    return new gd(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
let Jl = class extends Gt {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Ui(), this.environmentIntensity = 1, this.environmentRotation = new Ui(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
};
class Uu {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = _u, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = ur();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return Ix("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ur()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ur()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Gi = /* @__PURE__ */ new H();
class Ao {
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Gi.fromBufferAttribute(this, t), Gi.applyMatrix4(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Gi.fromBufferAttribute(this, t), Gi.applyNormalMatrix(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Gi.fromBufferAttribute(this, t), Gi.transformDirection(e), this.setXYZ(t, Gi.x, Gi.y, Gi.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = $i(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = Nt(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  setX(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Nt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = $i(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array), i = Nt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Nt(t, this.array), n = Nt(n, this.array), i = Nt(i, this.array), r = Nt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return new Rt(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Ao(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Ad extends ii {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Je(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let tl;
const wc = /* @__PURE__ */ new H(), nl = /* @__PURE__ */ new H(), il = /* @__PURE__ */ new H(), rl = /* @__PURE__ */ new ke(), Ec = /* @__PURE__ */ new ke(), Qx = /* @__PURE__ */ new st(), If = /* @__PURE__ */ new H(), Cc = /* @__PURE__ */ new H(), Tf = /* @__PURE__ */ new H(), H_ = /* @__PURE__ */ new ke(), zp = /* @__PURE__ */ new ke(), j_ = /* @__PURE__ */ new ke();
class zx extends Gt {
  constructor(e = new Ad()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", tl === void 0) {
      tl = new Dt();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Uu(t, 5);
      tl.setIndex([0, 1, 2, 0, 2, 3]), tl.setAttribute("position", new Ao(n, 3, 0, !1)), tl.setAttribute("uv", new Ao(n, 2, 3, !1));
    }
    this.geometry = tl, this.material = e, this.center = new ke(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), nl.setFromMatrixScale(this.matrixWorld), Qx.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), il.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && nl.multiplyScalar(-il.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && (r = Math.cos(n), i = Math.sin(n));
    const a = this.center;
    Bf(If.set(-0.5, -0.5, 0), il, a, nl, i, r), Bf(Cc.set(0.5, -0.5, 0), il, a, nl, i, r), Bf(Tf.set(0.5, 0.5, 0), il, a, nl, i, r), H_.set(0, 0), zp.set(1, 0), j_.set(1, 1);
    let o = e.ray.intersectTriangle(If, Cc, Tf, !1, wc);
    if (o === null && (Bf(Cc.set(-0.5, 0.5, 0), il, a, nl, i, r), zp.set(0, 1), o = e.ray.intersectTriangle(If, Tf, Cc, !1, wc), o === null))
      return;
    const l = e.ray.origin.distanceTo(wc);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: wc.clone(),
      uv: di.getInterpolation(wc, If, Cc, Tf, H_, zp, j_, new ke()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Bf(s, e, t, n, i, r) {
  rl.subVectors(s, t).addScalar(0.5).multiply(n), i !== void 0 ? (Ec.x = r * rl.x - i * rl.y, Ec.y = i * rl.x + r * rl.y) : Ec.copy(rl), s.copy(e), s.x += Ec.x, s.y += Ec.y, s.applyMatrix4(Qx);
}
const Pf = /* @__PURE__ */ new H(), W_ = /* @__PURE__ */ new H();
class $x extends Gt {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let r;
    for (r = 0; r < i.length && !(t < i[r].distance); r++)
      ;
    return i.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let r = t[n].distance;
        if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Pf.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Pf);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Pf.setFromMatrixPosition(e.matrixWorld), W_.setFromMatrixPosition(this.matrixWorld);
      const n = Pf.distanceTo(W_) / e.zoom;
      t[0].object.visible = !0;
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let a = t[i].distance;
        if (t[i].object.visible && (a -= a * t[i].hysteresis), n >= a)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < r; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let i = 0, r = n.length; i < r; i++) {
      const a = n[i];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis
      });
    }
    return t;
  }
}
const q_ = /* @__PURE__ */ new H(), X_ = /* @__PURE__ */ new Xt(), Y_ = /* @__PURE__ */ new Xt(), kR = /* @__PURE__ */ new H(), K_ = /* @__PURE__ */ new st(), Rf = /* @__PURE__ */ new H(), $p = /* @__PURE__ */ new Vn(), J_ = /* @__PURE__ */ new st(), Vp = /* @__PURE__ */ new wa();
class _d extends tt {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = tg, this.bindMatrix = new st(), this.bindMatrixInverse = new st(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new dn()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Rf), this.boundingBox.expandByPoint(Rf);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Vn()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Rf), this.boundingSphere.expandByPoint(Rf);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, i = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), $p.copy(this.boundingSphere), $p.applyMatrix4(i), e.ray.intersectsSphere($p) !== !1 && (J_.copy(i).invert(), Vp.copy(e.ray).applyMatrix4(J_), !(this.boundingBox !== null && Vp.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Vp)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Xt(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === tg ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === ox ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, i = this.geometry;
    X_.fromBufferAttribute(i.attributes.skinIndex, e), Y_.fromBufferAttribute(i.attributes.skinWeight, e), q_.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const a = Y_.getComponent(r);
      if (a !== 0) {
        const o = X_.getComponent(r);
        K_.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(kR.copy(q_).applyMatrix4(K_), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class bd extends Gt {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Di extends wn {
  constructor(e = null, t = 1, n = 1, i, r, a, o, l, c = nn, u = nn, f, h) {
    super(null, a, o, l, c, u, i, r, f, h), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const Z_ = /* @__PURE__ */ new st(), UR = /* @__PURE__ */ new st();
class Fu {
  constructor(e = [], t = []) {
    this.uuid = ur(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new st());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new st();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
    for (let r = 0, a = e.length; r < a; r++) {
      const o = e[r] ? e[r].matrixWorld : UR;
      Z_.multiplyMatrices(o, t[r]), Z_.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Fu(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Di(t, e, e, vn, hn);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let a = t[r];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new bd()), this.bones.push(a), this.boneInverses.push(new st().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const o = n[i];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class cs extends Rt {
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const sl = /* @__PURE__ */ new st(), eb = /* @__PURE__ */ new st(), Df = [], tb = /* @__PURE__ */ new dn(), FR = /* @__PURE__ */ new st(), Sc = /* @__PURE__ */ new tt(), Mc = /* @__PURE__ */ new Vn();
class Zl extends tt {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new cs(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, FR);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new dn()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, sl), tb.copy(e.boundingBox).applyMatrix4(sl), this.boundingBox.union(tb);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Vn()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, sl), Mc.copy(e.boundingSphere).applyMatrix4(sl), this.boundingSphere.union(Mc);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, r = n.length + 1, a = e * r + 1;
    for (let o = 0; o < n.length; o++)
      n[o] = i[a + o];
  }
  raycast(e, t) {
    const n = this.matrixWorld, i = this.count;
    if (Sc.geometry = this.geometry, Sc.material = this.material, Sc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Mc.copy(this.boundingSphere), Mc.applyMatrix4(n), e.ray.intersectsSphere(Mc) !== !1))
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, sl), eb.multiplyMatrices(n, sl), Sc.matrixWorld = eb, Sc.raycast(e, Df);
        for (let a = 0, o = Df.length; a < o; a++) {
          const l = Df[a];
          l.instanceId = r, l.object = this, t.push(l);
        }
        Df.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new cs(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences, i = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new Di(new Float32Array(i * this.count), i, this.count, Ts, hn));
    const r = this.morphTexture.source.data.data;
    let a = 0;
    for (let c = 0; c < n.length; c++)
      a += n[c];
    const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = i * e;
    r[l] = o, r.set(n, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
function OR(s, e) {
  return s.z - e.z;
}
function NR(s, e) {
  return e.z - s.z;
}
class GR {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const n = this.pool, i = this.list;
    this.index >= n.length && n.push({
      start: -1,
      count: -1,
      z: -1
    });
    const r = n[this.index];
    i.push(r), this.index++, r.start = e.start, r.count = e.count, r.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const ol = "batchId", to = /* @__PURE__ */ new st(), nb = /* @__PURE__ */ new st(), QR = /* @__PURE__ */ new st(), ib = /* @__PURE__ */ new st(), Hp = /* @__PURE__ */ new ku(), Lf = /* @__PURE__ */ new dn(), zo = /* @__PURE__ */ new Vn(), Ic = /* @__PURE__ */ new H(), jp = /* @__PURE__ */ new GR(), Ti = /* @__PURE__ */ new tt(), kf = [];
function zR(s, e, t = 0) {
  const n = e.itemSize;
  if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
    const i = s.count;
    for (let r = 0; r < i; r++)
      for (let a = 0; a < n; a++)
        e.setComponent(r + t, a, s.getComponent(r, a));
  } else
    e.array.set(s.array, t * n);
  e.needsUpdate = !0;
}
class Vx extends tt {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, n = t * 2, i) {
    super(new Dt(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new Di(t, e, e, vn, hn);
    this._matricesTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, i = this._maxGeometryCount, r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const l = e.getAttribute(o), { array: c, itemSize: u, normalized: f } = l, h = new c.constructor(n * u), d = new Rt(h, u, f);
        t.setAttribute(o, d);
      }
      if (e.getIndex() !== null) {
        const o = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new Rt(o, 1));
      }
      const a = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
      t.setAttribute(ol, new Rt(a, 1)), this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    if (e.getAttribute(ol))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${ol}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (n === ol)
        continue;
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(n), r = t.getAttribute(n);
      if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new dn());
    const e = this._geometryCount, t = this.boundingBox, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, to), this.getBoundingBoxAt(i, Lf).applyMatrix4(to), t.union(Lf));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Vn());
    const e = this._geometryCount, t = this.boundingSphere, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, to), this.getBoundingSphereAt(i, zo).applyMatrix4(to), t.union(zo));
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let r = null;
    const a = this._reservedRanges, o = this._drawRanges, l = this._bounds;
    this._geometryCount !== 0 && (r = a[a.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, r === null ? i.vertexStart = 0 : i.vertexStart = r.vertexStart + r.vertexCount;
    const c = e.getIndex(), u = c !== null;
    if (u && (n === -1 ? i.indexCount = c.count : i.indexCount = n, r === null ? i.indexStart = 0 : i.indexStart = r.indexStart + r.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const f = this._visibility, h = this._active, d = this._matricesTexture, m = this._matricesTexture.image.data;
    f.push(!0), h.push(!0);
    const _ = this._geometryCount;
    this._geometryCount++, QR.toArray(m, _ * 16), d.needsUpdate = !0, a.push(i), o.push({
      start: u ? i.indexStart : i.vertexStart,
      count: -1
    }), l.push({
      boxInitialized: !1,
      box: new dn(),
      sphereInitialized: !1,
      sphere: new Vn()
    });
    const g = this.geometry.getAttribute(ol);
    for (let A = 0; A < i.vertexCount; A++)
      g.setX(i.vertexStart + A, _);
    return g.needsUpdate = !0, this.setGeometryAt(_, e), _;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, i = n.getIndex() !== null, r = n.getIndex(), a = t.getIndex(), o = this._reservedRanges[e];
    if (i && a.count > o.indexCount || t.attributes.position.count > o.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = o.vertexStart, c = o.vertexCount;
    for (const d in n.attributes) {
      if (d === ol)
        continue;
      const m = t.getAttribute(d), _ = n.getAttribute(d);
      zR(m, _, l);
      const g = m.itemSize;
      for (let A = m.count, v = c; A < v; A++) {
        const y = l + A;
        for (let w = 0; w < g; w++)
          _.setComponent(y, w, 0);
      }
      _.needsUpdate = !0, _.addUpdateRange(l * g, c * g);
    }
    if (i) {
      const d = o.indexStart;
      for (let m = 0; m < a.count; m++)
        r.setX(d + m, l + a.getX(m));
      for (let m = a.count, _ = o.indexCount; m < _; m++)
        r.setX(d + m, l);
      r.needsUpdate = !0, r.addUpdateRange(d, o.indexCount);
    }
    const u = this._bounds[e];
    t.boundingBox !== null ? (u.box.copy(t.boundingBox), u.boxInitialized = !0) : u.boxInitialized = !1, t.boundingSphere !== null ? (u.sphere.copy(t.boundingSphere), u.sphereInitialized = !0) : u.sphereInitialized = !1;
    const f = this._drawRanges[e], h = t.getAttribute("position");
    return f.count = i ? a.count : h.count, this._visibilityChanged = !0, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this);
  }
  getInstanceCountAt(e) {
    return this._multiDrawInstances === null ? null : this._multiDrawInstances[e];
  }
  setInstanceCountAt(e, t) {
    return this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)), this._multiDrawInstances[e] = t, e;
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1)
      return null;
    const i = this._bounds[e], r = i.box, a = this.geometry;
    if (i.boxInitialized === !1) {
      r.makeEmpty();
      const o = a.index, l = a.attributes.position, c = this._drawRanges[e];
      for (let u = c.start, f = c.start + c.count; u < f; u++) {
        let h = u;
        o && (h = o.getX(h)), r.expandByPoint(Ic.fromBufferAttribute(l, h));
      }
      i.boxInitialized = !0;
    }
    return t.copy(r), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1)
      return null;
    const i = this._bounds[e], r = i.sphere, a = this.geometry;
    if (i.sphereInitialized === !1) {
      r.makeEmpty(), this.getBoundingBoxAt(e, Lf), Lf.getCenter(r.center);
      const o = a.index, l = a.attributes.position, c = this._drawRanges[e];
      let u = 0;
      for (let f = c.start, h = c.start + c.count; f < h; f++) {
        let d = f;
        o && (d = o.getX(d)), Ic.fromBufferAttribute(l, d), u = Math.max(u, r.center.distanceToSquared(Ic));
      }
      r.radius = Math.sqrt(u), i.sphereInitialized = !0;
    }
    return t.copy(r), t;
  }
  setMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture, r = this._matricesTexture.image.data, a = this._geometryCount;
    return e >= a || n[e] === !1 ? this : (t.toArray(r, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture.image.data, r = this._geometryCount;
    return e >= r || n[e] === !1 ? null : t.fromArray(i, e * 16);
  }
  setVisibleAt(e, t) {
    const n = this._visibility, i = this._active, r = this._geometryCount;
    return e >= r || i[e] === !1 || n[e] === t ? this : (n[e] = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, n = this._active, i = this._geometryCount;
    return e >= i || n[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const n = this._visibility, i = this._active, r = this._drawRanges, a = this._geometryCount, o = this.matrixWorld, l = this.geometry;
    Ti.material = this.material, Ti.geometry.index = l.index, Ti.geometry.attributes = l.attributes, Ti.geometry.boundingBox === null && (Ti.geometry.boundingBox = new dn()), Ti.geometry.boundingSphere === null && (Ti.geometry.boundingSphere = new Vn());
    for (let c = 0; c < a; c++) {
      if (!n[c] || !i[c])
        continue;
      const u = r[c];
      Ti.geometry.setDrawRange(u.start, u.count), this.getMatrixAt(c, Ti.matrixWorld).premultiply(o), this.getBoundingBoxAt(c, Ti.geometry.boundingBox), this.getBoundingSphereAt(c, Ti.geometry.boundingSphere), Ti.raycast(e, kf);
      for (let f = 0, h = kf.length; f < h; f++) {
        const d = kf[f];
        d.object = this, d.batchId = c, t.push(d);
      }
      kf.length = 0;
    }
    Ti.material = null, Ti.geometry.index = null, Ti.geometry.attributes = {}, Ti.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, n, i, r) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const a = i.getIndex(), o = a === null ? 1 : a.array.BYTES_PER_ELEMENT, l = this._active, c = this._visibility, u = this._multiDrawStarts, f = this._multiDrawCounts, h = this._drawRanges, d = this.perObjectFrustumCulled;
    d && (ib.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), Hp.setFromProjectionMatrix(
      ib,
      e.coordinateSystem
    ));
    let m = 0;
    if (this.sortObjects) {
      nb.copy(this.matrixWorld).invert(), Ic.setFromMatrixPosition(n.matrixWorld).applyMatrix4(nb);
      for (let A = 0, v = c.length; A < v; A++)
        if (c[A] && l[A]) {
          this.getMatrixAt(A, to), this.getBoundingSphereAt(A, zo).applyMatrix4(to);
          let y = !1;
          if (d && (y = !Hp.intersectsSphere(zo)), !y) {
            const w = Ic.distanceTo(zo.center);
            jp.push(h[A], w);
          }
        }
      const _ = jp.list, g = this.customSort;
      g === null ? _.sort(r.transparent ? NR : OR) : g.call(this, _, n);
      for (let A = 0, v = _.length; A < v; A++) {
        const y = _[A];
        u[m] = y.start * o, f[m] = y.count, m++;
      }
      jp.reset();
    } else
      for (let _ = 0, g = c.length; _ < g; _++)
        if (c[_] && l[_]) {
          let A = !1;
          if (d && (this.getMatrixAt(_, to), this.getBoundingSphereAt(_, zo).applyMatrix4(to), A = !Hp.intersectsSphere(zo)), !A) {
            const v = h[_];
            u[m] = v.start * o, f[m] = v.count, m++;
          }
        }
    this._multiDrawCount = m, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, i, r, a) {
    this.onBeforeRender(e, null, i, r, a);
  }
}
class Jn extends ii {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Je(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Kh = /* @__PURE__ */ new H(), Jh = /* @__PURE__ */ new H(), rb = /* @__PURE__ */ new st(), Tc = /* @__PURE__ */ new wa(), Uf = /* @__PURE__ */ new Vn(), Wp = /* @__PURE__ */ new H(), sb = /* @__PURE__ */ new H();
class qn extends Gt {
  constructor(e = new Dt(), t = new Jn()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let i = 1, r = t.count; i < r; i++)
        Kh.fromBufferAttribute(t, i - 1), Jh.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += Kh.distanceTo(Jh);
      e.setAttribute("lineDistance", new ht(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Uf.copy(n.boundingSphere), Uf.applyMatrix4(i), Uf.radius += r, e.ray.intersectsSphere(Uf) === !1)
      return;
    rb.copy(i).invert(), Tc.copy(e.ray).applyMatrix4(rb);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = this.isLineSegments ? 2 : 1, u = n.index, h = n.attributes.position;
    if (u !== null) {
      const d = Math.max(0, a.start), m = Math.min(u.count, a.start + a.count);
      for (let _ = d, g = m - 1; _ < g; _ += c) {
        const A = u.getX(_), v = u.getX(_ + 1), y = Ff(this, e, Tc, l, A, v);
        y && t.push(y);
      }
      if (this.isLineLoop) {
        const _ = u.getX(m - 1), g = u.getX(d), A = Ff(this, e, Tc, l, _, g);
        A && t.push(A);
      }
    } else {
      const d = Math.max(0, a.start), m = Math.min(h.count, a.start + a.count);
      for (let _ = d, g = m - 1; _ < g; _ += c) {
        const A = Ff(this, e, Tc, l, _, _ + 1);
        A && t.push(A);
      }
      if (this.isLineLoop) {
        const _ = Ff(this, e, Tc, l, m - 1, d);
        _ && t.push(_);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function Ff(s, e, t, n, i, r) {
  const a = s.geometry.attributes.position;
  if (Kh.fromBufferAttribute(a, i), Jh.fromBufferAttribute(a, r), t.distanceSqToSegment(Kh, Jh, Wp, sb) > n)
    return;
  Wp.applyMatrix4(s.matrixWorld);
  const l = e.ray.origin.distanceTo(Wp);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: sb.clone().applyMatrix4(s.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: s
    };
}
const ob = /* @__PURE__ */ new H(), ab = /* @__PURE__ */ new H();
class zr extends qn {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let i = 0, r = t.count; i < r; i += 2)
        ob.fromBufferAttribute(t, i), ab.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + ob.distanceTo(ab);
      e.setAttribute("lineDistance", new ht(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class wA extends qn {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class vd extends ii {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Je(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const lb = /* @__PURE__ */ new st(), Eg = /* @__PURE__ */ new wa(), Of = /* @__PURE__ */ new Vn(), Nf = /* @__PURE__ */ new H();
class EA extends Gt {
  constructor(e = new Dt(), t = new vd()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Of.copy(n.boundingSphere), Of.applyMatrix4(i), Of.radius += r, e.ray.intersectsSphere(Of) === !1)
      return;
    lb.copy(i).invert(), Eg.copy(e.ray).applyMatrix4(lb);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = n.index, f = n.attributes.position;
    if (c !== null) {
      const h = Math.max(0, a.start), d = Math.min(c.count, a.start + a.count);
      for (let m = h, _ = d; m < _; m++) {
        const g = c.getX(m);
        Nf.fromBufferAttribute(f, g), cb(Nf, g, l, i, e, t, this);
      }
    } else {
      const h = Math.max(0, a.start), d = Math.min(f.count, a.start + a.count);
      for (let m = h, _ = d; m < _; m++)
        Nf.fromBufferAttribute(f, m), cb(Nf, m, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function cb(s, e, t, n, i, r, a) {
  const o = Eg.distanceSqToPoint(s);
  if (o < t) {
    const l = new H();
    Eg.closestPointToPoint(s, l), l.applyMatrix4(n);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far)
      return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a
    });
  }
}
class $R extends wn {
  constructor(e, t, n, i, r, a, o, l, c) {
    super(e, t, n, i, r, a, o, l, c), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Yt, this.magFilter = r !== void 0 ? r : Yt, this.generateMipmaps = !1;
    const u = this;
    function f() {
      u.needsUpdate = !0, e.requestVideoFrameCallback(f);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(f);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class VR extends wn {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = nn, this.minFilter = nn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class ec extends wn {
  constructor(e, t, n, i, r, a, o, l, c, u, f, h) {
    super(null, a, o, l, c, u, i, r, f, h), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Hx extends ec {
  constructor(e, t, n, i, r, a) {
    super(e, t, n, r, a), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = yi;
  }
}
class jx extends ec {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, as), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class Wx extends wn {
  constructor(e, t, n, i, r, a, o, l, c) {
    super(e, t, n, i, r, a, o, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class $r {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, i = this.getPoint(0), r = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      n = this.getPoint(a / e), r += n.distanceTo(i), t.push(r), i = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let a;
    t ? a = t : a = e * n[r - 1];
    let o = 0, l = r - 1, c;
    for (; o <= l; )
      if (i = Math.floor(o + (l - o) / 2), c = n[i] - a, c < 0)
        o = i + 1;
      else if (c > 0)
        l = i - 1;
      else {
        l = i;
        break;
      }
    if (i = l, n[i] === a)
      return i / (r - 1);
    const u = n[i], h = n[i + 1] - u, d = (a - u) / h;
    return (i + d) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, r = e + 1e-4;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const a = this.getPoint(i), o = this.getPoint(r), l = t || (a.isVector2 ? new ke() : new H());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new H(), i = [], r = [], a = [], o = new H(), l = new st();
    for (let d = 0; d <= e; d++) {
      const m = d / e;
      i[d] = this.getTangentAt(m, new H());
    }
    r[0] = new H(), a[0] = new H();
    let c = Number.MAX_VALUE;
    const u = Math.abs(i[0].x), f = Math.abs(i[0].y), h = Math.abs(i[0].z);
    u <= c && (c = u, n.set(1, 0, 0)), f <= c && (c = f, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), a[0].crossVectors(i[0], r[0]);
    for (let d = 1; d <= e; d++) {
      if (r[d] = r[d - 1].clone(), a[d] = a[d - 1].clone(), o.crossVectors(i[d - 1], i[d]), o.length() > Number.EPSILON) {
        o.normalize();
        const m = Math.acos(Fn(i[d - 1].dot(i[d]), -1, 1));
        r[d].applyMatrix4(l.makeRotationAxis(o, m));
      }
      a[d].crossVectors(i[d], r[d]);
    }
    if (t === !0) {
      let d = Math.acos(Fn(r[0].dot(r[e]), -1, 1));
      d /= e, i[0].dot(o.crossVectors(r[0], r[e])) > 0 && (d = -d);
      for (let m = 1; m <= e; m++)
        r[m].applyMatrix4(l.makeRotationAxis(i[m], d * m)), a[m].crossVectors(i[m], r[m]);
    }
    return {
      tangents: i,
      normals: r,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class yd extends $r {
  constructor(e = 0, t = 0, n = 1, i = 1, r = 0, a = Math.PI * 2, o = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
  }
  getPoint(e, t = new ke()) {
    const n = t, i = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(r) < Number.EPSILON;
    for (; r < 0; )
      r += i;
    for (; r > i; )
      r -= i;
    r < Number.EPSILON && (a ? r = 0 : r = i), this.aClockwise === !0 && !a && (r === i ? r = -i : r = r - i);
    const o = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), f = Math.sin(this.aRotation), h = l - this.aX, d = c - this.aY;
      l = h * u - d * f + this.aX, c = h * f + d * u + this.aY;
    }
    return n.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class qx extends yd {
  constructor(e, t, n, i, r, a) {
    super(e, t, n, n, i, r, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function CA() {
  let s = 0, e = 0, t = 0, n = 0;
  function i(r, a, o, l) {
    s = r, e = o, t = -3 * r + 3 * a - 2 * o - l, n = 2 * r - 2 * a + o + l;
  }
  return {
    initCatmullRom: function(r, a, o, l, c) {
      i(a, o, c * (o - r), c * (l - a));
    },
    initNonuniformCatmullRom: function(r, a, o, l, c, u, f) {
      let h = (a - r) / c - (o - r) / (c + u) + (o - a) / u, d = (o - a) / u - (l - a) / (u + f) + (l - o) / f;
      h *= u, d *= u, i(a, o, h, d);
    },
    calc: function(r) {
      const a = r * r, o = a * r;
      return s + e * r + t * a + n * o;
    }
  };
}
const Gf = /* @__PURE__ */ new H(), qp = /* @__PURE__ */ new CA(), Xp = /* @__PURE__ */ new CA(), Yp = /* @__PURE__ */ new CA();
class Xx extends $r {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
  }
  getPoint(e, t = new H()) {
    const n = t, i = this.points, r = i.length, a = (r - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a), l = a - o;
    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : l === 0 && o === r - 1 && (o = r - 2, l = 1);
    let c, u;
    this.closed || o > 0 ? c = i[(o - 1) % r] : (Gf.subVectors(i[0], i[1]).add(i[0]), c = Gf);
    const f = i[o % r], h = i[(o + 1) % r];
    if (this.closed || o + 2 < r ? u = i[(o + 2) % r] : (Gf.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), u = Gf), this.curveType === "centripetal" || this.curveType === "chordal") {
      const d = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(f), d), _ = Math.pow(f.distanceToSquared(h), d), g = Math.pow(h.distanceToSquared(u), d);
      _ < 1e-4 && (_ = 1), m < 1e-4 && (m = _), g < 1e-4 && (g = _), qp.initNonuniformCatmullRom(c.x, f.x, h.x, u.x, m, _, g), Xp.initNonuniformCatmullRom(c.y, f.y, h.y, u.y, m, _, g), Yp.initNonuniformCatmullRom(c.z, f.z, h.z, u.z, m, _, g);
    } else
      this.curveType === "catmullrom" && (qp.initCatmullRom(c.x, f.x, h.x, u.x, this.tension), Xp.initCatmullRom(c.y, f.y, h.y, u.y, this.tension), Yp.initCatmullRom(c.z, f.z, h.z, u.z, this.tension));
    return n.set(
      qp.calc(l),
      Xp.calc(l),
      Yp.calc(l)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new H().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function ub(s, e, t, n, i) {
  const r = (n - e) * 0.5, a = (i - t) * 0.5, o = s * s, l = s * o;
  return (2 * t - 2 * n + r + a) * l + (-3 * t + 3 * n - 2 * r - a) * o + r * s + t;
}
function HR(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function jR(s, e) {
  return 2 * (1 - s) * s * e;
}
function WR(s, e) {
  return s * s * e;
}
function nu(s, e, t, n) {
  return HR(s, e) + jR(s, t) + WR(s, n);
}
function qR(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function XR(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function YR(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function KR(s, e) {
  return s * s * s * e;
}
function iu(s, e, t, n, i) {
  return qR(s, e) + XR(s, t) + YR(s, n) + KR(s, i);
}
class SA extends $r {
  constructor(e = new ke(), t = new ke(), n = new ke(), i = new ke()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new ke()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return n.set(
      iu(e, i.x, r.x, a.x, o.x),
      iu(e, i.y, r.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Yx extends $r {
  constructor(e = new H(), t = new H(), n = new H(), i = new H()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new H()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return n.set(
      iu(e, i.x, r.x, a.x, o.x),
      iu(e, i.y, r.y, a.y, o.y),
      iu(e, i.z, r.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class MA extends $r {
  constructor(e = new ke(), t = new ke()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new ke()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ke()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Kx extends $r {
  constructor(e = new H(), t = new H()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new H()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new H()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class IA extends $r {
  constructor(e = new ke(), t = new ke(), n = new ke()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new ke()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2;
    return n.set(
      nu(e, i.x, r.x, a.x),
      nu(e, i.y, r.y, a.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class TA extends $r {
  constructor(e = new H(), t = new H(), n = new H()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new H()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2;
    return n.set(
      nu(e, i.x, r.x, a.x),
      nu(e, i.y, r.y, a.y),
      nu(e, i.z, r.z, a.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class BA extends $r {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new ke()) {
    const n = t, i = this.points, r = (i.length - 1) * e, a = Math.floor(r), o = r - a, l = i[a === 0 ? a : a - 1], c = i[a], u = i[a > i.length - 2 ? i.length - 1 : a + 1], f = i[a > i.length - 3 ? i.length - 1 : a + 2];
    return n.set(
      ub(o, l.x, c.x, u.x, f.x),
      ub(o, l.y, c.y, u.y, f.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new ke().fromArray(i));
    }
    return this;
  }
}
var Zh = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: qx,
  CatmullRomCurve3: Xx,
  CubicBezierCurve: SA,
  CubicBezierCurve3: Yx,
  EllipseCurve: yd,
  LineCurve: MA,
  LineCurve3: Kx,
  QuadraticBezierCurve: IA,
  QuadraticBezierCurve3: TA,
  SplineCurve: BA
});
class Jx extends $r {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Zh[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const a = i[r] - n, o = this.curves[r], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, t);
      }
      r++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const a = r[i], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        n && n.equals(u) || (t.push(u), n = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new Zh[i.type]().fromJSON(i));
    }
    return this;
  }
}
class yu extends Jx {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new ke(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new MA(this.currentPoint.clone(), new ke(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const r = new IA(
      this.currentPoint.clone(),
      new ke(e, t),
      new ke(n, i)
    );
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, a) {
    const o = new SA(
      this.currentPoint.clone(),
      new ke(e, t),
      new ke(n, i),
      new ke(r, a)
    );
    return this.curves.push(o), this.currentPoint.set(r, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new BA(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, r, a) {
    const o = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + o,
      t + l,
      n,
      i,
      r,
      a
    ), this;
  }
  absarc(e, t, n, i, r, a) {
    return this.absellipse(e, t, n, n, i, r, a), this;
  }
  ellipse(e, t, n, i, r, a, o, l) {
    const c = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + c, t + u, n, i, r, a, o, l), this;
  }
  absellipse(e, t, n, i, r, a, o, l) {
    const c = new yd(e, t, n, i, r, a, o, l);
    if (this.curves.length > 0) {
      const f = c.getPoint(0);
      f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Ou extends Dt {
  constructor(e = [new ke(0, -0.5), new ke(0.5, 0), new ke(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: i
    }, t = Math.floor(t), i = Fn(i, 0, Math.PI * 2);
    const r = [], a = [], o = [], l = [], c = [], u = 1 / t, f = new H(), h = new ke(), d = new H(), m = new H(), _ = new H();
    let g = 0, A = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          g = e[v + 1].x - e[v].x, A = e[v + 1].y - e[v].y, d.x = A * 1, d.y = -g, d.z = A * 0, _.copy(d), d.normalize(), l.push(d.x, d.y, d.z);
          break;
        case e.length - 1:
          l.push(_.x, _.y, _.z);
          break;
        default:
          g = e[v + 1].x - e[v].x, A = e[v + 1].y - e[v].y, d.x = A * 1, d.y = -g, d.z = A * 0, m.copy(d), d.x += _.x, d.y += _.y, d.z += _.z, d.normalize(), l.push(d.x, d.y, d.z), _.copy(m);
      }
    for (let v = 0; v <= t; v++) {
      const y = n + v * u * i, w = Math.sin(y), E = Math.cos(y);
      for (let I = 0; I <= e.length - 1; I++) {
        f.x = e[I].x * w, f.y = e[I].y, f.z = e[I].x * E, a.push(f.x, f.y, f.z), h.x = v / t, h.y = I / (e.length - 1), o.push(h.x, h.y);
        const C = l[3 * I + 0] * w, B = l[3 * I + 1], T = l[3 * I + 0] * E;
        c.push(C, B, T);
      }
    }
    for (let v = 0; v < t; v++)
      for (let y = 0; y < e.length - 1; y++) {
        const w = y + v * e.length, E = w, I = w + e.length, C = w + e.length + 1, B = w + 1;
        r.push(E, I, B), r.push(C, B, I);
      }
    this.setIndex(r), this.setAttribute("position", new ht(a, 3)), this.setAttribute("uv", new ht(o, 2)), this.setAttribute("normal", new ht(c, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ou(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Nu extends Ou {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const r = new yu();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new Nu(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class xd extends Dt {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: i
    }, t = Math.max(3, t);
    const r = [], a = [], o = [], l = [], c = new H(), u = new ke();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let f = 0, h = 3; f <= t; f++, h += 3) {
      const d = n + f / t * i;
      c.x = e * Math.cos(d), c.y = e * Math.sin(d), a.push(c.x, c.y, c.z), o.push(0, 0, 1), u.x = (a[h] / e + 1) / 2, u.y = (a[h + 1] / e + 1) / 2, l.push(u.x, u.y);
    }
    for (let f = 1; f <= t; f++)
      r.push(f, f + 1, 0);
    this.setIndex(r), this.setAttribute("position", new ht(a, 3)), this.setAttribute("normal", new ht(o, 3)), this.setAttribute("uv", new ht(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new xd(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Wn extends Dt {
  constructor(e = 1, t = 1, n = 1, i = 32, r = 1, a = !1, o = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: a,
      thetaStart: o,
      thetaLength: l
    };
    const c = this;
    i = Math.floor(i), r = Math.floor(r);
    const u = [], f = [], h = [], d = [];
    let m = 0;
    const _ = [], g = n / 2;
    let A = 0;
    v(), a === !1 && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.setAttribute("position", new ht(f, 3)), this.setAttribute("normal", new ht(h, 3)), this.setAttribute("uv", new ht(d, 2));
    function v() {
      const w = new H(), E = new H();
      let I = 0;
      const C = (t - e) / n;
      for (let B = 0; B <= r; B++) {
        const T = [], S = B / r, D = S * (t - e) + e;
        for (let R = 0; R <= i; R++) {
          const P = R / i, L = P * l + o, V = Math.sin(L), U = Math.cos(L);
          E.x = D * V, E.y = -S * n + g, E.z = D * U, f.push(E.x, E.y, E.z), w.set(V, C, U).normalize(), h.push(w.x, w.y, w.z), d.push(P, 1 - S), T.push(m++);
        }
        _.push(T);
      }
      for (let B = 0; B < i; B++)
        for (let T = 0; T < r; T++) {
          const S = _[T][B], D = _[T + 1][B], R = _[T + 1][B + 1], P = _[T][B + 1];
          u.push(S, D, P), u.push(D, R, P), I += 6;
        }
      c.addGroup(A, I, 0), A += I;
    }
    function y(w) {
      const E = m, I = new ke(), C = new H();
      let B = 0;
      const T = w === !0 ? e : t, S = w === !0 ? 1 : -1;
      for (let R = 1; R <= i; R++)
        f.push(0, g * S, 0), h.push(0, S, 0), d.push(0.5, 0.5), m++;
      const D = m;
      for (let R = 0; R <= i; R++) {
        const L = R / i * l + o, V = Math.cos(L), U = Math.sin(L);
        C.x = T * U, C.y = g * S, C.z = T * V, f.push(C.x, C.y, C.z), h.push(0, S, 0), I.x = V * 0.5 + 0.5, I.y = U * 0.5 * S + 0.5, d.push(I.x, I.y), m++;
      }
      for (let R = 0; R < i; R++) {
        const P = E + R, L = D + R;
        w === !0 ? u.push(L, L + 1, P) : u.push(L + 1, L, P), B += 3;
      }
      c.addGroup(A, B, w === !0 ? 1 : 2), A += B;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class wd extends Wn {
  constructor(e = 1, t = 1, n = 32, i = 1, r = !1, a = 0, o = Math.PI * 2) {
    super(0, e, t, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: a,
      thetaLength: o
    };
  }
  static fromJSON(e) {
    return new wd(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class xo extends Dt {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: i
    };
    const r = [], a = [];
    o(i), c(n), u(), this.setAttribute("position", new ht(r, 3)), this.setAttribute("normal", new ht(r.slice(), 3)), this.setAttribute("uv", new ht(a, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(v) {
      const y = new H(), w = new H(), E = new H();
      for (let I = 0; I < t.length; I += 3)
        d(t[I + 0], y), d(t[I + 1], w), d(t[I + 2], E), l(y, w, E, v);
    }
    function l(v, y, w, E) {
      const I = E + 1, C = [];
      for (let B = 0; B <= I; B++) {
        C[B] = [];
        const T = v.clone().lerp(w, B / I), S = y.clone().lerp(w, B / I), D = I - B;
        for (let R = 0; R <= D; R++)
          R === 0 && B === I ? C[B][R] = T : C[B][R] = T.clone().lerp(S, R / D);
      }
      for (let B = 0; B < I; B++)
        for (let T = 0; T < 2 * (I - B) - 1; T++) {
          const S = Math.floor(T / 2);
          T % 2 === 0 ? (h(C[B][S + 1]), h(C[B + 1][S]), h(C[B][S])) : (h(C[B][S + 1]), h(C[B + 1][S + 1]), h(C[B + 1][S]));
        }
    }
    function c(v) {
      const y = new H();
      for (let w = 0; w < r.length; w += 3)
        y.x = r[w + 0], y.y = r[w + 1], y.z = r[w + 2], y.normalize().multiplyScalar(v), r[w + 0] = y.x, r[w + 1] = y.y, r[w + 2] = y.z;
    }
    function u() {
      const v = new H();
      for (let y = 0; y < r.length; y += 3) {
        v.x = r[y + 0], v.y = r[y + 1], v.z = r[y + 2];
        const w = g(v) / 2 / Math.PI + 0.5, E = A(v) / Math.PI + 0.5;
        a.push(w, 1 - E);
      }
      m(), f();
    }
    function f() {
      for (let v = 0; v < a.length; v += 6) {
        const y = a[v + 0], w = a[v + 2], E = a[v + 4], I = Math.max(y, w, E), C = Math.min(y, w, E);
        I > 0.9 && C < 0.1 && (y < 0.2 && (a[v + 0] += 1), w < 0.2 && (a[v + 2] += 1), E < 0.2 && (a[v + 4] += 1));
      }
    }
    function h(v) {
      r.push(v.x, v.y, v.z);
    }
    function d(v, y) {
      const w = v * 3;
      y.x = e[w + 0], y.y = e[w + 1], y.z = e[w + 2];
    }
    function m() {
      const v = new H(), y = new H(), w = new H(), E = new H(), I = new ke(), C = new ke(), B = new ke();
      for (let T = 0, S = 0; T < r.length; T += 9, S += 6) {
        v.set(r[T + 0], r[T + 1], r[T + 2]), y.set(r[T + 3], r[T + 4], r[T + 5]), w.set(r[T + 6], r[T + 7], r[T + 8]), I.set(a[S + 0], a[S + 1]), C.set(a[S + 2], a[S + 3]), B.set(a[S + 4], a[S + 5]), E.copy(v).add(y).add(w).divideScalar(3);
        const D = g(E);
        _(I, S + 0, v, D), _(C, S + 2, y, D), _(B, S + 4, w, D);
      }
    }
    function _(v, y, w, E) {
      E < 0 && v.x === 1 && (a[y] = v.x - 1), w.x === 0 && w.z === 0 && (a[y] = E / 2 / Math.PI + 0.5);
    }
    function g(v) {
      return Math.atan2(v.z, -v.x);
    }
    function A(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new xo(e.vertices, e.indices, e.radius, e.details);
  }
}
class Ed extends xo {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      // (1/, , 0)
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i
    ], a = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, a, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Ed(e.radius, e.detail);
  }
}
const Qf = /* @__PURE__ */ new H(), zf = /* @__PURE__ */ new H(), Kp = /* @__PURE__ */ new H(), $f = /* @__PURE__ */ new di();
class Zx extends Dt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), r = Math.cos(da * t), a = e.getIndex(), o = e.getAttribute("position"), l = a ? a.count : o.count, c = [0, 0, 0], u = ["a", "b", "c"], f = new Array(3), h = {}, d = [];
      for (let m = 0; m < l; m += 3) {
        a ? (c[0] = a.getX(m), c[1] = a.getX(m + 1), c[2] = a.getX(m + 2)) : (c[0] = m, c[1] = m + 1, c[2] = m + 2);
        const { a: _, b: g, c: A } = $f;
        if (_.fromBufferAttribute(o, c[0]), g.fromBufferAttribute(o, c[1]), A.fromBufferAttribute(o, c[2]), $f.getNormal(Kp), f[0] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(_.z * i)}`, f[1] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(g.z * i)}`, f[2] = `${Math.round(A.x * i)},${Math.round(A.y * i)},${Math.round(A.z * i)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
          for (let v = 0; v < 3; v++) {
            const y = (v + 1) % 3, w = f[v], E = f[y], I = $f[u[v]], C = $f[u[y]], B = `${w}_${E}`, T = `${E}_${w}`;
            T in h && h[T] ? (Kp.dot(h[T].normal) <= r && (d.push(I.x, I.y, I.z), d.push(C.x, C.y, C.z)), h[T] = null) : B in h || (h[B] = {
              index0: c[v],
              index1: c[y],
              normal: Kp.clone()
            });
          }
      }
      for (const m in h)
        if (h[m]) {
          const { index0: _, index1: g } = h[m];
          Qf.fromBufferAttribute(o, _), zf.fromBufferAttribute(o, g), d.push(Qf.x, Qf.y, Qf.z), d.push(zf.x, zf.y, zf.z);
        }
      this.setAttribute("position", new ht(d, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class ho extends yu {
  constructor(e) {
    super(e), this.uuid = ur(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new yu().fromJSON(i));
    }
    return this;
  }
}
const JR = {
  triangulate: function(s, e, t = 2) {
    const n = e && e.length, i = n ? e[0] * t : s.length;
    let r = ew(s, 0, i, t, !0);
    const a = [];
    if (!r || r.next === r.prev)
      return a;
    let o, l, c, u, f, h, d;
    if (n && (r = iD(s, e, r, t)), s.length > 80 * t) {
      o = c = s[0], l = u = s[1];
      for (let m = t; m < i; m += t)
        f = s[m], h = s[m + 1], f < o && (o = f), h < l && (l = h), f > c && (c = f), h > u && (u = h);
      d = Math.max(c - o, u - l), d = d !== 0 ? 32767 / d : 0;
    }
    return xu(r, a, t, o, l, d, 0), a;
  }
};
function ew(s, e, t, n, i) {
  let r, a;
  if (i === pD(s, e, t, n) > 0)
    for (r = e; r < t; r += n)
      a = fb(r, s[r], s[r + 1], a);
  else
    for (r = t - n; r >= e; r -= n)
      a = fb(r, s[r], s[r + 1], a);
  return a && Cd(a, a.next) && (Eu(a), a = a.next), a;
}
function Aa(s, e) {
  if (!s)
    return s;
  e || (e = s);
  let t = s, n;
  do
    if (n = !1, !t.steiner && (Cd(t, t.next) || Rn(t.prev, t, t.next) === 0)) {
      if (Eu(t), t = e = t.prev, t === t.next)
        break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function xu(s, e, t, n, i, r, a) {
  if (!s)
    return;
  !a && r && lD(s, n, i, r);
  let o = s, l, c;
  for (; s.prev !== s.next; ) {
    if (l = s.prev, c = s.next, r ? eD(s, n, i, r) : ZR(s)) {
      e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), Eu(s), s = c.next, o = c.next;
      continue;
    }
    if (s = c, s === o) {
      a ? a === 1 ? (s = tD(Aa(s), e, t), xu(s, e, t, n, i, r, 2)) : a === 2 && nD(s, e, t, n, i, r) : xu(Aa(s), e, t, n, i, r, 1);
      break;
    }
  }
}
function ZR(s) {
  const e = s.prev, t = s, n = s.next;
  if (Rn(e, t, n) >= 0)
    return !1;
  const i = e.x, r = t.x, a = n.x, o = e.y, l = t.y, c = n.y, u = i < r ? i < a ? i : a : r < a ? r : a, f = o < l ? o < c ? o : c : l < c ? l : c, h = i > r ? i > a ? i : a : r > a ? r : a, d = o > l ? o > c ? o : c : l > c ? l : c;
  let m = n.next;
  for (; m !== e; ) {
    if (m.x >= u && m.x <= h && m.y >= f && m.y <= d && wl(i, o, r, l, a, c, m.x, m.y) && Rn(m.prev, m, m.next) >= 0)
      return !1;
    m = m.next;
  }
  return !0;
}
function eD(s, e, t, n) {
  const i = s.prev, r = s, a = s.next;
  if (Rn(i, r, a) >= 0)
    return !1;
  const o = i.x, l = r.x, c = a.x, u = i.y, f = r.y, h = a.y, d = o < l ? o < c ? o : c : l < c ? l : c, m = u < f ? u < h ? u : h : f < h ? f : h, _ = o > l ? o > c ? o : c : l > c ? l : c, g = u > f ? u > h ? u : h : f > h ? f : h, A = Cg(d, m, e, t, n), v = Cg(_, g, e, t, n);
  let y = s.prevZ, w = s.nextZ;
  for (; y && y.z >= A && w && w.z <= v; ) {
    if (y.x >= d && y.x <= _ && y.y >= m && y.y <= g && y !== i && y !== a && wl(o, u, l, f, c, h, y.x, y.y) && Rn(y.prev, y, y.next) >= 0 || (y = y.prevZ, w.x >= d && w.x <= _ && w.y >= m && w.y <= g && w !== i && w !== a && wl(o, u, l, f, c, h, w.x, w.y) && Rn(w.prev, w, w.next) >= 0))
      return !1;
    w = w.nextZ;
  }
  for (; y && y.z >= A; ) {
    if (y.x >= d && y.x <= _ && y.y >= m && y.y <= g && y !== i && y !== a && wl(o, u, l, f, c, h, y.x, y.y) && Rn(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; w && w.z <= v; ) {
    if (w.x >= d && w.x <= _ && w.y >= m && w.y <= g && w !== i && w !== a && wl(o, u, l, f, c, h, w.x, w.y) && Rn(w.prev, w, w.next) >= 0)
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function tD(s, e, t) {
  let n = s;
  do {
    const i = n.prev, r = n.next.next;
    !Cd(i, r) && tw(i, n, n.next, r) && wu(i, r) && wu(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), Eu(n), Eu(n.next), n = s = r), n = n.next;
  } while (n !== s);
  return Aa(n);
}
function nD(s, e, t, n, i, r) {
  let a = s;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && fD(a, o)) {
        let l = nw(a, o);
        a = Aa(a, a.next), l = Aa(l, l.next), xu(a, e, t, n, i, r, 0), xu(l, e, t, n, i, r, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== s);
}
function iD(s, e, t, n) {
  const i = [];
  let r, a, o, l, c;
  for (r = 0, a = e.length; r < a; r++)
    o = e[r] * n, l = r < a - 1 ? e[r + 1] * n : s.length, c = ew(s, o, l, n, !1), c === c.next && (c.steiner = !0), i.push(uD(c));
  for (i.sort(rD), r = 0; r < i.length; r++)
    t = sD(i[r], t);
  return t;
}
function rD(s, e) {
  return s.x - e.x;
}
function sD(s, e) {
  const t = oD(s, e);
  if (!t)
    return e;
  const n = nw(t, s);
  return Aa(n, n.next), Aa(t, t.next);
}
function oD(s, e) {
  let t = e, n = -1 / 0, i;
  const r = s.x, a = s.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const h = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (h <= r && h > n && (n = h, i = t.x < t.next.x ? t : t.next, h === r))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i)
    return null;
  const o = i, l = i.x, c = i.y;
  let u = 1 / 0, f;
  t = i;
  do
    r >= t.x && t.x >= l && r !== t.x && wl(a < c ? r : n, a, l, c, a < c ? n : r, a, t.x, t.y) && (f = Math.abs(a - t.y) / (r - t.x), wu(t, s) && (f < u || f === u && (t.x > i.x || t.x === i.x && aD(i, t))) && (i = t, u = f)), t = t.next;
  while (t !== o);
  return i;
}
function aD(s, e) {
  return Rn(s.prev, s, e.prev) < 0 && Rn(e.next, s, s.next) < 0;
}
function lD(s, e, t, n) {
  let i = s;
  do
    i.z === 0 && (i.z = Cg(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== s);
  i.prevZ.nextZ = null, i.prevZ = null, cD(i);
}
function cD(s) {
  let e, t, n, i, r, a, o, l, c = 1;
  do {
    for (t = s, s = null, r = null, a = 0; t; ) {
      for (a++, n = t, o = 0, e = 0; e < c && (o++, n = n.nextZ, !!n); e++)
        ;
      for (l = c; o > 0 || l > 0 && n; )
        o !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, o--) : (i = n, n = n.nextZ, l--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
      t = n;
    }
    r.nextZ = null, c *= 2;
  } while (a > 1);
  return s;
}
function Cg(s, e, t, n, i) {
  return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function uD(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function wl(s, e, t, n, i, r, a, o) {
  return (i - a) * (e - o) >= (s - a) * (r - o) && (s - a) * (n - o) >= (t - a) * (e - o) && (t - a) * (r - o) >= (i - a) * (n - o);
}
function fD(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !hD(s, e) && // dones't intersect other edges
  (wu(s, e) && wu(e, s) && dD(s, e) && // locally visible
  (Rn(s.prev, s, e.prev) || Rn(s, e.prev, e)) || // does not create opposite-facing sectors
  Cd(s, e) && Rn(s.prev, s, s.next) > 0 && Rn(e.prev, e, e.next) > 0);
}
function Rn(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function Cd(s, e) {
  return s.x === e.x && s.y === e.y;
}
function tw(s, e, t, n) {
  const i = Hf(Rn(s, e, t)), r = Hf(Rn(s, e, n)), a = Hf(Rn(t, n, s)), o = Hf(Rn(t, n, e));
  return !!(i !== r && a !== o || i === 0 && Vf(s, t, e) || r === 0 && Vf(s, n, e) || a === 0 && Vf(t, s, n) || o === 0 && Vf(t, e, n));
}
function Vf(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function Hf(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function hD(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && tw(t, t.next, s, e))
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function wu(s, e) {
  return Rn(s.prev, s, s.next) < 0 ? Rn(s, e, s.next) >= 0 && Rn(s, s.prev, e) >= 0 : Rn(s, e, s.prev) < 0 || Rn(s, s.next, e) < 0;
}
function dD(s, e) {
  let t = s, n = !1;
  const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== s);
  return n;
}
function nw(s, e) {
  const t = new Sg(s.i, s.x, s.y), n = new Sg(e.i, e.x, e.y), i = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
}
function fb(s, e, t, n) {
  const i = new Sg(s, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Eu(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Sg(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function pD(s, e, t, n) {
  let i = 0;
  for (let r = e, a = t - n; r < t; r += n)
    i += (s[a] - s[r]) * (s[r + 1] + s[a + 1]), a = r;
  return i;
}
class ss {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, r = 0; r < t; i = r++)
      n += e[i].x * e[r].y - e[r].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return ss.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], i = [], r = [];
    hb(e), db(n, e);
    let a = e.length;
    t.forEach(hb);
    for (let l = 0; l < t.length; l++)
      i.push(a), a += t[l].length, db(n, t[l]);
    const o = JR.triangulate(n, i);
    for (let l = 0; l < o.length; l += 3)
      r.push(o.slice(l, l + 3));
    return r;
  }
}
function hb(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function db(s, e) {
  for (let t = 0; t < e.length; t++)
    s.push(e[t].x), s.push(e[t].y);
}
class Gu extends Dt {
  constructor(e = new ho([new ke(0.5, 0.5), new ke(-0.5, 0.5), new ke(-0.5, -0.5), new ke(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, i = [], r = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      a(c);
    }
    this.setAttribute("position", new ht(i, 3)), this.setAttribute("uv", new ht(r, 2)), this.computeVertexNormals();
    function a(o) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, f = t.depth !== void 0 ? t.depth : 1;
      let h = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, d = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : d - 0.1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const A = t.extrudePath, v = t.UVGenerator !== void 0 ? t.UVGenerator : mD;
      let y, w = !1, E, I, C, B;
      A && (y = A.getSpacedPoints(u), w = !0, h = !1, E = A.computeFrenetFrames(u, !1), I = new H(), C = new H(), B = new H()), h || (g = 0, d = 0, m = 0, _ = 0);
      const T = o.extractPoints(c);
      let S = T.shape;
      const D = T.holes;
      if (!ss.isClockWise(S)) {
        S = S.reverse();
        for (let ae = 0, De = D.length; ae < De; ae++) {
          const Ee = D[ae];
          ss.isClockWise(Ee) && (D[ae] = Ee.reverse());
        }
      }
      const P = ss.triangulateShape(S, D), L = S;
      for (let ae = 0, De = D.length; ae < De; ae++) {
        const Ee = D[ae];
        S = S.concat(Ee);
      }
      function V(ae, De, Ee) {
        return De || console.error("THREE.ExtrudeGeometry: vec does not exist"), ae.clone().addScaledVector(De, Ee);
      }
      const U = S.length, Q = P.length;
      function q(ae, De, Ee) {
        let Ie, Ce, ze;
        const Fe = ae.x - De.x, W = ae.y - De.y, G = Ee.x - ae.x, se = Ee.y - ae.y, _e = Fe * Fe + W * W, ve = Fe * se - W * G;
        if (Math.abs(ve) > Number.EPSILON) {
          const ue = Math.sqrt(_e), Te = Math.sqrt(G * G + se * se), Ge = De.x - W / ue, Pe = De.y + Fe / ue, he = Ee.x - se / Te, Se = Ee.y + G / Te, Ve = ((he - Ge) * se - (Se - Pe) * G) / (Fe * se - W * G);
          Ie = Ge + Fe * Ve - ae.x, Ce = Pe + W * Ve - ae.y;
          const Ye = Ie * Ie + Ce * Ce;
          if (Ye <= 2)
            return new ke(Ie, Ce);
          ze = Math.sqrt(Ye / 2);
        } else {
          let ue = !1;
          Fe > Number.EPSILON ? G > Number.EPSILON && (ue = !0) : Fe < -Number.EPSILON ? G < -Number.EPSILON && (ue = !0) : Math.sign(W) === Math.sign(se) && (ue = !0), ue ? (Ie = -W, Ce = Fe, ze = Math.sqrt(_e)) : (Ie = Fe, Ce = W, ze = Math.sqrt(_e / 2));
        }
        return new ke(Ie / ze, Ce / ze);
      }
      const oe = [];
      for (let ae = 0, De = L.length, Ee = De - 1, Ie = ae + 1; ae < De; ae++, Ee++, Ie++)
        Ee === De && (Ee = 0), Ie === De && (Ie = 0), oe[ae] = q(L[ae], L[Ee], L[Ie]);
      const le = [];
      let k, X = oe.concat();
      for (let ae = 0, De = D.length; ae < De; ae++) {
        const Ee = D[ae];
        k = [];
        for (let Ie = 0, Ce = Ee.length, ze = Ce - 1, Fe = Ie + 1; Ie < Ce; Ie++, ze++, Fe++)
          ze === Ce && (ze = 0), Fe === Ce && (Fe = 0), k[Ie] = q(Ee[Ie], Ee[ze], Ee[Fe]);
        le.push(k), X = X.concat(k);
      }
      for (let ae = 0; ae < g; ae++) {
        const De = ae / g, Ee = d * Math.cos(De * Math.PI / 2), Ie = m * Math.sin(De * Math.PI / 2) + _;
        for (let Ce = 0, ze = L.length; Ce < ze; Ce++) {
          const Fe = V(L[Ce], oe[Ce], Ie);
          Y(Fe.x, Fe.y, -Ee);
        }
        for (let Ce = 0, ze = D.length; Ce < ze; Ce++) {
          const Fe = D[Ce];
          k = le[Ce];
          for (let W = 0, G = Fe.length; W < G; W++) {
            const se = V(Fe[W], k[W], Ie);
            Y(se.x, se.y, -Ee);
          }
        }
      }
      const fe = m + _;
      for (let ae = 0; ae < U; ae++) {
        const De = h ? V(S[ae], X[ae], fe) : S[ae];
        w ? (C.copy(E.normals[0]).multiplyScalar(De.x), I.copy(E.binormals[0]).multiplyScalar(De.y), B.copy(y[0]).add(C).add(I), Y(B.x, B.y, B.z)) : Y(De.x, De.y, 0);
      }
      for (let ae = 1; ae <= u; ae++)
        for (let De = 0; De < U; De++) {
          const Ee = h ? V(S[De], X[De], fe) : S[De];
          w ? (C.copy(E.normals[ae]).multiplyScalar(Ee.x), I.copy(E.binormals[ae]).multiplyScalar(Ee.y), B.copy(y[ae]).add(C).add(I), Y(B.x, B.y, B.z)) : Y(Ee.x, Ee.y, f / u * ae);
        }
      for (let ae = g - 1; ae >= 0; ae--) {
        const De = ae / g, Ee = d * Math.cos(De * Math.PI / 2), Ie = m * Math.sin(De * Math.PI / 2) + _;
        for (let Ce = 0, ze = L.length; Ce < ze; Ce++) {
          const Fe = V(L[Ce], oe[Ce], Ie);
          Y(Fe.x, Fe.y, f + Ee);
        }
        for (let Ce = 0, ze = D.length; Ce < ze; Ce++) {
          const Fe = D[Ce];
          k = le[Ce];
          for (let W = 0, G = Fe.length; W < G; W++) {
            const se = V(Fe[W], k[W], Ie);
            w ? Y(se.x, se.y + y[u - 1].y, y[u - 1].x + Ee) : Y(se.x, se.y, f + Ee);
          }
        }
      }
      te(), j();
      function te() {
        const ae = i.length / 3;
        if (h) {
          let De = 0, Ee = U * De;
          for (let Ie = 0; Ie < Q; Ie++) {
            const Ce = P[Ie];
            pe(Ce[2] + Ee, Ce[1] + Ee, Ce[0] + Ee);
          }
          De = u + g * 2, Ee = U * De;
          for (let Ie = 0; Ie < Q; Ie++) {
            const Ce = P[Ie];
            pe(Ce[0] + Ee, Ce[1] + Ee, Ce[2] + Ee);
          }
        } else {
          for (let De = 0; De < Q; De++) {
            const Ee = P[De];
            pe(Ee[2], Ee[1], Ee[0]);
          }
          for (let De = 0; De < Q; De++) {
            const Ee = P[De];
            pe(Ee[0] + U * u, Ee[1] + U * u, Ee[2] + U * u);
          }
        }
        n.addGroup(ae, i.length / 3 - ae, 0);
      }
      function j() {
        const ae = i.length / 3;
        let De = 0;
        Ae(L, De), De += L.length;
        for (let Ee = 0, Ie = D.length; Ee < Ie; Ee++) {
          const Ce = D[Ee];
          Ae(Ce, De), De += Ce.length;
        }
        n.addGroup(ae, i.length / 3 - ae, 1);
      }
      function Ae(ae, De) {
        let Ee = ae.length;
        for (; --Ee >= 0; ) {
          const Ie = Ee;
          let Ce = Ee - 1;
          Ce < 0 && (Ce = ae.length - 1);
          for (let ze = 0, Fe = u + g * 2; ze < Fe; ze++) {
            const W = U * ze, G = U * (ze + 1), se = De + Ie + W, _e = De + Ce + W, ve = De + Ce + G, ue = De + Ie + G;
            me(se, _e, ve, ue);
          }
        }
      }
      function Y(ae, De, Ee) {
        l.push(ae), l.push(De), l.push(Ee);
      }
      function pe(ae, De, Ee) {
        re(ae), re(De), re(Ee);
        const Ie = i.length / 3, Ce = v.generateTopUV(n, i, Ie - 3, Ie - 2, Ie - 1);
        ye(Ce[0]), ye(Ce[1]), ye(Ce[2]);
      }
      function me(ae, De, Ee, Ie) {
        re(ae), re(De), re(Ie), re(De), re(Ee), re(Ie);
        const Ce = i.length / 3, ze = v.generateSideWallUV(n, i, Ce - 6, Ce - 3, Ce - 2, Ce - 1);
        ye(ze[0]), ye(ze[1]), ye(ze[3]), ye(ze[1]), ye(ze[2]), ye(ze[3]);
      }
      function re(ae) {
        i.push(l[ae * 3 + 0]), i.push(l[ae * 3 + 1]), i.push(l[ae * 3 + 2]);
      }
      function ye(ae) {
        r.push(ae.x), r.push(ae.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return gD(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, a = e.shapes.length; r < a; r++) {
      const o = t[e.shapes[r]];
      n.push(o);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new Zh[i.type]().fromJSON(i)), new Gu(n, e.options);
  }
}
const mD = {
  generateTopUV: function(s, e, t, n, i) {
    const r = e[t * 3], a = e[t * 3 + 1], o = e[n * 3], l = e[n * 3 + 1], c = e[i * 3], u = e[i * 3 + 1];
    return [
      new ke(r, a),
      new ke(o, l),
      new ke(c, u)
    ];
  },
  generateSideWallUV: function(s, e, t, n, i, r) {
    const a = e[t * 3], o = e[t * 3 + 1], l = e[t * 3 + 2], c = e[n * 3], u = e[n * 3 + 1], f = e[n * 3 + 2], h = e[i * 3], d = e[i * 3 + 1], m = e[i * 3 + 2], _ = e[r * 3], g = e[r * 3 + 1], A = e[r * 3 + 2];
    return Math.abs(o - u) < Math.abs(a - c) ? [
      new ke(a, 1 - l),
      new ke(c, 1 - f),
      new ke(h, 1 - m),
      new ke(_, 1 - A)
    ] : [
      new ke(o, 1 - l),
      new ke(u, 1 - f),
      new ke(d, 1 - m),
      new ke(g, 1 - A)
    ];
  }
};
function gD(s, e, t) {
  if (t.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Sd extends xo {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Sd(e.radius, e.detail);
  }
}
class Bs extends xo {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Bs(e.radius, e.detail);
  }
}
class Md extends Dt {
  constructor(e = 0.5, t = 1, n = 32, i = 1, r = 0, a = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: a
    }, n = Math.max(3, n), i = Math.max(1, i);
    const o = [], l = [], c = [], u = [];
    let f = e;
    const h = (t - e) / i, d = new H(), m = new ke();
    for (let _ = 0; _ <= i; _++) {
      for (let g = 0; g <= n; g++) {
        const A = r + g / n * a;
        d.x = f * Math.cos(A), d.y = f * Math.sin(A), l.push(d.x, d.y, d.z), c.push(0, 0, 1), m.x = (d.x / t + 1) / 2, m.y = (d.y / t + 1) / 2, u.push(m.x, m.y);
      }
      f += h;
    }
    for (let _ = 0; _ < i; _++) {
      const g = _ * (n + 1);
      for (let A = 0; A < n; A++) {
        const v = A + g, y = v, w = v + n + 1, E = v + n + 2, I = v + 1;
        o.push(y, w, I), o.push(w, E, I);
      }
    }
    this.setIndex(o), this.setAttribute("position", new ht(l, 3)), this.setAttribute("normal", new ht(c, 3)), this.setAttribute("uv", new ht(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Md(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Id extends Dt {
  constructor(e = new ho([new ke(0, 0.5), new ke(-0.5, -0.5), new ke(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], i = [], r = [], a = [];
    let o = 0, l = 0;
    if (Array.isArray(e) === !1)
      c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(o, l, u), o += l, l = 0;
    this.setIndex(n), this.setAttribute("position", new ht(i, 3)), this.setAttribute("normal", new ht(r, 3)), this.setAttribute("uv", new ht(a, 2));
    function c(u) {
      const f = i.length / 3, h = u.extractPoints(t);
      let d = h.shape;
      const m = h.holes;
      ss.isClockWise(d) === !1 && (d = d.reverse());
      for (let g = 0, A = m.length; g < A; g++) {
        const v = m[g];
        ss.isClockWise(v) === !0 && (m[g] = v.reverse());
      }
      const _ = ss.triangulateShape(d, m);
      for (let g = 0, A = m.length; g < A; g++) {
        const v = m[g];
        d = d.concat(v);
      }
      for (let g = 0, A = d.length; g < A; g++) {
        const v = d[g];
        i.push(v.x, v.y, 0), r.push(0, 0, 1), a.push(v.x, v.y);
      }
      for (let g = 0, A = _.length; g < A; g++) {
        const v = _[g], y = v[0] + f, w = v[1] + f, E = v[2] + f;
        n.push(y, w, E), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return AD(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, r = e.shapes.length; i < r; i++) {
      const a = t[e.shapes[i]];
      n.push(a);
    }
    return new Id(n, e.curveSegments);
  }
}
function AD(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class tc extends Dt {
  constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: a,
      thetaLength: o
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const u = [], f = new H(), h = new H(), d = [], m = [], _ = [], g = [];
    for (let A = 0; A <= n; A++) {
      const v = [], y = A / n;
      let w = 0;
      A === 0 && a === 0 ? w = 0.5 / t : A === n && l === Math.PI && (w = -0.5 / t);
      for (let E = 0; E <= t; E++) {
        const I = E / t;
        f.x = -e * Math.cos(i + I * r) * Math.sin(a + y * o), f.y = e * Math.cos(a + y * o), f.z = e * Math.sin(i + I * r) * Math.sin(a + y * o), m.push(f.x, f.y, f.z), h.copy(f).normalize(), _.push(h.x, h.y, h.z), g.push(I + w, 1 - y), v.push(c++);
      }
      u.push(v);
    }
    for (let A = 0; A < n; A++)
      for (let v = 0; v < t; v++) {
        const y = u[A][v + 1], w = u[A][v], E = u[A + 1][v], I = u[A + 1][v + 1];
        (A !== 0 || a > 0) && d.push(y, w, I), (A !== n - 1 || l < Math.PI) && d.push(w, E, I);
      }
    this.setIndex(d), this.setAttribute("position", new ht(m, 3)), this.setAttribute("normal", new ht(_, 3)), this.setAttribute("uv", new ht(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new tc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Td extends xo {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Td(e.radius, e.detail);
  }
}
class Ms extends Dt {
  constructor(e = 1, t = 0.4, n = 12, i = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: i,
      arc: r
    }, n = Math.floor(n), i = Math.floor(i);
    const a = [], o = [], l = [], c = [], u = new H(), f = new H(), h = new H();
    for (let d = 0; d <= n; d++)
      for (let m = 0; m <= i; m++) {
        const _ = m / i * r, g = d / n * Math.PI * 2;
        f.x = (e + t * Math.cos(g)) * Math.cos(_), f.y = (e + t * Math.cos(g)) * Math.sin(_), f.z = t * Math.sin(g), o.push(f.x, f.y, f.z), u.x = e * Math.cos(_), u.y = e * Math.sin(_), h.subVectors(f, u).normalize(), l.push(h.x, h.y, h.z), c.push(m / i), c.push(d / n);
      }
    for (let d = 1; d <= n; d++)
      for (let m = 1; m <= i; m++) {
        const _ = (i + 1) * d + m - 1, g = (i + 1) * (d - 1) + m - 1, A = (i + 1) * (d - 1) + m, v = (i + 1) * d + m;
        a.push(_, g, v), a.push(g, A, v);
      }
    this.setIndex(a), this.setAttribute("position", new ht(o, 3)), this.setAttribute("normal", new ht(l, 3)), this.setAttribute("uv", new ht(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ms(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Bd extends Dt {
  constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: a
    }, n = Math.floor(n), i = Math.floor(i);
    const o = [], l = [], c = [], u = [], f = new H(), h = new H(), d = new H(), m = new H(), _ = new H(), g = new H(), A = new H();
    for (let y = 0; y <= n; ++y) {
      const w = y / n * r * Math.PI * 2;
      v(w, r, a, e, d), v(w + 0.01, r, a, e, m), g.subVectors(m, d), A.addVectors(m, d), _.crossVectors(g, A), A.crossVectors(_, g), _.normalize(), A.normalize();
      for (let E = 0; E <= i; ++E) {
        const I = E / i * Math.PI * 2, C = -t * Math.cos(I), B = t * Math.sin(I);
        f.x = d.x + (C * A.x + B * _.x), f.y = d.y + (C * A.y + B * _.y), f.z = d.z + (C * A.z + B * _.z), l.push(f.x, f.y, f.z), h.subVectors(f, d).normalize(), c.push(h.x, h.y, h.z), u.push(y / n), u.push(E / i);
      }
    }
    for (let y = 1; y <= n; y++)
      for (let w = 1; w <= i; w++) {
        const E = (i + 1) * (y - 1) + (w - 1), I = (i + 1) * y + (w - 1), C = (i + 1) * y + w, B = (i + 1) * (y - 1) + w;
        o.push(E, I, B), o.push(I, C, B);
      }
    this.setIndex(o), this.setAttribute("position", new ht(l, 3)), this.setAttribute("normal", new ht(c, 3)), this.setAttribute("uv", new ht(u, 2));
    function v(y, w, E, I, C) {
      const B = Math.cos(y), T = Math.sin(y), S = E / w * y, D = Math.cos(S);
      C.x = I * (2 + D) * 0.5 * B, C.y = I * (2 + D) * T * 0.5, C.z = I * Math.sin(S) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Bd(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Pd extends Dt {
  constructor(e = new TA(new H(-1, -1, 0), new H(-1, 1, 0), new H(1, 1, 0)), t = 64, n = 1, i = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: i,
      closed: r
    };
    const a = e.computeFrenetFrames(t, r);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new H(), l = new H(), c = new ke();
    let u = new H();
    const f = [], h = [], d = [], m = [];
    _(), this.setIndex(m), this.setAttribute("position", new ht(f, 3)), this.setAttribute("normal", new ht(h, 3)), this.setAttribute("uv", new ht(d, 2));
    function _() {
      for (let y = 0; y < t; y++)
        g(y);
      g(r === !1 ? t : 0), v(), A();
    }
    function g(y) {
      u = e.getPointAt(y / t, u);
      const w = a.normals[y], E = a.binormals[y];
      for (let I = 0; I <= i; I++) {
        const C = I / i * Math.PI * 2, B = Math.sin(C), T = -Math.cos(C);
        l.x = T * w.x + B * E.x, l.y = T * w.y + B * E.y, l.z = T * w.z + B * E.z, l.normalize(), h.push(l.x, l.y, l.z), o.x = u.x + n * l.x, o.y = u.y + n * l.y, o.z = u.z + n * l.z, f.push(o.x, o.y, o.z);
      }
    }
    function A() {
      for (let y = 1; y <= t; y++)
        for (let w = 1; w <= i; w++) {
          const E = (i + 1) * (y - 1) + (w - 1), I = (i + 1) * y + (w - 1), C = (i + 1) * y + w, B = (i + 1) * (y - 1) + w;
          m.push(E, I, B), m.push(I, C, B);
        }
    }
    function v() {
      for (let y = 0; y <= t; y++)
        for (let w = 0; w <= i; w++)
          c.x = y / t, c.y = w / i, d.push(c.x, c.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Pd(
      new Zh[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class iw extends Dt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), i = new H(), r = new H();
      if (e.index !== null) {
        const a = e.attributes.position, o = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const f = l[c], h = f.start, d = f.count;
          for (let m = h, _ = h + d; m < _; m += 3)
            for (let g = 0; g < 3; g++) {
              const A = o.getX(m + g), v = o.getX(m + (g + 1) % 3);
              i.fromBufferAttribute(a, A), r.fromBufferAttribute(a, v), pb(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * o + c, f = 3 * o + (c + 1) % 3;
            i.fromBufferAttribute(a, u), r.fromBufferAttribute(a, f), pb(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new ht(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function pb(s, e, t) {
  const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var mb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Pn,
  CapsuleGeometry: Nu,
  CircleGeometry: xd,
  ConeGeometry: wd,
  CylinderGeometry: Wn,
  DodecahedronGeometry: Ed,
  EdgesGeometry: Zx,
  ExtrudeGeometry: Gu,
  IcosahedronGeometry: Sd,
  LatheGeometry: Ou,
  OctahedronGeometry: Bs,
  PlaneGeometry: Fi,
  PolyhedronGeometry: xo,
  RingGeometry: Md,
  ShapeGeometry: Id,
  SphereGeometry: tc,
  TetrahedronGeometry: Td,
  TorusGeometry: Ms,
  TorusKnotGeometry: Bd,
  TubeGeometry: Pd,
  WireframeGeometry: iw
});
class rw extends ii {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Je(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class sw extends Hn {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class Qu extends ii {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Je(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ui(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class wr extends Qu {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ke(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Fn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Je(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Je(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Je(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class ow extends ii {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Je(16777215), this.specular = new Je(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ui(), this.combine = Pu, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class aw extends ii {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Je(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class lw extends ii {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class cw extends ii {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ui(), this.combine = Pu, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class uw extends ii {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Je(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = vo, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class fw extends Jn {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function ua(s, e, t) {
  return !s || // let 'undefined' and 'null' pass
  !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
}
function hw(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function dw(s) {
  function e(i, r) {
    return s[i] - s[r];
  }
  const t = s.length, n = new Array(t);
  for (let i = 0; i !== t; ++i)
    n[i] = i;
  return n.sort(e), n;
}
function Mg(s, e, t) {
  const n = s.length, i = new s.constructor(n);
  for (let r = 0, a = 0; a !== n; ++r) {
    const o = t[r] * e;
    for (let l = 0; l !== e; ++l)
      i[a++] = s[o + l];
  }
  return i;
}
function PA(s, e, t, n) {
  let i = 1, r = s[0];
  for (; r !== void 0 && r[n] === void 0; )
    r = s[i++];
  if (r === void 0)
    return;
  let a = r[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push.apply(t, a)), r = s[i++];
      while (r !== void 0);
    else if (a.toArray !== void 0)
      do
        a = r[n], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = s[i++];
      while (r !== void 0);
    else
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push(a)), r = s[i++];
      while (r !== void 0);
}
function _D(s, e, t, n, i = 30) {
  const r = s.clone();
  r.name = e;
  const a = [];
  for (let l = 0; l < r.tracks.length; ++l) {
    const c = r.tracks[l], u = c.getValueSize(), f = [], h = [];
    for (let d = 0; d < c.times.length; ++d) {
      const m = c.times[d] * i;
      if (!(m < t || m >= n)) {
        f.push(c.times[d]);
        for (let _ = 0; _ < u; ++_)
          h.push(c.values[d * u + _]);
      }
    }
    f.length !== 0 && (c.times = ua(f, c.times.constructor), c.values = ua(h, c.values.constructor), a.push(c));
  }
  r.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < r.tracks.length; ++l)
    o > r.tracks[l].times[0] && (o = r.tracks[l].times[0]);
  for (let l = 0; l < r.tracks.length; ++l)
    r.tracks[l].shift(-1 * o);
  return r.resetDuration(), r;
}
function bD(s, e = 0, t = s, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length, r = e / n;
  for (let a = 0; a < i; ++a) {
    const o = t.tracks[a], l = o.ValueTypeName;
    if (l === "bool" || l === "string")
      continue;
    const c = s.tracks.find(function(A) {
      return A.name === o.name && A.ValueTypeName === l;
    });
    if (c === void 0)
      continue;
    let u = 0;
    const f = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = f / 3);
    let h = 0;
    const d = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
    const m = o.times.length - 1;
    let _;
    if (r <= o.times[0]) {
      const A = u, v = f - u;
      _ = o.values.slice(A, v);
    } else if (r >= o.times[m]) {
      const A = m * f + u, v = A + f - u;
      _ = o.values.slice(A, v);
    } else {
      const A = o.createInterpolant(), v = u, y = f - u;
      A.evaluate(r), _ = A.resultBuffer.slice(v, y);
    }
    l === "quaternion" && new en().fromArray(_).normalize().conjugate().toArray(_);
    const g = c.times.length;
    for (let A = 0; A < g; ++A) {
      const v = A * d + h;
      if (l === "quaternion")
        en.multiplyQuaternionsFlat(
          c.values,
          v,
          _,
          0,
          c.values,
          v
        );
      else {
        const y = d - h * 2;
        for (let w = 0; w < y; ++w)
          c.values[v + w] -= _[w];
      }
    }
  }
  return s.blendMode = hA, s;
}
const vD = {
  convertArray: ua,
  isTypedArray: hw,
  getKeyframeOrder: dw,
  sortedArray: Mg,
  flattenJSON: PA,
  subclip: _D,
  makeClipAdditive: bD
};
class nc {
  constructor(e, t, n, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, i = t[n], r = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          i:
            if (!(e < i)) {
              for (let o = n + 2; ; ) {
                if (i === void 0) {
                  if (e < r)
                    break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === o)
                  break;
                if (r = i, i = t[++n], e < i)
                  break t;
              }
              a = t.length;
              break n;
            }
          if (!(e >= r)) {
            const o = t[1];
            e < o && (n = 2, r = o);
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l)
                break;
              if (i = r, r = t[--n - 1], e >= r)
                break t;
            }
            a = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < a; ) {
          const o = n + a >>> 1;
          e < t[o] ? a = o : n = o + 1;
        }
        if (i = t[n], r = t[n - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
    for (let a = 0; a !== i; ++a)
      t[a] = n[r + a];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class pw extends nc {
  constructor(e, t, n, i) {
    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: aa,
      endingEnd: aa
    };
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2, a = e + 1, o = i[r], l = i[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case la:
          r = e, o = 2 * t - n;
          break;
        case pu:
          r = i.length - 2, o = t + i[r] - i[r + 1];
          break;
        default:
          r = e, o = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case la:
          a = e, l = 2 * n - t;
          break;
        case pu:
          a = 1, l = n + i[1] - i[0];
          break;
        default:
          a = e - 1, l = t;
      }
    const c = (n - t) * 0.5, u = this.valueSize;
    this._weightPrev = c / (t - o), this._weightNext = c / (l - n), this._offsetPrev = r * u, this._offsetNext = a * u;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, u = this._offsetPrev, f = this._offsetNext, h = this._weightPrev, d = this._weightNext, m = (n - t) / (i - t), _ = m * m, g = _ * m, A = -h * g + 2 * h * _ - h * m, v = (1 + h) * g + (-1.5 - 2 * h) * _ + (-0.5 + h) * m + 1, y = (-1 - d) * g + (1.5 + d) * _ + 0.5 * m, w = d * g - d * _;
    for (let E = 0; E !== o; ++E)
      r[E] = A * a[u + E] + v * a[c + E] + y * a[l + E] + w * a[f + E];
    return r;
  }
}
class RA extends nc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, u = (n - t) / (i - t), f = 1 - u;
    for (let h = 0; h !== o; ++h)
      r[h] = a[c + h] * f + a[l + h] * u;
    return r;
  }
}
class mw extends nc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Vr {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = ua(t, this.TimeBufferType), this.values = ua(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: ua(e.times, Array),
        values: ua(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new mw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new RA(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new pw(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Nl:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ga:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Ih:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Nl;
      case this.InterpolantFactoryMethodLinear:
        return ga;
      case this.InterpolantFactoryMethodSmooth:
        return Ih;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, i = n.length;
    let r = 0, a = i - 1;
    for (; r !== i && n[r] < e; )
      ++r;
    for (; a !== -1 && n[a] > t; )
      --a;
    if (++a, r !== 0 || a !== i) {
      r >= a && (a = Math.max(a, 1), r = a - 1);
      const o = this.getValueSize();
      this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, i = this.values, r = n.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let o = 0; o !== r; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1;
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1;
        break;
      }
      a = l;
    }
    if (i !== void 0 && hw(i))
      for (let o = 0, l = i.length; o !== l; ++o) {
        const c = i[o];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === Ih, r = e.length - 1;
    let a = 1;
    for (let o = 1; o < r; ++o) {
      let l = !1;
      const c = e[o], u = e[o + 1];
      if (c !== u && (o !== 1 || c !== e[0]))
        if (i)
          l = !0;
        else {
          const f = o * n, h = f - n, d = f + n;
          for (let m = 0; m !== n; ++m) {
            const _ = t[f + m];
            if (_ !== t[h + m] || _ !== t[d + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const f = o * n, h = a * n;
          for (let d = 0; d !== n; ++d)
            t[h + d] = t[f + d];
        }
        ++a;
      }
    }
    if (r > 0) {
      e[a] = e[r];
      for (let o = r * n, l = a * n, c = 0; c !== n; ++c)
        t[l + c] = t[o + c];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Vr.prototype.TimeBufferType = Float32Array;
Vr.prototype.ValueBufferType = Float32Array;
Vr.prototype.DefaultInterpolation = ga;
class Ca extends Vr {
}
Ca.prototype.ValueTypeName = "bool";
Ca.prototype.ValueBufferType = Array;
Ca.prototype.DefaultInterpolation = Nl;
Ca.prototype.InterpolantFactoryMethodLinear = void 0;
Ca.prototype.InterpolantFactoryMethodSmooth = void 0;
class DA extends Vr {
}
DA.prototype.ValueTypeName = "color";
class _a extends Vr {
}
_a.prototype.ValueTypeName = "number";
class gw extends nc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (n - t) / (i - t);
    let c = e * o;
    for (let u = c + o; c !== u; c += 4)
      en.slerpFlat(r, 0, a, c - o, a, c, l);
    return r;
  }
}
class _o extends Vr {
  InterpolantFactoryMethodLinear(e) {
    return new gw(this.times, this.values, this.getValueSize(), e);
  }
}
_o.prototype.ValueTypeName = "quaternion";
_o.prototype.DefaultInterpolation = ga;
_o.prototype.InterpolantFactoryMethodSmooth = void 0;
class Sa extends Vr {
}
Sa.prototype.ValueTypeName = "string";
Sa.prototype.ValueBufferType = Array;
Sa.prototype.DefaultInterpolation = Nl;
Sa.prototype.InterpolantFactoryMethodLinear = void 0;
Sa.prototype.InterpolantFactoryMethodSmooth = void 0;
class ba extends Vr {
}
ba.prototype.ValueTypeName = "vector";
class zl {
  constructor(e = "", t = -1, n = [], i = ud) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = ur(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, i = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a)
      t.push(xD(n[a]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, a = n.length; r !== a; ++r)
      t.push(Vr.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length, a = [];
    for (let o = 0; o < r; o++) {
      let l = [], c = [];
      l.push(
        (o + r - 1) % r,
        o,
        (o + 1) % r
      ), c.push(0, 1, 0);
      const u = dw(l);
      l = Mg(l, 1, u), c = Mg(c, 1, u), !i && l[0] === 0 && (l.push(r), c.push(c[0])), a.push(
        new _a(
          ".morphTargetInfluences[" + t[o].name + "]",
          l,
          c
        ).scale(1 / n)
      );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], u = c.name.match(r);
      if (u && u.length > 1) {
        const f = u[1];
        let h = i[f];
        h || (i[f] = h = []), h.push(c);
      }
    }
    const a = [];
    for (const o in i)
      a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
    return a;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(f, h, d, m, _) {
      if (d.length !== 0) {
        const g = [], A = [];
        PA(d, g, A, m), g.length !== 0 && _.push(new f(h, g, A));
      }
    }, i = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let f = 0; f < c.length; f++) {
      const h = c[f].keys;
      if (!(!h || h.length === 0))
        if (h[0].morphTargets) {
          const d = {};
          let m;
          for (m = 0; m < h.length; m++)
            if (h[m].morphTargets)
              for (let _ = 0; _ < h[m].morphTargets.length; _++)
                d[h[m].morphTargets[_]] = -1;
          for (const _ in d) {
            const g = [], A = [];
            for (let v = 0; v !== h[m].morphTargets.length; ++v) {
              const y = h[m];
              g.push(y.time), A.push(y.morphTarget === _ ? 1 : 0);
            }
            i.push(new _a(".morphTargetInfluence[" + _ + "]", g, A));
          }
          l = d.length * a;
        } else {
          const d = ".bones[" + t[f].name + "]";
          n(
            ba,
            d + ".position",
            h,
            "pos",
            i
          ), n(
            _o,
            d + ".quaternion",
            h,
            "rot",
            i
          ), n(
            ba,
            d + ".scale",
            h,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(r, l, i, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function yD(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return _a;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ba;
    case "color":
      return DA;
    case "quaternion":
      return _o;
    case "bool":
    case "boolean":
      return Ca;
    case "string":
      return Sa;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function xD(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = yD(s.type);
  if (s.times === void 0) {
    const t = [], n = [];
    PA(s.keys, t, n, "value"), s.times = t, s.values = n;
  }
  return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
}
const Ps = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class LA {
  constructor(e, t, n) {
    const i = this;
    let r = !1, a = 0, o = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
      o++, r === !1 && i.onStart !== void 0 && i.onStart(u, a, o), r = !0;
    }, this.itemEnd = function(u) {
      a++, i.onProgress !== void 0 && i.onProgress(u, a, o), a === o && (r = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(u) {
      i.onError !== void 0 && i.onError(u);
    }, this.resolveURL = function(u) {
      return l ? l(u) : u;
    }, this.setURLModifier = function(u) {
      return l = u, this;
    }, this.addHandler = function(u, f) {
      return c.push(u, f), this;
    }, this.removeHandler = function(u) {
      const f = c.indexOf(u);
      return f !== -1 && c.splice(f, 2), this;
    }, this.getHandler = function(u) {
      for (let f = 0, h = c.length; f < h; f += 2) {
        const d = c[f], m = c[f + 1];
        if (d.global && (d.lastIndex = 0), d.test(u))
          return m;
      }
      return null;
    };
  }
}
const Aw = /* @__PURE__ */ new LA();
class ai {
  constructor(e) {
    this.manager = e !== void 0 ? e : Aw, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
ai.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const xs = {};
class wD extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class ri extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = Ps.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (xs[e] !== void 0) {
      xs[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      return;
    }
    xs[e] = [], xs[e].push({
      onLoad: t,
      onProgress: n,
      onError: i
    });
    const a = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), o = this.mimeType, l = this.responseType;
    fetch(a).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const u = xs[e], f = c.body.getReader(), h = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), d = h ? parseInt(h) : 0, m = d !== 0;
        let _ = 0;
        const g = new ReadableStream({
          start(A) {
            v();
            function v() {
              f.read().then(({ done: y, value: w }) => {
                if (y)
                  A.close();
                else {
                  _ += w.byteLength;
                  const E = new ProgressEvent("progress", { lengthComputable: m, loaded: _, total: d });
                  for (let I = 0, C = u.length; I < C; I++) {
                    const B = u[I];
                    B.onProgress && B.onProgress(E);
                  }
                  A.enqueue(w), v();
                }
              });
            }
          }
        });
        return new Response(g);
      } else
        throw new wD(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((u) => new DOMParser().parseFromString(u, o));
        case "json":
          return c.json();
        default:
          if (o === void 0)
            return c.text();
          {
            const f = /charset="?([^;"\s]*)"?/i.exec(o), h = f && f[1] ? f[1].toLowerCase() : void 0, d = new TextDecoder(h);
            return c.arrayBuffer().then((m) => d.decode(m));
          }
      }
    }).then((c) => {
      Ps.add(e, c);
      const u = xs[e];
      delete xs[e];
      for (let f = 0, h = u.length; f < h; f++) {
        const d = u[f];
        d.onLoad && d.onLoad(c);
      }
    }).catch((c) => {
      const u = xs[e];
      if (u === void 0)
        throw this.manager.itemError(e), c;
      delete xs[e];
      for (let f = 0, h = u.length; f < h; f++) {
        const d = u[f];
        d.onError && d.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class ED extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new ri(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = zl.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class CD extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = [], o = new ec(), l = new ri(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
    let c = 0;
    function u(f) {
      l.load(e[f], function(h) {
        const d = r.parse(h, !0);
        a[f] = {
          width: d.width,
          height: d.height,
          format: d.format,
          mipmaps: d.mipmaps
        }, c += 1, c === 6 && (d.mipmapCount === 1 && (o.minFilter = Yt), o.image = a, o.format = d.format, o.needsUpdate = !0, t && t(o));
      }, n, i);
    }
    if (Array.isArray(e))
      for (let f = 0, h = e.length; f < h; ++f)
        u(f);
    else
      l.load(e, function(f) {
        const h = r.parse(f, !0);
        if (h.isCubemap) {
          const d = h.mipmaps.length / h.mipmapCount;
          for (let m = 0; m < d; m++) {
            a[m] = { mipmaps: [] };
            for (let _ = 0; _ < h.mipmapCount; _++)
              a[m].mipmaps.push(h.mipmaps[m * h.mipmapCount + _]), a[m].format = h.format, a[m].width = h.width, a[m].height = h.height;
          }
          o.image = a;
        } else
          o.image.width = h.width, o.image.height = h.height, o.mipmaps = h.mipmaps;
        h.mipmapCount === 1 && (o.minFilter = Yt), o.format = h.format, o.needsUpdate = !0, t && t(o);
      }, n, i);
    return o;
  }
}
class Cu extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = Ps.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    const o = vu("img");
    function l() {
      u(), Ps.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(f) {
      u(), i && i(f), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function u() {
      o.removeEventListener("load", l, !1), o.removeEventListener("error", c, !1);
    }
    return o.addEventListener("load", l, !1), o.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
  }
}
class _w extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new Xl();
    r.colorSpace = Qn;
    const a = new Cu(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let o = 0;
    function l(c) {
      a.load(e[c], function(u) {
        r.images[c] = u, o++, o === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, i);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return r;
  }
}
class bw extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new Di(), o = new ri(this.manager);
    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(e, function(l) {
      let c;
      try {
        c = r.parse(l);
      } catch (u) {
        if (i !== void 0)
          i(u);
        else {
          console.error(u);
          return;
        }
      }
      c.image !== void 0 ? a.image = c.image : c.data !== void 0 && (a.image.width = c.width, a.image.height = c.height, a.image.data = c.data), a.wrapS = c.wrapS !== void 0 ? c.wrapS : yi, a.wrapT = c.wrapT !== void 0 ? c.wrapT : yi, a.magFilter = c.magFilter !== void 0 ? c.magFilter : Yt, a.minFilter = c.minFilter !== void 0 ? c.minFilter : Yt, a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 && (a.colorSpace = c.colorSpace), c.flipY !== void 0 && (a.flipY = c.flipY), c.format !== void 0 && (a.format = c.format), c.type !== void 0 && (a.type = c.type), c.mipmaps !== void 0 && (a.mipmaps = c.mipmaps, a.minFilter = Yi), c.mipmapCount === 1 && (a.minFilter = Yt), c.generateMipmaps !== void 0 && (a.generateMipmaps = c.generateMipmaps), a.needsUpdate = !0, t && t(a, c);
    }, n, i), a;
  }
}
class Su extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new wn(), a = new Cu(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
    }, n, i), r;
  }
}
class wo extends Gt {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Je(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class vw extends wo {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Gt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Je(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Jp = /* @__PURE__ */ new st(), gb = /* @__PURE__ */ new H(), Ab = /* @__PURE__ */ new H();
class kA {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new st(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ku(), this._frameExtents = new ke(1, 1), this._viewportCount = 1, this._viewports = [
      new Xt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    gb.setFromMatrixPosition(e.matrixWorld), t.position.copy(gb), Ab.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Ab), t.updateMatrixWorld(), Jp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Jp), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(Jp);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class SD extends kA {
  constructor() {
    super(new ni(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = Gl * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class UA extends wo {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Gt.DEFAULT_UP), this.updateMatrix(), this.target = new Gt(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new SD();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const _b = /* @__PURE__ */ new st(), Bc = /* @__PURE__ */ new H(), Zp = /* @__PURE__ */ new H();
class MD extends kA {
  constructor() {
    super(new ni(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ke(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Xt(2, 1, 1, 1),
      // negative X
      new Xt(0, 1, 1, 1),
      // positive Z
      new Xt(3, 1, 1, 1),
      // negative Z
      new Xt(1, 1, 1, 1),
      // positive Y
      new Xt(3, 0, 1, 1),
      // negative Y
      new Xt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new H(1, 0, 0),
      new H(-1, 0, 0),
      new H(0, 0, 1),
      new H(0, 0, -1),
      new H(0, 1, 0),
      new H(0, -1, 0)
    ], this._cubeUps = [
      new H(0, 1, 0),
      new H(0, 1, 0),
      new H(0, 1, 0),
      new H(0, 1, 0),
      new H(0, 0, 1),
      new H(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), Bc.setFromMatrixPosition(e.matrixWorld), n.position.copy(Bc), Zp.copy(n.position), Zp.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Zp), n.updateMatrixWorld(), i.makeTranslation(-Bc.x, -Bc.y, -Bc.z), _b.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_b);
  }
}
class FA extends wo {
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new MD();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class ID extends kA {
  constructor() {
    super(new yo(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class Rd extends wo {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Gt.DEFAULT_UP), this.updateMatrix(), this.target = new Gt(), this.shadow = new ID();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class yw extends wo {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class xw extends wo {
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class ww {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new H());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, i = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * i), t.addScaledVector(a[2], 0.488603 * r), t.addScaledVector(a[3], 0.488603 * n), t.addScaledVector(a[4], 1.092548 * (n * i)), t.addScaledVector(a[5], 1.092548 * (i * r)), t.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(a[7], 1.092548 * (n * r)), t.addScaledVector(a[8], 0.546274 * (n * n - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 2 * 0.511664 * i), t.addScaledVector(a[2], 2 * 0.511664 * r), t.addScaledVector(a[3], 2 * 0.511664 * n), t.addScaledVector(a[4], 2 * 0.429043 * n * i), t.addScaledVector(a[5], 2 * 0.429043 * i * r), t.addScaledVector(a[6], 0.743125 * r * r - 0.247708), t.addScaledVector(a[7], 2 * 0.429043 * n * r), t.addScaledVector(a[8], 0.429043 * (n * n - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - i * i);
  }
}
class Ew extends wo {
  constructor(e = new ww(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Dd extends ai {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, i) {
    const r = this, a = new ri(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = this.textures;
    function n(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const i = Dd.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Je().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const a = e.uniforms[r];
        switch (i.uniforms[r] = {}, a.type) {
          case "t":
            i.uniforms[r].value = n(a.value);
            break;
          case "c":
            i.uniforms[r].value = new Je().setHex(a.value);
            break;
          case "v2":
            i.uniforms[r].value = new ke().fromArray(a.value);
            break;
          case "v3":
            i.uniforms[r].value = new H().fromArray(a.value);
            break;
          case "v4":
            i.uniforms[r].value = new Xt().fromArray(a.value);
            break;
          case "m3":
            i.uniforms[r].value = new Ot().fromArray(a.value);
            break;
          case "m4":
            i.uniforms[r].value = new st().fromArray(a.value);
            break;
          default:
            i.uniforms[r].value = a.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const r in e.extensions)
        i.extensions[r] = e.extensions[r];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), i.normalScale = new ke().fromArray(r);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new ke().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: rw,
      SpriteMaterial: Ad,
      RawShaderMaterial: sw,
      ShaderMaterial: Hn,
      PointsMaterial: vd,
      MeshPhysicalMaterial: wr,
      MeshStandardMaterial: Qu,
      MeshPhongMaterial: ow,
      MeshToonMaterial: aw,
      MeshNormalMaterial: lw,
      MeshLambertMaterial: cw,
      MeshDepthMaterial: Ea,
      MeshDistanceMaterial: Kl,
      MeshBasicMaterial: $n,
      MeshMatcapMaterial: uw,
      LineDashedMaterial: fw,
      LineBasicMaterial: Jn,
      Material: ii
    };
    return new t[e]();
  }
}
class po {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class Ld extends Dt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class Cw extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new ri(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = {}, n = {};
    function i(d, m) {
      if (t[m] !== void 0)
        return t[m];
      const g = d.interleavedBuffers[m], A = r(d, g.buffer), v = yl(g.type, A), y = new Uu(v, g.stride);
      return y.uuid = g.uuid, t[m] = y, y;
    }
    function r(d, m) {
      if (n[m] !== void 0)
        return n[m];
      const g = d.arrayBuffers[m], A = new Uint32Array(g).buffer;
      return n[m] = A, A;
    }
    const a = e.isInstancedBufferGeometry ? new Ld() : new Dt(), o = e.data.index;
    if (o !== void 0) {
      const d = yl(o.type, o.array);
      a.setIndex(new Rt(d, 1));
    }
    const l = e.data.attributes;
    for (const d in l) {
      const m = l[d];
      let _;
      if (m.isInterleavedBufferAttribute) {
        const g = i(e.data, m.data);
        _ = new Ao(g, m.itemSize, m.offset, m.normalized);
      } else {
        const g = yl(m.type, m.array), A = m.isInstancedBufferAttribute ? cs : Rt;
        _ = new A(g, m.itemSize, m.normalized);
      }
      m.name !== void 0 && (_.name = m.name), m.usage !== void 0 && _.setUsage(m.usage), a.setAttribute(d, _);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const d in c) {
        const m = c[d], _ = [];
        for (let g = 0, A = m.length; g < A; g++) {
          const v = m[g];
          let y;
          if (v.isInterleavedBufferAttribute) {
            const w = i(e.data, v.data);
            y = new Ao(w, v.itemSize, v.offset, v.normalized);
          } else {
            const w = yl(v.type, v.array);
            y = new Rt(w, v.itemSize, v.normalized);
          }
          v.name !== void 0 && (y.name = v.name), _.push(y);
        }
        a.morphAttributes[d] = _;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const f = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (f !== void 0)
      for (let d = 0, m = f.length; d !== m; ++d) {
        const _ = f[d];
        a.addGroup(_.start, _.count, _.materialIndex);
      }
    const h = e.data.boundingSphere;
    if (h !== void 0) {
      const d = new H();
      h.center !== void 0 && d.fromArray(h.center), a.boundingSphere = new Vn(d, h.radius);
    }
    return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a;
  }
}
class TD extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = this.path === "" ? po.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const o = new ri(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      let c = null;
      try {
        c = JSON.parse(l);
      } catch (f) {
        i !== void 0 && i(f), console.error("THREE:ObjectLoader: Can't parse " + e + ".", f.message);
        return;
      }
      const u = c.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(c, t);
    }, n, i);
  }
  async loadAsync(e, t) {
    const n = this, i = this.path === "" ? po.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const r = new ri(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const a = await r.loadAsync(e, t), o = JSON.parse(a), l = o.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(o);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), a = this.parseImages(e.images, function() {
      t !== void 0 && t(c);
    }), o = this.parseTextures(e.textures, a), l = this.parseMaterials(e.materials, o), c = this.parseObject(e.object, r, l, o, n), u = this.parseSkeletons(e.skeletons, c);
    if (this.bindSkeletons(c, u), t !== void 0) {
      let f = !1;
      for (const h in a)
        if (a[h].data instanceof HTMLImageElement) {
          f = !0;
          break;
        }
      f === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), a = this.parseTextures(e.textures, r), o = this.parseMaterials(e.materials, a), l = this.parseObject(e.object, i, o, a, t), c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const r = new ho().fromJSON(e[n]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, i = {};
    if (t.traverse(function(r) {
      r.isBone && (i[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = new Fu().fromJSON(e[r], i);
        n[o.uuid] = o;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new Cw();
      for (let r = 0, a = e.length; r < a; r++) {
        let o;
        const l = e[r];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            o = i.parse(l);
            break;
          default:
            l.type in mb ? o = mb[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        o.uuid = l.uuid, l.name !== void 0 && (o.name = l.name), l.userData !== void 0 && (o.userData = l.userData), n[l.uuid] = o;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, i = {};
    if (e !== void 0) {
      const r = new Dd();
      r.setTextures(t);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a];
        n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)), i[l.uuid] = n[l.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n], r = zl.parse(i);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, i = {};
    let r;
    function a(l) {
      return n.manager.itemStart(l), r.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function o(l) {
      if (typeof l == "string") {
        const c = l, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
        return a(u);
      } else
        return l.data ? {
          data: yl(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new LA(t);
      r = new Cu(l), r.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const f = e[c], h = f.url;
        if (Array.isArray(h)) {
          const d = [];
          for (let m = 0, _ = h.length; m < _; m++) {
            const g = h[m], A = o(g);
            A !== null && (A instanceof HTMLImageElement ? d.push(A) : d.push(new Di(A.data, A.width, A.height)));
          }
          i[f.uuid] = new ca(d);
        } else {
          const d = o(f.url);
          i[f.uuid] = new ca(d);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let i;
    async function r(a) {
      if (typeof a == "string") {
        const o = a, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
        return await i.loadAsync(l);
      } else
        return a.data ? {
          data: yl(a.type, a.data),
          width: a.width,
          height: a.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new Cu(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a], c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let f = 0, h = c.length; f < h; f++) {
            const d = c[f], m = await r(d);
            m !== null && (m instanceof HTMLImageElement ? u.push(m) : u.push(new Di(m.data, m.width, m.height)));
          }
          n[l.uuid] = new ca(u);
        } else {
          const u = await r(l.url);
          n[l.uuid] = new ca(u);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(r, a) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), a[r]);
    }
    const i = {};
    if (e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = e[r];
        o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), t[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image);
        const l = t[o.image], c = l.data;
        let u;
        Array.isArray(c) ? (u = new Xl(), c.length === 6 && (u.needsUpdate = !0)) : (c && c.data ? u = new Di() : u = new wn(), c && (u.needsUpdate = !0)), u.source = l, u.uuid = o.uuid, o.name !== void 0 && (u.name = o.name), o.mapping !== void 0 && (u.mapping = n(o.mapping, BD)), o.channel !== void 0 && (u.channel = o.channel), o.offset !== void 0 && u.offset.fromArray(o.offset), o.repeat !== void 0 && u.repeat.fromArray(o.repeat), o.center !== void 0 && u.center.fromArray(o.center), o.rotation !== void 0 && (u.rotation = o.rotation), o.wrap !== void 0 && (u.wrapS = n(o.wrap[0], bb), u.wrapT = n(o.wrap[1], bb)), o.format !== void 0 && (u.format = o.format), o.internalFormat !== void 0 && (u.internalFormat = o.internalFormat), o.type !== void 0 && (u.type = o.type), o.colorSpace !== void 0 && (u.colorSpace = o.colorSpace), o.minFilter !== void 0 && (u.minFilter = n(o.minFilter, vb)), o.magFilter !== void 0 && (u.magFilter = n(o.magFilter, vb)), o.anisotropy !== void 0 && (u.anisotropy = o.anisotropy), o.flipY !== void 0 && (u.flipY = o.flipY), o.generateMipmaps !== void 0 && (u.generateMipmaps = o.generateMipmaps), o.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (u.unpackAlignment = o.unpackAlignment), o.compareFunction !== void 0 && (u.compareFunction = o.compareFunction), o.userData !== void 0 && (u.userData = o.userData), i[o.uuid] = u;
      }
    return i;
  }
  parseObject(e, t, n, i, r) {
    let a;
    function o(h) {
      return t[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", h), t[h];
    }
    function l(h) {
      if (h !== void 0) {
        if (Array.isArray(h)) {
          const d = [];
          for (let m = 0, _ = h.length; m < _; m++) {
            const g = h[m];
            n[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), d.push(n[g]);
          }
          return d;
        }
        return n[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", h), n[h];
      }
    }
    function c(h) {
      return i[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", h), i[h];
    }
    let u, f;
    switch (e.type) {
      case "Scene":
        a = new Jl(), e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new Je(e.background) : a.background = c(e.background)), e.environment !== void 0 && (a.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new gd(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new md(e.fog.color, e.fog.density)), e.fog.name !== "" && (a.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && a.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (a.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && a.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        a = new ni(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (a.focus = e.focus), e.zoom !== void 0 && (a.zoom = e.zoom), e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        a = new yo(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (a.zoom = e.zoom), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new yw(e.color, e.intensity);
        break;
      case "DirectionalLight":
        a = new Rd(e.color, e.intensity);
        break;
      case "PointLight":
        a = new FA(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new xw(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        a = new UA(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        a = new vw(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new Ew().fromJSON(e);
        break;
      case "SkinnedMesh":
        u = o(e.geometry), f = l(e.material), a = new _d(u, f), e.bindMode !== void 0 && (a.bindMode = e.bindMode), e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        u = o(e.geometry), f = l(e.material), a = new tt(u, f);
        break;
      case "InstancedMesh":
        u = o(e.geometry), f = l(e.material);
        const h = e.count, d = e.instanceMatrix, m = e.instanceColor;
        a = new Zl(u, f, h), a.instanceMatrix = new cs(new Float32Array(d.array), 16), m !== void 0 && (a.instanceColor = new cs(new Float32Array(m.array), m.itemSize));
        break;
      case "BatchedMesh":
        u = o(e.geometry), f = l(e.material), a = new Vx(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, f), a.geometry = u, a.perObjectFrustumCulled = e.perObjectFrustumCulled, a.sortObjects = e.sortObjects, a._drawRanges = e.drawRanges, a._reservedRanges = e.reservedRanges, a._visibility = e.visibility, a._active = e.active, a._bounds = e.bounds.map((_) => {
          const g = new dn();
          g.min.fromArray(_.boxMin), g.max.fromArray(_.boxMax);
          const A = new Vn();
          return A.radius = _.sphereRadius, A.center.fromArray(_.sphereCenter), {
            boxInitialized: _.boxInitialized,
            box: g,
            sphereInitialized: _.sphereInitialized,
            sphere: A
          };
        }), a._maxGeometryCount = e.maxGeometryCount, a._maxVertexCount = e.maxVertexCount, a._maxIndexCount = e.maxIndexCount, a._geometryInitialized = e.geometryInitialized, a._geometryCount = e.geometryCount, a._matricesTexture = c(e.matricesTexture.uuid);
        break;
      case "LOD":
        a = new $x();
        break;
      case "Line":
        a = new qn(o(e.geometry), l(e.material));
        break;
      case "LineLoop":
        a = new wA(o(e.geometry), l(e.material));
        break;
      case "LineSegments":
        a = new zr(o(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new EA(o(e.geometry), l(e.material));
        break;
      case "Sprite":
        a = new zx(l(e.material));
        break;
      case "Group":
        a = new Xn();
        break;
      case "Bone":
        a = new bd();
        break;
      default:
        a = new Gt();
    }
    if (a.uuid = e.uuid, e.name !== void 0 && (a.name = e.name), e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position), e.rotation !== void 0 && a.rotation.fromArray(e.rotation), e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion), e.scale !== void 0 && a.scale.fromArray(e.scale)), e.up !== void 0 && a.up.fromArray(e.up), e.castShadow !== void 0 && (a.castShadow = e.castShadow), e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (a.visible = e.visible), e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder), e.userData !== void 0 && (a.userData = e.userData), e.layers !== void 0 && (a.layers.mask = e.layers), e.children !== void 0) {
      const h = e.children;
      for (let d = 0; d < h.length; d++)
        a.add(this.parseObject(h[d], t, n, i, r));
    }
    if (e.animations !== void 0) {
      const h = e.animations;
      for (let d = 0; d < h.length; d++) {
        const m = h[d];
        a.animations.push(r[m]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const h = e.levels;
      for (let d = 0; d < h.length; d++) {
        const m = h[d], _ = a.getObjectByProperty("uuid", m.object);
        _ !== void 0 && a.addLevel(_, m.distance, m.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const i = t[n.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
      }
    });
  }
}
const BD = {
  UVMapping: od,
  CubeReflectionMapping: as,
  CubeRefractionMapping: go,
  EquirectangularReflectionMapping: kl,
  EquirectangularRefractionMapping: hu,
  CubeUVReflectionMapping: Vl
}, bb = {
  RepeatWrapping: Or,
  ClampToEdgeWrapping: yi,
  MirroredRepeatWrapping: Ul
}, vb = {
  NearestFilter: nn,
  NearestMipmapNearestFilter: ad,
  NearestMipmapLinearFilter: oa,
  LinearFilter: Yt,
  LinearMipmapNearestFilter: Tl,
  LinearMipmapLinearFilter: Yi
};
class Sw extends ai {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = Ps.get(e);
    if (a !== void 0) {
      if (r.manager.itemStart(e), a.then) {
        a.then((c) => {
          t && t(c), r.manager.itemEnd(e);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    }
    const o = {};
    o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
    const l = fetch(e, o).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      return Ps.add(e, c), t && t(c), r.manager.itemEnd(e), c;
    }).catch(function(c) {
      i && i(c), Ps.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
    });
    Ps.add(e, l), r.manager.itemStart(e);
  }
}
let jf;
class OA {
  static getContext() {
    return jf === void 0 && (jf = new (window.AudioContext || window.webkitAudioContext)()), jf;
  }
  static setContext(e) {
    jf = e;
  }
}
class Mw extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new ri(this.manager);
    a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      try {
        const c = l.slice(0);
        OA.getContext().decodeAudioData(c, function(f) {
          t(f);
        }).catch(o);
      } catch (c) {
        o(c);
      }
    }, n, i);
    function o(l) {
      i ? i(l) : console.error(l), r.manager.itemError(e);
    }
  }
}
const yb = /* @__PURE__ */ new st(), xb = /* @__PURE__ */ new st(), $o = /* @__PURE__ */ new st();
class PD {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ni(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ni(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, $o.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, r = i * t.near / t.focus, a = t.near * Math.tan(da * t.fov * 0.5) / t.zoom;
      let o, l;
      xb.elements[12] = -i, yb.elements[12] = i, o = -a * t.aspect + r, l = a * t.aspect + r, $o.elements[0] = 2 * t.near / (l - o), $o.elements[8] = (l + o) / (l - o), this.cameraL.projectionMatrix.copy($o), o = -a * t.aspect - r, l = a * t.aspect - r, $o.elements[0] = 2 * t.near / (l - o), $o.elements[8] = (l + o) / (l - o), this.cameraR.projectionMatrix.copy($o);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(xb), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(yb);
  }
}
class Iw {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = wb(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = wb();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function wb() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Vo = /* @__PURE__ */ new H(), Eb = /* @__PURE__ */ new en(), RD = /* @__PURE__ */ new H(), Ho = /* @__PURE__ */ new H();
let Tw = class extends Gt {
  constructor() {
    super(), this.type = "AudioListener", this.context = OA.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Iw();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Vo, Eb, RD), Ho.set(0, 0, -1).applyQuaternion(Eb), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Vo.x, i), t.positionY.linearRampToValueAtTime(Vo.y, i), t.positionZ.linearRampToValueAtTime(Vo.z, i), t.forwardX.linearRampToValueAtTime(Ho.x, i), t.forwardY.linearRampToValueAtTime(Ho.y, i), t.forwardZ.linearRampToValueAtTime(Ho.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(Vo.x, Vo.y, Vo.z), t.setOrientation(Ho.x, Ho.y, Ho.z, n.x, n.y, n.z);
  }
}, NA = class extends Gt {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
};
const jo = /* @__PURE__ */ new H(), Cb = /* @__PURE__ */ new en(), DD = /* @__PURE__ */ new H(), Wo = /* @__PURE__ */ new H();
let Bw = class extends NA {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(jo, Cb, DD), Wo.set(0, 0, 1).applyQuaternion(Cb);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(jo.x, n), t.positionY.linearRampToValueAtTime(jo.y, n), t.positionZ.linearRampToValueAtTime(jo.z, n), t.orientationX.linearRampToValueAtTime(Wo.x, n), t.orientationY.linearRampToValueAtTime(Wo.y, n), t.orientationZ.linearRampToValueAtTime(Wo.z, n);
    } else
      t.setPosition(jo.x, jo.y, jo.z), t.setOrientation(Wo.x, Wo.y, Wo.z);
  }
};
class LD {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class Pw {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let i, r, a;
    switch (t) {
      case "quaternion":
        i = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        i = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, i = this.valueSize, r = e * i + i;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== i; ++o)
        n[r + o] = n[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(n, r, 0, o, i);
    }
    this.cumulativeWeight = a;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        n,
        i,
        l,
        1 - r,
        t
      );
    }
    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (n[l] !== n[l + t]) {
        o.setValue(n, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
    e.getValue(t, i);
    for (let r = n, a = i; r !== a; ++r)
      t[r] = t[i + r % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, i, r) {
    if (i >= 0.5)
      for (let a = 0; a !== r; ++a)
        e[t + a] = e[n + a];
  }
  _slerp(e, t, n, i) {
    en.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, r) {
    const a = this._workIndex * r;
    en.multiplyQuaternionsFlat(e, a, e, t, e, n), en.slerpFlat(e, t, e, t, e, a, i);
  }
  _lerp(e, t, n, i, r) {
    const a = 1 - i;
    for (let o = 0; o !== r; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[n + o] * i;
    }
  }
  _lerpAdditive(e, t, n, i, r) {
    for (let a = 0; a !== r; ++a) {
      const o = t + a;
      e[o] = e[o] + e[n + a] * i;
    }
  }
}
const GA = "\\[\\]\\.:\\/", kD = new RegExp("[" + GA + "]", "g"), QA = "[^" + GA + "]", UD = "[^" + GA.replace("\\.", "") + "]", FD = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", QA), OD = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", UD), ND = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", QA), GD = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", QA), QD = new RegExp(
  "^" + FD + OD + ND + GD + "$"
), zD = ["material", "materials", "bones", "map"];
class $D {
  constructor(e, t, n) {
    const i = n || Zt.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Zt {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Zt.parseTrackName(t), this.node = Zt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Zt.Composite(e, t, n) : new Zt(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(kD, "");
  }
  static parseTrackName(e) {
    const t = QD.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      zD.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(r) {
        for (let a = 0; a < r.length; a++) {
          const o = r[a];
          if (o.name === t || o.uuid === t)
            return o;
          const l = n(o.children);
          if (l)
            return l;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, i = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = Zt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
    } else
      a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Zt.Composite = $D;
Zt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Zt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Zt.prototype.GetterByBindingType = [
  Zt.prototype._getValue_direct,
  Zt.prototype._getValue_array,
  Zt.prototype._getValue_arrayElement,
  Zt.prototype._getValue_toArray
];
Zt.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Zt.prototype._setValue_direct,
    Zt.prototype._setValue_direct_setNeedsUpdate,
    Zt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Zt.prototype._setValue_array,
    Zt.prototype._setValue_array_setNeedsUpdate,
    Zt.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Zt.prototype._setValue_arrayElement,
    Zt.prototype._setValue_arrayElement_setNeedsUpdate,
    Zt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Zt.prototype._setValue_fromArray,
    Zt.prototype._setValue_fromArray_setNeedsUpdate,
    Zt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class VD {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ur(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, a = r.length;
    let o, l = e.length, c = this.nCachedObjects_;
    for (let u = 0, f = arguments.length; u !== f; ++u) {
      const h = arguments[u], d = h.uuid;
      let m = t[d];
      if (m === void 0) {
        m = l++, t[d] = m, e.push(h);
        for (let _ = 0, g = a; _ !== g; ++_)
          r[_].push(new Zt(h, n[_], i[_]));
      } else if (m < c) {
        o = e[m];
        const _ = --c, g = e[_];
        t[g.uuid] = m, e[m] = g, t[d] = _, e[_] = h;
        for (let A = 0, v = a; A !== v; ++A) {
          const y = r[A], w = y[_];
          let E = y[m];
          y[m] = w, E === void 0 && (E = new Zt(h, n[A], i[A])), y[_] = E;
        }
      } else
        e[m] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a], c = l.uuid, u = t[c];
      if (u !== void 0 && u >= r) {
        const f = r++, h = e[f];
        t[h.uuid] = u, e[u] = h, t[c] = f, e[f] = l;
        for (let d = 0, m = i; d !== m; ++d) {
          const _ = n[d], g = _[f], A = _[u];
          _[u] = g, _[f] = A;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_, a = e.length;
    for (let o = 0, l = arguments.length; o !== l; ++o) {
      const c = arguments[o], u = c.uuid, f = t[u];
      if (f !== void 0)
        if (delete t[u], f < r) {
          const h = --r, d = e[h], m = --a, _ = e[m];
          t[d.uuid] = f, e[f] = d, t[_.uuid] = h, e[h] = _, e.pop();
          for (let g = 0, A = i; g !== A; ++g) {
            const v = n[g], y = v[h], w = v[m];
            v[f] = y, v[h] = w, v.pop();
          }
        } else {
          const h = --a, d = e[h];
          h > 0 && (t[d.uuid] = f), e[f] = d, e.pop();
          for (let m = 0, _ = i; m !== _; ++m) {
            const g = n[m];
            g[f] = g[h], g.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const r = this._bindings;
    if (i !== void 0)
      return r[i];
    const a = this._paths, o = this._parsedPaths, l = this._objects, c = l.length, u = this.nCachedObjects_, f = new Array(c);
    i = r.length, n[e] = i, a.push(e), o.push(t), r.push(f);
    for (let h = u, d = l.length; h !== d; ++h) {
      const m = l[h];
      f[h] = new Zt(m, e, t);
    }
    return f;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const i = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, l = a[o], c = e[o];
      t[c] = n, a[n] = l, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop();
    }
  }
}
class Rw {
  constructor(e, t, n = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
    const r = t.tracks, a = r.length, o = new Array(a), l = {
      endingStart: aa,
      endingEnd: aa
    };
    for (let c = 0; c !== a; ++c) {
      const u = r[c].createInterpolant(null);
      o[c] = u, u.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = px, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const i = this._clip.duration, r = e._clip.duration, a = r / i, o = i / r;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer, r = i.time, a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const l = o.parameterPositions, c = o.sampleValues;
    return l[0] = r, l[1] = r + n, c[0] = e / a, c[1] = t / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * n;
      l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case hA:
          for (let u = 0, f = l.length; u !== f; ++u)
            l[u].evaluate(a), c[u].accumulateAdditive(o);
          break;
        case ud:
        default:
          for (let u = 0, f = l.length; u !== f; ++u)
            l[u].evaluate(a), c[u].accumulate(i, o);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let i = this.time + e, r = this._loopCount;
    const a = n === mx;
    if (e === 0)
      return r === -1 ? i : a && (r & 1) === 1 ? t - i : i;
    if (n === dx) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), i >= t || i < 0) {
        const o = Math.floor(i / t);
        i -= t * o, r += Math.abs(o);
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: o
          });
        }
      } else
        this.time = i;
      if (a && (r & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = la, i.endingEnd = la) : (e ? i.endingStart = this.zeroSlopeAtStart ? la : aa : i.endingStart = pu, t ? i.endingEnd = this.zeroSlopeAtEnd ? la : aa : i.endingEnd = pu);
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer, r = i.time;
    let a = this._weightInterpolant;
    a === null && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
    const o = a.parameterPositions, l = a.sampleValues;
    return o[0] = r, l[0] = t, o[1] = r + e, l[1] = n, this;
  }
}
const HD = new Float32Array(1);
class Dw extends Qr {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, a = e._propertyBindings, o = e._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && (u = {}, c[l] = u);
    for (let f = 0; f !== r; ++f) {
      const h = i[f], d = h.name;
      let m = u[d];
      if (m !== void 0)
        ++m.referenceCount, a[f] = m;
      else {
        if (m = a[f], m !== void 0) {
          m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, d));
          continue;
        }
        const _ = t && t._propertyBindings[f].binding.parsedPath;
        m = new Pw(
          Zt.create(n, d, _),
          h.ValueTypeName,
          h.getValueSize()
        ), ++m.referenceCount, this._addInactiveBinding(m, l, d), a[f] = m;
      }
      o[f].resultBuffer = m.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions, r = this._actionsByClip;
    let a = r[t];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = a;
    else {
      const o = a.knownActions;
      e._byClipCacheIndex = o.length, o.push(e);
    }
    e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, a = this._actionsByClip, o = a[r], l = o.knownActions, c = l[l.length - 1], u = e._byClipCacheIndex;
    c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
    const f = o.actionByRoot, h = (e._localRoot || this._root).uuid;
    delete f[h], l.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = t[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName, r = this._bindings;
    let a = i[t];
    a === void 0 && (a = {}, i[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[i], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[i];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new RA(
      new Float32Array(2),
      new Float32Array(2),
      1,
      HD
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const i = t || this._root, r = i.uuid;
    let a = typeof e == "string" ? zl.findByName(i, e) : e;
    const o = a !== null ? a.uuid : e, l = this._actionsByClip[o];
    let c = null;
    if (n === void 0 && (a !== null ? n = a.blendMode : n = ud), l !== void 0) {
      const f = l.actionByRoot[r];
      if (f !== void 0 && f.blendMode === n)
        return f;
      c = l.knownActions[0], a === null && (a = c._clip);
    }
    if (a === null)
      return null;
    const u = new Rw(this, a, t, n);
    return this._bindAction(u, c), this._addInactiveAction(u, o, r), u;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, i = n.uuid, r = typeof e == "string" ? zl.findByName(n, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
    return o !== void 0 && o.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
    for (let c = 0; c !== n; ++c)
      t[c]._update(i, e, r, a);
    const o = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      o[c].apply(a);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
    if (r !== void 0) {
      const a = r.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const c = a[o];
        this._deactivateAction(c);
        const u = c._cacheIndex, f = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, f._cacheIndex = u, t[u] = f, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete i[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const a in n) {
      const o = n[a].actionByRoot, l = o[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName, r = i[t];
    if (r !== void 0)
      for (const a in r) {
        const o = r[a];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class zA {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new zA(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let jD = 0;
class WD extends Qr {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: jD++ }), this.name = "", this.usage = _u, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let a = 0; a < r.length; a++)
        this.uniforms.push(r[a].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class qD extends Uu {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class XD {
  constructor(e, t, n, i, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
const Sb = /* @__PURE__ */ new st();
class zu {
  constructor(e, t, n = 0, i = 1 / 0) {
    this.ray = new wa(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new dd(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return Sb.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Sb), this;
  }
  intersectObject(e, t = !0, n = []) {
    return Ig(e, this, n, t), n.sort(Mb), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, r = e.length; i < r; i++)
      Ig(e[i], this, n, t);
    return n.sort(Mb), n;
  }
}
function Mb(s, e) {
  return s.distance - e.distance;
}
function Ig(s, e, t, n) {
  if (s.layers.test(e.layers) && s.raycast(e, t), n === !0) {
    const i = s.children;
    for (let r = 0, a = i.length; r < a; r++)
      Ig(i[r], e, t, !0);
  }
}
class ed {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Fn(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class YD {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ib = /* @__PURE__ */ new ke();
class KD {
  constructor(e = new ke(1 / 0, 1 / 0), t = new ke(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Ib.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ib).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Tb = /* @__PURE__ */ new H(), Wf = /* @__PURE__ */ new H();
class os {
  constructor(e = new H(), t = new H()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Tb.subVectors(e, this.start), Wf.subVectors(this.end, this.start);
    const n = Wf.dot(Wf);
    let r = Wf.dot(Tb) / n;
    return t && (r = Fn(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Bb = /* @__PURE__ */ new H();
class JD extends Gt {
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new Dt(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = a / l * Math.PI * 2, u = o / l * Math.PI * 2;
      i.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(u),
        Math.sin(u),
        1
      );
    }
    n.setAttribute("position", new ht(i, 3));
    const r = new Jn({ fog: !1, toneMapped: !1 });
    this.cone = new zr(n, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), Bb.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Bb), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const no = /* @__PURE__ */ new H(), qf = /* @__PURE__ */ new st(), em = /* @__PURE__ */ new st();
class ZD extends zr {
  constructor(e) {
    const t = Lw(e), n = new Dt(), i = [], r = [], a = new Je(0, 0, 1), o = new Je(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      u.parent && u.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
    }
    n.setAttribute("position", new ht(i, 3)), n.setAttribute("color", new ht(r, 3));
    const l = new Jn({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, i = n.getAttribute("position");
    em.copy(this.root.matrixWorld).invert();
    for (let r = 0, a = 0; r < t.length; r++) {
      const o = t[r];
      o.parent && o.parent.isBone && (qf.multiplyMatrices(em, o.matrixWorld), no.setFromMatrixPosition(qf), i.setXYZ(a, no.x, no.y, no.z), qf.multiplyMatrices(em, o.parent.matrixWorld), no.setFromMatrixPosition(qf), i.setXYZ(a + 1, no.x, no.y, no.z), a += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Lw(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, Lw(s.children[t]));
  return e;
}
class e3 extends tt {
  constructor(e, t, n) {
    const i = new tc(t, 4, 2), r = new $n({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const t3 = /* @__PURE__ */ new H(), Pb = /* @__PURE__ */ new Je(), Rb = /* @__PURE__ */ new Je();
class n3 extends Gt {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const i = new Bs(t);
    i.rotateY(Math.PI * 0.5), this.material = new $n({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = i.getAttribute("position"), a = new Float32Array(r.count * 3);
    i.setAttribute("color", new Rt(a, 3)), this.add(new tt(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      Pb.copy(this.light.color), Rb.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const r = n < i / 2 ? Pb : Rb;
        t.setXYZ(n, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(t3.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class i3 extends zr {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    n = new Je(n), i = new Je(i);
    const r = t / 2, a = e / t, o = e / 2, l = [], c = [];
    for (let h = 0, d = 0, m = -o; h <= t; h++, m += a) {
      l.push(-o, 0, m, o, 0, m), l.push(m, 0, -o, m, 0, o);
      const _ = h === r ? n : i;
      _.toArray(c, d), d += 3, _.toArray(c, d), d += 3, _.toArray(c, d), d += 3, _.toArray(c, d), d += 3;
    }
    const u = new Dt();
    u.setAttribute("position", new ht(l, 3)), u.setAttribute("color", new ht(c, 3));
    const f = new Jn({ vertexColors: !0, toneMapped: !1 });
    super(u, f), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class r3 extends zr {
  constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, a = 8947848) {
    r = new Je(r), a = new Je(a);
    const o = [], l = [];
    if (t > 1)
      for (let f = 0; f < t; f++) {
        const h = f / t * (Math.PI * 2), d = Math.sin(h) * e, m = Math.cos(h) * e;
        o.push(0, 0, 0), o.push(d, 0, m);
        const _ = f & 1 ? r : a;
        l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b);
      }
    for (let f = 0; f < n; f++) {
      const h = f & 1 ? r : a, d = e - e / n * f;
      for (let m = 0; m < i; m++) {
        let _ = m / i * (Math.PI * 2), g = Math.sin(_) * d, A = Math.cos(_) * d;
        o.push(g, 0, A), l.push(h.r, h.g, h.b), _ = (m + 1) / i * (Math.PI * 2), g = Math.sin(_) * d, A = Math.cos(_) * d, o.push(g, 0, A), l.push(h.r, h.g, h.b);
      }
    }
    const c = new Dt();
    c.setAttribute("position", new ht(o, 3)), c.setAttribute("color", new ht(l, 3));
    const u = new Jn({ vertexColors: !0, toneMapped: !1 });
    super(c, u), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Db = /* @__PURE__ */ new H(), Xf = /* @__PURE__ */ new H(), Lb = /* @__PURE__ */ new H();
class s3 extends Gt {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new Dt();
    i.setAttribute("position", new ht([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new Jn({ fog: !1, toneMapped: !1 });
    this.lightPlane = new qn(i, r), this.add(this.lightPlane), i = new Dt(), i.setAttribute("position", new ht([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new qn(i, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Db.setFromMatrixPosition(this.light.matrixWorld), Xf.setFromMatrixPosition(this.light.target.matrixWorld), Lb.subVectors(Xf, Db), this.lightPlane.lookAt(Xf), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Xf), this.targetLine.scale.z = Lb.length();
  }
}
const Yf = /* @__PURE__ */ new H(), Ln = /* @__PURE__ */ new Lu();
class o3 extends zr {
  constructor(e) {
    const t = new Dt(), n = new Jn({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], a = {};
    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4");
    function o(m, _) {
      l(m), l(_);
    }
    function l(m) {
      i.push(0, 0, 0), r.push(0, 0, 0), a[m] === void 0 && (a[m] = []), a[m].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new ht(i, 3)), t.setAttribute("color", new ht(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
    const c = new Je(16755200), u = new Je(16711680), f = new Je(43775), h = new Je(16777215), d = new Je(3355443);
    this.setColors(c, u, f, h, d);
  }
  setColors(e, t, n, i, r) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, n.r, n.g, n.b), o.setXYZ(33, n.r, n.g, n.b), o.setXYZ(34, n.r, n.g, n.b), o.setXYZ(35, n.r, n.g, n.b), o.setXYZ(36, n.r, n.g, n.b), o.setXYZ(37, n.r, n.g, n.b), o.setXYZ(38, i.r, i.g, i.b), o.setXYZ(39, i.r, i.g, i.b), o.setXYZ(40, r.r, r.g, r.b), o.setXYZ(41, r.r, r.g, r.b), o.setXYZ(42, r.r, r.g, r.b), o.setXYZ(43, r.r, r.g, r.b), o.setXYZ(44, r.r, r.g, r.b), o.setXYZ(45, r.r, r.g, r.b), o.setXYZ(46, r.r, r.g, r.b), o.setXYZ(47, r.r, r.g, r.b), o.setXYZ(48, r.r, r.g, r.b), o.setXYZ(49, r.r, r.g, r.b), o.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, i = 1;
    Ln.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Gn("c", t, e, Ln, 0, 0, -1), Gn("t", t, e, Ln, 0, 0, 1), Gn("n1", t, e, Ln, -n, -i, -1), Gn("n2", t, e, Ln, n, -i, -1), Gn("n3", t, e, Ln, -n, i, -1), Gn("n4", t, e, Ln, n, i, -1), Gn("f1", t, e, Ln, -n, -i, 1), Gn("f2", t, e, Ln, n, -i, 1), Gn("f3", t, e, Ln, -n, i, 1), Gn("f4", t, e, Ln, n, i, 1), Gn("u1", t, e, Ln, n * 0.7, i * 1.1, -1), Gn("u2", t, e, Ln, -n * 0.7, i * 1.1, -1), Gn("u3", t, e, Ln, 0, i * 2, -1), Gn("cf1", t, e, Ln, -n, 0, 1), Gn("cf2", t, e, Ln, n, 0, 1), Gn("cf3", t, e, Ln, 0, -i, 1), Gn("cf4", t, e, Ln, 0, i, 1), Gn("cn1", t, e, Ln, -n, 0, -1), Gn("cn2", t, e, Ln, n, 0, -1), Gn("cn3", t, e, Ln, 0, -i, -1), Gn("cn4", t, e, Ln, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Gn(s, e, t, n, i, r, a) {
  Yf.set(i, r, a).unproject(n);
  const o = e[s];
  if (o !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, u = o.length; c < u; c++)
      l.setXYZ(o[c], Yf.x, Yf.y, Yf.z);
  }
}
const Kf = /* @__PURE__ */ new dn();
class a3 extends zr {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), r = new Dt();
    r.setIndex(new Rt(n, 1)), r.setAttribute("position", new Rt(i, 3)), super(r, new Jn({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Kf.setFromObject(this.object), Kf.isEmpty())
      return;
    const t = Kf.min, n = Kf.max, i = this.geometry.attributes.position, r = i.array;
    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class l3 extends zr {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new Dt();
    r.setIndex(new Rt(n, 1)), r.setAttribute("position", new ht(i, 3)), super(r, new Jn({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class c3 extends qn {
  constructor(e, t = 1, n = 16776960) {
    const i = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], a = new Dt();
    a.setAttribute("position", new ht(r, 3)), a.computeBoundingSphere(), super(a, new Jn({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Dt();
    l.setAttribute("position", new ht(o, 3)), l.computeBoundingSphere(), this.add(new tt(l, new $n({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const kb = /* @__PURE__ */ new H();
let Jf, tm;
class u3 extends Gt {
  // dir is assumed to be normalized
  constructor(e = new H(0, 0, 1), t = new H(0, 0, 0), n = 1, i = 16776960, r = n * 0.2, a = r * 0.2) {
    super(), this.type = "ArrowHelper", Jf === void 0 && (Jf = new Dt(), Jf.setAttribute("position", new ht([0, 0, 0, 0, 1, 0], 3)), tm = new Wn(0, 0.5, 1, 5, 1), tm.translate(0, -0.5, 0)), this.position.copy(t), this.line = new qn(Jf, new Jn({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new tt(tm, new $n({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      kb.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(kb, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class f3 extends zr {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new Dt();
    i.setAttribute("position", new ht(t, 3)), i.setAttribute("color", new ht(n, 3));
    const r = new Jn({ vertexColors: !0, toneMapped: !1 });
    super(i, r), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const i = new Je(), r = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class kw {
  constructor() {
    this.type = "ShapePath", this.color = new Je(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new yu(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, a) {
    return this.currentPath.bezierCurveTo(e, t, n, i, r, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(A) {
      const v = [];
      for (let y = 0, w = A.length; y < w; y++) {
        const E = A[y], I = new ho();
        I.curves = E.curves, v.push(I);
      }
      return v;
    }
    function n(A, v) {
      const y = v.length;
      let w = !1;
      for (let E = y - 1, I = 0; I < y; E = I++) {
        let C = v[E], B = v[I], T = B.x - C.x, S = B.y - C.y;
        if (Math.abs(S) > Number.EPSILON) {
          if (S < 0 && (C = v[I], T = -T, B = v[E], S = -S), A.y < C.y || A.y > B.y)
            continue;
          if (A.y === C.y) {
            if (A.x === C.x)
              return !0;
          } else {
            const D = S * (A.x - C.x) - T * (A.y - C.y);
            if (D === 0)
              return !0;
            if (D < 0)
              continue;
            w = !w;
          }
        } else {
          if (A.y !== C.y)
            continue;
          if (B.x <= A.x && A.x <= C.x || C.x <= A.x && A.x <= B.x)
            return !0;
        }
      }
      return w;
    }
    const i = ss.isClockWise, r = this.subPaths;
    if (r.length === 0)
      return [];
    let a, o, l;
    const c = [];
    if (r.length === 1)
      return o = r[0], l = new ho(), l.curves = o.curves, c.push(l), c;
    let u = !i(r[0].getPoints());
    u = e ? !u : u;
    const f = [], h = [];
    let d = [], m = 0, _;
    h[m] = void 0, d[m] = [];
    for (let A = 0, v = r.length; A < v; A++)
      o = r[A], _ = o.getPoints(), a = i(_), a = e ? !a : a, a ? (!u && h[m] && m++, h[m] = { s: new ho(), p: _ }, h[m].s.curves = o.curves, u && m++, d[m] = []) : d[m].push({ h: o, p: _[0] });
    if (!h[0])
      return t(r);
    if (h.length > 1) {
      let A = !1, v = 0;
      for (let y = 0, w = h.length; y < w; y++)
        f[y] = [];
      for (let y = 0, w = h.length; y < w; y++) {
        const E = d[y];
        for (let I = 0; I < E.length; I++) {
          const C = E[I];
          let B = !0;
          for (let T = 0; T < h.length; T++)
            n(C.p, h[T].p) && (y !== T && v++, B ? (B = !1, f[T].push(C)) : A = !0);
          B && f[y].push(C);
        }
      }
      v > 0 && A === !1 && (d = f);
    }
    let g;
    for (let A = 0, v = h.length; A < v; A++) {
      l = h[A].s, c.push(l), g = d[A];
      for (let y = 0, w = g.length; y < w; y++)
        l.holes.push(g[y].h);
    }
    return c;
  }
}
class h3 extends Ji {
  // @deprecated, r162
  constructor(e = 1, t = 1, n = 1, i = {}) {
    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...i, count: n }), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: $l
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = $l);
const d3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: lA,
  AddEquation: co,
  AddOperation: Z1,
  AdditiveAnimationBlendMode: hA,
  AdditiveBlending: uu,
  AgXToneMapping: rx,
  AlphaFormat: lx,
  AlwaysCompare: Cx,
  AlwaysDepth: j1,
  AlwaysStencilFunc: Yh,
  AmbientLight: yw,
  AnimationAction: Rw,
  AnimationClip: zl,
  AnimationLoader: ED,
  AnimationMixer: Dw,
  AnimationObjectGroup: VD,
  AnimationUtils: vD,
  ArcCurve: qx,
  ArrayCamera: Gx,
  ArrowHelper: u3,
  AttachedBindMode: tg,
  Audio: NA,
  AudioAnalyser: LD,
  AudioContext: OA,
  AudioListener: Tw,
  AudioLoader: Mw,
  AxesHelper: f3,
  BackSide: Kn,
  BasicDepthPacking: Ax,
  BasicShadowMap: QM,
  BatchedMesh: Vx,
  Bone: bd,
  BooleanKeyframeTrack: Ca,
  Box2: KD,
  Box3: dn,
  Box3Helper: l3,
  BoxGeometry: Pn,
  BoxHelper: a3,
  BufferAttribute: Rt,
  BufferGeometry: Dt,
  BufferGeometryLoader: Cw,
  ByteType: zh,
  Cache: Ps,
  Camera: Lu,
  CameraHelper: o3,
  CanvasTexture: Wx,
  CapsuleGeometry: Nu,
  CatmullRomCurve3: Xx,
  CineonToneMapping: nx,
  CircleGeometry: xd,
  ClampToEdgeWrapping: yi,
  Clock: Iw,
  Color: Je,
  ColorKeyframeTrack: DA,
  ColorManagement: cn,
  CompressedArrayTexture: Hx,
  CompressedCubeTexture: jx,
  CompressedTexture: ec,
  CompressedTextureLoader: CD,
  ConeGeometry: wd,
  ConstantAlphaFactor: $1,
  ConstantColorFactor: Q1,
  CubeCamera: _A,
  CubeReflectionMapping: as,
  CubeRefractionMapping: go,
  CubeTexture: Xl,
  CubeTextureLoader: _w,
  CubeUVReflectionMapping: Vl,
  CubicBezierCurve: SA,
  CubicBezierCurve3: Yx,
  CubicInterpolant: pw,
  CullFaceBack: Jm,
  CullFaceFront: S1,
  CullFaceFrontBack: GM,
  CullFaceNone: C1,
  Curve: $r,
  CurvePath: Jx,
  CustomBlending: M1,
  CustomToneMapping: ix,
  CylinderGeometry: Wn,
  Cylindrical: YD,
  Data3DTexture: hd,
  DataArrayTexture: fd,
  DataTexture: Di,
  DataTextureLoader: bw,
  DataUtils: Wc,
  DecrementStencilOp: qM,
  DecrementWrapStencilOp: YM,
  DefaultLoadingManager: Aw,
  DepthFormat: ha,
  DepthStencilFormat: Fl,
  DepthTexture: yA,
  DetachedBindMode: ox,
  DirectionalLight: Rd,
  DirectionalLightHelper: s3,
  DiscreteInterpolant: mw,
  DisplayP3ColorSpace: Du,
  DodecahedronGeometry: Ed,
  DoubleSide: zn,
  DstAlphaFactor: U1,
  DstColorFactor: O1,
  DynamicCopyUsage: u2,
  DynamicDrawUsage: Pl,
  DynamicReadUsage: a2,
  EdgesGeometry: Zx,
  EllipseCurve: yd,
  EqualCompare: yx,
  EqualDepth: q1,
  EqualStencilFunc: e2,
  EquirectangularReflectionMapping: kl,
  EquirectangularRefractionMapping: hu,
  Euler: Ui,
  EventDispatcher: Qr,
  ExtrudeGeometry: Gu,
  FileLoader: ri,
  Float16BufferAttribute: X2,
  Float32BufferAttribute: ht,
  FloatType: hn,
  Fog: gd,
  FogExp2: md,
  FramebufferTexture: VR,
  FrontSide: Hi,
  Frustum: ku,
  GLBufferAttribute: XD,
  GLSL1: h2,
  GLSL3: yg,
  GreaterCompare: xx,
  GreaterDepth: Y1,
  GreaterEqualCompare: Ex,
  GreaterEqualDepth: X1,
  GreaterEqualStencilFunc: r2,
  GreaterStencilFunc: n2,
  GridHelper: i3,
  Group: Xn,
  HalfFloatType: Ri,
  HemisphereLight: vw,
  HemisphereLightHelper: n3,
  IcosahedronGeometry: Sd,
  ImageBitmapLoader: Sw,
  ImageLoader: Cu,
  ImageUtils: Tx,
  IncrementStencilOp: WM,
  IncrementWrapStencilOp: XM,
  InstancedBufferAttribute: cs,
  InstancedBufferGeometry: Ld,
  InstancedInterleavedBuffer: qD,
  InstancedMesh: Zl,
  Int16BufferAttribute: W2,
  Int32BufferAttribute: q2,
  Int8BufferAttribute: V2,
  IntType: Bl,
  InterleavedBuffer: Uu,
  InterleavedBufferAttribute: Ao,
  Interpolant: nc,
  InterpolateDiscrete: Nl,
  InterpolateLinear: ga,
  InterpolateSmooth: Ih,
  InvertStencilOp: KM,
  KeepStencilOp: ta,
  KeyframeTrack: Vr,
  LOD: $x,
  LatheGeometry: Ou,
  Layers: dd,
  LessCompare: vx,
  LessDepth: W1,
  LessEqualCompare: pA,
  LessEqualDepth: fu,
  LessEqualStencilFunc: t2,
  LessStencilFunc: ZM,
  Light: wo,
  LightProbe: Ew,
  Line: qn,
  Line3: os,
  LineBasicMaterial: Jn,
  LineCurve: MA,
  LineCurve3: Kx,
  LineDashedMaterial: fw,
  LineLoop: wA,
  LineSegments: zr,
  LinearDisplayP3ColorSpace: Wl,
  LinearFilter: Yt,
  LinearInterpolant: RA,
  LinearMipMapLinearFilter: HM,
  LinearMipMapNearestFilter: VM,
  LinearMipmapLinearFilter: Yi,
  LinearMipmapNearestFilter: Tl,
  LinearSRGBColorSpace: Bn,
  LinearToneMapping: ex,
  LinearTransfer: mu,
  Loader: ai,
  LoaderUtils: po,
  LoadingManager: LA,
  LoopOnce: dx,
  LoopPingPong: mx,
  LoopRepeat: px,
  LuminanceAlphaFormat: fx,
  LuminanceFormat: ux,
  MOUSE: ts,
  Material: ii,
  MaterialLoader: Dd,
  MathUtils: ls,
  Matrix3: Ot,
  Matrix4: st,
  MaxEquation: P1,
  Mesh: tt,
  MeshBasicMaterial: $n,
  MeshDepthMaterial: Ea,
  MeshDistanceMaterial: Kl,
  MeshLambertMaterial: cw,
  MeshMatcapMaterial: uw,
  MeshNormalMaterial: lw,
  MeshPhongMaterial: ow,
  MeshPhysicalMaterial: wr,
  MeshStandardMaterial: Qu,
  MeshToonMaterial: aw,
  MinEquation: B1,
  MirroredRepeatWrapping: Ul,
  MixOperation: J1,
  MultiplyBlending: eg,
  MultiplyOperation: Pu,
  NearestFilter: nn,
  NearestMipMapLinearFilter: $M,
  NearestMipMapNearestFilter: zM,
  NearestMipmapLinearFilter: oa,
  NearestMipmapNearestFilter: ad,
  NeutralToneMapping: sx,
  NeverCompare: bx,
  NeverDepth: H1,
  NeverStencilFunc: JM,
  NoBlending: Ds,
  NoColorSpace: Ur,
  NoToneMapping: Ls,
  NormalAnimationBlendMode: ud,
  NormalBlending: fa,
  NotEqualCompare: wx,
  NotEqualDepth: K1,
  NotEqualStencilFunc: i2,
  NumberKeyframeTrack: _a,
  Object3D: Gt,
  ObjectLoader: TD,
  ObjectSpaceNormalMap: _x,
  OctahedronGeometry: Bs,
  OneFactor: D1,
  OneMinusConstantAlphaFactor: V1,
  OneMinusConstantColorFactor: z1,
  OneMinusDstAlphaFactor: F1,
  OneMinusDstColorFactor: N1,
  OneMinusSrcAlphaFactor: Qh,
  OneMinusSrcColorFactor: k1,
  OrthographicCamera: yo,
  P3Primaries: Au,
  PCFShadowMap: aA,
  PCFSoftShadowMap: sd,
  PMREMGenerator: xg,
  Path: yu,
  PerspectiveCamera: ni,
  Plane: _r,
  PlaneGeometry: Fi,
  PlaneHelper: c3,
  PointLight: FA,
  PointLightHelper: e3,
  Points: EA,
  PointsMaterial: vd,
  PolarGridHelper: r3,
  PolyhedronGeometry: xo,
  PositionalAudio: Bw,
  PropertyBinding: Zt,
  PropertyMixer: Pw,
  QuadraticBezierCurve: IA,
  QuadraticBezierCurve3: TA,
  Quaternion: en,
  QuaternionKeyframeTrack: _o,
  QuaternionLinearInterpolant: gw,
  RED_GREEN_RGTC2_Format: bg,
  RED_RGTC1_Format: hx,
  REVISION: $l,
  RGBADepthPacking: jl,
  RGBAFormat: vn,
  RGBAIntegerFormat: Ol,
  RGBA_ASTC_10x10_Format: dg,
  RGBA_ASTC_10x5_Format: ug,
  RGBA_ASTC_10x6_Format: fg,
  RGBA_ASTC_10x8_Format: hg,
  RGBA_ASTC_12x10_Format: pg,
  RGBA_ASTC_12x12_Format: mg,
  RGBA_ASTC_4x4_Format: qh,
  RGBA_ASTC_5x4_Format: rg,
  RGBA_ASTC_5x5_Format: sg,
  RGBA_ASTC_6x5_Format: og,
  RGBA_ASTC_6x6_Format: du,
  RGBA_ASTC_8x5_Format: ag,
  RGBA_ASTC_8x6_Format: lg,
  RGBA_ASTC_8x8_Format: cg,
  RGBA_BPTC_Format: eu,
  RGBA_ETC2_EAC_Format: Wh,
  RGBA_PVRTC_2BPPV1_Format: ig,
  RGBA_PVRTC_4BPPV1_Format: Vh,
  RGBA_S3TC_DXT1_Format: Jc,
  RGBA_S3TC_DXT3_Format: Mh,
  RGBA_S3TC_DXT5_Format: Zc,
  RGBFormat: cx,
  RGB_BPTC_SIGNED_Format: gg,
  RGB_BPTC_UNSIGNED_Format: Ag,
  RGB_ETC1_Format: Hh,
  RGB_ETC2_Format: jh,
  RGB_PVRTC_2BPPV1_Format: ng,
  RGB_PVRTC_4BPPV1_Format: $h,
  RGB_S3TC_DXT1_Format: Sh,
  RGFormat: uo,
  RGIntegerFormat: Ru,
  RawShaderMaterial: sw,
  Ray: wa,
  Raycaster: zu,
  Rec709Primaries: gu,
  RectAreaLight: xw,
  RedFormat: Ts,
  RedIntegerFormat: cd,
  ReinhardToneMapping: tx,
  RenderTarget: Bx,
  RepeatWrapping: Or,
  ReplaceStencilOp: Th,
  ReverseSubtractEquation: T1,
  RingGeometry: Md,
  SIGNED_RED_GREEN_RGTC2_Format: vg,
  SIGNED_RED_RGTC1_Format: _g,
  SRGBColorSpace: Qn,
  SRGBTransfer: yn,
  Scene: Jl,
  ShaderChunk: gt,
  ShaderLib: br,
  ShaderMaterial: Hn,
  ShadowMaterial: rw,
  Shape: ho,
  ShapeGeometry: Id,
  ShapePath: kw,
  ShapeUtils: ss,
  ShortType: cA,
  Skeleton: Fu,
  SkeletonHelper: ZD,
  SkinnedMesh: _d,
  Source: ca,
  Sphere: Vn,
  SphereGeometry: tc,
  Spherical: ed,
  SphericalHarmonics3: ww,
  SplineCurve: BA,
  SpotLight: UA,
  SpotLightHelper: JD,
  Sprite: zx,
  SpriteMaterial: Ad,
  SrcAlphaFactor: Gh,
  SrcAlphaSaturateFactor: G1,
  SrcColorFactor: L1,
  StaticCopyUsage: c2,
  StaticDrawUsage: _u,
  StaticReadUsage: o2,
  StereoCamera: PD,
  StreamCopyUsage: f2,
  StreamDrawUsage: s2,
  StreamReadUsage: l2,
  StringKeyframeTrack: Sa,
  SubtractEquation: I1,
  SubtractiveBlending: Zm,
  TOUCH: ea,
  TangentSpaceNormalMap: vo,
  TetrahedronGeometry: Td,
  Texture: wn,
  TextureLoader: Su,
  TorusGeometry: Ms,
  TorusKnotGeometry: Bd,
  Triangle: di,
  TriangleFanDrawMode: Xh,
  TriangleStripDrawMode: dA,
  TrianglesDrawMode: gx,
  TubeGeometry: Pd,
  UVMapping: od,
  Uint16BufferAttribute: gA,
  Uint32BufferAttribute: AA,
  Uint8BufferAttribute: H2,
  Uint8ClampedBufferAttribute: j2,
  Uniform: zA,
  UniformsGroup: WD,
  UniformsLib: ot,
  UniformsUtils: ql,
  UnsignedByteType: Un,
  UnsignedInt248Type: Hl,
  UnsignedInt5999Type: ax,
  UnsignedIntType: xr,
  UnsignedShort4444Type: uA,
  UnsignedShort5551Type: fA,
  UnsignedShortType: ld,
  VSMShadowMap: es,
  Vector2: ke,
  Vector3: H,
  Vector4: Xt,
  VectorKeyframeTrack: ba,
  VideoTexture: $R,
  WebGL3DRenderTarget: L2,
  WebGLArrayRenderTarget: D2,
  WebGLCoordinateSystem: is,
  WebGLCubeRenderTarget: bA,
  WebGLMultipleRenderTargets: h3,
  WebGLRenderTarget: Ji,
  WebGLRenderer: xA,
  WebGLUtils: Nx,
  WebGPUCoordinateSystem: bu,
  WireframeGeometry: iw,
  WrapAroundEnding: pu,
  ZeroCurvatureEnding: aa,
  ZeroFactor: R1,
  ZeroSlopeEnding: la,
  ZeroStencilOp: jM,
  createCanvasElement: Mx
}, Symbol.toStringTag, { value: "Module" }));
function p3(s) {
  return { all: s = s || /* @__PURE__ */ new Map(), on: function(e, t) {
    var n = s.get(e);
    n ? n.push(t) : s.set(e, [t]);
  }, off: function(e, t) {
    var n = s.get(e);
    n && (t ? n.splice(n.indexOf(t) >>> 0, 1) : s.set(e, []));
  }, emit: function(e, t) {
    var n = s.get(e);
    n && n.slice().map(function(i) {
      i(t);
    }), (n = s.get("*")) && n.slice().map(function(i) {
      i(e, t);
    });
  } };
}
class oo {
  constructor() {
    qt(this, "allVertices", {});
    /** Nodes that are fully unlinked */
    qt(this, "isolatedVertices", {});
    qt(this, "connectedVertices", {});
    qt(this, "sortedConnectedValues", []);
    qt(this, "needsSort", !1);
    qt(this, "emitter", p3());
    qt(this, "emit", this.emitter.emit.bind(this.emitter));
    qt(this, "on", this.emitter.on.bind(this.emitter));
    qt(this, "off", this.emitter.off.bind(this.emitter));
    qt(this, "getKey", (e) => typeof e == "object" ? e.key : e);
  }
  get sortedVertices() {
    return this.mapNodes((e) => e);
  }
  moveToIsolated(e) {
    const t = this.connectedVertices[e];
    t && (this.isolatedVertices[e] = t, delete this.connectedVertices[e]);
  }
  moveToConnected(e) {
    const t = this.isolatedVertices[e];
    t && (this.connectedVertices[e] = t, delete this.isolatedVertices[e]);
  }
  add(e, t, n) {
    if (this.allVertices[e] && this.allVertices[e].value !== void 0)
      throw new Error(`A node with the key ${e.toString()} already exists`);
    let i = this.allVertices[e];
    i ? i.value === void 0 && (i.value = t) : (i = {
      value: t,
      previous: /* @__PURE__ */ new Set(),
      next: /* @__PURE__ */ new Set()
    }, this.allVertices[e] = i);
    const r = i.next.size > 0 || i.previous.size > 0;
    if (!(n != null && n.after) && !(n != null && n.before) && !r) {
      this.isolatedVertices[e] = i, this.emit("node:added", {
        key: e,
        type: "isolated",
        value: t
      });
      return;
    } else
      this.connectedVertices[e] = i;
    if (n != null && n.after) {
      const a = Array.isArray(n.after) ? n.after : [n.after];
      a.forEach((o) => {
        i.previous.add(this.getKey(o));
      }), a.forEach((o) => {
        const l = this.getKey(o), c = this.allVertices[l];
        c ? (c.next.add(e), this.moveToConnected(l)) : (this.allVertices[l] = {
          value: void 0,
          previous: /* @__PURE__ */ new Set(),
          next: /* @__PURE__ */ new Set([e])
        }, this.connectedVertices[l] = this.allVertices[l]);
      });
    }
    if (n != null && n.before) {
      const a = Array.isArray(n.before) ? n.before : [n.before];
      a.forEach((o) => {
        i.next.add(this.getKey(o));
      }), a.forEach((o) => {
        const l = this.getKey(o), c = this.allVertices[l];
        c ? (c.previous.add(e), this.moveToConnected(l)) : (this.allVertices[l] = {
          value: void 0,
          previous: /* @__PURE__ */ new Set([e]),
          next: /* @__PURE__ */ new Set()
        }, this.connectedVertices[l] = this.allVertices[l]);
      });
    }
    this.emit("node:added", {
      key: e,
      type: "connected",
      value: t
    }), this.needsSort = !0;
  }
  remove(e) {
    const t = this.getKey(e);
    if (this.isolatedVertices[t]) {
      delete this.isolatedVertices[t], delete this.allVertices[t], this.emit("node:removed", {
        key: t,
        type: "isolated"
      });
      return;
    }
    const i = this.connectedVertices[t];
    i && (i.next.forEach((r) => {
      const a = this.connectedVertices[r];
      a && (a.previous.delete(t), a.previous.size === 0 && a.next.size === 0 && this.moveToIsolated(r));
    }), i.previous.forEach((r) => {
      const a = this.connectedVertices[r];
      a && (a.next.delete(t), a.previous.size === 0 && a.next.size === 0 && this.moveToIsolated(r));
    }), delete this.connectedVertices[t], delete this.allVertices[t], this.emit("node:removed", {
      key: t,
      type: "connected"
    }), this.needsSort = !0);
  }
  mapNodes(e) {
    this.needsSort && this.sort();
    const t = [];
    return this.forEachNode((n, i) => {
      t.push(e(n, i));
    }), t;
  }
  forEachNode(e) {
    this.needsSort && this.sort();
    let t = 0;
    for (; t < this.sortedConnectedValues.length; t++)
      e(this.sortedConnectedValues[t], t);
    Reflect.ownKeys(this.isolatedVertices).forEach((n) => {
      const i = this.isolatedVertices[n];
      i.value !== void 0 && e(i.value, t++);
    });
  }
  getValueByKey(e) {
    var t;
    return (t = this.allVertices[e]) == null ? void 0 : t.value;
  }
  getKeyByValue(e) {
    return Reflect.ownKeys(this.connectedVertices).find((t) => this.connectedVertices[t].value === e) ?? Reflect.ownKeys(this.isolatedVertices).find((t) => this.isolatedVertices[t].value === e);
  }
  sort() {
    var a;
    const e = /* @__PURE__ */ new Map(), t = [], n = [], i = Reflect.ownKeys(this.connectedVertices).filter((o) => this.connectedVertices[o].value !== void 0);
    for (i.forEach((o) => {
      e.set(o, 0);
    }), i.forEach((o) => {
      this.connectedVertices[o].next.forEach((c) => {
        this.connectedVertices[c] && e.set(c, (e.get(c) || 0) + 1);
      });
    }), e.forEach((o, l) => {
      o === 0 && t.push(l);
    }); t.length > 0; ) {
      const o = t.shift();
      n.push(o);
      const l = i.find((c) => c === o);
      l && ((a = this.connectedVertices[l]) == null || a.next.forEach((c) => {
        const u = (e.get(c) || 0) - 1;
        e.set(c, u), u === 0 && t.push(c);
      }));
    }
    if (n.length !== i.length)
      throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");
    const r = (o) => o !== void 0;
    this.sortedConnectedValues = n.map((o) => this.connectedVertices[o].value).filter(r), this.needsSort = !1;
  }
  clear() {
    this.allVertices = {}, this.isolatedVertices = {}, this.connectedVertices = {}, this.sortedConnectedValues = [], this.needsSort = !1;
  }
  static isKey(e) {
    return typeof e == "string" || typeof e == "symbol";
  }
  static isValue(e) {
    return typeof e == "object" && "key" in e;
  }
}
class m3 {
  constructor(e, t, n) {
    qt(this, "key");
    qt(this, "stage");
    qt(this, "callback");
    qt(this, "runTask", !0);
    this.stage = e, this.key = t, this.callback = n;
  }
  stop() {
    this.runTask = !1;
  }
  start() {
    this.runTask = !0;
  }
  run(e) {
    this.runTask && this.callback(e);
  }
}
class g3 extends oo {
  constructor(t, n, i) {
    super();
    qt(this, "key");
    qt(this, "scheduler");
    qt(this, "callback", (t, n) => n());
    qt(this, "removeTask", this.remove.bind(this));
    this.scheduler = t, this.key = n, i && (this.callback = i.bind(this));
  }
  get tasks() {
    return this.sortedVertices;
  }
  createTask(t, n, i) {
    const r = new m3(this, t, n);
    return this.add(t, r, i), r;
  }
  getTask(t) {
    return this.getValueByKey(t);
  }
  run(t) {
    this.callback(t, (n) => {
      this.forEachNode((i) => {
        i.run(n ?? t);
      });
    });
  }
  runWithTiming(t) {
    const n = {};
    return this.callback(t, (i) => {
      this.forEachNode((r) => {
        const a = performance.now();
        r.run(i ?? t);
        const o = performance.now() - a;
        n[r.key] = o;
      });
    }), n;
  }
  getSchedule() {
    return this.mapNodes((t) => t.key.toString());
  }
}
class A3 extends oo {
  constructor(t) {
    super();
    qt(this, "lastTime", performance.now());
    qt(this, "clampDeltaTo", 0.1);
    qt(this, "removeStage", this.remove.bind(this));
    t != null && t.clampDeltaTo && (this.clampDeltaTo = t.clampDeltaTo), this.run = this.run.bind(this);
  }
  get stages() {
    return this.sortedVertices;
  }
  createStage(t, n) {
    const i = new g3(this, t, n == null ? void 0 : n.callback);
    return this.add(t, i, {
      after: n == null ? void 0 : n.after,
      before: n == null ? void 0 : n.before
    }), i;
  }
  getStage(t) {
    return this.getValueByKey(t);
  }
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(t) {
    const n = t - this.lastTime;
    this.forEachNode((i) => {
      i.run(Math.min(n / 1e3, this.clampDeltaTo));
    }), this.lastTime = t;
  }
  runWithTiming(t) {
    const n = t - this.lastTime, i = {}, r = performance.now();
    return this.forEachNode((a) => {
      const o = performance.now(), l = a.runWithTiming(Math.min(n / 1e3, this.clampDeltaTo)), c = performance.now() - o;
      i[a.key.toString()] = {
        duration: c,
        tasks: l
      };
    }), {
      total: performance.now() - r,
      stages: i
    };
  }
  getSchedule(t = {
    tasks: !0
  }) {
    return {
      stages: this.mapNodes((n) => {
        if (n === void 0)
          throw new Error("Stage not found");
        return {
          key: n.key.toString(),
          tasks: t.tasks ? n.getSchedule() : void 0
        };
      })
    };
  }
  dispose() {
    this.clear();
  }
}
const tn = (s, e) => {
  const t = hi(s, (r) => r);
  let n;
  const i = t.subscribe(async (r) => {
    n && n();
    const a = await e(r);
    a && (n = a);
  });
  Sn(() => {
    i(), n && n();
  });
};
function _3(s, e) {
  const t = {
    current: void 0
  };
  return tn(s, (n) => {
    t.current = e ? e(n) : n;
  }), t;
}
const xn = (s) => {
  const e = Ft(s), t = {
    set: (n) => {
      t.current = n, e.set(n);
    },
    subscribe: e.subscribe,
    update: (n) => {
      const i = n(t.current);
      t.current = i, e.set(i);
    },
    current: s
  };
  return t;
}, kd = new ni(75, 0, 0.1, 1e3);
kd.position.z = 5;
kd.lookAt(0, 0, 0);
const b3 = () => kd, v3 = (s) => {
  tn(s.size, (e) => {
    if (s.camera.current === kd) {
      const t = s.camera.current;
      t.aspect = e.width / e.height, t.updateProjectionMatrix(), s.invalidate();
    }
  });
}, y3 = Symbol("use-legacy-frame-compatibility-context"), x3 = () => {
  const s = {
    useFrameOrders: [],
    useRenderOrders: []
  };
  return xi(y3, s), s;
}, w3 = (s) => {
  const e = {
    frameInvalidated: !0,
    advance: !1,
    autoInvalidations: /* @__PURE__ */ new Set(),
    resetFrameInvalidation: () => {
      e.frameInvalidated = !1, e.advance = !1;
    },
    dispose: async (c = !1) => {
      await rd(), !(!e.shouldDispose && !c) && (e.disposableObjects.forEach((u, f) => {
        var h;
        (u === 0 || c) && ((h = f == null ? void 0 : f.dispose) == null || h.call(f), e.disposableObjects.delete(f));
      }), e.shouldDispose = !1);
    },
    collectDisposableObjects: (c, u) => {
      const f = u ?? [];
      return c && (c != null && c.dispose && typeof c.dispose == "function" && c.type !== "Scene" && f.push(c), Object.entries(c).forEach(([h, d]) => {
        if (h === "parent" || h === "children" || typeof d != "object")
          return;
        const m = d;
        m != null && m.dispose && e.collectDisposableObjects(m, f);
      })), f;
    },
    addDisposableObjects: (c) => {
      c.forEach((u) => {
        const f = e.disposableObjects.get(u);
        f ? e.disposableObjects.set(u, f + 1) : e.disposableObjects.set(u, 1);
      });
    },
    removeDisposableObjects: (c) => {
      c.length !== 0 && (c.forEach((u) => {
        const f = e.disposableObjects.get(u);
        f && f > 0 && e.disposableObjects.set(u, f - 1);
      }), e.shouldDispose = !0);
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: !1
  }, { useRenderOrders: t } = x3(), n = new A3(), i = n.createStage(Symbol("threlte-main-stage")), r = n.createStage(Symbol("threlte-render-stage"), {
    after: i,
    callback(c, u) {
      o.shouldRender() && u();
    }
  }), a = r.createTask(Symbol("threlte-auto-render-task"), (c) => {
    t.length > 0 || o.renderer.render(o.scene, o.camera.current);
  }), o = {
    size: hi([s.userSize, s.parentSize], ([c, u]) => c || u),
    camera: xn(b3()),
    scene: new Jl(),
    renderer: void 0,
    invalidate: () => {
      e.frameInvalidated = !0;
    },
    advance: () => {
      e.advance = !0;
    },
    colorSpace: xn(s.colorSpace),
    toneMapping: xn(s.toneMapping),
    dpr: xn(s.dpr),
    useLegacyLights: xn(s.useLegacyLights),
    shadows: xn(s.shadows),
    colorManagementEnabled: xn(s.colorManagementEnabled),
    renderMode: xn(s.renderMode),
    autoRender: xn(s.autoRender),
    scheduler: n,
    mainStage: i,
    renderStage: r,
    autoRenderTask: a,
    shouldRender: () => o.renderMode.current === "always" || o.renderMode.current === "on-demand" && (e.frameInvalidated || e.autoInvalidations.size > 0) || o.renderMode.current === "manual" && e.advance
  };
  v3(o);
  const l = xn({});
  return xi("threlte", o), xi("threlte-internal-context", e), xi("threlte-user-context", l), o;
}, $A = typeof window < "u", E3 = () => {
  const s = xn({ width: 0, height: 0 });
  if (!$A)
    return {
      parentSize: s,
      parentSizeAction: () => {
      }
    };
  const e = { childList: !0, subtree: !1, attributes: !1 };
  let t;
  const n = (o) => {
    i.disconnect(), r.disconnect(), i.observe(o), r.observe(o, e);
  }, i = new ResizeObserver(([o]) => {
    const { width: l, height: c } = o.contentRect;
    l === s.current.width && c === s.current.height || s.set({ width: l, height: c });
  }), r = new MutationObserver((o) => {
    for (const l of o)
      for (const c of l.removedNodes)
        if (t === c && t.parentElement) {
          n(t.parentElement);
          return;
        }
  }), a = (o) => {
    t = o;
    const l = t.parentElement;
    l && (s.set({
      width: l.clientWidth,
      height: l.clientHeight
    }), n(l));
  };
  return Sn(() => {
    i.disconnect(), r.disconnect();
  }), {
    parentSize: s,
    parentSizeAction: a
  };
};
function Uw(s, e) {
  const t = Ft(s);
  let n = s;
  const i = t.subscribe((o) => n = o);
  return Sn(i), {
    ...t,
    set: (o) => {
      if ((o == null ? void 0 : o.uuid) === (n == null ? void 0 : n.uuid))
        return;
      const l = n;
      t.set(o), e == null || e(o, l);
    },
    update: (o) => {
      const l = o(n);
      if ((l == null ? void 0 : l.uuid) === (n == null ? void 0 : n.uuid))
        return;
      const c = n;
      t.set(l), e == null || e(l, c);
    }
  };
}
const un = () => {
  const s = wi("threlte");
  if (s === void 0)
    throw new Error("No Threlte context found, are you using this hook inside of <Canvas>?");
  return s;
}, VA = Symbol("threlte-hierarchical-parent-context"), Er = () => wi(VA), C3 = (s) => xi(VA, s), S3 = (s) => {
  const e = Uw(s);
  return xi(VA, e), e;
};
function M3(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[6],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, [r]) {
      n && n.p && (!e || r & /*$$scope*/
      64) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[6],
        e ? xt(
          t,
          /*$$scope*/
          i[6],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[6]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
const I3 = () => ({
  onChildMount: wi("threlte-hierarchical-object-on-mount"),
  onChildDestroy: wi("threlte-hierarchical-object-on-destroy")
});
function T3(s, e, t) {
  var g;
  let n, { $$slots: i = {}, $$scope: r } = e, { object: a = void 0 } = e, { onChildMount: o = void 0 } = e;
  const l = (A) => {
    o == null || o(A);
  };
  let { onChildDestroy: c = void 0 } = e;
  const u = (A) => {
    c == null || c(A);
  }, { invalidate: f } = un(), h = Er();
  lt(s, h, (A) => t(5, n = A));
  let { parent: d = n } = e;
  const m = I3();
  a && ((g = m.onChildMount) == null || g.call(m, a), f());
  const _ = Uw(a, (A, v) => {
    var y, w;
    v && ((y = m.onChildDestroy) == null || y.call(m, v), f()), A && ((w = m.onChildMount) == null || w.call(m, A), f());
  });
  return Sn(() => {
    var A;
    a && ((A = m.onChildDestroy) == null || A.call(m, a), f());
  }), xi("threlte-hierarchical-object-on-mount", l), xi("threlte-hierarchical-object-on-destroy", u), C3(_), s.$$set = (A) => {
    "object" in A && t(2, a = A.object), "onChildMount" in A && t(3, o = A.onChildMount), "onChildDestroy" in A && t(4, c = A.onChildDestroy), "parent" in A && t(1, d = A.parent), "$$scope" in A && t(6, r = A.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*$parentStore*/
    32 && t(1, d = n), s.$$.dirty & /*object*/
    4 && _.set(a);
  }, [
    h,
    d,
    a,
    o,
    c,
    n,
    r,
    i
  ];
}
class ic extends Mt {
  constructor(e) {
    super(), Ct(this, e, T3, M3, _t, {
      object: 2,
      onChildMount: 3,
      onChildDestroy: 4,
      parent: 1
    });
  }
  get object() {
    return this.$$.ctx[2];
  }
  set object(e) {
    this.$$set({ object: e }), ne();
  }
  get onChildMount() {
    return this.$$.ctx[3];
  }
  set onChildMount(e) {
    this.$$set({ onChildMount: e }), ne();
  }
  get onChildDestroy() {
    return this.$$.ctx[4];
  }
  set onChildDestroy(e) {
    this.$$set({ onChildDestroy: e }), ne();
  }
  get parent() {
    return this.$$.ctx[1];
  }
  set parent(e) {
    this.$$set({ parent: e }), ne();
  }
}
St(ic, { object: {}, onChildMount: {}, onChildDestroy: {}, parent: {} }, ["default"], [], !0);
function B3(s) {
  let e;
  const t = (
    /*#slots*/
    s[1].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[4],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      16) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[4],
        e ? xt(
          t,
          /*$$scope*/
          i[4],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[4]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function P3(s) {
  let e, t;
  return e = new ic({
    props: {
      object: (
        /*object*/
        s[0]
      ),
      onChildMount: (
        /*func*/
        s[2]
      ),
      onChildDestroy: (
        /*func_1*/
        s[3]
      ),
      $$slots: { default: [B3] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, [i]) {
      const r = {};
      i & /*object*/
      1 && (r.object = /*object*/
      n[0]), i & /*object*/
      1 && (r.onChildMount = /*func*/
      n[2]), i & /*object*/
      1 && (r.onChildDestroy = /*func_1*/
      n[3]), i & /*$$scope*/
      16 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function R3(s, e, t) {
  let { $$slots: n = {}, $$scope: i } = e, { object: r } = e;
  const a = (l) => r.add(l), o = (l) => r.remove(l);
  return s.$$set = (l) => {
    "object" in l && t(0, r = l.object), "$$scope" in l && t(4, i = l.$$scope);
  }, [r, n, a, o, i];
}
class HA extends Mt {
  constructor(e) {
    super(), Ct(this, e, R3, P3, _t, { object: 0 });
  }
  get object() {
    return this.$$.ctx[0];
  }
  set object(e) {
    this.$$set({ object: e }), ne();
  }
}
St(HA, { object: {} }, ["default"], [], !0);
const Ub = (s, e) => {
  if (s === e)
    return !0;
  if (!s || !e)
    return !1;
  const t = s.length;
  if (e.length !== t)
    return !1;
  for (let n = 0; n < t; n++)
    if (s[n] !== e[n])
      return !1;
  return !0;
}, D3 = () => {
  xi("threlte-cache", []);
}, Fw = () => {
  const s = wi("threlte-cache");
  if (!s)
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  return {
    remember: (n, i) => {
      for (const a of s)
        if (Ub(i, a.keys)) {
          if (a.error)
            throw a.error;
          if (a.promise)
            return a.promise;
        }
      const r = {
        promise: n(),
        keys: i,
        value: void 0
      };
      return s.push(r), r.promise.catch((a) => {
        r.error = a;
      }), r.promise;
    },
    clear: (n) => {
      const i = s.findIndex((r) => Ub(n, r.keys));
      i !== -1 && s.splice(i, 1);
    }
  };
}, L3 = $l.replace("dev", ""), Tg = Number.parseInt(L3), k3 = (s) => {
  const e = Ft(void 0), t = (n, i) => {
    s.renderer = new xA({
      powerPreference: "high-performance",
      canvas: n,
      antialias: !0,
      alpha: !0,
      ...i
    }), e.set(s.renderer);
  };
  return tn([s.colorManagementEnabled], ([n]) => {
    cn.enabled = n;
  }), tn([e, s.colorSpace], ([n, i]) => {
    n && (n.outputColorSpace = i);
  }), tn([e, s.dpr], ([n, i]) => {
    n == null || n.setPixelRatio(i);
  }), tn([e, s.size], ([n, i]) => {
    var r;
    (r = n == null ? void 0 : n.xr) != null && r.isPresenting || n == null || n.setSize(i.width, i.height);
  }), tn([e, s.shadows], ([n, i]) => {
    n && (n.shadowMap.enabled = !!i, i && i !== !0 ? n.shadowMap.type = i : i === !0 && (n.shadowMap.type = sd));
  }), tn([e, s.toneMapping], ([n, i]) => {
    n && (n.toneMapping = i);
  }), tn([e, s.useLegacyLights], ([n, i]) => {
    n && i && (n.useLegacyLights = i);
  }), {
    createRenderer: t
  };
}, Ow = () => wi("threlte-internal-context");
function U3(s) {
  v1(s, "rf-o3oskp", "canvas.rf-o3oskp{display:block}");
}
function Fb(s) {
  let e, t;
  return e = new HA({
    props: {
      object: (
        /*ctx*/
        s[0].scene
      ),
      $$slots: { default: [F3] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      131072 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function F3(s) {
  let e;
  const t = (
    /*#slots*/
    s[15].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[17],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      131072) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[17],
        e ? xt(
          t,
          /*$$scope*/
          i[17],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[17]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function O3(s) {
  let e, t, n, i, r = (
    /*$initialized*/
    s[2] && Fb(s)
  );
  return {
    c() {
      e = Rs("canvas"), r && r.c(), Fr(e, "class", "rf-o3oskp");
    },
    m(a, o) {
      we(a, e, o), r && r.m(e, null), s[16](e), t = !0, n || (i = Fh(
        /*parentSizeAction*/
        s[4].call(null, e)
      ), n = !0);
    },
    p(a, [o]) {
      /*$initialized*/
      a[2] ? r ? (r.p(a, o), o & /*$initialized*/
      4 && O(r, 1)) : (r = Fb(a), r.c(), O(r, 1), r.m(e, null)) : r && (Li(), N(r, 1, 1, () => {
        r = null;
      }), ki());
    },
    i(a) {
      t || (O(r), t = !0);
    },
    o(a) {
      N(r), t = !1;
    },
    d(a) {
      a && xe(e), r && r.d(), s[16](null), n = !1, i();
    }
  };
}
function N3(s, e, t) {
  let n, { $$slots: i = {}, $$scope: r } = e, { colorManagementEnabled: a = !0 } = e, { colorSpace: o = "srgb" } = e, { dpr: l = $A ? window.devicePixelRatio : 1 } = e, { renderMode: c = "on-demand" } = e, { rendererParameters: u = void 0 } = e, { shadows: f = sd } = e, { size: h = void 0 } = e, { toneMapping: d = lA } = e, { useLegacyLights: m = !(Tg >= 155) } = e, { autoRender: _ = !0 } = e, g, A = Ft(!1);
  lt(s, A, (S) => t(2, n = S));
  const v = Ft(h), { parentSize: y, parentSizeAction: w } = E3(), E = w3({
    colorManagementEnabled: a,
    colorSpace: o,
    dpr: l,
    renderMode: c,
    parentSize: y,
    autoRender: _,
    shadows: f,
    toneMapping: d,
    useLegacyLights: m,
    userSize: v
  }), I = Ow(), C = E;
  tn([A, C.autoRender], ([S, D]) => (S && D ? C.autoRenderTask.start() : C.autoRenderTask.stop(), () => {
    C.autoRenderTask.stop();
  })), D3();
  const { createRenderer: B } = k3(C);
  Us(() => {
    B(g, u), C.renderer.setAnimationLoop((S) => {
      I.dispose(), C.scheduler.run(S), I.resetFrameInvalidation();
    }), A.set(!0);
  }), Sn(() => {
    var S;
    I.dispose(!0), C.scheduler.dispose(), (S = C.renderer) == null || S.dispose();
  });
  function T(S) {
    Ut[S ? "unshift" : "push"](() => {
      g = S, t(1, g);
    });
  }
  return s.$$set = (S) => {
    "colorManagementEnabled" in S && t(5, a = S.colorManagementEnabled), "colorSpace" in S && t(6, o = S.colorSpace), "dpr" in S && t(7, l = S.dpr), "renderMode" in S && t(8, c = S.renderMode), "rendererParameters" in S && t(9, u = S.rendererParameters), "shadows" in S && t(10, f = S.shadows), "size" in S && t(11, h = S.size), "toneMapping" in S && t(12, d = S.toneMapping), "useLegacyLights" in S && t(13, m = S.useLegacyLights), "autoRender" in S && t(14, _ = S.autoRender), "$$scope" in S && t(17, r = S.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*size*/
    2048 && v.set(h), s.$$.dirty & /*colorSpace*/
    64 && C.colorSpace.set(o), s.$$.dirty & /*dpr*/
    128 && C.dpr.set(l), s.$$.dirty & /*renderMode*/
    256 && C.renderMode.set(c), s.$$.dirty & /*autoRender*/
    16384 && C.autoRender.set(_), s.$$.dirty & /*shadows*/
    1024 && C.shadows.set(f), s.$$.dirty & /*toneMapping*/
    4096 && C.toneMapping.set(d);
  }, [
    C,
    g,
    n,
    A,
    w,
    a,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    _,
    i,
    T,
    r
  ];
}
class Nw extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      N3,
      O3,
      _t,
      {
        colorManagementEnabled: 5,
        colorSpace: 6,
        dpr: 7,
        renderMode: 8,
        rendererParameters: 9,
        shadows: 10,
        size: 11,
        toneMapping: 12,
        useLegacyLights: 13,
        autoRender: 14,
        ctx: 0
      },
      U3
    );
  }
  get colorManagementEnabled() {
    return this.$$.ctx[5];
  }
  set colorManagementEnabled(e) {
    this.$$set({ colorManagementEnabled: e }), ne();
  }
  get colorSpace() {
    return this.$$.ctx[6];
  }
  set colorSpace(e) {
    this.$$set({ colorSpace: e }), ne();
  }
  get dpr() {
    return this.$$.ctx[7];
  }
  set dpr(e) {
    this.$$set({ dpr: e }), ne();
  }
  get renderMode() {
    return this.$$.ctx[8];
  }
  set renderMode(e) {
    this.$$set({ renderMode: e }), ne();
  }
  get rendererParameters() {
    return this.$$.ctx[9];
  }
  set rendererParameters(e) {
    this.$$set({ rendererParameters: e }), ne();
  }
  get shadows() {
    return this.$$.ctx[10];
  }
  set shadows(e) {
    this.$$set({ shadows: e }), ne();
  }
  get size() {
    return this.$$.ctx[11];
  }
  set size(e) {
    this.$$set({ size: e }), ne();
  }
  get toneMapping() {
    return this.$$.ctx[12];
  }
  set toneMapping(e) {
    this.$$set({ toneMapping: e }), ne();
  }
  get useLegacyLights() {
    return this.$$.ctx[13];
  }
  set useLegacyLights(e) {
    this.$$set({ useLegacyLights: e }), ne();
  }
  get autoRender() {
    return this.$$.ctx[14];
  }
  set autoRender(e) {
    this.$$set({ autoRender: e }), ne();
  }
  get ctx() {
    return this.$$.ctx[0];
  }
}
St(Nw, { colorManagementEnabled: { type: "Boolean" }, colorSpace: {}, dpr: {}, renderMode: {}, rendererParameters: {}, shadows: {}, size: {}, toneMapping: {}, useLegacyLights: {}, autoRender: { type: "Boolean" } }, ["default"], ["ctx"], !0);
function G3(s) {
  let e;
  const t = (
    /*#slots*/
    s[9].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, [r]) {
      n && n.p && (!e || r & /*$$scope*/
      256) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? xt(
          t,
          /*$$scope*/
          i[8],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[8]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
const Ob = "threlte-disposable-object-context";
function Q3(s, e, t) {
  let n, i, { $$slots: r = {}, $$scope: a } = e;
  const { collectDisposableObjects: o, addDisposableObjects: l, removeDisposableObjects: c } = Ow();
  let { object: u = void 0 } = e, f = u, { dispose: h = void 0 } = e;
  const d = wi(Ob);
  lt(s, d, (g) => t(7, i = g));
  const m = Ft(h ?? i ?? !0);
  lt(s, m, (g) => t(6, n = g)), xi(Ob, m);
  let _ = n ? o(u) : [];
  return l(_), Sn(() => {
    c(_);
  }), s.$$set = (g) => {
    "object" in g && t(2, u = g.object), "dispose" in g && t(3, h = g.dispose), "$$scope" in g && t(8, a = g.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*dispose, $parentDispose*/
    136 && m.set(h ?? i ?? !0), s.$$.dirty & /*object, previousObject, disposables, $mergedDispose*/
    116 && u !== f && (c(_), t(5, _ = n ? o(u) : []), l(_), t(4, f = u));
  }, [
    d,
    m,
    u,
    h,
    f,
    _,
    n,
    i,
    a,
    r
  ];
}
class Gw extends Mt {
  constructor(e) {
    super(), Ct(this, e, Q3, G3, _t, { object: 2, dispose: 3 });
  }
  get object() {
    return this.$$.ctx[2];
  }
  set object(e) {
    this.$$set({ object: e }), ne();
  }
  get dispose() {
    return this.$$.ctx[3];
  }
  set dispose(e) {
    this.$$set({ dispose: e }), ne();
  }
}
St(Gw, { object: {}, dispose: {} }, ["default"], [], !0);
const z3 = /^\s*class\s+/, $3 = (s) => typeof s != "function" ? !1 : z3.test(s.toString()), V3 = (s) => Array.isArray(s), Nb = (s, e) => $3(s) ? V3(e) ? new s(...e) : new s() : s, H3 = (s) => "isObject3D" in s, Gb = (s) => "dispose" in s, Qw = (s, e) => {
  if (e.includes(".")) {
    const t = e.split("."), n = t.pop();
    for (let i = 0; i < t.length; i += 1)
      s = s[t[i]];
    return {
      target: s,
      key: n
    };
  } else
    return {
      target: s,
      key: e
    };
}, nm = Symbol("initialValueBeforeAttach"), j3 = () => {
  const { invalidate: s } = un();
  let e = !1, t = nm, n, i, r;
  const a = (l, c, u) => {
    if (o(), !u) {
      const f = l;
      ((f == null ? void 0 : f.isMaterial) || !1) && (u = "material"), ((f == null ? void 0 : f.isBufferGeometry) || (f == null ? void 0 : f.isGeometry) || !1) && (u = "geometry");
    }
    if (u) {
      if (typeof u == "function")
        n = u(c, l);
      else {
        const { target: f, key: h } = Qw(c, u);
        t = f[h], f[h] = l, i = f, r = h;
      }
      e = !0, s();
    }
  }, o = () => {
    e && (n ? (n(), n = void 0) : i && r && t !== nm && (i[r] = t, t = nm, i = void 0, r = void 0), e = !1, s());
  };
  return Sn(() => {
    o();
  }), {
    update: a
  };
}, W3 = (s) => s && s.isCamera, zw = (s) => s && s.isOrthographicCamera, $w = (s) => s && s.isPerspectiveCamera, q3 = (s) => $w(s) || zw(s), X3 = () => {
  const { invalidate: s, size: e, camera: t } = un();
  let n, i;
  Sn(() => {
    i == null || i();
  });
  const r = (l) => {
    n && (zw(n) ? (n.left = l.width / -2, n.right = l.width / 2, n.top = l.height / 2, n.bottom = l.height / -2, n.updateProjectionMatrix(), n.updateMatrixWorld(), s()) : $w(n) && (n.aspect = l.width / l.height, n.updateProjectionMatrix(), n.updateMatrixWorld(), s()));
  };
  return {
    update: (l, c) => {
      if (i == null || i(), c || !q3(l)) {
        n = void 0;
        return;
      }
      n = l, i = e.subscribe(r);
    },
    makeDefaultCamera: (l, c) => {
      !W3(l) || !c || (t.set(l), s());
    }
  };
}, us = () => {
  const s = Gr(), e = (n, i) => {
    const r = s.$$.callbacks[n];
    r && r.forEach((a) => {
      a(i);
    });
  };
  return Object.defineProperty(e, "hasEventListener", {
    value: (n) => !!s.$$.callbacks[n],
    enumerable: !0
  }), e;
}, Y3 = () => {
  const s = us(), e = [];
  let t, n = !1;
  const i = () => {
    e.forEach((o) => o()), e.length = 0, s("create", { ref: t, cleanup: (o) => {
      e.push(o);
    } });
  }, r = (a) => {
    t = a, n && i();
  };
  return Us(() => {
    i(), n = !0;
  }), Sn(() => {
    e.forEach((a) => a());
  }), {
    updateRef: r
  };
}, Qb = (s) => !!(s != null && s.addEventListener), K3 = () => {
  const s = us(), e = Gr(), t = (l) => {
    l != null && l.type && s(l.type, l);
  }, n = (l, c) => {
    Qb(l) && c.forEach((u) => {
      l.removeEventListener(u, t);
    });
  }, i = (l, c) => {
    Qb(l) && c.forEach((u) => {
      l.addEventListener(u, t);
    });
  }, r = Ft(), a = Ft([]);
  return tn([r, a], ([l, c]) => (i(l, c), () => n(l, c))), Us(() => {
    a.set(Object.keys(e.$$.callbacks));
  }), {
    updateRef: (l) => {
      r.set(l);
    }
  };
}, J3 = (s) => {
  const t = wi("threlte-plugin-context");
  if (!t)
    return;
  const n = Object.values(t).map((c) => c(s)).filter(Boolean), i = n.flatMap((c) => c.pluginProps ?? []);
  let r = [];
  return Sn(() => {
    r.forEach((c) => c());
  }), {
    updateRef: (c) => {
      r.forEach((u) => u()), r = [], n.forEach((u) => {
        var h;
        const f = (h = u.onRefChange) == null ? void 0 : h.call(u, c);
        f && r.push(f);
      });
    },
    updateProps: (c) => {
      n.forEach((u) => {
        var f;
        (f = u.onPropsChange) == null || f.call(u, c);
      });
    },
    updateRestProps: (c) => {
      n.forEach((u) => {
        var f;
        (f = u.onRestPropsChange) == null || f.call(u, c);
      });
    },
    pluginsProps: i
  };
}, Z3 = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]), eL = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]), tL = (s) => typeof s == "string" || typeof s == "number" || typeof s == "boolean" || typeof s > "u" || s === null, zb = (s, e, t) => {
  var n, i, r;
  return !Array.isArray(t) && typeof t == "number" && typeof ((n = s[e]) == null ? void 0 : n.setScalar) == "function" && // colors do have a setScalar function, but we don't want to use it, because
  // the hex notation (i.e. 0xff0000) is very popular and matches the number
  // type. So we exclude colors here.
  !((i = s[e]) != null && i.isColor) ? (a, o, l) => {
    a[o].setScalar(l);
  } : typeof ((r = s[e]) == null ? void 0 : r.set) == "function" ? Array.isArray(t) ? (a, o, l) => {
    a[o].set(...l);
  } : (a, o, l) => {
    a[o].set(l);
  } : (a, o, l) => {
    a[o] = l;
  };
}, nL = () => {
  const { invalidate: s } = un(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = (r, a, o, l) => {
    if (tL(o)) {
      const f = e.get(a);
      if (f && f.instance === r && f.value === o)
        return;
      e.set(a, {
        instance: r,
        value: o
      });
    }
    const { key: c, target: u } = Qw(r, a);
    if (o != null) {
      const f = t.get(a);
      if (f)
        f(u, c, o);
      else {
        const h = zb(u, c, o);
        t.set(a, h), h(u, c, o);
      }
    } else
      zb(u, c, o)(u, c, o);
    l.manualCamera || eL.has(c) && (u.isPerspectiveCamera || u.isOrthographicCamera) && u.updateProjectionMatrix();
  };
  return {
    updateProps: (r, a, o) => {
      var l;
      for (const c in a)
        !Z3.has(c) && !((l = o.pluginsProps) != null && l.includes(c)) && n(r, c, a[c], o), s();
    }
  };
}, iL = (s) => ({ ref: s & /*ref*/
2 }), $b = (s) => ({ ref: (
  /*ref*/
  s[1]
) }), rL = (s) => ({ ref: s & /*ref*/
2 }), Vb = (s) => ({ ref: (
  /*ref*/
  s[1]
) });
function Hb(s) {
  let e, t;
  return e = new Gw({
    props: {
      object: (
        /*ref*/
        s[1]
      ),
      dispose: (
        /*dispose*/
        s[0]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*ref*/
      2 && (r.object = /*ref*/
      n[1]), i & /*dispose*/
      1 && (r.dispose = /*dispose*/
      n[0]), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function sL(s) {
  let e;
  const t = (
    /*#slots*/
    s[10].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[11],
    $b
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      2050) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[11],
        e ? xt(
          t,
          /*$$scope*/
          i[11],
          r,
          iL
        ) : Et(
          /*$$scope*/
          i[11]
        ),
        $b
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function oL(s) {
  let e, t;
  return e = new HA({
    props: {
      object: (
        /*ref*/
        s[1]
      ),
      $$slots: { default: [aL] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*ref*/
      2 && (r.object = /*ref*/
      n[1]), i & /*$$scope, ref*/
      2050 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function aL(s) {
  let e;
  const t = (
    /*#slots*/
    s[10].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[11],
    Vb
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      2050) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[11],
        e ? xt(
          t,
          /*$$scope*/
          i[11],
          r,
          rL
        ) : Et(
          /*$$scope*/
          i[11]
        ),
        Vb
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function lL(s) {
  let e = Gb(
    /*ref*/
    s[1]
  ), t, n, i, r, a, o, l = e && Hb(s);
  const c = [oL, sL], u = [];
  function f(h, d) {
    return d & /*ref*/
    2 && (n = null), n == null && (n = !!H3(
      /*ref*/
      h[1]
    )), n ? 0 : 1;
  }
  return i = f(s, -1), r = u[i] = c[i](s), {
    c() {
      l && l.c(), t = Me(), r.c(), a = ji();
    },
    m(h, d) {
      l && l.m(h, d), we(h, t, d), u[i].m(h, d), we(h, a, d), o = !0;
    },
    p(h, [d]) {
      d & /*ref*/
      2 && (e = Gb(
        /*ref*/
        h[1]
      )), e ? l ? (l.p(h, d), d & /*ref*/
      2 && O(l, 1)) : (l = Hb(h), l.c(), O(l, 1), l.m(t.parentNode, t)) : l && (Li(), N(l, 1, 1, () => {
        l = null;
      }), ki());
      let m = i;
      i = f(h, d), i === m ? u[i].p(h, d) : (Li(), N(u[m], 1, 1, () => {
        u[m] = null;
      }), ki(), r = u[i], r ? r.p(h, d) : (r = u[i] = c[i](h), r.c()), O(r, 1), r.m(a.parentNode, a));
    },
    i(h) {
      o || (O(l), O(r), o = !0);
    },
    o(h) {
      N(l), N(r), o = !1;
    },
    d(h) {
      h && (xe(t), xe(a)), l && l.d(h), u[i].d(h);
    }
  };
}
function cL(s, e, t) {
  const n = ["is", "args", "attach", "manual", "makeDefault", "dispose", "ref"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { is: l } = e, { args: c = void 0 } = e, { attach: u = void 0 } = e, { manual: f = void 0 } = e, { makeDefault: h = void 0 } = e, { dispose: d = void 0 } = e;
  const m = Er();
  lt(s, m, (D) => t(9, r = D));
  const _ = Y3();
  let g = Nb(l, c);
  _.updateRef(g);
  let A = !1;
  const v = () => {
    if (!A) {
      A = !0;
      return;
    }
    t(1, g = Nb(l, c)), _.updateRef(g);
  };
  let { ref: y = g } = e;
  const w = S3(g), E = J3({ ref: g, props: e }), I = (E == null ? void 0 : E.pluginsProps) ?? [], C = nL(), B = X3(), T = j3(), S = K3();
  return s.$$set = (D) => {
    t(23, e = We(We({}, e), rn(D))), t(22, i = ft(e, n)), "is" in D && t(4, l = D.is), "args" in D && t(5, c = D.args), "attach" in D && t(6, u = D.attach), "manual" in D && t(7, f = D.manual), "makeDefault" in D && t(8, h = D.makeDefault), "dispose" in D && t(0, d = D.dispose), "ref" in D && t(3, y = D.ref), "$$scope" in D && t(11, o = D.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*is, args*/
    48 && v(), s.$$.dirty & /*ref*/
    2 && t(3, y = g), s.$$.dirty & /*ref*/
    2 && w.set(g), C.updateProps(g, i, { manualCamera: f, pluginsProps: I }), s.$$.dirty & /*ref, manual*/
    130 && B.update(g, f), s.$$.dirty & /*ref, makeDefault*/
    258 && B.makeDefaultCamera(g, h), s.$$.dirty & /*ref, $parent, attach*/
    578 && T.update(g, r, u), s.$$.dirty & /*ref*/
    2 && S.updateRef(g), s.$$.dirty & /*ref*/
    2 && (E == null || E.updateRef(g)), E == null || E.updateProps(e), E == null || E.updateRestProps(i);
  }, e = rn(e), [
    d,
    g,
    m,
    y,
    l,
    c,
    u,
    f,
    h,
    r,
    a,
    o
  ];
}
let jA = class extends Mt {
  constructor(e) {
    super(), Ct(this, e, cL, lL, _t, {
      is: 4,
      args: 5,
      attach: 6,
      manual: 7,
      makeDefault: 8,
      dispose: 0,
      ref: 3
    });
  }
  get is() {
    return this.$$.ctx[4];
  }
  set is(e) {
    this.$$set({ is: e }), ne();
  }
  get args() {
    return this.$$.ctx[5];
  }
  set args(e) {
    this.$$set({ args: e }), ne();
  }
  get attach() {
    return this.$$.ctx[6];
  }
  set attach(e) {
    this.$$set({ attach: e }), ne();
  }
  get manual() {
    return this.$$.ctx[7];
  }
  set manual(e) {
    this.$$set({ manual: e }), ne();
  }
  get makeDefault() {
    return this.$$.ctx[8];
  }
  set makeDefault(e) {
    this.$$set({ makeDefault: e }), ne();
  }
  get dispose() {
    return this.$$.ctx[0];
  }
  set dispose(e) {
    this.$$set({ dispose: e }), ne();
  }
  get ref() {
    return this.$$.ctx[3];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
};
St(jA, { is: {}, args: {}, attach: {}, manual: {}, makeDefault: {}, dispose: {}, ref: {} }, ["default"], [], !0);
const uL = {}, fL = (s, e) => {
  const t = uL[e] || d3[e];
  if (!t)
    throw new Error(`No Three.js module found for ${e}. Did you forget to extend the catalogue?`);
  return {
    ...s,
    props: {
      ...s.props,
      is: t
    }
  };
}, hL = (s) => new Proxy(class {
}, {
  construct(e, [t]) {
    const n = t;
    return new jA(fL(n, s));
  }
}), ee = new Proxy(class {
}, {
  construct(s, [e]) {
    const t = e;
    return new jA(t);
  },
  get(s, e) {
    return hL(e);
  }
});
function WA(s, e) {
  const t = "threlte-plugin-context";
  if (Array.isArray(s)) {
    const [n, i] = s;
    xi(t, {
      ...wi(t),
      [n]: i
    });
  } else {
    const n = s, i = e;
    if (!i)
      return;
    xi(t, {
      ...wi(t),
      [n]: i
    });
  }
}
function On(s, e, t) {
  if (!$A)
    return {
      task: void 0,
      start: () => {
      },
      stop: () => {
      },
      started: oA(!1)
    };
  let n, i, r;
  oo.isKey(s) ? (n = s, i = e, r = t) : (n = Symbol("useTask"), i = s, r = e);
  const a = un();
  let o = a.mainStage;
  if (r) {
    if (r.stage)
      if (oo.isValue(r.stage))
        o = r.stage;
      else {
        const d = a.scheduler.getStage(r.stage);
        if (!d)
          throw new Error(`No stage found with key ${r.stage.toString()}`);
        o = d;
      }
    else if (r.after)
      if (Array.isArray(r.after))
        for (let d = 0; d < r.after.length; d++) {
          const m = r.after[d];
          if (oo.isValue(m)) {
            o = m.stage;
            break;
          }
        }
      else
        oo.isValue(r.after) && (o = r.after.stage);
    else if (r.before)
      if (Array.isArray(r.before))
        for (let d = 0; d < r.before.length; d++) {
          const m = r.before[d];
          if (oo.isValue(m)) {
            o = m.stage;
            break;
          }
        }
      else
        oo.isValue(r.before) && (o = r.before.stage);
  }
  const { autoInvalidations: l } = wi("threlte-internal-context"), c = Ft(!1), u = o.createTask(n, i, r), f = () => {
    c.set(!0), ((r == null ? void 0 : r.autoInvalidate) ?? !0) && l.add(i), u.start();
  }, h = () => {
    c.set(!0), ((r == null ? void 0 : r.autoInvalidate) ?? !0) && l.delete(i), u.stop();
  };
  return (r == null ? void 0 : r.autoStart) ?? !0 ? f() : h(), Sn(() => {
    o && o.removeTask(n);
  }), {
    task: u,
    start: f,
    stop: h,
    started: {
      subscribe: c.subscribe
    }
  };
}
function jb(s, e) {
  const { scheduler: t } = un();
  return t.getStage(s) ?? t.createStage(s, e);
}
function qA(s, e, t) {
  const n = wi("threlte-user-context");
  if (!n)
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  return s ? s && !e ? hi(n, (i) => i[s]) : (n.update((i) => {
    if (s in i) {
      if (!t || t.existing === "skip")
        return i;
      if (t.existing === "merge")
        return Object.assign(i[s], e), i;
    }
    return i[s] = e, i;
  }), n.current[s]) : {
    subscribe: n.subscribe
  };
}
const Dl = (s) => {
  const e = Ft(void 0), t = Ft(void 0);
  return s.then((n) => {
    e.set(n);
  }).catch((n) => {
    console.error("Error in asyncWritable:", n.message), t.set(n);
  }), Object.assign(Object.assign(s, e), { error: t, promise: s });
};
function $u(s, e) {
  const { remember: t, clear: n } = Fw();
  let i;
  const r = () => {
    var c;
    const l = new s(...(e == null ? void 0 : e.args) ?? []);
    return (c = e == null ? void 0 : e.extend) == null || c.call(e, l), l;
  };
  return {
    load: (l, c) => {
      const u = async (f) => {
        var h;
        if (i || (i = r()), "loadAsync" in i) {
          const d = await i.loadAsync(f, c == null ? void 0 : c.onProgress);
          return ((h = c == null ? void 0 : c.transform) == null ? void 0 : h.call(c, d)) ?? d;
        } else
          return new Promise((d, m) => {
            i.load(f, (_) => {
              var g;
              return d(((g = c == null ? void 0 : c.transform) == null ? void 0 : g.call(c, _)) ?? _);
            }, (_) => {
              var g;
              return (g = c == null ? void 0 : c.onProgress) == null ? void 0 : g.call(c, _);
            }, m);
          });
      };
      if (Array.isArray(l)) {
        const f = l.map((d) => t(() => u(d), [s, d]));
        return Dl(Promise.all(f));
      } else if (typeof l == "string") {
        const f = t(() => u(l), [s, l]);
        return Dl(f);
      } else {
        const f = Object.values(l).map((d) => t(() => u(d), [s, d]));
        return Dl(Promise.all(f).then((d) => Object.fromEntries(Object.entries(l).map(([m], _) => [m, d[_]]))));
      }
    },
    clear: (l) => {
      Array.isArray(l) ? l.forEach((c) => {
        n([s, c]);
      }) : typeof l == "string" ? n([s, l]) : Object.entries(l).forEach(([c, u]) => {
        n([s, c, u]);
      });
    },
    loader: i
  };
}
const An = () => {
  const s = Gr(), e = Ft(void 0);
  return tn(e, (t) => {
    t && Object.entries(s.$$.callbacks).forEach((n) => {
      const [i, r] = n;
      i in t.$$.callbacks && Array.isArray(t.$$.callbacks[i]) ? t.$$.callbacks[i].push(...r) : t.$$.callbacks[i] = r;
    });
  }), e;
};
var dL = function() {
  var s = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), n = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var i = WebAssembly.validate(t) ? e : s, r, a = WebAssembly.instantiate(o(i), {}).then(function(A) {
    r = A.instance, r.exports.__wasm_call_ctors();
  });
  function o(A) {
    for (var v = new Uint8Array(A.length), y = 0; y < A.length; ++y) {
      var w = A.charCodeAt(y);
      v[y] = w > 96 ? w - 97 : w > 64 ? w - 39 : w + 4;
    }
    for (var E = 0, y = 0; y < A.length; ++y)
      v[E++] = v[y] < 60 ? n[v[y]] : (v[y] - 60) * 64 + v[++y];
    return v.buffer.slice(0, E);
  }
  function l(A, v, y, w, E, I) {
    var C = r.exports.sbrk, B = y + 3 & -4, T = C(B * w), S = C(E.length), D = new Uint8Array(r.exports.memory.buffer);
    D.set(E, S);
    var R = A(T, y, w, S, E.length);
    if (R == 0 && I && I(T, B, w), v.set(D.subarray(T, T + y * w)), C(T - C(0)), R != 0)
      throw new Error("Malformed buffer data: " + R);
  }
  var c = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, u = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, f = [], h = 0;
  function d(A) {
    var v = {
      object: new Worker(A),
      pending: 0,
      requests: {}
    };
    return v.object.onmessage = function(y) {
      var w = y.data;
      v.pending -= w.count, v.requests[w.id][w.action](w.value), delete v.requests[w.id];
    }, v;
  }
  function m(A) {
    for (var v = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(i)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + l.toString() + g.toString(), y = new Blob([v], { type: "text/javascript" }), w = URL.createObjectURL(y), E = 0; E < A; ++E)
      f[E] = d(w);
    URL.revokeObjectURL(w);
  }
  function _(A, v, y, w, E) {
    for (var I = f[0], C = 1; C < f.length; ++C)
      f[C].pending < I.pending && (I = f[C]);
    return new Promise(function(B, T) {
      var S = new Uint8Array(y), D = h++;
      I.pending += A, I.requests[D] = { resolve: B, reject: T }, I.object.postMessage({ id: D, count: A, size: v, source: S, mode: w, filter: E }, [S.buffer]);
    });
  }
  function g(A) {
    a.then(function() {
      var v = A.data;
      try {
        var y = new Uint8Array(v.count * v.size);
        l(r.exports[v.mode], y, v.count, v.size, v.source, r.exports[v.filter]), self.postMessage({ id: v.id, count: v.count, action: "resolve", value: y }, [y.buffer]);
      } catch (w) {
        self.postMessage({ id: v.id, count: v.count, action: "reject", value: w });
      }
    });
  }
  return {
    ready: a,
    supported: !0,
    useWorkers: function(A) {
      m(A);
    },
    decodeVertexBuffer: function(A, v, y, w, E) {
      l(r.exports.meshopt_decodeVertexBuffer, A, v, y, w, r.exports[c[E]]);
    },
    decodeIndexBuffer: function(A, v, y, w) {
      l(r.exports.meshopt_decodeIndexBuffer, A, v, y, w);
    },
    decodeIndexSequence: function(A, v, y, w) {
      l(r.exports.meshopt_decodeIndexSequence, A, v, y, w);
    },
    decodeGltfBuffer: function(A, v, y, w, E, I) {
      l(r.exports[u[E]], A, v, y, w, r.exports[c[I]]);
    },
    decodeGltfBufferAsync: function(A, v, y, w, E) {
      return f.length > 0 ? _(A, v, y, u[w], c[E]) : a.then(function() {
        var I = new Uint8Array(A * v);
        return l(r.exports[u[w]], I, A, v, y, r.exports[c[E]]), I;
      });
    }
  };
}();
const im = /* @__PURE__ */ new WeakMap();
class pL extends ai {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, i) {
    const r = new ri(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      this.parse(a, t, i);
    }, n, i);
  }
  parse(e, t, n = () => {
  }) {
    this.decodeDracoFile(e, t, null, null, Qn).catch(n);
  }
  decodeDracoFile(e, t, n, i, r = Bn, a = () => {
  }) {
    const o = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
      vertexColorSpace: r
    };
    return this.decodeGeometry(e, o).then(t).catch(a);
  }
  decodeGeometry(e, t) {
    const n = JSON.stringify(t);
    if (im.has(e)) {
      const l = im.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const r = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(r, a).then((l) => (i = l, new Promise((c, u) => {
      i._callbacks[r] = { resolve: c, reject: u }, i.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return o.catch(() => !0).then(() => {
      i && r && this._releaseTask(i, r);
    }), im.set(e, {
      key: n,
      promise: o
    }), o;
  }
  _createGeometry(e) {
    const t = new Dt();
    e.index && t.setIndex(new Rt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n], r = i.name, a = i.array, o = i.itemSize, l = new Rt(a, o);
      r === "color" && (this._assignVertexColorSpace(l, i.vertexColorSpace), l.normalized = !(a instanceof Float32Array)), t.setAttribute(r, l);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== Qn)
      return;
    const n = new Je();
    for (let i = 0, r = e.count; i < r; i++)
      n.fromBufferAttribute(e, i).convertSRGBToLinear(), e.setXYZ(i, n.r, n.g, n.b);
  }
  _loadLibrary(e, t) {
    const n = new ri(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, r) => {
      n.load(e, i, void 0, r);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const i = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const r = mL.toString(), a = [
        "/* draco decoder */",
        i,
        "",
        "/* worker */",
        r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([a]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function(r) {
          const a = r.data;
          switch (a.type) {
            case "decode":
              i._callbacks[a.id].resolve(a);
              break;
            case "error":
              i._callbacks[a.id].reject(a);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"');
          }
        }, this.workerPool.push(i);
      } else
        this.workerPool.sort(function(i, r) {
          return i._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function mL() {
  let s, e;
  onmessage = function(a) {
    const o = a.data;
    switch (o.type) {
      case "init":
        s = o.decoderConfig, e = new Promise(function(u) {
          s.onModuleLoaded = function(f) {
            u({ draco: f });
          }, DracoDecoderModule(s);
        });
        break;
      case "decode":
        const l = o.buffer, c = o.taskConfig;
        e.then((u) => {
          const f = u.draco, h = new f.Decoder();
          try {
            const d = t(f, h, new Int8Array(l), c), m = d.attributes.map((_) => _.array.buffer);
            d.index && m.push(d.index.array.buffer), self.postMessage({ type: "decode", id: o.id, geometry: d }, m);
          } catch (d) {
            console.error(d), self.postMessage({ type: "error", id: o.id, error: d.message });
          } finally {
            f.destroy(h);
          }
        });
        break;
    }
  };
  function t(a, o, l, c) {
    const u = c.attributeIDs, f = c.attributeTypes;
    let h, d;
    const m = o.GetEncodedGeometryType(l);
    if (m === a.TRIANGULAR_MESH)
      h = new a.Mesh(), d = o.DecodeArrayToMesh(l, l.byteLength, h);
    else if (m === a.POINT_CLOUD)
      h = new a.PointCloud(), d = o.DecodeArrayToPointCloud(l, l.byteLength, h);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!d.ok() || h.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
    const _ = { index: null, attributes: [] };
    for (const g in u) {
      const A = self[f[g]];
      let v, y;
      if (c.useUniqueIDs)
        y = u[g], v = o.GetAttributeByUniqueId(h, y);
      else {
        if (y = o.GetAttributeId(h, a[u[g]]), y === -1)
          continue;
        v = o.GetAttribute(h, y);
      }
      const w = i(a, o, h, g, A, v);
      g === "color" && (w.vertexColorSpace = c.vertexColorSpace), _.attributes.push(w);
    }
    return m === a.TRIANGULAR_MESH && (_.index = n(a, o, h)), a.destroy(h), _;
  }
  function n(a, o, l) {
    const u = l.num_faces() * 3, f = u * 4, h = a._malloc(f);
    o.GetTrianglesUInt32Array(l, f, h);
    const d = new Uint32Array(a.HEAPF32.buffer, h, u).slice();
    return a._free(h), { array: d, itemSize: 1 };
  }
  function i(a, o, l, c, u, f) {
    const h = f.num_components(), m = l.num_points() * h, _ = m * u.BYTES_PER_ELEMENT, g = r(a, u), A = a._malloc(_);
    o.GetAttributeDataArrayForAllPoints(l, f, g, _, A);
    const v = new u(a.HEAPF32.buffer, A, m).slice();
    return a._free(A), {
      name: c,
      array: v,
      itemSize: h
    };
  }
  function r(a, o) {
    switch (o) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
function Wb(s, e) {
  if (e === gx)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (e === Xh || e === dA) {
    let t = s.getIndex();
    if (t === null) {
      const a = [], o = s.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++)
          a.push(l);
        s.setIndex(a), t = s.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
    }
    const n = t.count - 2, i = [];
    if (e === Xh)
      for (let a = 1; a <= n; a++)
        i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0 ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2))) : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = s.clone();
    return r.setIndex(i), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
}
function XA(s, e = Math.PI / 3) {
  const t = Math.cos(e), n = (1 + 1e-10) * 100, i = [new H(), new H(), new H()], r = new H(), a = new H(), o = new H(), l = new H();
  function c(_) {
    const g = ~~(_.x * n), A = ~~(_.y * n), v = ~~(_.z * n);
    return `${g},${A},${v}`;
  }
  const u = s.index ? s.toNonIndexed() : s, f = u.attributes.position, h = {};
  for (let _ = 0, g = f.count / 3; _ < g; _++) {
    const A = 3 * _, v = i[0].fromBufferAttribute(f, A + 0), y = i[1].fromBufferAttribute(f, A + 1), w = i[2].fromBufferAttribute(f, A + 2);
    r.subVectors(w, y), a.subVectors(v, y);
    const E = new H().crossVectors(r, a).normalize();
    for (let I = 0; I < 3; I++) {
      const C = i[I], B = c(C);
      B in h || (h[B] = []), h[B].push(E);
    }
  }
  const d = new Float32Array(f.count * 3), m = new Rt(d, 3, !1);
  for (let _ = 0, g = f.count / 3; _ < g; _++) {
    const A = 3 * _, v = i[0].fromBufferAttribute(f, A + 0), y = i[1].fromBufferAttribute(f, A + 1), w = i[2].fromBufferAttribute(f, A + 2);
    r.subVectors(w, y), a.subVectors(v, y), o.crossVectors(r, a).normalize();
    for (let E = 0; E < 3; E++) {
      const I = i[E], C = c(I), B = h[C];
      l.set(0, 0, 0);
      for (let T = 0, S = B.length; T < S; T++) {
        const D = B[T];
        o.dot(D) > t && l.add(D);
      }
      l.normalize(), m.setXYZ(A + E, l.x, l.y, l.z);
    }
  }
  return u.setAttribute("normal", m), u;
}
class gL extends ai {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new yL(t);
    }), this.register(function(t) {
      return new xL(t);
    }), this.register(function(t) {
      return new PL(t);
    }), this.register(function(t) {
      return new RL(t);
    }), this.register(function(t) {
      return new DL(t);
    }), this.register(function(t) {
      return new EL(t);
    }), this.register(function(t) {
      return new CL(t);
    }), this.register(function(t) {
      return new SL(t);
    }), this.register(function(t) {
      return new ML(t);
    }), this.register(function(t) {
      return new vL(t);
    }), this.register(function(t) {
      return new IL(t);
    }), this.register(function(t) {
      return new wL(t);
    }), this.register(function(t) {
      return new BL(t);
    }), this.register(function(t) {
      return new TL(t);
    }), this.register(function(t) {
      return new _L(t);
    }), this.register(function(t) {
      return new LL(t);
    }), this.register(function(t) {
      return new kL(t);
    });
  }
  load(e, t, n, i) {
    const r = this;
    let a;
    if (this.resourcePath !== "")
      a = this.resourcePath;
    else if (this.path !== "") {
      const c = po.extractUrlBase(e);
      a = po.resolveURL(c, this.path);
    } else
      a = po.extractUrlBase(e);
    this.manager.itemStart(e);
    const o = function(c) {
      i ? i(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new ri(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        r.parse(c, a, function(u) {
          t(u), r.manager.itemEnd(e);
        }, o);
      } catch (u) {
        o(u);
      }
    }, n, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, i) {
    let r;
    const a = {}, o = {}, l = new TextDecoder();
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === Vw) {
        try {
          a[Ht.KHR_BINARY_GLTF] = new UL(e);
        } catch (f) {
          i && i(f);
          return;
        }
        r = JSON.parse(a[Ht.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(l.decode(e));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new XL(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const f = this.pluginCallbacks[u](c);
      f.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[f.name] = f, a[f.name] = !0;
    }
    if (r.extensionsUsed)
      for (let u = 0; u < r.extensionsUsed.length; ++u) {
        const f = r.extensionsUsed[u], h = r.extensionsRequired || [];
        switch (f) {
          case Ht.KHR_MATERIALS_UNLIT:
            a[f] = new bL();
            break;
          case Ht.KHR_DRACO_MESH_COMPRESSION:
            a[f] = new FL(r, this.dracoLoader);
            break;
          case Ht.KHR_TEXTURE_TRANSFORM:
            a[f] = new OL();
            break;
          case Ht.KHR_MESH_QUANTIZATION:
            a[f] = new NL();
            break;
          default:
            h.indexOf(f) >= 0 && o[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function AL() {
  let s = {};
  return {
    get: function(e) {
      return s[e];
    },
    add: function(e, t) {
      s[e] = t;
    },
    remove: function(e) {
      delete s[e];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const Ht = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class _L {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let i = t.cache.get(n);
    if (i)
      return i;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new Je(16777215);
    l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], Bn);
    const f = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new Rd(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new FA(u), c.distance = f;
        break;
      case "spot":
        c = new UA(u), c.distance = f, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, ao(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(c), t.cache.add(n, i), i;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
    return o === void 0 ? null : this._loadLight(o).then(function(l) {
      return n._getNodeRef(t.cache, o, l);
    });
  }
}
class bL {
  constructor() {
    this.name = Ht.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return $n;
  }
  extendParams(e, t, n) {
    const i = [];
    e.color = new Je(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const a = r.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], Bn), e.opacity = a[3];
      }
      r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, Qn));
    }
    return Promise.all(i);
  }
}
class vL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class yL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ke(o, o);
    }
    return Promise.all(r);
  }
}
class xL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class wL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
  }
}
class EL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new Je(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = i.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], Bn);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Qn)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
  }
}
class CL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
  }
}
class SL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Je().setRGB(o[0], o[1], o[2], Bn), Promise.all(r);
  }
}
class ML {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class IL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Je().setRGB(o[0], o[1], o[2], Bn), a.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Qn)), Promise.all(r);
  }
}
class TL {
  constructor(e) {
    this.parser = e, this.name = Ht.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
  }
}
class BL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : wr;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
  }
}
class PL {
  constructor(e) {
    this.parser = e, this.name = Ht.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name])
      return null;
    const r = i.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, a);
  }
}
class RL {
  constructor(e) {
    this.parser = e, this.name = Ht.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class DL {
  constructor(e) {
    this.parser = e, this.name = Ht.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class LL {
  constructor(e) {
    this.name = Ht.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name], r = this.parser.getDependency("buffer", i.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(o) {
        const l = i.byteOffset || 0, c = i.byteLength || 0, u = i.count, f = i.byteStride, h = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(u, f, h, i.mode, i.filter).then(function(d) {
          return d.buffer;
        }) : a.ready.then(function() {
          const d = new ArrayBuffer(u * f);
          return a.decodeGltfBuffer(new Uint8Array(d), u, f, h, i.mode, i.filter), d;
        });
      });
    } else
      return null;
  }
}
class kL {
  constructor(e) {
    this.name = Ht.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const c of i.primitives)
      if (c.mode !== Ar.TRIANGLES && c.mode !== Ar.TRIANGLE_STRIP && c.mode !== Ar.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const a = n.extensions[this.name].attributes, o = [], l = {};
    for (const c in a)
      o.push(this.parser.getDependency("accessor", a[c]).then((u) => (l[c] = u, l[c])));
    return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((c) => {
      const u = c.pop(), f = u.isGroup ? u.children : [u], h = c[0].count, d = [];
      for (const m of f) {
        const _ = new st(), g = new H(), A = new en(), v = new H(1, 1, 1), y = new Zl(m.geometry, m.material, h);
        for (let w = 0; w < h; w++)
          l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, w), l.ROTATION && A.fromBufferAttribute(l.ROTATION, w), l.SCALE && v.fromBufferAttribute(l.SCALE, w), y.setMatrixAt(w, _.compose(g, A, v));
        for (const w in l)
          if (w === "_COLOR_0") {
            const E = l[w];
            y.instanceColor = new cs(E.array, E.itemSize, E.normalized);
          } else
            w !== "TRANSLATION" && w !== "ROTATION" && w !== "SCALE" && m.geometry.setAttribute(w, l[w]);
        Gt.prototype.copy.call(y, m), this.parser.assignFinalMaterial(y), d.push(y);
      }
      return u.isGroup ? (u.clear(), u.add(...d), u) : d[0];
    }));
  }
}
const Vw = "glTF", Pc = 12, qb = { JSON: 1313821514, BIN: 5130562 };
class UL {
  constructor(e) {
    this.name = Ht.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Pc), n = new TextDecoder();
    if (this.header = {
      magic: n.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Vw)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - Pc, r = new DataView(e, Pc);
    let a = 0;
    for (; a < i; ) {
      const o = r.getUint32(a, !0);
      a += 4;
      const l = r.getUint32(a, !0);
      if (a += 4, l === qb.JSON) {
        const c = new Uint8Array(e, Pc + a, o);
        this.content = n.decode(c);
      } else if (l === qb.BIN) {
        const c = Pc + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class FL {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ht.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
    for (const u in a) {
      const f = Bg[u] || u.toLowerCase();
      o[f] = a[u];
    }
    for (const u in e.attributes) {
      const f = Bg[u] || u.toLowerCase();
      if (a[u] !== void 0) {
        const h = n.accessors[e.attributes[u]], d = Ll[h.componentType];
        c[f] = d.name, l[f] = h.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(u) {
      return new Promise(function(f, h) {
        i.decodeDracoFile(u, function(d) {
          for (const m in d.attributes) {
            const _ = d.attributes[m], g = l[m];
            g !== void 0 && (_.normalized = g);
          }
          f(d);
        }, o, c, Bn, h);
      });
    });
  }
}
class OL {
  constructor() {
    this.name = Ht.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class NL {
  constructor() {
    this.name = Ht.KHR_MESH_QUANTIZATION;
  }
}
class Hw extends nc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i;
    for (let a = 0; a !== i; a++)
      t[a] = n[r + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, c = o * 3, u = i - t, f = (n - t) / u, h = f * f, d = h * f, m = e * c, _ = m - c, g = -2 * d + 3 * h, A = d - h, v = 1 - g, y = A - h + f;
    for (let w = 0; w !== o; w++) {
      const E = a[_ + w + o], I = a[_ + w + l] * u, C = a[m + w + o], B = a[m + w] * u;
      r[w] = v * E + y * I + g * C + A * B;
    }
    return r;
  }
}
const GL = new en();
class QL extends Hw {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return GL.fromArray(r).normalize().toArray(r), r;
  }
}
const Ar = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Ll = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Xb = {
  9728: nn,
  9729: Yt,
  9984: ad,
  9985: Tl,
  9986: oa,
  9987: Yi
}, Yb = {
  33071: yi,
  33648: Ul,
  10497: Or
}, rm = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Bg = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, io = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, zL = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: ga,
  STEP: Nl
}, sm = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function $L(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Qu({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Hi
  })), s.DefaultMaterial;
}
function qo(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function ao(s, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function VL(s, e, t) {
  let n = !1, i = !1, r = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const f = e[c];
    if (f.POSITION !== void 0 && (n = !0), f.NORMAL !== void 0 && (i = !0), f.COLOR_0 !== void 0 && (r = !0), n && i && r)
      break;
  }
  if (!n && !i && !r)
    return Promise.resolve(s);
  const a = [], o = [], l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const f = e[c];
    if (n) {
      const h = f.POSITION !== void 0 ? t.getDependency("accessor", f.POSITION) : s.attributes.position;
      a.push(h);
    }
    if (i) {
      const h = f.NORMAL !== void 0 ? t.getDependency("accessor", f.NORMAL) : s.attributes.normal;
      o.push(h);
    }
    if (r) {
      const h = f.COLOR_0 !== void 0 ? t.getDependency("accessor", f.COLOR_0) : s.attributes.color;
      l.push(h);
    }
  }
  return Promise.all([
    Promise.all(a),
    Promise.all(o),
    Promise.all(l)
  ]).then(function(c) {
    const u = c[0], f = c[1], h = c[2];
    return n && (s.morphAttributes.position = u), i && (s.morphAttributes.normal = f), r && (s.morphAttributes.color = h), s.morphTargetsRelative = !0, s;
  });
}
function HL(s, e) {
  if (s.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function jL(s) {
  let e;
  const t = s.extensions && s.extensions[Ht.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + om(t.attributes) : e = s.indices + ":" + om(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let n = 0, i = s.targets.length; n < i; n++)
      e += ":" + om(s.targets[n]);
  return e;
}
function om(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++)
    e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function Pg(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function WL(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const qL = new st();
class XL {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new AL(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, i = !1, r = -1;
    typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && r < 98 ? this.textureLoader = new Su(this.options.manager) : this.textureLoader = new Sw(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ri(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, i = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
      return a._markDefs && a._markDefs();
    }), Promise.all(this._invokeAll(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(a) {
      const o = {
        scene: a[0][i.scene || 0],
        scenes: a[0],
        animations: a[1],
        cameras: a[2],
        asset: i.asset,
        parser: n,
        userData: {}
      };
      return qo(r, o, i), ao(o, i), Promise.all(n._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(o);
      })).then(function() {
        for (const l of o.scenes)
          l.updateMatrixWorld();
        e(o);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i].joints;
      for (let o = 0, l = a.length; o < l; o++)
        e[a[o]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const a = e[i];
      a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const i = n.clone(), r = (a, o) => {
      const l = this.associations.get(a);
      l != null && this.associations.set(o, l);
      for (const [c, u] of a.children.entries())
        r(u, o.children[c]);
    };
    return r(n, i), i.name += "_instance_" + e.uses[t]++, i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i)
        return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (i = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !i)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(i.map(function(r, a) {
        return n.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ht.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function(r, a) {
      n.load(po.resolveURL(t.uri, i.path), r, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const i = t.byteLength || 0, r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = rm[i.type], o = Ll[i.componentType], l = i.normalized === !0, c = new o(i.count * a);
      return Promise.resolve(new Rt(c, a, l));
    }
    const r = [];
    return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function(a) {
      const o = a[0], l = rm[i.type], c = Ll[i.componentType], u = c.BYTES_PER_ELEMENT, f = u * l, h = i.byteOffset || 0, d = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, m = i.normalized === !0;
      let _, g;
      if (d && d !== f) {
        const A = Math.floor(h / d), v = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + A + ":" + i.count;
        let y = t.cache.get(v);
        y || (_ = new c(o, A * d, i.count * d / u), y = new Uu(_, d / u), t.cache.add(v, y)), g = new Ao(y, l, h % d / u, m);
      } else
        o === null ? _ = new c(i.count * l) : _ = new c(o, h, i.count * l), g = new Rt(_, l, m);
      if (i.sparse !== void 0) {
        const A = rm.SCALAR, v = Ll[i.sparse.indices.componentType], y = i.sparse.indices.byteOffset || 0, w = i.sparse.values.byteOffset || 0, E = new v(a[1], y, i.sparse.count * A), I = new c(a[2], w, i.sparse.count * l);
        o !== null && (g = new Rt(g.array.slice(), g.itemSize, g.normalized));
        for (let C = 0, B = E.length; C < B; C++) {
          const T = E[C];
          if (g.setX(T, I[C * l]), l >= 2 && g.setY(T, I[C * l + 1]), l >= 3 && g.setZ(T, I[C * l + 2]), l >= 4 && g.setW(T, I[C * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, a = t.images[r];
    let o = this.textureLoader;
    if (a.uri) {
      const l = n.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, r, o);
  }
  loadTextureImage(e, t, n) {
    const i = this, r = this.json, a = r.textures[e], o = r.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(u) {
      u.flipY = !1, u.name = a.name || o.name || "", u.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (u.name = o.uri);
      const h = (r.samplers || {})[a.sampler] || {};
      return u.magFilter = Xb[h.magFilter] || Yt, u.minFilter = Xb[h.minFilter] || Yi, u.wrapS = Yb[h.wrapS] || Or, u.wrapT = Yb[h.wrapT] || Or, i.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, i = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((f) => f.clone());
    const a = i.images[e], o = self.URL || self.webkitURL;
    let l = a.uri || "", c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function(f) {
        c = !0;
        const h = new Blob([f], { type: a.mimeType });
        return l = o.createObjectURL(h), l;
      });
    else if (a.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(l).then(function(f) {
      return new Promise(function(h, d) {
        let m = h;
        t.isImageBitmapLoader === !0 && (m = function(_) {
          const g = new wn(_);
          g.needsUpdate = !0, h(g);
        }), t.load(po.resolveURL(f, r.path), m, void 0, d);
      });
    }).then(function(f) {
      return c === !0 && o.revokeObjectURL(l), f.userData.mimeType = a.mimeType || WL(a.uri), f;
    }).catch(function(f) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), f;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, i) {
    const r = this;
    return this.getDependency("texture", n.index).then(function(a) {
      if (!a)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[Ht.KHR_TEXTURE_TRANSFORM]) {
        const o = n.extensions !== void 0 ? n.extensions[Ht.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const l = r.associations.get(a);
          a = r.extensions[Ht.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, l);
        }
      }
      return i !== void 0 && (a.colorSpace = i), e[t] = a, a;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new vd(), ii.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(o, l)), n = l;
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l || (l = new Jn(), ii.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(o, l)), n = l;
    }
    if (i || r || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      i && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l || (l = n.clone(), r && (l.vertexColors = !0), a && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return Qu;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, i = this.extensions, r = n.materials[e];
    let a;
    const o = {}, l = r.extensions || {}, c = [];
    if (l[Ht.KHR_MATERIALS_UNLIT]) {
      const f = i[Ht.KHR_MATERIALS_UNLIT];
      a = f.getMaterialType(), c.push(f.extendParams(o, r, t));
    } else {
      const f = r.pbrMetallicRoughness || {};
      if (o.color = new Je(1, 1, 1), o.opacity = 1, Array.isArray(f.baseColorFactor)) {
        const h = f.baseColorFactor;
        o.color.setRGB(h[0], h[1], h[2], Bn), o.opacity = h[3];
      }
      f.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", f.baseColorTexture, Qn)), o.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, o.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", f.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", f.metallicRoughnessTexture))), a = this._invokeOne(function(h) {
        return h.getMaterialType && h.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(h) {
        return h.extendMaterialParams && h.extendMaterialParams(e, o);
      })));
    }
    r.doubleSided === !0 && (o.side = zn);
    const u = r.alphaMode || sm.OPAQUE;
    if (u === sm.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, u === sm.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== $n && (c.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new ke(1, 1), r.normalTexture.scale !== void 0)) {
      const f = r.normalTexture.scale;
      o.normalScale.set(f, f);
    }
    if (r.occlusionTexture !== void 0 && a !== $n && (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== $n) {
      const f = r.emissiveFactor;
      o.emissive = new Je().setRGB(f[0], f[1], f[2], Bn);
    }
    return r.emissiveTexture !== void 0 && a !== $n && c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, Qn)), Promise.all(c).then(function() {
      const f = new a(o);
      return r.name && (f.name = r.name), ao(f, r), t.associations.set(f, { materials: e }), r.extensions && qo(i, f, r), f;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Zt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, i = this.primitiveCache;
    function r(o) {
      return n[Ht.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
        return Kb(l, o, t);
      });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o], u = jL(c), f = i[u];
      if (f)
        a.push(f.promise);
      else {
        let h;
        c.extensions && c.extensions[Ht.KHR_DRACO_MESH_COMPRESSION] ? h = r(c) : h = Kb(new Dt(), c, t), i[u] = { primitive: c, promise: h }, a.push(h);
      }
    }
    return Promise.all(a);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, i = this.extensions, r = n.meshes[e], a = r.primitives, o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l].material === void 0 ? $L(this.cache) : this.getDependency("material", a[l].material);
      o.push(u);
    }
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
      const c = l.slice(0, l.length - 1), u = l[l.length - 1], f = [];
      for (let d = 0, m = u.length; d < m; d++) {
        const _ = u[d], g = a[d];
        let A;
        const v = c[d];
        if (g.mode === Ar.TRIANGLES || g.mode === Ar.TRIANGLE_STRIP || g.mode === Ar.TRIANGLE_FAN || g.mode === void 0)
          A = r.isSkinnedMesh === !0 ? new _d(_, v) : new tt(_, v), A.isSkinnedMesh === !0 && A.normalizeSkinWeights(), g.mode === Ar.TRIANGLE_STRIP ? A.geometry = Wb(A.geometry, dA) : g.mode === Ar.TRIANGLE_FAN && (A.geometry = Wb(A.geometry, Xh));
        else if (g.mode === Ar.LINES)
          A = new zr(_, v);
        else if (g.mode === Ar.LINE_STRIP)
          A = new qn(_, v);
        else if (g.mode === Ar.LINE_LOOP)
          A = new wA(_, v);
        else if (g.mode === Ar.POINTS)
          A = new EA(_, v);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
        Object.keys(A.geometry.morphAttributes).length > 0 && HL(A, r), A.name = t.createUniqueName(r.name || "mesh_" + e), ao(A, r), g.extensions && qo(i, A, g), t.assignFinalMaterial(A), f.push(A);
      }
      for (let d = 0, m = f.length; d < m; d++)
        t.associations.set(f[d], {
          meshes: e,
          primitives: d
        });
      if (f.length === 1)
        return r.extensions && qo(i, f[0], r), f[0];
      const h = new Xn();
      r.extensions && qo(i, h, r), t.associations.set(h, { meshes: e });
      for (let d = 0, m = f.length; d < m; d++)
        h.add(f[d]);
      return h;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new ni(ls.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new yo(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), ao(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let i = 0, r = t.joints.length; i < r; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
      const r = i.pop(), a = i, o = [], l = [];
      for (let c = 0, u = a.length; c < u; c++) {
        const f = a[c];
        if (f) {
          o.push(f);
          const h = new st();
          r !== null && h.fromArray(r.array, c * 16), l.push(h);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Fu(o, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, i = t.animations[e], r = i.name ? i.name : "animation_" + e, a = [], o = [], l = [], c = [], u = [];
    for (let f = 0, h = i.channels.length; f < h; f++) {
      const d = i.channels[f], m = i.samplers[d.sampler], _ = d.target, g = _.node, A = i.parameters !== void 0 ? i.parameters[m.input] : m.input, v = i.parameters !== void 0 ? i.parameters[m.output] : m.output;
      _.node !== void 0 && (a.push(this.getDependency("node", g)), o.push(this.getDependency("accessor", A)), l.push(this.getDependency("accessor", v)), c.push(m), u.push(_));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u)
    ]).then(function(f) {
      const h = f[0], d = f[1], m = f[2], _ = f[3], g = f[4], A = [];
      for (let v = 0, y = h.length; v < y; v++) {
        const w = h[v], E = d[v], I = m[v], C = _[v], B = g[v];
        if (w === void 0)
          continue;
        w.updateMatrix && w.updateMatrix();
        const T = n._createAnimationTracks(w, E, I, C, B);
        if (T)
          for (let S = 0; S < T.length; S++)
            A.push(T[S]);
      }
      return new zl(r, void 0, A);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, i = t.nodes[e];
    return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
      const a = n._getNodeRef(n.meshCache, i.mesh, r);
      return i.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let l = 0, c = i.weights.length; l < c; l++)
            o.morphTargetInfluences[l] = i.weights[l];
      }), a;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, i = t.nodes[e], r = n._loadNodeShallow(e), a = [], o = i.children || [];
    for (let c = 0, u = o.length; c < u; c++)
      a.push(n.getDependency("node", o[c]));
    const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
    return Promise.all([
      r,
      Promise.all(a),
      l
    ]).then(function(c) {
      const u = c[0], f = c[1], h = c[2];
      h !== null && u.traverse(function(d) {
        d.isSkinnedMesh && d.bind(h, qL);
      });
      for (let d = 0, m = f.length; d < m; d++)
        u.add(f[d]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, i = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], a = r.name ? i.createUniqueName(r.name) : "", o = [], l = i._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && o.push(l), r.camera !== void 0 && o.push(i.getDependency("camera", r.camera).then(function(c) {
      return i._getNodeRef(i.cameraCache, r.camera, c);
    })), i._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      o.push(c);
    }), this.nodeCache[e] = Promise.all(o).then(function(c) {
      let u;
      if (r.isBone === !0 ? u = new bd() : c.length > 1 ? u = new Xn() : c.length === 1 ? u = c[0] : u = new Gt(), u !== c[0])
        for (let f = 0, h = c.length; f < h; f++)
          u.add(c[f]);
      if (r.name && (u.userData.name = r.name, u.name = a), ao(u, r), r.extensions && qo(n, u, r), r.matrix !== void 0) {
        const f = new st();
        f.fromArray(r.matrix), u.applyMatrix4(f);
      } else
        r.translation !== void 0 && u.position.fromArray(r.translation), r.rotation !== void 0 && u.quaternion.fromArray(r.rotation), r.scale !== void 0 && u.scale.fromArray(r.scale);
      return i.associations.has(u) || i.associations.set(u, {}), i.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], i = this, r = new Xn();
    n.name && (r.name = i.createUniqueName(n.name)), ao(r, n), n.extensions && qo(t, r, n);
    const a = n.nodes || [], o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(i.getDependency("node", a[l]));
    return Promise.all(o).then(function(l) {
      for (let u = 0, f = l.length; u < f; u++)
        r.add(l[u]);
      const c = (u) => {
        const f = /* @__PURE__ */ new Map();
        for (const [h, d] of i.associations)
          (h instanceof ii || h instanceof wn) && f.set(h, d);
        return u.traverse((h) => {
          const d = i.associations.get(h);
          d != null && f.set(h, d);
        }), f;
      };
      return i.associations = c(r), r;
    });
  }
  _createAnimationTracks(e, t, n, i, r) {
    const a = [], o = e.name ? e.name : e.uuid, l = [];
    io[r.path] === io.weights ? e.traverse(function(h) {
      h.morphTargetInfluences && l.push(h.name ? h.name : h.uuid);
    }) : l.push(o);
    let c;
    switch (io[r.path]) {
      case io.weights:
        c = _a;
        break;
      case io.rotation:
        c = _o;
        break;
      case io.position:
      case io.scale:
        c = ba;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            c = _a;
            break;
          case 2:
          case 3:
          default:
            c = ba;
            break;
        }
        break;
    }
    const u = i.interpolation !== void 0 ? zL[i.interpolation] : ga, f = this._getArrayFromAccessor(n);
    for (let h = 0, d = l.length; h < d; h++) {
      const m = new c(
        l[h] + "." + io[r.path],
        t.array,
        f,
        u
      );
      i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), a.push(m);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Pg(t.constructor), i = new Float32Array(t.length);
      for (let r = 0, a = t.length; r < a; r++)
        i[r] = t[r] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const i = this instanceof _o ? QL : Hw;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function YL(s, e, t) {
  const n = e.attributes, i = new dn();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION], l = o.min, c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (i.set(
        new H(l[0], l[1], l[2]),
        new H(c[0], c[1], c[2])
      ), o.normalized) {
        const u = Pg(Ll[o.componentType]);
        i.min.multiplyScalar(u), i.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const o = new H(), l = new H();
    for (let c = 0, u = r.length; c < u; c++) {
      const f = r[c];
      if (f.POSITION !== void 0) {
        const h = t.json.accessors[f.POSITION], d = h.min, m = h.max;
        if (d !== void 0 && m !== void 0) {
          if (l.setX(Math.max(Math.abs(d[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(d[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(d[2]), Math.abs(m[2]))), h.normalized) {
            const _ = Pg(Ll[h.componentType]);
            l.multiplyScalar(_);
          }
          o.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    i.expandByVector(o);
  }
  s.boundingBox = i;
  const a = new Vn();
  i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, s.boundingSphere = a;
}
function Kb(s, e, t) {
  const n = e.attributes, i = [];
  function r(a, o) {
    return t.getDependency("accessor", a).then(function(l) {
      s.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = Bg[a] || a.toLowerCase();
    o in s.attributes || i.push(r(n[a], o));
  }
  if (e.indices !== void 0 && !s.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      s.setIndex(o);
    });
    i.push(a);
  }
  return cn.workingColorSpace !== Bn && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${cn.workingColorSpace}" not supported.`), ao(s, e), YL(s, e, t), Promise.all(i).then(function() {
    return e.targets !== void 0 ? VL(s, e.targets, t) : s;
  });
}
class KL {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & 1 << e))
        return e;
    return -1;
  }
  _onMessage(e, t) {
    const n = this.workersResolve[e];
    if (n && n(t), this.queue.length) {
      const { resolve: i, msg: r, transfer: a } = this.queue.shift();
      this.workersResolve[e] = i, this.workers[e].postMessage(r, a);
    } else
      this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((n) => {
      const i = this._getIdleWorker();
      i !== -1 ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = n, this.workers[i].postMessage(e, t)) : this.queue.push({ resolve: n, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const JL = 0, Jb = 2, ZL = 1, Zb = 2, ek = 0, tk = 1, nk = 10, ik = 0, jw = 9, Ww = 15, qw = 16, Xw = 22, Yw = 37, Kw = 43, Jw = 76, Zw = 83, eE = 97, tE = 100, nE = 103, iE = 109, rE = 165, sE = 166;
class rk {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class Rc {
  constructor(e, t, n, i) {
    this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t = 0) {
    const n = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== t && i < e; )
      i++, this._offset++;
    return i < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);
  }
}
const Qi = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function ev(s) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(s) : Buffer.from(s).toString("utf8");
}
function sk(s) {
  const e = new Uint8Array(s.buffer, s.byteOffset, Qi.length);
  if (e[0] !== Qi[0] || e[1] !== Qi[1] || e[2] !== Qi[2] || e[3] !== Qi[3] || e[4] !== Qi[4] || e[5] !== Qi[5] || e[6] !== Qi[6] || e[7] !== Qi[7] || e[8] !== Qi[8] || e[9] !== Qi[9] || e[10] !== Qi[10] || e[11] !== Qi[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const t = new rk(), n = 17 * Uint32Array.BYTES_PER_ELEMENT, i = new Rc(s, Qi.length, n, !0);
  t.vkFormat = i._nextUint32(), t.typeSize = i._nextUint32(), t.pixelWidth = i._nextUint32(), t.pixelHeight = i._nextUint32(), t.pixelDepth = i._nextUint32(), t.layerCount = i._nextUint32(), t.faceCount = i._nextUint32();
  const r = i._nextUint32();
  t.supercompressionScheme = i._nextUint32();
  const a = i._nextUint32(), o = i._nextUint32(), l = i._nextUint32(), c = i._nextUint32(), u = i._nextUint64(), f = i._nextUint64(), h = new Rc(s, Qi.length + n, 3 * r * 8, !0);
  for (let Q = 0; Q < r; Q++)
    t.levels.push({ levelData: new Uint8Array(s.buffer, s.byteOffset + h._nextUint64(), h._nextUint64()), uncompressedByteLength: h._nextUint64() });
  const d = new Rc(s, a, o, !0), m = { vendorId: d._skip(4)._nextUint16(), descriptorType: d._nextUint16(), versionNumber: d._nextUint16(), descriptorBlockSize: d._nextUint16(), colorModel: d._nextUint8(), colorPrimaries: d._nextUint8(), transferFunction: d._nextUint8(), flags: d._nextUint8(), texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], samples: [] }, _ = (m.descriptorBlockSize / 4 - 6) / 4;
  for (let Q = 0; Q < _; Q++) {
    const q = { bitOffset: d._nextUint16(), bitLength: d._nextUint8(), channelType: d._nextUint8(), samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & q.channelType ? (q.sampleLower = d._nextInt32(), q.sampleUpper = d._nextInt32()) : (q.sampleLower = d._nextUint32(), q.sampleUpper = d._nextUint32()), m.samples[Q] = q;
  }
  t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(m);
  const g = new Rc(s, l, c, !0);
  for (; g._offset < c; ) {
    const Q = g._nextUint32(), q = g._scan(Q), oe = ev(q), le = g._scan(Q - q.byteLength);
    t.keyValue[oe] = oe.match(/^ktx/i) ? ev(le) : le, g._offset % 4 && g._skip(4 - g._offset % 4);
  }
  if (f <= 0)
    return t;
  const A = new Rc(s, u, f, !0), v = A._nextUint16(), y = A._nextUint16(), w = A._nextUint32(), E = A._nextUint32(), I = A._nextUint32(), C = A._nextUint32(), B = [];
  for (let Q = 0; Q < r; Q++)
    B.push({ imageFlags: A._nextUint32(), rgbSliceByteOffset: A._nextUint32(), rgbSliceByteLength: A._nextUint32(), alphaSliceByteOffset: A._nextUint32(), alphaSliceByteLength: A._nextUint32() });
  const T = u + A._offset, S = T + w, D = S + E, R = D + I, P = new Uint8Array(s.buffer, s.byteOffset + T, w), L = new Uint8Array(s.buffer, s.byteOffset + S, E), V = new Uint8Array(s.buffer, s.byteOffset + D, I), U = new Uint8Array(s.buffer, s.byteOffset + R, C);
  return t.globalData = { endpointCount: v, selectorCount: y, imageDescs: B, endpointsData: P, selectorsData: L, tablesData: V, extendedData: U }, t;
}
let am, Es, Rg;
const lm = { env: { emscripten_notify_memory_growth: function(s) {
  Rg = new Uint8Array(Es.exports.memory.buffer);
} } };
class ok {
  init() {
    return am || (am = typeof fetch < "u" ? fetch("data:application/wasm;base64," + tv).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, lm)).then(this._init) : WebAssembly.instantiate(Buffer.from(tv, "base64"), lm).then(this._init), am);
  }
  _init(e) {
    Es = e.instance, lm.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!Es)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const n = e.byteLength, i = Es.exports.malloc(n);
    Rg.set(e, i), t = t || Number(Es.exports.ZSTD_findDecompressedSize(i, n));
    const r = Es.exports.malloc(t), a = Es.exports.ZSTD_decompress(r, t, i, n), o = Rg.slice(r, r + a);
    return Es.exports.free(i), Es.exports.free(r), o;
  }
}
const tv = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", cm = /* @__PURE__ */ new WeakMap();
let um = 0, fm;
class rs extends ai {
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new KL(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  async detectSupportAsync(e) {
    return this.workerConfig = {
      astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
      etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
    }, this;
  }
  detectSupport(e) {
    return e.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: e.hasFeature("texture-compression-astc"),
      etc1Supported: e.hasFeature("texture-compression-etc1"),
      etc2Supported: e.hasFeature("texture-compression-etc2"),
      dxtSupported: e.hasFeature("texture-compression-bc"),
      bptcSupported: e.hasFeature("texture-compression-bptc"),
      pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
    } : this.workerConfig = {
      astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, this;
  }
  init() {
    if (!this.transcoderPending) {
      const e = new ri(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), n = new ri(this.manager);
      n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
      const i = n.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, i]).then(([r, a]) => {
        const o = rs.BasisWorker.toString(), l = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(rs.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(rs.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(rs.BasisFormat),
          "/* basis_transcoder.js */",
          r,
          "/* worker */",
          o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([l])), this.transcoderBinary = a, this.workerPool.setWorkerCreator(() => {
          const c = new Worker(this.workerSourceURL), u = this.transcoderBinary.slice(0);
          return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: u }, [u]), c;
        });
      }), um > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), um++;
    }
    return this.transcoderPending;
  }
  load(e, t, n, i) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const r = new ri(this.manager);
    r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      if (cm.has(a))
        return cm.get(a).promise.then(t).catch(i);
      this._createTexture(a).then((o) => t ? t(o) : null).catch(i);
    }, n, i);
  }
  _createTextureFrom(e, t) {
    const { faces: n, width: i, height: r, format: a, type: o, error: l, dfdFlags: c } = e;
    if (o === "error")
      return Promise.reject(l);
    let u;
    if (t.faceCount === 6)
      u = new jx(n, a, Un);
    else {
      const f = n[0].mipmaps;
      u = t.layerCount > 1 ? new Hx(f, i, r, t.layerCount, a, Un) : new ec(f, i, r, a, Un);
    }
    return u.minFilter = n[0].mipmaps.length === 1 ? Yt : Yi, u.magFilter = Yt, u.generateMipmaps = !1, u.needsUpdate = !0, u.colorSpace = oE(t), u.premultiplyAlpha = !!(c & ZL), u;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(e, t = {}) {
    const n = sk(new Uint8Array(e));
    if (n.vkFormat !== ik)
      return lk(n);
    const i = t, r = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: i }, [e])).then((a) => this._createTextureFrom(a.data, n));
    return cm.set(e, { promise: r }), r;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), um--, this;
  }
}
rs.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
rs.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
rs.EngineFormat = {
  RGBAFormat: vn,
  RGBA_ASTC_4x4_Format: qh,
  RGBA_BPTC_Format: eu,
  RGBA_ETC2_EAC_Format: Wh,
  RGBA_PVRTC_4BPPV1_Format: Vh,
  RGBA_S3TC_DXT5_Format: Zc,
  RGB_ETC1_Format: Hh,
  RGB_ETC2_Format: jh,
  RGB_PVRTC_4BPPV1_Format: $h,
  RGBA_S3TC_DXT1_Format: Jc
};
rs.BasisWorker = function() {
  let s, e, t;
  const n = _EngineFormat, i = _TranscoderFormat, r = _BasisFormat;
  self.addEventListener("message", function(m) {
    const _ = m.data;
    switch (_.type) {
      case "init":
        s = _.config, a(_.transcoderBinary);
        break;
      case "transcode":
        e.then(() => {
          try {
            const { faces: g, buffers: A, width: v, height: y, hasAlpha: w, format: E, dfdFlags: I } = o(_.buffer);
            self.postMessage({ type: "transcode", id: _.id, faces: g, width: v, height: y, hasAlpha: w, format: E, dfdFlags: I }, A);
          } catch (g) {
            console.error(g), self.postMessage({ type: "error", id: _.id, error: g.message });
          }
        });
        break;
    }
  });
  function a(m) {
    e = new Promise((_) => {
      t = { wasmBinary: m, onRuntimeInitialized: _ }, BASIS(t);
    }).then(() => {
      t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function o(m) {
    const _ = new t.KTX2File(new Uint8Array(m));
    function g() {
      _.close(), _.delete();
    }
    if (!_.isValid())
      throw g(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    const A = _.isUASTC() ? r.UASTC_4x4 : r.ETC1S, v = _.getWidth(), y = _.getHeight(), w = _.getLayers() || 1, E = _.getLevels(), I = _.getFaces(), C = _.getHasAlpha(), B = _.getDFDFlags(), { transcoderFormat: T, engineFormat: S } = f(A, v, y, C);
    if (!v || !y || !E)
      throw g(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!_.startTranscoding())
      throw g(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const D = [], R = [];
    for (let P = 0; P < I; P++) {
      const L = [];
      for (let V = 0; V < E; V++) {
        const U = [];
        let Q, q;
        for (let le = 0; le < w; le++) {
          const k = _.getImageLevelInfo(V, le, P);
          P === 0 && V === 0 && le === 0 && (k.origWidth % 4 !== 0 || k.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), E > 1 ? (Q = k.origWidth, q = k.origHeight) : (Q = k.width, q = k.height);
          const X = new Uint8Array(_.getImageTranscodedSizeInBytes(V, le, 0, T));
          if (!_.transcodeImage(X, V, le, P, T, 0, -1, -1))
            throw g(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          U.push(X);
        }
        const oe = d(U);
        L.push({ data: oe, width: Q, height: q }), R.push(oe.buffer);
      }
      D.push({ mipmaps: L, width: v, height: y, format: S });
    }
    return g(), { faces: D, buffers: R, width: v, height: y, hasAlpha: C, format: S, dfdFlags: B };
  }
  const l = [
    {
      if: "astcSupported",
      basisFormat: [r.UASTC_4x4],
      transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
      engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.BC7_M5, i.BC7_M5],
      engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.BC1, i.BC3],
      engineFormat: [n.RGBA_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.ETC1, i.ETC2],
      engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.ETC1],
      engineFormat: [n.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
      engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    }
  ], c = l.sort(function(m, _) {
    return m.priorityETC1S - _.priorityETC1S;
  }), u = l.sort(function(m, _) {
    return m.priorityUASTC - _.priorityUASTC;
  });
  function f(m, _, g, A) {
    let v, y;
    const w = m === r.ETC1S ? c : u;
    for (let E = 0; E < w.length; E++) {
      const I = w[E];
      if (s[I.if] && I.basisFormat.includes(m) && !(A && I.transcoderFormat.length < 2) && !(I.needsPowerOfTwo && !(h(_) && h(g))))
        return v = I.transcoderFormat[A ? 1 : 0], y = I.engineFormat[A ? 1 : 0], { transcoderFormat: v, engineFormat: y };
    }
    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), v = i.RGBA32, y = n.RGBAFormat, { transcoderFormat: v, engineFormat: y };
  }
  function h(m) {
    return m <= 2 ? !0 : (m & m - 1) === 0 && m !== 0;
  }
  function d(m) {
    if (m.length === 1)
      return m[0];
    let _ = 0;
    for (let v = 0; v < m.length; v++) {
      const y = m[v];
      _ += y.byteLength;
    }
    const g = new Uint8Array(_);
    let A = 0;
    for (let v = 0; v < m.length; v++) {
      const y = m[v];
      g.set(y, A), A += y.byteLength;
    }
    return g;
  }
};
const ak = /* @__PURE__ */ new Set([vn, uo, Ts]), hm = {
  [iE]: vn,
  [eE]: vn,
  [Yw]: vn,
  [Kw]: vn,
  [nE]: uo,
  [Zw]: uo,
  [qw]: uo,
  [Xw]: uo,
  [tE]: Ts,
  [Jw]: Ts,
  [Ww]: Ts,
  [jw]: Ts,
  [sE]: du,
  [rE]: du
}, dm = {
  [iE]: hn,
  [eE]: Ri,
  [Yw]: Un,
  [Kw]: Un,
  [nE]: hn,
  [Zw]: Ri,
  [qw]: Un,
  [Xw]: Un,
  [tE]: hn,
  [Jw]: Ri,
  [Ww]: Un,
  [jw]: Un,
  [sE]: Un,
  [rE]: Un
};
async function lk(s) {
  const { vkFormat: e } = s;
  if (hm[e] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let t;
  s.supercompressionScheme === Jb && (fm || (fm = new Promise(async (r) => {
    const a = new ok();
    await a.init(), r(a);
  })), t = await fm);
  const n = [];
  for (let r = 0; r < s.levels.length; r++) {
    const a = Math.max(1, s.pixelWidth >> r), o = Math.max(1, s.pixelHeight >> r), l = s.pixelDepth ? Math.max(1, s.pixelDepth >> r) : 0, c = s.levels[r];
    let u;
    if (s.supercompressionScheme === JL)
      u = c.levelData;
    else if (s.supercompressionScheme === Jb)
      u = t.decode(c.levelData, c.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let f;
    dm[e] === hn ? f = new Float32Array(
      u.buffer,
      u.byteOffset,
      u.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : dm[e] === Ri ? f = new Uint16Array(
      u.buffer,
      u.byteOffset,
      u.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : f = u, n.push({
      data: f,
      width: a,
      height: o,
      depth: l
    });
  }
  let i;
  if (ak.has(hm[e]))
    i = s.pixelDepth === 0 ? new Di(n[0].data, s.pixelWidth, s.pixelHeight) : new hd(n[0].data, s.pixelWidth, s.pixelHeight, s.pixelDepth);
  else {
    if (s.pixelDepth > 0)
      throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    i = new ec(n, s.pixelWidth, s.pixelHeight);
  }
  return i.mipmaps = n, i.type = dm[e], i.format = hm[e], i.colorSpace = oE(s), i.needsUpdate = !0, Promise.resolve(i);
}
function oE(s) {
  const e = s.dataFormatDescriptor[0];
  return e.colorPrimaries === tk ? e.transferFunction === Zb ? Qn : Bn : e.colorPrimaries === nk ? e.transferFunction === Zb ? Du : Wl : (e.colorPrimaries === ek || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), Ur);
}
const ck = (s) => {
  const e = { nodes: {}, materials: {} };
  return s && s.traverse((t) => {
    t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material);
  }), e;
}, pm = {};
function Ud(s, e) {
  const { renderer: t } = un(), n = typeof s == "string" ? e : s, i = $u(gL, {
    extend(o) {
      if (n != null && n.useDraco)
        if (typeof n.useDraco == "string" || typeof n.useDraco == "boolean") {
          const l = typeof n.useDraco == "string" ? n.useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
          pm[l] || (pm[l] = new pL().setDecoderPath(l)), o.setDRACOLoader(pm[l]);
        } else
          o.setDRACOLoader(n.useDraco);
      if (n != null && n.useMeshopt && o.setMeshoptDecoder(dL), n != null && n.ktxTranscoderPath) {
        const l = new rs();
        l.setTranscoderPath(n == null ? void 0 : n.ktxTranscoderPath), l.detectSupport(t), o.setKTX2Loader(l);
      }
    }
  }), r = (o) => i.load(o, {
    transform(l) {
      return {
        ...l,
        ...ck(l.scene)
      };
    }
  }), a = typeof s == "string" ? s : void 0;
  return a ? r(a) : {
    load: r
  };
}
const nv = (s) => !!(s != null && s.isObject3D), uk = (s) => !!(s != null && s.subscribe) && typeof s.subscribe == "function";
function fk(s, e) {
  const t = uk(s) ? s : Ft(void 0), n = xn(nv(s) ? s : nv(e) ? e : void 0), i = hi([n, t], ([c, u]) => c ?? (u == null ? void 0 : u.scene)), r = xn({}), a = new Dw(void 0);
  tn([t, i], async ([c, u]) => {
    if (!c || !c.animations.length || !u)
      return;
    await rd();
    const f = c.animations.reduce((h, d) => {
      const m = a.clipAction(d, u);
      return {
        ...h,
        [d.name]: m
      };
    }, {});
    return r.set(f), () => {
      Object.values(f).forEach((h) => {
        const d = h;
        d.stop(), a.uncacheClip(d.getClip());
      });
    };
  });
  const { start: o, stop: l } = On((c) => {
    a.update(c);
  }, { autoStart: !1 });
  return tn(r, (c) => {
    Object.keys(c).length ? o() : l();
  }), {
    gltf: t,
    root: n,
    mixer: a,
    actions: r
  };
}
const aE = (s, e) => {
  const t = $u(Su, e), { renderer: n } = un();
  return t.load(s, {
    ...e,
    transform: (i) => {
      var r;
      return i.colorSpace = n.outputColorSpace, i.needsUpdate = !0, ((r = e == null ? void 0 : e.transform) == null ? void 0 : r.call(e, i)) ?? i;
    }
  });
}, lE = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER"), hk = (s) => {
  const e = us(), t = xn(/* @__PURE__ */ new Set()), n = xn(/* @__PURE__ */ new Map()), i = Ft(!1), r = () => {
    t.current.size === 0 && n.current.size === 0 && i.set(!0);
  }, a = Ft((s == null ? void 0 : s.final) ?? !1), o = (m) => {
    t.update((_) => (_.add(m), _));
  }, l = (m) => {
    t.update((_) => (_.delete(m), _));
  }, c = (m, _) => {
    n.update((g) => (g.set(m, _), g));
  }, u = (m) => {
    n.update((_) => (_.delete(m), _));
  }, f = hi([t, n, a, i], ([m, _, g, A]) => g && A ? !1 : _.size > 0 ? !0 : m.size > 0), h = {
    suspend(m) {
      o(m), m.catch((_) => {
        c(m, _), e("error", _);
      }).finally(() => {
        l(m), r();
      });
    },
    onComponentDestroy(m) {
      l(m), u(m), r();
    },
    suspended: f
  }, d = hi(n, (m) => Array.from(m.values()));
  return xi(lE, h), {
    promises: t,
    suspended: f,
    errors: d,
    setFinal: (m) => a.set(m ?? !1)
  };
}, rc = () => {
  const s = wi(lE), e = /* @__PURE__ */ new Set(), t = (i) => (s && (s.suspend(i), e.add(i)), i), n = {
    suspended: hi((s == null ? void 0 : s.suspended) ?? oA(!1), (i) => i)
  };
  return Sn(() => {
    if (s) {
      for (const i of e)
        s.onComponentDestroy(i);
      e.clear();
    }
  }), Object.assign(t, n);
};
function dk(s) {
  let e, t, n;
  const i = [
    { is: (
      /*is*/
      s[3]
    ) },
    { map: (
      /*texture*/
      s[4]
    ) },
    { toneMapped: !1 },
    { transparent: (
      /*transparent*/
      s[2]
    ) },
    { alphaTest: (
      /*alphaTest*/
      s[1]
    ) },
    /*$$restProps*/
    s[7]
  ];
  function r(o) {
    s[26](o);
  }
  let a = {};
  for (let o = 0; o < i.length; o += 1)
    a = We(a, i[o]);
  return (
    /*ref*/
    s[0] !== void 0 && (a.ref = /*ref*/
    s[0]), e = new ee({ props: a }), Ut.push(() => ar(e, "ref", r)), {
      c() {
        Z(e.$$.fragment);
      },
      m(o, l) {
        K(e, o, l), n = !0;
      },
      p(o, l) {
        const c = l[0] & /*is, texture, transparent, alphaTest, $$restProps*/
        158 ? jt(i, [
          l[0] & /*is*/
          8 && { is: (
            /*is*/
            o[3]
          ) },
          l[0] & /*texture*/
          16 && { map: (
            /*texture*/
            o[4]
          ) },
          i[2],
          l[0] & /*transparent*/
          4 && { transparent: (
            /*transparent*/
            o[2]
          ) },
          l[0] & /*alphaTest*/
          2 && { alphaTest: (
            /*alphaTest*/
            o[1]
          ) },
          l[0] & /*$$restProps*/
          128 && Kt(
            /*$$restProps*/
            o[7]
          )
        ]) : {};
        !t && l[0] & /*ref*/
        1 && (t = !0, c.ref = /*ref*/
        o[0], or(() => t = !1)), e.$set(c);
      },
      i(o) {
        n || (O(e.$$.fragment, o), n = !0);
      },
      o(o) {
        N(e.$$.fragment, o), n = !1;
      },
      d(o) {
        J(e, o);
      }
    }
  );
}
function pk(s) {
  let e, t, n, i, r;
  const a = [
    { is: (
      /*is*/
      s[3]
    ) },
    { map: (
      /*texture*/
      s[4]
    ) },
    { toneMapped: !1 },
    { side: zn },
    { shadowSide: zn },
    { transparent: (
      /*transparent*/
      s[2]
    ) },
    { alphaTest: (
      /*alphaTest*/
      s[1]
    ) },
    /*$$restProps*/
    s[7]
  ];
  function o(c) {
    s[25](c);
  }
  let l = {};
  for (let c = 0; c < a.length; c += 1)
    l = We(l, a[c]);
  return (
    /*ref*/
    s[0] !== void 0 && (l.ref = /*ref*/
    s[0]), e = new ee({ props: l }), Ut.push(() => ar(e, "ref", o)), i = new ee.MeshDepthMaterial({
      props: {
        attach: "customDepthMaterial",
        depthPacking: jl,
        map: (
          /*texture*/
          s[4]
        ),
        alphaTest: (
          /*alphaTest*/
          s[1]
        )
      }
    }), {
      c() {
        Z(e.$$.fragment), n = Me(), Z(i.$$.fragment);
      },
      m(c, u) {
        K(e, c, u), we(c, n, u), K(i, c, u), r = !0;
      },
      p(c, u) {
        const f = u[0] & /*is, texture, transparent, alphaTest, $$restProps*/
        158 ? jt(a, [
          u[0] & /*is*/
          8 && { is: (
            /*is*/
            c[3]
          ) },
          u[0] & /*texture*/
          16 && { map: (
            /*texture*/
            c[4]
          ) },
          a[2],
          a[3],
          a[4],
          u[0] & /*transparent*/
          4 && { transparent: (
            /*transparent*/
            c[2]
          ) },
          u[0] & /*alphaTest*/
          2 && { alphaTest: (
            /*alphaTest*/
            c[1]
          ) },
          u[0] & /*$$restProps*/
          128 && Kt(
            /*$$restProps*/
            c[7]
          )
        ]) : {};
        !t && u[0] & /*ref*/
        1 && (t = !0, f.ref = /*ref*/
        c[0], or(() => t = !1)), e.$set(f);
        const h = {};
        u[0] & /*texture*/
        16 && (h.map = /*texture*/
        c[4]), u[0] & /*alphaTest*/
        2 && (h.alphaTest = /*alphaTest*/
        c[1]), i.$set(h);
      },
      i(c) {
        r || (O(e.$$.fragment, c), O(i.$$.fragment, c), r = !0);
      },
      o(c) {
        N(e.$$.fragment, c), N(i.$$.fragment, c), r = !1;
      },
      d(c) {
        c && xe(n), J(e, c), J(i, c);
      }
    }
  );
}
function mk(s) {
  let e, t, n, i;
  const r = [pk, dk], a = [];
  function o(l, c) {
    return (
      /*texture*/
      l[4] && /*isMesh*/
      l[5] ? 0 : (
        /*texture*/
        l[4] ? 1 : -1
      )
    );
  }
  return ~(e = o(s)) && (t = a[e] = r[e](s)), {
    c() {
      t && t.c(), n = ji();
    },
    m(l, c) {
      ~e && a[e].m(l, c), we(l, n, c), i = !0;
    },
    p(l, c) {
      let u = e;
      e = o(l), e === u ? ~e && a[e].p(l, c) : (t && (Li(), N(a[u], 1, 1, () => {
        a[u] = null;
      }), ki()), ~e ? (t = a[e], t ? t.p(l, c) : (t = a[e] = r[e](l), t.c()), O(t, 1), t.m(n.parentNode, n)) : t = null);
    },
    i(l) {
      i || (O(t), i = !0);
    },
    o(l) {
      N(t), i = !1;
    },
    d(l) {
      l && xe(n), ~e && a[e].d(l);
    }
  };
}
function gk(s, e, t) {
  let n;
  const i = [
    "textureUrl",
    "dataUrl",
    "animation",
    "loop",
    "autoplay",
    "fps",
    "filter",
    "alphaTest",
    "delay",
    "transparent",
    "flipX",
    "startFrame",
    "endFrame",
    "rows",
    "columns",
    "totalFrames",
    "is",
    "ref",
    "play",
    "pause"
  ];
  let r = ft(e, i), a, { textureUrl: o } = e, { dataUrl: l = "" } = e, { animation: c = "" } = e, { loop: u = !0 } = e, { autoplay: f = !0 } = e, { fps: h = 10 } = e, { filter: d = "nearest" } = e, { alphaTest: m = 0.1 } = e, { delay: _ = 0 } = e, { transparent: g = !0 } = e, { flipX: A = !1 } = e, { startFrame: v = 0 } = e, { endFrame: y = void 0 } = e, { rows: w = 1 } = e, { columns: E = void 0 } = e, { totalFrames: I = 0 } = e;
  const C = Er();
  lt(s, C, (W) => t(24, a = W));
  const B = us(), T = ["forward", "reverse"], S = (W) => {
    const G = T.includes(W);
    return G || console.warn(`Unsupported sprite animation direction "${W}"`), G;
  };
  let D = 0, R = v, P = 0, L = A ? -1 : 1, V = 0, U = 0, Q, q, oe = [], le = "forward", k, X = { w: 0, h: 0 }, fe = "isMesh" in a, { is: te = fe ? new $n() : new Ad() } = e, { ref: j } = e;
  const Ae = rc(), Y = Ae(aE(o, {
    transform: (W) => (W.matrixAutoUpdate = !1, W.generateMipmaps = !1, W.premultiplyAlpha = !1, W.wrapS = W.wrapT = Or, W.magFilter = W.minFilter = d === "nearest" ? nn : Yt, W)
  })), pe = Ae(l ? $u(ri).load(l, {
    transform: (W) => {
      if (typeof W == "string")
        try {
          return JSON.parse(W);
        } catch {
          return;
        }
    }
  }) : Dl(new Promise((W) => {
    const G = Y.subscribe((se) => {
      se && (G(), W(me(se)));
    });
  }))), me = (W) => {
    const { width: G, height: se } = W.image, _e = E ?? I;
    P = I;
    const ve = G / _e, ue = se / w, Te = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: G, h: se },
        scale: 1
      }
    };
    for (let Ge = 0; Ge < P; Ge += 1) {
      const Pe = Math.floor(Ge / _e), Se = Ge % _e * ve, Ve = Pe * ue;
      Te.frames[`${Ge}`] = {
        frame: { x: Se, y: Ve, w: ve, h: ue },
        spriteSourceSize: {
          x: 0,
          y: 0,
          w: ve,
          h: ue
        },
        sourceSize: { w: ve, h: ue }
      };
    }
    return Te;
  }, re = (W) => {
    const G = X.w / V, se = X.h / U, _e = 1 / G, ve = 1 / se, ue = L > 0 ? _e * (W.x / V) : _e * (W.x / U) - Q.repeat.x, Te = Math.abs(1 - ve) - ve * (W.y / U);
    Q == null || Q.offset.set(ue, Te), Q == null || Q.updateMatrix();
  }, ye = (W) => {
    q && (k = q == null ? void 0 : q.meta.frameTags.find((G) => G.name === W), le = S(k == null ? void 0 : k.direction) ? k.direction : "forward", R = le === "forward" ? (k == null ? void 0 : k.from) ?? 0 : (k == null ? void 0 : k.to) ?? P - 1, re(q.frames[oe[R]].frame), B.hasEventListener("start") && B("start"));
  };
  let ae = !1;
  const De = async () => {
    ae = !0, await Promise.all([Y, pe]), ae && (D = performance.now() - _, Ie());
  }, Ee = () => {
    ae = !1, Ce();
  }, { start: Ie, stop: Ce } = On(
    () => {
      if (!q)
        return;
      const W = performance.now(), G = W - D, se = oe[R], { frame: _e, duration: ve } = q.frames[se], ue = ve ?? n;
      if (G <= ue)
        return;
      D = W - G % ue;
      const Te = le === "forward" ? (k == null ? void 0 : k.from) ?? v ?? 0 : (k == null ? void 0 : k.to) ?? y ?? P - 1, Ge = le === "forward" ? (k == null ? void 0 : k.to) ?? y ?? P - 1 : (k == null ? void 0 : k.from) ?? v ?? 0;
      switch (re(_e), le) {
        case "forward":
          R += 1;
          break;
        case "reverse":
          R -= 1;
          break;
      }
      (le === "forward" && R > Ge || le === "reverse" && R < Ge) && (R = Te, u ? B.hasEventListener("loop") && B("loop") : (Ee(), B.hasEventListener("end") && B("end")));
    },
    { autoStart: !1 }
  );
  tn([Y, pe], ([W, G]) => {
    if (W === void 0 || G === void 0)
      return;
    t(4, Q = W.clone()), q = G, oe = Object.keys(q.frames), P = oe.length, X = q.meta.size;
    const { sourceSize: se } = Object.values(q.frames)[0];
    V = se.w, U = se.h, Q.repeat.set(1 * L / (X.w / V), 1 / (X.h / U)), ye(c), B("load"), f && De();
  });
  function ze(W) {
    j = W, t(0, j);
  }
  function Fe(W) {
    j = W, t(0, j);
  }
  return s.$$set = (W) => {
    e = We(We({}, e), rn(W)), t(7, r = ft(e, i)), "textureUrl" in W && t(8, o = W.textureUrl), "dataUrl" in W && t(9, l = W.dataUrl), "animation" in W && t(10, c = W.animation), "loop" in W && t(11, u = W.loop), "autoplay" in W && t(12, f = W.autoplay), "fps" in W && t(13, h = W.fps), "filter" in W && t(14, d = W.filter), "alphaTest" in W && t(1, m = W.alphaTest), "delay" in W && t(15, _ = W.delay), "transparent" in W && t(2, g = W.transparent), "flipX" in W && t(16, A = W.flipX), "startFrame" in W && t(17, v = W.startFrame), "endFrame" in W && t(18, y = W.endFrame), "rows" in W && t(19, w = W.rows), "columns" in W && t(20, E = W.columns), "totalFrames" in W && t(21, I = W.totalFrames), "is" in W && t(3, te = W.is), "ref" in W && t(0, j = W.ref);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*$parent*/
    16777216 && t(5, fe = "isMesh" in a), s.$$.dirty[0] & /*fps*/
    8192 && (n = 1e3 / h), s.$$.dirty[0] & /*animation, autoplay*/
    5120 && (ye(c), f && De());
  }, [
    j,
    m,
    g,
    te,
    Q,
    fe,
    C,
    r,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    _,
    A,
    v,
    y,
    w,
    E,
    I,
    De,
    Ee,
    a,
    ze,
    Fe
  ];
}
class Ak extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      gk,
      mk,
      _t,
      {
        textureUrl: 8,
        dataUrl: 9,
        animation: 10,
        loop: 11,
        autoplay: 12,
        fps: 13,
        filter: 14,
        alphaTest: 1,
        delay: 15,
        transparent: 2,
        flipX: 16,
        startFrame: 17,
        endFrame: 18,
        rows: 19,
        columns: 20,
        totalFrames: 21,
        is: 3,
        ref: 0,
        play: 22,
        pause: 23
      },
      null,
      [-1, -1]
    );
  }
  get textureUrl() {
    return this.$$.ctx[8];
  }
  set textureUrl(e) {
    this.$$set({ textureUrl: e }), ne();
  }
  get dataUrl() {
    return this.$$.ctx[9];
  }
  set dataUrl(e) {
    this.$$set({ dataUrl: e }), ne();
  }
  get animation() {
    return this.$$.ctx[10];
  }
  set animation(e) {
    this.$$set({ animation: e }), ne();
  }
  get loop() {
    return this.$$.ctx[11];
  }
  set loop(e) {
    this.$$set({ loop: e }), ne();
  }
  get autoplay() {
    return this.$$.ctx[12];
  }
  set autoplay(e) {
    this.$$set({ autoplay: e }), ne();
  }
  get fps() {
    return this.$$.ctx[13];
  }
  set fps(e) {
    this.$$set({ fps: e }), ne();
  }
  get filter() {
    return this.$$.ctx[14];
  }
  set filter(e) {
    this.$$set({ filter: e }), ne();
  }
  get alphaTest() {
    return this.$$.ctx[1];
  }
  set alphaTest(e) {
    this.$$set({ alphaTest: e }), ne();
  }
  get delay() {
    return this.$$.ctx[15];
  }
  set delay(e) {
    this.$$set({ delay: e }), ne();
  }
  get transparent() {
    return this.$$.ctx[2];
  }
  set transparent(e) {
    this.$$set({ transparent: e }), ne();
  }
  get flipX() {
    return this.$$.ctx[16];
  }
  set flipX(e) {
    this.$$set({ flipX: e }), ne();
  }
  get startFrame() {
    return this.$$.ctx[17];
  }
  set startFrame(e) {
    this.$$set({ startFrame: e }), ne();
  }
  get endFrame() {
    return this.$$.ctx[18];
  }
  set endFrame(e) {
    this.$$set({ endFrame: e }), ne();
  }
  get rows() {
    return this.$$.ctx[19];
  }
  set rows(e) {
    this.$$set({ rows: e }), ne();
  }
  get columns() {
    return this.$$.ctx[20];
  }
  set columns(e) {
    this.$$set({ columns: e }), ne();
  }
  get totalFrames() {
    return this.$$.ctx[21];
  }
  set totalFrames(e) {
    this.$$set({ totalFrames: e }), ne();
  }
  get is() {
    return this.$$.ctx[3];
  }
  set is(e) {
    this.$$set({ is: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
  get play() {
    return this.$$.ctx[22];
  }
  get pause() {
    return this.$$.ctx[23];
  }
}
St(Ak, { textureUrl: {}, dataUrl: {}, animation: {}, loop: { type: "Boolean" }, autoplay: { type: "Boolean" }, fps: {}, filter: {}, alphaTest: {}, delay: {}, transparent: { type: "Boolean" }, flipX: { type: "Boolean" }, startFrame: {}, endFrame: {}, rows: {}, columns: {}, totalFrames: {}, is: {}, ref: {} }, [], ["play", "pause"], !0);
const _k = (s) => ({ ref: s & /*ref*/
4096 }), iv = (s) => ({ ref: (
  /*ref*/
  s[12]
) });
function bk(s) {
  let e, t, n, i, r;
  e = new ee.EdgesGeometry({
    props: {
      args: [
        /*geometry*/
        s[2],
        /*thresholdAngle*/
        s[0]
      ]
    }
  }), n = new ee.LineBasicMaterial({ props: { color: (
    /*color*/
    s[1]
  ) } });
  const a = (
    /*#slots*/
    s[9].default
  ), o = yt(
    a,
    s,
    /*$$scope*/
    s[11],
    iv
  );
  return {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), o && o.c();
    },
    m(l, c) {
      K(e, l, c), we(l, t, c), K(n, l, c), we(l, i, c), o && o.m(l, c), r = !0;
    },
    p(l, c) {
      const u = {};
      c & /*geometry, thresholdAngle*/
      5 && (u.args = [
        /*geometry*/
        l[2],
        /*thresholdAngle*/
        l[0]
      ]), e.$set(u);
      const f = {};
      c & /*color*/
      2 && (f.color = /*color*/
      l[1]), n.$set(f), o && o.p && (!r || c & /*$$scope, ref*/
      6144) && wt(
        o,
        a,
        l,
        /*$$scope*/
        l[11],
        r ? xt(
          a,
          /*$$scope*/
          l[11],
          c,
          _k
        ) : Et(
          /*$$scope*/
          l[11]
        ),
        iv
      );
    },
    i(l) {
      r || (O(e.$$.fragment, l), O(n.$$.fragment, l), O(o, l), r = !0);
    },
    o(l) {
      N(e.$$.fragment, l), N(n.$$.fragment, l), N(o, l), r = !1;
    },
    d(l) {
      l && (xe(t), xe(i)), J(e, l), J(n, l), o && o.d(l);
    }
  };
}
function vk(s) {
  let e, t;
  const n = [
    /*$$restProps*/
    s[6]
  ];
  let i = {
    $$slots: {
      default: [
        bk,
        ({ ref: r }) => ({ 12: r }),
        ({ ref: r }) => r ? 4096 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee.LineSegments({ props: i }), s[10](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*$$restProps*/
      64 ? jt(n, [Kt(
        /*$$restProps*/
        r[6]
      )]) : {};
      a & /*$$scope, ref, color, geometry, thresholdAngle*/
      6151 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[10](null), J(e, r);
    }
  };
}
function yk(s, e, t) {
  let n, i;
  const r = ["thresholdAngle", "color"];
  let a = ft(e, r), o, l, { $$slots: c = {}, $$scope: u } = e, { thresholdAngle: f = void 0 } = e, { color: h = void 0 } = e;
  const d = Er();
  if (lt(s, d, (g) => t(8, o = g)), !o || o.type !== "Mesh")
    throw new Error("Edges: component must be a child of a Mesh");
  const m = An();
  lt(s, m, (g) => t(3, l = g));
  function _(g) {
    Ut[g ? "unshift" : "push"](() => {
      l = g, m.set(l);
    });
  }
  return s.$$set = (g) => {
    e = We(We({}, e), rn(g)), t(6, a = ft(e, r)), "thresholdAngle" in g && t(0, f = g.thresholdAngle), "color" in g && t(1, h = g.color), "$$scope" in g && t(11, u = g.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*$parent*/
    256 && t(7, n = o), s.$$.dirty & /*parentMesh*/
    128 && t(2, i = "clone" in n.geometry ? n.geometry.clone() : n.geometry);
  }, [
    f,
    h,
    i,
    l,
    d,
    m,
    a,
    n,
    o,
    c,
    _,
    u
  ];
}
class xk extends Mt {
  constructor(e) {
    super(), Ct(this, e, yk, vk, _t, { thresholdAngle: 0, color: 1 });
  }
  get thresholdAngle() {
    return this.$$.ctx[0];
  }
  set thresholdAngle(e) {
    this.$$set({ thresholdAngle: e }), ne();
  }
  get color() {
    return this.$$.ctx[1];
  }
  set color(e) {
    this.$$set({ color: e }), ne();
  }
}
St(xk, { thresholdAngle: {}, color: {} }, ["default"], [], !0);
const wk = () => {
  const s = Gr();
  return {
    hasEventListeners: (t) => {
      const n = s.$$.callbacks;
      return t in n && n[t].length > 0;
    }
  };
}, Vu = new H(), YA = new H(), Ek = new H(), cE = (s) => s.isOrthographicCamera, uE = (s) => s.isPerspectiveCamera, Ck = (s) => cE(s) || uE(s), Sk = (s, e, t) => {
  const n = Vu.setFromMatrixPosition(s.matrixWorld);
  n.project(e);
  const i = t.width / 2, r = t.height / 2;
  return [n.x * i + i, -(n.y * r) + r];
}, Mk = (s, e) => {
  const t = Vu.setFromMatrixPosition(s.matrixWorld), n = YA.setFromMatrixPosition(e.matrixWorld), i = t.sub(n), r = e.getWorldDirection(Ek);
  return i.angleTo(r) > Math.PI / 2;
}, Ik = (s, e, t, n) => {
  const i = Vu.setFromMatrixPosition(s.matrixWorld), r = i.clone();
  r.project(e), t.setFromCamera(r, e);
  const a = t.intersectObjects(n, !0);
  if (a.length) {
    const o = a[0].distance;
    return i.distanceTo(t.ray.origin) < o;
  }
  return !0;
}, Tk = (s, e) => {
  if (cE(e))
    return e.zoom;
  if (uE(e)) {
    const t = Vu.setFromMatrixPosition(s.matrixWorld), n = YA.setFromMatrixPosition(e.matrixWorld), i = e.fov * Math.PI / 180, r = t.distanceTo(n);
    return 1 / (2 * Math.tan(i / 2) * r);
  } else
    return 1;
}, Bk = (s, e, t) => {
  if (Ck(e)) {
    const n = Vu.setFromMatrixPosition(s.matrixWorld), i = YA.setFromMatrixPosition(e.matrixWorld), r = n.distanceTo(i), a = (t[1] - t[0]) / (e.far - e.near), o = t[1] - a * e.far;
    return Math.round(a * r + o);
  }
}, Dg = (s) => Math.abs(s) < 1e-10 ? 0 : s, fE = (s, e, t = "") => {
  let n = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    n += Dg(e[i] * s.elements[i]) + (i !== 15 ? "," : ")");
  return t + n;
}, Pk = ((s) => (e) => fE(e, s))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), Rk = ((s) => (e, t) => fE(e, s(t), "translate(-50%,-50%)"))((s) => [
  1 / s,
  1 / s,
  1 / s,
  1,
  -1 / s,
  -1 / s,
  -1 / s,
  -1,
  1 / s,
  1 / s,
  1 / s,
  1,
  1,
  1,
  1,
  1
]), Dk = (s) => s.split(/(?=[A-Z])/).join("-").toLowerCase(), ns = (s) => Object.entries(s).filter(([e, t]) => !!t).map(([e, t]) => `${Dk(e)}: ${t}`).join("; "), sr = (s, e) => {
  s.update((t) => ({
    ...t,
    ...e
  }));
}, Lk = (s) => ({ ref: s[0] & /*ref*/
4 }), rv = (s) => ({ ref: (
  /*ref*/
  s[2]
) });
function kk(s) {
  let e;
  const t = (
    /*#slots*/
    s[40].threlte
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[46],
    rv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[0] & /*ref*/
      4 | r[1] & /*$$scope*/
      32768) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[46],
        e ? xt(
          t,
          /*$$scope*/
          i[46],
          r,
          Lk
        ) : Et(
          /*$$scope*/
          i[46]
        ),
        rv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function Uk(s) {
  let e = (
    /*as*/
    s[1]
  ), t, n, i = (
    /*as*/
    s[1] && mm(s)
  );
  return {
    c() {
      i && i.c(), t = ji();
    },
    m(r, a) {
      i && i.m(r, a), we(r, t, a), n = !0;
    },
    p(r, a) {
      /*as*/
      r[1] ? e ? _t(
        e,
        /*as*/
        r[1]
      ) ? (i.d(1), i = mm(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : i.p(r, a) : (i = mm(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : e && (i.d(1), i = null, e = /*as*/
      r[1]);
    },
    i(r) {
      n || (O(i, r), n = !0);
    },
    o(r) {
      N(i, r), n = !1;
    },
    d(r) {
      r && xe(t), i && i.d(r);
    }
  };
}
function Fk(s) {
  let e = (
    /*as*/
    s[1]
  ), t, n, i = (
    /*as*/
    s[1] && gm(s)
  );
  return {
    c() {
      i && i.c(), t = ji();
    },
    m(r, a) {
      i && i.m(r, a), we(r, t, a), n = !0;
    },
    p(r, a) {
      /*as*/
      r[1] ? e ? _t(
        e,
        /*as*/
        r[1]
      ) ? (i.d(1), i = gm(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : i.p(r, a) : (i = gm(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : e && (i.d(1), i = null, e = /*as*/
      r[1]);
    },
    i(r) {
      n || (O(i, r), n = !0);
    },
    o(r) {
      N(i, r), n = !1;
    },
    d(r) {
      r && xe(t), i && i.d(r);
    }
  };
}
function sv(s) {
  let e;
  const t = (
    /*#slots*/
    s[40].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[46],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[1] & /*$$scope*/
      32768) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[46],
        e ? xt(
          t,
          /*$$scope*/
          i[46],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[46]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function mm(s) {
  let e, t, n, i, r, a, o, l = (
    /*showEl*/
    s[6] && sv(s)
  ), c = [
    {
      style: i = ns(
        /*$noTransformElStyles*/
        s[11]
      )
    }
  ], u = {};
  for (let f = 0; f < c.length; f += 1)
    u = We(u, c[f]);
  return {
    c() {
      e = Rs(
        /*as*/
        s[1]
      ), t = Rs("div"), l && l.c(), Fr(t, "style", n = ns(
        /*$noTransformDivStyles*/
        s[12]
      )), Nh(
        /*as*/
        s[1]
      )(e, u);
    },
    m(f, h) {
      we(f, e, h), Oh(e, t), l && l.m(t, null), s[45](e), r = !0, a || (o = [
        Fh(
          /*portalAction*/
          s[23].call(null, e)
        ),
        Fh(
          /*buildDefaultNonTransformStyles*/
          s[22].call(null, e)
        )
      ], a = !0);
    },
    p(f, h) {
      /*showEl*/
      f[6] ? l ? (l.p(f, h), h[0] & /*showEl*/
      64 && O(l, 1)) : (l = sv(f), l.c(), O(l, 1), l.m(t, null)) : l && (Li(), N(l, 1, 1, () => {
        l = null;
      }), ki()), (!r || h[0] & /*$noTransformDivStyles*/
      4096 && n !== (n = ns(
        /*$noTransformDivStyles*/
        f[12]
      ))) && Fr(t, "style", n), Nh(
        /*as*/
        f[1]
      )(e, u = jt(c, [
        (!r || h[0] & /*$noTransformElStyles*/
        2048 && i !== (i = ns(
          /*$noTransformElStyles*/
          f[11]
        ))) && { style: i }
      ]));
    },
    i(f) {
      r || (O(l), r = !0);
    },
    o(f) {
      N(l), r = !1;
    },
    d(f) {
      f && xe(e), l && l.d(), s[45](null), a = !1, xa(o);
    }
  };
}
function ov(s) {
  let e;
  const t = (
    /*#slots*/
    s[40].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[46],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[1] & /*$$scope*/
      32768) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[46],
        e ? xt(
          t,
          /*$$scope*/
          i[46],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[46]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function gm(s) {
  let e, t, n, i, r, a, o, l, c, u = (
    /*showEl*/
    s[6] && ov(s)
  ), f = [
    {
      style: a = ns(
        /*$transformElStyles*/
        s[8]
      )
    }
  ], h = {};
  for (let d = 0; d < f.length; d += 1)
    h = We(h, f[d]);
  return {
    c() {
      e = Rs(
        /*as*/
        s[1]
      ), t = Rs("div"), n = Rs("div"), u && u.c(), Fr(n, "style", i = ns(
        /*$transformInnerRefStyles*/
        s[10]
      )), Fr(t, "style", r = ns(
        /*$transformOuterRefStyles*/
        s[9]
      )), Nh(
        /*as*/
        s[1]
      )(e, h);
    },
    m(d, m) {
      we(d, e, m), Oh(e, t), Oh(t, n), u && u.m(n, null), s[42](n), s[43](t), s[44](e), o = !0, l || (c = Fh(
        /*portalAction*/
        s[23].call(null, e)
      ), l = !0);
    },
    p(d, m) {
      /*showEl*/
      d[6] ? u ? (u.p(d, m), m[0] & /*showEl*/
      64 && O(u, 1)) : (u = ov(d), u.c(), O(u, 1), u.m(n, null)) : u && (Li(), N(u, 1, 1, () => {
        u = null;
      }), ki()), (!o || m[0] & /*$transformInnerRefStyles*/
      1024 && i !== (i = ns(
        /*$transformInnerRefStyles*/
        d[10]
      ))) && Fr(n, "style", i), (!o || m[0] & /*$transformOuterRefStyles*/
      512 && r !== (r = ns(
        /*$transformOuterRefStyles*/
        d[9]
      ))) && Fr(t, "style", r), Nh(
        /*as*/
        d[1]
      )(e, h = jt(f, [
        (!o || m[0] & /*$transformElStyles*/
        256 && a !== (a = ns(
          /*$transformElStyles*/
          d[8]
        ))) && { style: a }
      ]));
    },
    i(d) {
      o || (O(u), o = !0);
    },
    o(d) {
      N(u), o = !1;
    },
    d(d) {
      d && xe(e), u && u.d(), s[42](null), s[43](null), s[44](null), l = !1, c();
    }
  };
}
function Ok(s) {
  let e, t, n, i, r, a;
  const o = [
    { is: (
      /*ref*/
      s[2]
    ) },
    /*$$restProps*/
    s[25]
  ];
  let l = {
    $$slots: {
      default: [kk, ({ ref: h }) => ({ 2: h }), ({ ref: h }) => [h ? 4 : 0]]
    },
    $$scope: { ctx: s }
  };
  for (let h = 0; h < o.length; h += 1)
    l = We(l, o[h]);
  e = new ee({ props: l }), s[41](e);
  const c = [Fk, Uk], u = [];
  function f(h, d) {
    return (
      /*transform*/
      h[0] ? 0 : 1
    );
  }
  return n = f(s), i = u[n] = c[n](s), {
    c() {
      Z(e.$$.fragment), t = Me(), i.c(), r = ji();
    },
    m(h, d) {
      K(e, h, d), we(h, t, d), u[n].m(h, d), we(h, r, d), a = !0;
    },
    p(h, d) {
      const m = d[0] & /*ref, $$restProps*/
      33554436 ? jt(o, [
        d[0] & /*ref*/
        4 && { is: (
          /*ref*/
          h[2]
        ) },
        d[0] & /*$$restProps*/
        33554432 && Kt(
          /*$$restProps*/
          h[25]
        )
      ]) : {};
      d[0] & /*ref*/
      4 | d[1] & /*$$scope*/
      32768 && (m.$$scope = { dirty: d, ctx: h }), e.$set(m);
      let _ = n;
      n = f(h), n === _ ? u[n].p(h, d) : (Li(), N(u[_], 1, 1, () => {
        u[_] = null;
      }), ki(), i = u[n], i ? i.p(h, d) : (i = u[n] = c[n](h), i.c()), O(i, 1), i.m(r.parentNode, r));
    },
    i(h) {
      a || (O(e.$$.fragment, h), O(i), a = !0);
    },
    o(h) {
      N(e.$$.fragment, h), N(i), a = !1;
    },
    d(h) {
      h && (xe(t), xe(r)), s[41](null), J(e, h), u[n].d(h);
    }
  };
}
function Nk(s, e, t) {
  const n = [
    "transform",
    "calculatePosition",
    "eps",
    "occlude",
    "zIndexRange",
    "sprite",
    "pointerEvents",
    "center",
    "fullscreen",
    "distanceFactor",
    "as",
    "portal",
    "ref",
    "visible"
  ];
  let i = ft(e, n), r, a, o, l, c, u, f, h, d, m, { $$slots: _ = {}, $$scope: g } = e, { transform: A = !1 } = e, { calculatePosition: v = Sk } = e, { eps: y = 1e-3 } = e, { occlude: w = !1 } = e, { zIndexRange: E = [16777271, 0] } = e, { sprite: I = !1 } = e, { pointerEvents: C = "auto" } = e, { center: B = !1 } = e, { fullscreen: T = !1 } = e, { distanceFactor: S = void 0 } = e, { as: D = "div" } = e, { portal: R = void 0 } = e;
  const P = us();
  let { ref: L = new Xn() } = e;
  const { renderer: V, camera: U, scene: Q, size: q } = un();
  lt(s, U, (he) => t(50, a = he)), lt(s, q, (he) => t(37, r = he));
  const oe = (he) => he.isPerspectiveCamera || he.isOrthographicCamera, le = () => {
    if (!oe(a))
      throw new Error("Only PerspectiveCamera or OrthographicCamera supported for component <HTML>");
    return a;
  }, k = new zu();
  let X = [0, 0], fe = 0, { visible: te = !0 } = e, j = document.createElement(D), Ae, Y;
  const { hasEventListeners: pe } = wk();
  let me = typeof w == "boolean" && w === !0 ? [Q] : Array.isArray(w) ? w : void 0;
  const re = hi(q, (he) => he.width / 2);
  lt(s, re, (he) => t(39, l = he));
  const ye = hi(q, (he) => he.height / 2);
  lt(s, ye, (he) => t(38, o = he));
  let ae = {
    common: { el: Ft({}) },
    transform: {
      el: Ft({
        position: "absolute",
        top: "0",
        left: "0",
        pointerEvents: "none",
        overflow: "hidden",
        display: "block",
        width: `${r.width}px`,
        height: `${r.height}px`
      }),
      outerRef: Ft({
        position: "absolute",
        top: "0",
        left: "0",
        width: `${r.width}px`,
        height: `${r.height}px`,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
      }),
      innerRef: Ft({ position: "absolute", pointerEvents: C })
    },
    noTransform: {
      el: Ft({}),
      div: Ft({
        position: "absolute",
        transform: B ? "translate3d(-50%,-50%,0)" : "none",
        top: T ? `${-o}px` : void 0,
        left: T ? `${-l}px` : void 0,
        width: T ? `${r.width}px` : void 0,
        height: T ? `${r.height}px` : void 0
      })
    }
  };
  const De = hi([ae.transform.el, ae.common.el], ([he, Se]) => ({ ...he, ...Se }));
  lt(s, De, (he) => t(8, u = he));
  const Ee = hi(ae.transform.outerRef, (he) => he);
  lt(s, Ee, (he) => t(9, f = he));
  const Ie = hi(ae.transform.innerRef, (he) => he);
  lt(s, Ie, (he) => t(10, h = he));
  const Ce = hi(ae.noTransform.el, (he) => he);
  lt(s, Ce, (he) => t(11, d = he));
  const ze = hi(ae.noTransform.div, (he) => he);
  lt(s, ze, (he) => t(12, m = he));
  const Fe = () => {
    let he = !0, Se = L.parent;
    e:
      for (; Se; ) {
        if ("visible" in Se && !Se.visible) {
          he = !1;
          break e;
        }
        Se = Se.parent;
      }
    return he;
  };
  let W = Fe();
  On(async () => {
    t(6, W = Fe());
    const he = le();
    he.updateMatrixWorld(), L.updateWorldMatrix(!0, !1);
    const Se = A ? X : v(L, he, r);
    if (A || Math.abs(fe - he.zoom) > y || Math.abs(X[0] - Se[0]) > y || Math.abs(X[1] - Se[1]) > y) {
      const Ve = Mk(L, he), Ye = te;
      if (me) {
        const $e = Ik(L, he, k, me);
        t(26, te = $e && !Ve);
      } else
        t(26, te = !Ve);
      if (Ye !== te && (pe("visibilitychange") ? P("visibilitychange", te) : sr(ae.common.el, { display: te ? "block" : "none" })), sr(ae.common.el, {
        zIndex: `${Bk(L, he, E)}`
      }), A) {
        const $e = he.projectionMatrix.elements[5] * o, { isOrthographicCamera: Ne, top: He, left: Qe, bottom: Ze, right: Ke } = he;
        let $ = L.matrixWorld;
        if (I && ($ = he.matrixWorldInverse.clone().transpose().copyPosition($).scale(L.scale), $.elements[3] = $.elements[7] = $.elements[11] = 0, $.elements[15] = 1), sr(ae.transform.el, {
          perspective: Ne ? "" : `${$e}px`
        }), Ae && Y) {
          const ge = Ne ? `scale(${$e}) translate(${Dg(-(Ke + Qe) / 2)}px,${Dg((He + Ze) / 2)}px)` : `translateZ(${$e}px)`, be = Pk(he.matrixWorldInverse);
          sr(ae.transform.outerRef, {
            transform: `${ge}${be}translate(${l}px, ${o}px)`
          }), sr(ae.transform.innerRef, {
            transform: Rk($, 1 / ((S || 10) / 400))
          });
        }
      } else {
        const $e = S === void 0 ? 1 : Tk(L, he) * S;
        sr(ae.noTransform.el, {
          transform: `translate3d(${Se[0]}px, ${Se[1]}px, 0) scale(${$e})`
        });
      }
      X = Se, fe = he.zoom;
    }
  });
  const G = (he) => {
    if (!L || A)
      return;
    Q.updateMatrixWorld();
    const Se = v(L, a, r);
    sr(ae.noTransform.el, {
      position: "absolute",
      top: "0",
      left: "0",
      transform: `translate3d(${Se[0]}px, ${Se[1]}px, 0)`,
      transformOrigin: "0 0"
    });
  }, se = (he) => {
    const Se = R ?? V.domElement.parentElement;
    if (!Se) {
      console.warn("HTML: target is undefined.");
      return;
    }
    return Se.appendChild(he), {
      destroy: () => {
        he.parentNode && he.parentNode.removeChild(he);
      }
    };
  }, _e = An();
  lt(s, _e, (he) => t(7, c = he));
  function ve(he) {
    Ut[he ? "unshift" : "push"](() => {
      c = he, _e.set(c);
    });
  }
  function ue(he) {
    Ut[he ? "unshift" : "push"](() => {
      Y = he, t(5, Y);
    });
  }
  function Te(he) {
    Ut[he ? "unshift" : "push"](() => {
      Ae = he, t(4, Ae);
    });
  }
  function Ge(he) {
    Ut[he ? "unshift" : "push"](() => {
      j = he, t(3, j);
    });
  }
  function Pe(he) {
    Ut[he ? "unshift" : "push"](() => {
      j = he, t(3, j);
    });
  }
  return s.$$set = (he) => {
    e = We(We({}, e), rn(he)), t(25, i = ft(e, n)), "transform" in he && t(0, A = he.transform), "calculatePosition" in he && t(27, v = he.calculatePosition), "eps" in he && t(28, y = he.eps), "occlude" in he && t(29, w = he.occlude), "zIndexRange" in he && t(30, E = he.zIndexRange), "sprite" in he && t(31, I = he.sprite), "pointerEvents" in he && t(32, C = he.pointerEvents), "center" in he && t(33, B = he.center), "fullscreen" in he && t(34, T = he.fullscreen), "distanceFactor" in he && t(35, S = he.distanceFactor), "as" in he && t(1, D = he.as), "portal" in he && t(36, R = he.portal), "ref" in he && t(2, L = he.ref), "visible" in he && t(26, te = he.visible), "$$scope" in he && t(46, g = he.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*occlude*/
    536870912 && (me = typeof w == "boolean" && w === !0 ? [Q] : Array.isArray(w) ? w : void 0), s.$$.dirty[1] & /*$size*/
    64 && sr(ae.transform.el, {
      width: `${r.width}px`,
      height: `${r.height}px`
    }), s.$$.dirty[1] & /*$size*/
    64 && sr(ae.transform.outerRef, {
      width: `${r.width}px`,
      height: `${r.height}px`
    }), s.$$.dirty[1] & /*pointerEvents*/
    2 && sr(ae.transform.innerRef, { pointerEvents: C }), s.$$.dirty[1] & /*pointerEvents*/
    2 && sr(ae.noTransform.div, { pointerEvents: C }), s.$$.dirty[1] & /*center*/
    4 && sr(ae.noTransform.div, {
      transform: B ? "translate3d(-50%, -50%, 0)" : "none"
    }), s.$$.dirty[1] & /*fullscreen, $heightHalf, $widthHalf, $size*/
    456 && sr(ae.noTransform.div, {
      top: T ? `${-o}px` : void 0,
      left: T ? `${-l}px` : void 0,
      width: T ? `${r.width}px` : void 0,
      height: T ? `${r.height}px` : void 0
    });
  }, [
    A,
    D,
    L,
    j,
    Ae,
    Y,
    W,
    c,
    u,
    f,
    h,
    d,
    m,
    U,
    q,
    re,
    ye,
    De,
    Ee,
    Ie,
    Ce,
    ze,
    G,
    se,
    _e,
    i,
    te,
    v,
    y,
    w,
    E,
    I,
    C,
    B,
    T,
    S,
    R,
    r,
    o,
    l,
    _,
    ve,
    ue,
    Te,
    Ge,
    Pe,
    g
  ];
}
class Gk extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      Nk,
      Ok,
      _t,
      {
        transform: 0,
        calculatePosition: 27,
        eps: 28,
        occlude: 29,
        zIndexRange: 30,
        sprite: 31,
        pointerEvents: 32,
        center: 33,
        fullscreen: 34,
        distanceFactor: 35,
        as: 1,
        portal: 36,
        ref: 2,
        visible: 26
      },
      null,
      [-1, -1]
    );
  }
  get transform() {
    return this.$$.ctx[0];
  }
  set transform(e) {
    this.$$set({ transform: e }), ne();
  }
  get calculatePosition() {
    return this.$$.ctx[27];
  }
  set calculatePosition(e) {
    this.$$set({ calculatePosition: e }), ne();
  }
  get eps() {
    return this.$$.ctx[28];
  }
  set eps(e) {
    this.$$set({ eps: e }), ne();
  }
  get occlude() {
    return this.$$.ctx[29];
  }
  set occlude(e) {
    this.$$set({ occlude: e }), ne();
  }
  get zIndexRange() {
    return this.$$.ctx[30];
  }
  set zIndexRange(e) {
    this.$$set({ zIndexRange: e }), ne();
  }
  get sprite() {
    return this.$$.ctx[31];
  }
  set sprite(e) {
    this.$$set({ sprite: e }), ne();
  }
  get pointerEvents() {
    return this.$$.ctx[32];
  }
  set pointerEvents(e) {
    this.$$set({ pointerEvents: e }), ne();
  }
  get center() {
    return this.$$.ctx[33];
  }
  set center(e) {
    this.$$set({ center: e }), ne();
  }
  get fullscreen() {
    return this.$$.ctx[34];
  }
  set fullscreen(e) {
    this.$$set({ fullscreen: e }), ne();
  }
  get distanceFactor() {
    return this.$$.ctx[35];
  }
  set distanceFactor(e) {
    this.$$set({ distanceFactor: e }), ne();
  }
  get as() {
    return this.$$.ctx[1];
  }
  set as(e) {
    this.$$set({ as: e }), ne();
  }
  get portal() {
    return this.$$.ctx[36];
  }
  set portal(e) {
    this.$$set({ portal: e }), ne();
  }
  get ref() {
    return this.$$.ctx[2];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
  get visible() {
    return this.$$.ctx[26];
  }
  set visible(e) {
    this.$$set({ visible: e }), ne();
  }
}
St(Gk, { transform: { type: "Boolean" }, calculatePosition: {}, eps: {}, occlude: { type: "Boolean" }, zIndexRange: {}, sprite: { type: "Boolean" }, pointerEvents: {}, center: { type: "Boolean" }, fullscreen: { type: "Boolean" }, distanceFactor: {}, as: {}, portal: {}, ref: {}, visible: { type: "Boolean" } }, ["threlte", "default"], [], !0);
const Qk = (s) => ({ ref: s & /*ref*/
32768 }), av = (s) => ({ ref: (
  /*ref*/
  s[15]
) });
function zk(s) {
  let e;
  const t = (
    /*#slots*/
    s[11].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[12],
    av
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      36864) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[12],
        e ? xt(
          t,
          /*$$scope*/
          i[12],
          r,
          Qk
        ) : Et(
          /*$$scope*/
          i[12]
        ),
        av
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function $k(s) {
  let e, t;
  const n = [
    { position: (
      /*floatPosition*/
      s[0]
    ) },
    { rotation: (
      /*floatRotation*/
      s[1]
    ) },
    /*$$restProps*/
    s[2]
  ];
  let i = {
    $$slots: {
      default: [
        zk,
        ({ ref: r }) => ({ 15: r }),
        ({ ref: r }) => r ? 32768 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee.Group({ props: i }), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*floatPosition, floatRotation, $$restProps*/
      7 ? jt(n, [
        a & /*floatPosition*/
        1 && { position: (
          /*floatPosition*/
          r[0]
        ) },
        a & /*floatRotation*/
        2 && { rotation: (
          /*floatRotation*/
          r[1]
        ) },
        a & /*$$restProps*/
        4 && Kt(
          /*$$restProps*/
          r[2]
        )
      ]) : {};
      a & /*$$scope, ref*/
      36864 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      J(e, r);
    }
  };
}
function Vk(s, e, t) {
  const n = [
    "position",
    "rotation",
    "speed",
    "floatIntensity",
    "floatingRange",
    "rotationSpeed",
    "rotationIntensity",
    "seed"
  ];
  let i = ft(e, n), { $$slots: r = {}, $$scope: a } = e, { position: o = 0 } = e, { rotation: l = 0 } = e, { speed: c = 1 } = e, { floatIntensity: u = 1 } = e, { floatingRange: f = [-0.1, 0.1] } = e, { rotationSpeed: h = 0 } = e, { rotationIntensity: d = 0 } = e, { seed: m = Math.random() * 1e4 } = e, _ = m, g = Array.isArray(o) ? o : [o, o, o];
  const A = ls.mapLinear;
  let v = Array.isArray(l) ? l : [l, l, l];
  return On((y) => {
    _ += y;
    const w = Array.isArray(c) ? c : [c, c, c], E = Array.isArray(u) ? u : [u, u, u], I = f.length == 3 ? f : [[0, 0], f, [0, 0]];
    t(0, g = Array.isArray(o) ? o : [o, o, o]), t(0, g[0] = g[0] + A(Math.sin(_ / 4 * w[0]) / 10, -0.1, 0.1, ...I[0]) * E[0], g), t(0, g[1] = g[1] + A(Math.sin(_ / 4 * w[1]) / 10, -0.1, 0.1, ...I[1]) * E[1], g), t(0, g[2] = g[2] + A(Math.sin(_ / 4 * w[2]) / 10, -0.1, 0.1, ...I[2]) * E[2], g), t(0, g);
    const C = Array.isArray(h) ? h : [h, h, h], B = Array.isArray(d) ? d : [d, d, d];
    t(1, v = Array.isArray(l) ? l : [l, l, l]), t(1, v[0] += Math.cos(_ / 4 * C[0]) / 8 * B[0], v), t(1, v[1] += Math.cos(_ / 4 * C[1]) / 8 * B[1], v), t(1, v[2] += Math.cos(_ / 4 * C[2]) / 8 * B[2], v);
  }), s.$$set = (y) => {
    e = We(We({}, e), rn(y)), t(2, i = ft(e, n)), "position" in y && t(3, o = y.position), "rotation" in y && t(4, l = y.rotation), "speed" in y && t(5, c = y.speed), "floatIntensity" in y && t(6, u = y.floatIntensity), "floatingRange" in y && t(7, f = y.floatingRange), "rotationSpeed" in y && t(8, h = y.rotationSpeed), "rotationIntensity" in y && t(9, d = y.rotationIntensity), "seed" in y && t(10, m = y.seed), "$$scope" in y && t(12, a = y.$$scope);
  }, [
    g,
    v,
    i,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    r,
    a
  ];
}
class Hk extends Mt {
  constructor(e) {
    super(), Ct(this, e, Vk, $k, _t, {
      position: 3,
      rotation: 4,
      speed: 5,
      floatIntensity: 6,
      floatingRange: 7,
      rotationSpeed: 8,
      rotationIntensity: 9,
      seed: 10
    });
  }
  get position() {
    return this.$$.ctx[3];
  }
  set position(e) {
    this.$$set({ position: e }), ne();
  }
  get rotation() {
    return this.$$.ctx[4];
  }
  set rotation(e) {
    this.$$set({ rotation: e }), ne();
  }
  get speed() {
    return this.$$.ctx[5];
  }
  set speed(e) {
    this.$$set({ speed: e }), ne();
  }
  get floatIntensity() {
    return this.$$.ctx[6];
  }
  set floatIntensity(e) {
    this.$$set({ floatIntensity: e }), ne();
  }
  get floatingRange() {
    return this.$$.ctx[7];
  }
  set floatingRange(e) {
    this.$$set({ floatingRange: e }), ne();
  }
  get rotationSpeed() {
    return this.$$.ctx[8];
  }
  set rotationSpeed(e) {
    this.$$set({ rotationSpeed: e }), ne();
  }
  get rotationIntensity() {
    return this.$$.ctx[9];
  }
  set rotationIntensity(e) {
    this.$$set({ rotationIntensity: e }), ne();
  }
  get seed() {
    return this.$$.ctx[10];
  }
  set seed(e) {
    this.$$set({ seed: e }), ne();
  }
}
St(Hk, { position: {}, rotation: {}, speed: {}, floatIntensity: {}, floatingRange: {}, rotationSpeed: {}, rotationIntensity: {}, seed: {} }, ["default"], [], !0);
const jk = (s) => ({ ref: s & /*ref*/
67108864 }), lv = (s) => ({ ref: (
  /*ref*/
  s[26]
) });
function cv(s) {
  let e, t;
  const n = [
    { is: (
      /*scene*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [
        Wk,
        ({ ref: r }) => ({ 26: r }),
        ({ ref: r }) => r ? 67108864 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[18](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*scene, $$restProps*/
      9 ? jt(n, [
        a & /*scene*/
        1 && { is: (
          /*scene*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      67633152 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[18](null), J(e, r);
    }
  };
}
function Wk(s) {
  let e;
  const t = (
    /*#slots*/
    s[17].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[19],
    lv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      67633152) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[19],
        e ? xt(
          t,
          /*$$scope*/
          i[19],
          r,
          jk
        ) : Et(
          /*$$scope*/
          i[19]
        ),
        lv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function qk(s) {
  let e, t, n = (
    /*scene*/
    s[0] && cv(s)
  );
  return {
    c() {
      n && n.c(), e = ji();
    },
    m(i, r) {
      n && n.m(i, r), we(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*scene*/
      i[0] ? n ? (n.p(i, r), r & /*scene*/
      1 && O(n, 1)) : (n = cv(i), n.c(), O(n, 1), n.m(e.parentNode, e)) : n && (Li(), N(n, 1, 1, () => {
        n = null;
      }), ki());
    },
    i(i) {
      t || (O(n), t = !0);
    },
    o(i) {
      N(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function Xk(s, e, t) {
  const n = [
    "url",
    "useDraco",
    "useMeshopt",
    "ktxTranscoderPath",
    "gltf",
    "scene",
    "animations",
    "asset",
    "cameras",
    "scenes",
    "userData",
    "parser",
    "materials",
    "nodes"
  ];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e;
  const l = An();
  lt(s, l, (L) => t(1, r = L));
  let { url: c } = e, { useDraco: u = !1 } = e, { useMeshopt: f = !1 } = e, { ktxTranscoderPath: h = void 0 } = e;
  const d = us();
  let { gltf: m = void 0 } = e, { scene: _ = void 0 } = e, { animations: g = void 0 } = e, { asset: A = void 0 } = e, { cameras: v = void 0 } = e, { scenes: y = void 0 } = e, { userData: w = void 0 } = e, { parser: E = void 0 } = e, { materials: I = void 0 } = e, { nodes: C = void 0 } = e;
  const B = Ud({
    useDraco: u ? typeof u == "string" ? u : "https://www.gstatic.com/draco/v1/decoders/" : void 0,
    useMeshopt: f,
    ktxTranscoderPath: h
  }), T = (L) => {
    m && d("unload"), t(4, m = L), t(0, _ = L.scene), t(5, g = L.animations), t(6, A = L.asset), t(7, v = L.cameras), t(8, y = L.scenes), t(9, w = L.userData), t(10, E = L.parser), t(11, I = L.materials), t(12, C = L.nodes), d("load", m);
  }, S = (L) => {
    console.error(`Error loading GLTF: ${L.message}`), t(4, m = void 0), t(0, _ = void 0), t(5, g = void 0), t(6, A = void 0), t(7, v = void 0), t(8, y = void 0), t(9, w = void 0), t(10, E = void 0), t(12, C = void 0), t(11, I = void 0), d("error", L.message);
  }, D = rc(), R = async (L) => {
    try {
      const V = await D(B.load(L));
      T(V);
    } catch (V) {
      S(V);
    }
  };
  function P(L) {
    Ut[L ? "unshift" : "push"](() => {
      r = L, l.set(r);
    });
  }
  return s.$$set = (L) => {
    e = We(We({}, e), rn(L)), t(3, i = ft(e, n)), "url" in L && t(13, c = L.url), "useDraco" in L && t(14, u = L.useDraco), "useMeshopt" in L && t(15, f = L.useMeshopt), "ktxTranscoderPath" in L && t(16, h = L.ktxTranscoderPath), "gltf" in L && t(4, m = L.gltf), "scene" in L && t(0, _ = L.scene), "animations" in L && t(5, g = L.animations), "asset" in L && t(6, A = L.asset), "cameras" in L && t(7, v = L.cameras), "scenes" in L && t(8, y = L.scenes), "userData" in L && t(9, w = L.userData), "parser" in L && t(10, E = L.parser), "materials" in L && t(11, I = L.materials), "nodes" in L && t(12, C = L.nodes), "$$scope" in L && t(19, o = L.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*url*/
    8192 && R(c);
  }, [
    _,
    r,
    l,
    i,
    m,
    g,
    A,
    v,
    y,
    w,
    E,
    I,
    C,
    c,
    u,
    f,
    h,
    a,
    P,
    o
  ];
}
class Yk extends Mt {
  constructor(e) {
    super(), Ct(this, e, Xk, qk, _t, {
      url: 13,
      useDraco: 14,
      useMeshopt: 15,
      ktxTranscoderPath: 16,
      gltf: 4,
      scene: 0,
      animations: 5,
      asset: 6,
      cameras: 7,
      scenes: 8,
      userData: 9,
      parser: 10,
      materials: 11,
      nodes: 12
    });
  }
  get url() {
    return this.$$.ctx[13];
  }
  set url(e) {
    this.$$set({ url: e }), ne();
  }
  get useDraco() {
    return this.$$.ctx[14];
  }
  set useDraco(e) {
    this.$$set({ useDraco: e }), ne();
  }
  get useMeshopt() {
    return this.$$.ctx[15];
  }
  set useMeshopt(e) {
    this.$$set({ useMeshopt: e }), ne();
  }
  get ktxTranscoderPath() {
    return this.$$.ctx[16];
  }
  set ktxTranscoderPath(e) {
    this.$$set({ ktxTranscoderPath: e }), ne();
  }
  get gltf() {
    return this.$$.ctx[4];
  }
  set gltf(e) {
    this.$$set({ gltf: e }), ne();
  }
  get scene() {
    return this.$$.ctx[0];
  }
  set scene(e) {
    this.$$set({ scene: e }), ne();
  }
  get animations() {
    return this.$$.ctx[5];
  }
  set animations(e) {
    this.$$set({ animations: e }), ne();
  }
  get asset() {
    return this.$$.ctx[6];
  }
  set asset(e) {
    this.$$set({ asset: e }), ne();
  }
  get cameras() {
    return this.$$.ctx[7];
  }
  set cameras(e) {
    this.$$set({ cameras: e }), ne();
  }
  get scenes() {
    return this.$$.ctx[8];
  }
  set scenes(e) {
    this.$$set({ scenes: e }), ne();
  }
  get userData() {
    return this.$$.ctx[9];
  }
  set userData(e) {
    this.$$set({ userData: e }), ne();
  }
  get parser() {
    return this.$$.ctx[10];
  }
  set parser(e) {
    this.$$set({ parser: e }), ne();
  }
  get materials() {
    return this.$$.ctx[11];
  }
  set materials(e) {
    this.$$set({ materials: e }), ne();
  }
  get nodes() {
    return this.$$.ctx[12];
  }
  set nodes(e) {
    this.$$set({ nodes: e }), ne();
  }
}
St(Yk, { url: {}, useDraco: { type: "Boolean" }, useMeshopt: { type: "Boolean" }, ktxTranscoderPath: {}, gltf: {}, scene: {}, animations: {}, asset: {}, cameras: {}, scenes: {}, userData: {}, parser: {}, materials: {}, nodes: {} }, ["default"], [], !0);
function uv(s) {
  s[57] = -20;
}
function Kk(s) {
  let e, t;
  return e = new ee.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*xColor*/
          s[0],
          "X"
        )
      ),
      opacity: (
        /*p*/
        s[3][0] >= 0 ? 1 : 0.5
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, xColor*/
      4097 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*xColor*/
        n[0],
        "X"
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][0] >= 0 ? 1 : 0.5), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Jk(s) {
  let e, t, n, i;
  return e = new ee({ props: { is: (
    /*stemGeometry*/
    s[15]
  ) } }), n = new ee.MeshBasicMaterial({
    props: {
      transparent: !0,
      opacity: (
        /*p*/
        s[3][0] >= 0 ? 1 : 0.5
      ),
      color: (
        /*xColor*/
        s[0]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        s[10] && /*frontMostAxisIndex*/
        s[11] === 0 && /*p*/
        s[3][0] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        s[57]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), we(r, t, a), K(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a[0] & /*p*/
      8 && (o.opacity = /*p*/
      r[3][0] >= 0 ? 1 : 0.5), a[0] & /*xColor*/
      1 && (o.color = /*xColor*/
      r[0]), a[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      3080 && (o.polygonOffset = /*usePolygonOffset*/
      r[10] && /*frontMostAxisIndex*/
      r[11] === 0 && /*p*/
      r[3][0] < 0.75), n.$set(o);
    },
    i(r) {
      i || (O(e.$$.fragment, r), O(n.$$.fragment, r), i = !0);
    },
    o(r) {
      N(e.$$.fragment, r), N(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && xe(t), J(e, r), J(n, r);
    }
  };
}
function Zk(s) {
  let e, t;
  return e = new ee.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*xColor*/
          s[0]
        )
      ),
      opacity: (
        /*p*/
        s[3][0] >= 0 ? 0.5 : 1
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, xColor*/
      4097 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*xColor*/
        n[0]
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][0] >= 0 ? 0.5 : 1), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function eU(s) {
  let e, t;
  return e = new ee.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*yColor*/
          s[1],
          "Y"
        )
      ),
      opacity: (
        /*p*/
        s[3][1] >= 0 ? 1 : 0.5
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, yColor*/
      4098 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*yColor*/
        n[1],
        "Y"
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][1] >= 0 ? 1 : 0.5), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function tU(s) {
  let e, t, n, i;
  return e = new ee({ props: { is: (
    /*stemGeometry*/
    s[15]
  ) } }), n = new ee.MeshBasicMaterial({
    props: {
      transparent: !0,
      opacity: (
        /*p*/
        s[3][1] >= 0 ? 1 : 0.5
      ),
      color: (
        /*yColor*/
        s[1]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        s[10] && /*frontMostAxisIndex*/
        s[11] === 1 && /*p*/
        s[3][1] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        s[57]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), we(r, t, a), K(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a[0] & /*p*/
      8 && (o.opacity = /*p*/
      r[3][1] >= 0 ? 1 : 0.5), a[0] & /*yColor*/
      2 && (o.color = /*yColor*/
      r[1]), a[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      3080 && (o.polygonOffset = /*usePolygonOffset*/
      r[10] && /*frontMostAxisIndex*/
      r[11] === 1 && /*p*/
      r[3][1] < 0.75), n.$set(o);
    },
    i(r) {
      i || (O(e.$$.fragment, r), O(n.$$.fragment, r), i = !0);
    },
    o(r) {
      N(e.$$.fragment, r), N(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && xe(t), J(e, r), J(n, r);
    }
  };
}
function nU(s) {
  let e, t;
  return e = new ee.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*yColor*/
          s[1]
        )
      ),
      opacity: (
        /*p*/
        s[3][1] >= 0 ? 0.5 : 1
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, yColor*/
      4098 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*yColor*/
        n[1]
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][1] >= 0 ? 0.5 : 1), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function iU(s) {
  let e, t;
  return e = new ee.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*zColor*/
          s[2],
          "Z"
        )
      ),
      opacity: (
        /*p*/
        s[3][2] >= 0 ? 1 : 0.5
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, zColor*/
      4100 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*zColor*/
        n[2],
        "Z"
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][2] >= 0 ? 1 : 0.5), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function rU(s) {
  let e, t, n, i;
  return e = new ee({ props: { is: (
    /*stemGeometry*/
    s[15]
  ) } }), n = new ee.MeshBasicMaterial({
    props: {
      transparent: !0,
      opacity: (
        /*p*/
        s[3][2] >= 0 ? 1 : 0.5
      ),
      color: (
        /*zColor*/
        s[2]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        s[10] && /*frontMostAxisIndex*/
        s[11] === 2 && /*p*/
        s[3][2] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        s[57]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), we(r, t, a), K(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a[0] & /*p*/
      8 && (o.opacity = /*p*/
      r[3][2] >= 0 ? 1 : 0.5), a[0] & /*zColor*/
      4 && (o.color = /*zColor*/
      r[2]), a[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      3080 && (o.polygonOffset = /*usePolygonOffset*/
      r[10] && /*frontMostAxisIndex*/
      r[11] === 2 && /*p*/
      r[3][2] < 0.75), n.$set(o);
    },
    i(r) {
      i || (O(e.$$.fragment, r), O(n.$$.fragment, r), i = !0);
    },
    o(r) {
      N(e.$$.fragment, r), N(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && xe(t), J(e, r), J(n, r);
    }
  };
}
function sU(s) {
  let e, t;
  return e = new ee.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*zColor*/
          s[2]
        )
      ),
      opacity: (
        /*p*/
        s[3][2] >= 0 ? 0.5 : 1
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, zColor*/
      4100 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*zColor*/
        n[2]
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][2] >= 0 ? 0.5 : 1), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function oU(s) {
  uv(s);
  let e, t, n, i, r, a, o, l, c, u, f, h, d, m, _, g, A, v, y, w, E, I, C, B;
  function T(k) {
    s[27](k);
  }
  let S = {
    renderOrder: 1,
    "position.x": 1,
    "userData.targetPosition": [1, 0, 0],
    "userData.targetEuler": [0, Math.PI * 0.5, 0],
    $$slots: { default: [Kk] },
    $$scope: { ctx: s }
  };
  /*posX*/
  s[4] !== void 0 && (S.ref = /*posX*/
  s[4]), e = new ee.Sprite({ props: S }), Ut.push(() => ar(e, "ref", T)), i = new ee.Mesh({
    props: {
      "position.x": 0.39,
      renderOrder: (
        /*frontMostAxisIndex*/
        s[11] === 0 ? -1 : 0
      ),
      $$slots: { default: [Jk] },
      $$scope: { ctx: s }
    }
  });
  function D(k) {
    s[28](k);
  }
  let R = {
    renderOrder: 1,
    "position.x": -1,
    scale: 0.8,
    "userData.targetPosition": [-1, 0, 0],
    "userData.targetEuler": [0, -Math.PI * 0.5, 0],
    $$slots: { default: [Zk] },
    $$scope: { ctx: s }
  };
  /*negX*/
  s[7] !== void 0 && (R.ref = /*negX*/
  s[7]), a = new ee.Sprite({ props: R }), Ut.push(() => ar(a, "ref", D));
  function P(k) {
    s[29](k);
  }
  let L = {
    renderOrder: 1,
    "position.y": 1,
    "userData.targetPosition": [0, 1, 0],
    "userData.targetEuler": [-Math.PI * 0.5, 0, 0],
    $$slots: { default: [eU] },
    $$scope: { ctx: s }
  };
  /*posY*/
  s[5] !== void 0 && (L.ref = /*posY*/
  s[5]), c = new ee.Sprite({ props: L }), Ut.push(() => ar(c, "ref", P)), h = new ee.Mesh({
    props: {
      "position.y": 0.39,
      "rotation.z": Math.PI / 2,
      renderOrder: (
        /*frontMostAxisIndex*/
        s[11] === 1 ? -1 : 0
      ),
      $$slots: { default: [tU] },
      $$scope: { ctx: s }
    }
  });
  function V(k) {
    s[30](k);
  }
  let U = {
    renderOrder: 1,
    "position.y": -1,
    scale: 0.8,
    "userData.targetPosition": [0, -1, 0],
    "userData.targetEuler": [Math.PI * 0.5, 0, 0],
    $$slots: { default: [nU] },
    $$scope: { ctx: s }
  };
  /*negY*/
  s[8] !== void 0 && (U.ref = /*negY*/
  s[8]), m = new ee.Sprite({ props: U }), Ut.push(() => ar(m, "ref", V));
  function Q(k) {
    s[31](k);
  }
  let q = {
    renderOrder: 1,
    "position.z": 1,
    "userData.targetPosition": [0, 0, 1],
    "userData.targetEuler": [0, 0, 0],
    $$slots: { default: [iU] },
    $$scope: { ctx: s }
  };
  /*posZ*/
  s[6] !== void 0 && (q.ref = /*posZ*/
  s[6]), A = new ee.Sprite({ props: q }), Ut.push(() => ar(A, "ref", Q)), w = new ee.Mesh({
    props: {
      "position.z": 0.39,
      "rotation.y": -Math.PI / 2,
      renderOrder: (
        /*frontMostAxisIndex*/
        s[11] === 2 ? -1 : 0
      ),
      $$slots: { default: [rU] },
      $$scope: { ctx: s }
    }
  });
  function oe(k) {
    s[32](k);
  }
  let le = {
    renderOrder: 1,
    "position.z": -1,
    scale: 0.8,
    "userData.targetPosition": [0, 0, -1],
    "userData.targetEuler": [0, Math.PI, 0],
    $$slots: { default: [sU] },
    $$scope: { ctx: s }
  };
  return (
    /*negZ*/
    s[9] !== void 0 && (le.ref = /*negZ*/
    s[9]), I = new ee.Sprite({ props: le }), Ut.push(() => ar(I, "ref", oe)), {
      c() {
        Z(e.$$.fragment), n = Me(), Z(i.$$.fragment), r = Me(), Z(a.$$.fragment), l = Me(), Z(c.$$.fragment), f = Me(), Z(h.$$.fragment), d = Me(), Z(m.$$.fragment), g = Me(), Z(A.$$.fragment), y = Me(), Z(w.$$.fragment), E = Me(), Z(I.$$.fragment);
      },
      m(k, X) {
        K(e, k, X), we(k, n, X), K(i, k, X), we(k, r, X), K(a, k, X), we(k, l, X), K(c, k, X), we(k, f, X), K(h, k, X), we(k, d, X), K(m, k, X), we(k, g, X), K(A, k, X), we(k, y, X), K(w, k, X), we(k, E, X), K(I, k, X), B = !0;
      },
      p(k, X) {
        uv(k);
        const fe = {};
        X[0] & /*textureSize, xColor, p*/
        4105 | X[1] & /*$$scope*/
        134217728 && (fe.$$scope = { dirty: X, ctx: k }), !t && X[0] & /*posX*/
        16 && (t = !0, fe.ref = /*posX*/
        k[4], or(() => t = !1)), e.$set(fe);
        const te = {};
        X[0] & /*frontMostAxisIndex*/
        2048 && (te.renderOrder = /*frontMostAxisIndex*/
        k[11] === 0 ? -1 : 0), X[0] & /*p, xColor, usePolygonOffset, frontMostAxisIndex*/
        3081 | X[1] & /*$$scope*/
        134217728 && (te.$$scope = { dirty: X, ctx: k }), i.$set(te);
        const j = {};
        X[0] & /*textureSize, xColor, p*/
        4105 | X[1] & /*$$scope*/
        134217728 && (j.$$scope = { dirty: X, ctx: k }), !o && X[0] & /*negX*/
        128 && (o = !0, j.ref = /*negX*/
        k[7], or(() => o = !1)), a.$set(j);
        const Ae = {};
        X[0] & /*textureSize, yColor, p*/
        4106 | X[1] & /*$$scope*/
        134217728 && (Ae.$$scope = { dirty: X, ctx: k }), !u && X[0] & /*posY*/
        32 && (u = !0, Ae.ref = /*posY*/
        k[5], or(() => u = !1)), c.$set(Ae);
        const Y = {};
        X[0] & /*frontMostAxisIndex*/
        2048 && (Y.renderOrder = /*frontMostAxisIndex*/
        k[11] === 1 ? -1 : 0), X[0] & /*p, yColor, usePolygonOffset, frontMostAxisIndex*/
        3082 | X[1] & /*$$scope*/
        134217728 && (Y.$$scope = { dirty: X, ctx: k }), h.$set(Y);
        const pe = {};
        X[0] & /*textureSize, yColor, p*/
        4106 | X[1] & /*$$scope*/
        134217728 && (pe.$$scope = { dirty: X, ctx: k }), !_ && X[0] & /*negY*/
        256 && (_ = !0, pe.ref = /*negY*/
        k[8], or(() => _ = !1)), m.$set(pe);
        const me = {};
        X[0] & /*textureSize, zColor, p*/
        4108 | X[1] & /*$$scope*/
        134217728 && (me.$$scope = { dirty: X, ctx: k }), !v && X[0] & /*posZ*/
        64 && (v = !0, me.ref = /*posZ*/
        k[6], or(() => v = !1)), A.$set(me);
        const re = {};
        X[0] & /*frontMostAxisIndex*/
        2048 && (re.renderOrder = /*frontMostAxisIndex*/
        k[11] === 2 ? -1 : 0), X[0] & /*p, zColor, usePolygonOffset, frontMostAxisIndex*/
        3084 | X[1] & /*$$scope*/
        134217728 && (re.$$scope = { dirty: X, ctx: k }), w.$set(re);
        const ye = {};
        X[0] & /*textureSize, zColor, p*/
        4108 | X[1] & /*$$scope*/
        134217728 && (ye.$$scope = { dirty: X, ctx: k }), !C && X[0] & /*negZ*/
        512 && (C = !0, ye.ref = /*negZ*/
        k[9], or(() => C = !1)), I.$set(ye);
      },
      i(k) {
        B || (O(e.$$.fragment, k), O(i.$$.fragment, k), O(a.$$.fragment, k), O(c.$$.fragment, k), O(h.$$.fragment, k), O(m.$$.fragment, k), O(A.$$.fragment, k), O(w.$$.fragment, k), O(I.$$.fragment, k), B = !0);
      },
      o(k) {
        N(e.$$.fragment, k), N(i.$$.fragment, k), N(a.$$.fragment, k), N(c.$$.fragment, k), N(h.$$.fragment, k), N(m.$$.fragment, k), N(A.$$.fragment, k), N(w.$$.fragment, k), N(I.$$.fragment, k), B = !1;
      },
      d(k) {
        k && (xe(n), xe(r), xe(l), xe(f), xe(d), xe(g), xe(y), xe(E)), J(e, k), J(i, k), J(a, k), J(c, k), J(h, k), J(m, k), J(A, k), J(w, k), J(I, k);
      }
    }
  );
}
function aU(s) {
  let e, t;
  return e = new ee({
    props: {
      is: (
        /*root*/
        s[13]
      ),
      $$slots: { default: [oU] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*negZ, textureSize, zColor, p, frontMostAxisIndex, usePolygonOffset, posZ, negY, yColor, posY, negX, xColor, posX*/
      8191 | i[1] & /*$$scope*/
      134217728 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function lU(s) {
  let e, t;
  return e = new ic({
    props: {
      $$slots: { default: [aU] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*negZ, textureSize, zColor, p, frontMostAxisIndex, usePolygonOffset, posZ, negY, yColor, posY, negX, xColor, posX*/
      8191 | i[1] & /*$$scope*/
      134217728 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function cU(s, e, t) {
  let n, i, r, a, { renderTask: o = void 0 } = e, { animationTask: l = void 0 } = e, { turnRate: c = 2 * Math.PI } = e, { center: u = [0, 0, 0] } = e, { verticalPlacement: f = "bottom" } = e, { horizontalPlacement: h = "right" } = e, { size: d = 128 } = e, { xColor: m = 16725587 } = e, { yColor: _ = 9100032 } = e, { zColor: g = 2920447 } = e, { toneMapped: A = !1 } = e, { paddingX: v = 0 } = e, { paddingY: y = 0 } = e;
  const { autoRenderTask: w, renderer: E, camera: I, invalidate: C } = un(), B = new yo(-1.25, 1.25, 1.25, -1.25, 0, 4);
  B.position.set(0, 0, 2);
  const T = new Jl(), S = new Xt();
  On(
    (o == null ? void 0 : o.key) ?? Symbol("threlte-extras-gizmo-render"),
    () => {
      const ue = E.autoClear;
      t(26, E.autoClear = !1, E), E.getViewport(S);
      const Te = E.toneMapping;
      t(26, E.toneMapping = A ? E.toneMapping : 0, E);
      const Ge = h === "left" ? v : E.domElement.offsetWidth - d - v, Pe = f === "bottom" ? y : E.domElement.offsetHeight - d - y;
      E.setViewport(Ge, Pe, d, d), E.render(T, B), E.setViewport(S.x, S.y, S.z, S.w), t(26, E.autoClear = ue, E), t(26, E.toneMapping = Te, E);
    },
    {
      ...o ?? { after: w },
      autoInvalidate: !1
    }
  );
  const D = document.createElement("div"), P = E.domElement.getBoundingClientRect();
  D.style.position = "absolute";
  let L, V, U, Q, q, oe;
  const le = new H(), k = new en(), X = new en(), fe = new en();
  let te = 0, j = !1;
  const Ae = new ke(), Y = new zu(), pe = (ue, Te, Ge) => Math.abs(ue.x - Te.x) + Math.abs(ue.y - Te.y) + Math.abs(ue.z - Te.z) + Math.abs(ue.w - Te.w) < Ge, me = (ue) => {
    const Te = ue.object, Ge = Te.userData.targetPosition, Pe = Te.userData.targetEuler;
    te = I.current.position.distanceTo(n), le.set(...Ge).multiplyScalar(te).add(n), k.setFromEuler(new Ui(...Pe));
    const he = new Gt();
    return he.position.copy(n), he.lookAt(I.current.position), X.copy(he.quaternion), he.lookAt(le), fe.copy(he.quaternion), pe(fe, X, 1e-4) ? !0 : (j = !0, !1);
  }, re = (ue) => {
    if (j)
      return;
    const Te = D.getBoundingClientRect(), Ge = Te.left + (D.offsetWidth - d), Pe = Te.top + (D.offsetHeight - d);
    Ae.x = (ue.clientX - Ge) / (Te.right - Ge) * 2 - 1, Ae.y = -((ue.clientY - Pe) / (Te.bottom - Pe)) * 2 + 1, Y.setFromCamera(Ae, B);
    const he = Y.intersectObjects([L, V, U, Q, q, oe]);
    he.length > 0 && me(he[0]) && he.length > 1 && me(he[1]);
  };
  Us(() => {
    var ue;
    (ue = E.domElement.parentElement) == null || ue.appendChild(D), D.addEventListener("click", re);
  }), Sn(() => {
    var ue;
    (ue = E.domElement.parentElement) == null || ue.removeChild(D), D.removeEventListener("click", re);
  });
  const ye = new H();
  let ae = [0, 0, 0];
  On(
    (l == null ? void 0 : l.key) ?? Symbol("threlte-extras-gizmo-animation"),
    (ue) => {
      if (ye.set(0, 0, 1).applyQuaternion(I.current.quaternion), (ye.x !== ae[0] || ye.y !== ae[1] || ye.z !== ae[2]) && (t(3, ae = [ye.x, ye.y, ye.z]), T.quaternion.copy(I.current.quaternion).invert(), C()), j) {
        const Te = ue * c;
        X.rotateTowards(fe, Te), I.current.position.set(0, 0, 1).applyQuaternion(X).multiplyScalar(te).add(n), I.current.quaternion.rotateTowards(k, Te), X.angleTo(fe) === 0 && (j = !1), C();
      }
    },
    { ...l, autoInvalidate: !1 }
  );
  const De = (ue) => {
    if (ue <= 0)
      return 1;
    let Te = 1;
    for (; Te < ue; )
      Te <<= 1;
    return Te;
  }, Ee = {}, Ie = new Je(), Ce = (ue, Te, Ge = "") => {
    Ie.set(Te);
    const Pe = `${Ie.getHexString()}-${Ge}`;
    Ee[Pe] && Ee[Pe].dispose();
    const he = document.createElement("canvas");
    he.width = ue, he.height = ue;
    const Se = he.getContext("2d");
    if (Se.beginPath(), Se.arc(ue / 2, ue / 2, ue / 4, 0, 2 * Math.PI), Se.closePath(), Se.fillStyle = Ie.convertSRGBToLinear().getStyle(), Se.fill(), Ge) {
      const Ye = Math.abs(ue * 0.375);
      Se.font = `${Ye}px Arial`, Se.textAlign = "center", Se.fillStyle = "#000000";
      const $e = ue * (41 / 64);
      Se.fillText(Ge, ue / 2, $e);
    }
    const Ve = new Wx(he);
    return Ee[Pe] = Ve, Ve;
  }, ze = new Nu(0.025, 0.78);
  ze.rotateZ(Math.PI / 2);
  function Fe(ue) {
    L = ue, t(4, L);
  }
  function W(ue) {
    Q = ue, t(7, Q);
  }
  function G(ue) {
    V = ue, t(5, V);
  }
  function se(ue) {
    q = ue, t(8, q);
  }
  function _e(ue) {
    U = ue, t(6, U);
  }
  function ve(ue) {
    oe = ue, t(9, oe);
  }
  return s.$$set = (ue) => {
    "renderTask" in ue && t(16, o = ue.renderTask), "animationTask" in ue && t(17, l = ue.animationTask), "turnRate" in ue && t(18, c = ue.turnRate), "center" in ue && t(19, u = ue.center), "verticalPlacement" in ue && t(20, f = ue.verticalPlacement), "horizontalPlacement" in ue && t(21, h = ue.horizontalPlacement), "size" in ue && t(22, d = ue.size), "xColor" in ue && t(0, m = ue.xColor), "yColor" in ue && t(1, _ = ue.yColor), "zColor" in ue && t(2, g = ue.zColor), "toneMapped" in ue && t(23, A = ue.toneMapped), "paddingX" in ue && t(24, v = ue.paddingX), "paddingY" in ue && t(25, y = ue.paddingY);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*center*/
    524288 && (n = new H(...u)), s.$$.dirty[0] & /*size, horizontalPlacement, verticalPlacement, toneMapped, paddingX, paddingY*/
    66060288 && C(), s.$$.dirty[0] & /*horizontalPlacement, size, paddingX, verticalPlacement, paddingY*/
    57671680 && (h === "right" ? (D.style.right = "", D.style.left = `${P.right - d - v}px`) : (D.style.right = "", D.style.left = `${v + P.left}px`), f === "bottom" ? (D.style.bottom = "", D.style.top = `${P.bottom - d - y}px`) : (D.style.bottom = "", D.style.top = `${y + P.top}px`), D.style.height = `${d}px`, D.style.width = `${d}px`), s.$$.dirty[0] & /*size, renderer*/
    71303168 && t(12, i = De(d * 0.3 * E.getPixelRatio())), s.$$.dirty[0] & /*p*/
    8 && t(11, r = ae.indexOf(Math.max(...ae))), s.$$.dirty[0] & /*p*/
    8 && t(10, a = ae.some((ue) => ue < 0));
  }, [
    m,
    _,
    g,
    ae,
    L,
    V,
    U,
    Q,
    q,
    oe,
    a,
    r,
    i,
    T,
    Ce,
    ze,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    A,
    v,
    y,
    E,
    Fe,
    W,
    G,
    se,
    _e,
    ve
  ];
}
class uU extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      cU,
      lU,
      _t,
      {
        renderTask: 16,
        animationTask: 17,
        turnRate: 18,
        center: 19,
        verticalPlacement: 20,
        horizontalPlacement: 21,
        size: 22,
        xColor: 0,
        yColor: 1,
        zColor: 2,
        toneMapped: 23,
        paddingX: 24,
        paddingY: 25
      },
      null,
      [-1, -1]
    );
  }
  get renderTask() {
    return this.$$.ctx[16];
  }
  set renderTask(e) {
    this.$$set({ renderTask: e }), ne();
  }
  get animationTask() {
    return this.$$.ctx[17];
  }
  set animationTask(e) {
    this.$$set({ animationTask: e }), ne();
  }
  get turnRate() {
    return this.$$.ctx[18];
  }
  set turnRate(e) {
    this.$$set({ turnRate: e }), ne();
  }
  get center() {
    return this.$$.ctx[19];
  }
  set center(e) {
    this.$$set({ center: e }), ne();
  }
  get verticalPlacement() {
    return this.$$.ctx[20];
  }
  set verticalPlacement(e) {
    this.$$set({ verticalPlacement: e }), ne();
  }
  get horizontalPlacement() {
    return this.$$.ctx[21];
  }
  set horizontalPlacement(e) {
    this.$$set({ horizontalPlacement: e }), ne();
  }
  get size() {
    return this.$$.ctx[22];
  }
  set size(e) {
    this.$$set({ size: e }), ne();
  }
  get xColor() {
    return this.$$.ctx[0];
  }
  set xColor(e) {
    this.$$set({ xColor: e }), ne();
  }
  get yColor() {
    return this.$$.ctx[1];
  }
  set yColor(e) {
    this.$$set({ yColor: e }), ne();
  }
  get zColor() {
    return this.$$.ctx[2];
  }
  set zColor(e) {
    this.$$set({ zColor: e }), ne();
  }
  get toneMapped() {
    return this.$$.ctx[23];
  }
  set toneMapped(e) {
    this.$$set({ toneMapped: e }), ne();
  }
  get paddingX() {
    return this.$$.ctx[24];
  }
  set paddingX(e) {
    this.$$set({ paddingX: e }), ne();
  }
  get paddingY() {
    return this.$$.ctx[25];
  }
  set paddingY(e) {
    this.$$set({ paddingY: e }), ne();
  }
}
St(uU, { renderTask: {}, animationTask: {}, turnRate: {}, center: {}, verticalPlacement: {}, horizontalPlacement: {}, size: {}, xColor: {}, yColor: {}, zColor: {}, toneMapped: { type: "Boolean" }, paddingX: {}, paddingY: {} }, [], [], !0);
const fU = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, hU = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, Xo = (s) => {
  let e = !1;
  const t = Ft(s());
  return {
    ...t,
    memoize: (...i) => {
      if (!e) {
        e = !0;
        return;
      }
      t.set(s());
    }
  };
}, dU = (s) => ({ ref: s[1] & /*ref*/
1024 }), fv = (s) => ({ ref: (
  /*ref*/
  s[41]
) });
function pU(s) {
  let e, t, n, i, r;
  e = new ee.Mesh({
    props: {
      "scale.y": -1,
      "rotation.x": -Math.PI / 2,
      material: (
        /*shadowMaterial*/
        s[10]
      ),
      geometry: (
        /*$planeGeometry*/
        s[0]
      )
    }
  }), n = new ee({
    props: {
      is: (
        /*shadowCamera*/
        s[9]
      ),
      manual: !0
    }
  });
  const a = (
    /*#slots*/
    s[27].default
  ), o = yt(
    a,
    s,
    /*$$scope*/
    s[29],
    fv
  );
  return {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), o && o.c();
    },
    m(l, c) {
      K(e, l, c), we(l, t, c), K(n, l, c), we(l, i, c), o && o.m(l, c), r = !0;
    },
    p(l, c) {
      const u = {};
      c[0] & /*$planeGeometry*/
      1 && (u.geometry = /*$planeGeometry*/
      l[0]), e.$set(u), o && o.p && (!r || c[0] & /*$$scope*/
      536870912 | c[1] & /*ref*/
      1024) && wt(
        o,
        a,
        l,
        /*$$scope*/
        l[29],
        r ? xt(
          a,
          /*$$scope*/
          l[29],
          c,
          dU
        ) : Et(
          /*$$scope*/
          l[29]
        ),
        fv
      );
    },
    i(l) {
      r || (O(e.$$.fragment, l), O(n.$$.fragment, l), O(o, l), r = !0);
    },
    o(l) {
      N(e.$$.fragment, l), N(n.$$.fragment, l), N(o, l), r = !1;
    },
    d(l) {
      l && (xe(t), xe(i)), J(e, l), J(n, l), o && o.d(l);
    }
  };
}
function mU(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      "rotation.x": Math.PI / 2,
      $$slots: { default: [pU] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*$$scope, $planeGeometry*/
      536870913 | i[1] & /*ref*/
      1024 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function gU(s) {
  let e, t;
  const n = [
    /*$$restProps*/
    s[12]
  ];
  let i = {
    $$slots: {
      default: [
        mU,
        ({ ref: r }) => ({ 41: r }),
        ({ ref: r }) => [0, r ? 1024 : 0]
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee.Group({ props: i }), s[28](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a[0] & /*$$restProps*/
      4096 ? jt(n, [Kt(
        /*$$restProps*/
        r[12]
      )]) : {};
      a[0] & /*$$scope, $planeGeometry*/
      536870913 | a[1] & /*ref*/
      1024 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[28](null), J(e, r);
    }
  };
}
function AU(s, e, t) {
  const n = [
    "opacity",
    "width",
    "height",
    "blur",
    "far",
    "smooth",
    "resolution",
    "frames",
    "scale",
    "color",
    "depthWrite",
    "refresh"
  ];
  let i = ft(e, n), r, a, o, l, c, u, f, h, { $$slots: d = {}, $$scope: m } = e, { opacity: _ = 1 } = e, { width: g = 1 } = e, { height: A = 1 } = e, { blur: v = 1 } = e, { far: y = 10 } = e, { smooth: w = !0 } = e, { resolution: E = 512 } = e, { frames: I = 1 / 0 } = e, { scale: C = 10 } = e, { color: B = "#000000" } = e, { depthWrite: T = !1 } = e;
  const { scene: S, renderer: D } = un(), R = Xo(() => g * (Array.isArray(C) ? C[0] : C || 1));
  lt(s, R, (me) => t(26, f = me));
  const P = Xo(() => A * (Array.isArray(C) ? C[1] : C || 1));
  lt(s, P, (me) => t(25, u = me));
  const L = Xo(() => {
    const me = new Ji(E, E);
    return me.texture.generateMipmaps = !1, me.texture.colorSpace = D.outputColorSpace, me;
  });
  lt(s, L, (me) => t(36, l = me));
  const V = Xo(() => {
    const me = new Ji(E, E);
    return me.texture.generateMipmaps = !1, me;
  });
  lt(s, V, (me) => t(35, o = me));
  const U = Xo(() => new Fi(f, u).rotateX(Math.PI / 2));
  lt(s, U, (me) => t(0, a = me));
  const Q = Xo(() => new tt(a));
  lt(s, Q, (me) => t(37, c = me));
  const q = Xo(() => {
    const me = new Ea({ depthTest: !1, depthWrite: !1 });
    return me.onBeforeCompile = (re) => {
      re.uniforms = {
        ...re.uniforms,
        uColor: {
          value: new Je(B).convertSRGBToLinear()
        }
      }, re.fragmentShader = `uniform vec3 uColor;
` + re.fragmentShader, re.fragmentShader = re.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );"), re.fragmentShader = re.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    }, me;
  });
  lt(s, q, (me) => t(34, r = me));
  const oe = new Hn({
    ...fU,
    depthTest: !1
  }), le = new Hn({ ...hU, depthTest: !1 }), k = new yo(-f / 2, f / 2, u / 2, -u / 2, 0, y);
  k.updateProjectionMatrix();
  const X = new $n({
    map: l.texture,
    transparent: !0,
    opacity: _,
    depthWrite: T
  }), fe = (me) => {
    const re = c;
    re.visible = !0, re.material = oe, oe.uniforms.tDiffuse.value = l.texture, oe.uniforms.h.value = me * 1 / 256, D.setRenderTarget(o), D.render(re, k), re.material = le, le.uniforms.tDiffuse.value = o.texture, le.uniforms.v.value = me * 1 / 256, D.setRenderTarget(l), D.render(re, k), re.visible = !1;
  }, te = () => {
    const me = S.background;
    S.background = null;
    const re = S.overrideMaterial;
    S.overrideMaterial = r;
    const ye = D.getClearAlpha();
    D.setClearAlpha(0), D.setRenderTarget(l), D.render(S, k), S.overrideMaterial = re, fe(v), w && fe(v * 0.4), D.setRenderTarget(null), S.background = me, D.setClearAlpha(ye);
  }, j = () => {
    te();
  };
  let Ae = 0;
  On(() => {
    (I === 1 / 0 || Ae < I) && (te(), Ae += 1);
  }), Sn(() => {
    l.dispose(), o.dispose(), a.dispose(), r.dispose(), oe.dispose(), le.dispose(), X.dispose();
  });
  const Y = An();
  lt(s, Y, (me) => t(1, h = me));
  function pe(me) {
    Ut[me ? "unshift" : "push"](() => {
      h = me, Y.set(h);
    });
  }
  return s.$$set = (me) => {
    e = We(We({}, e), rn(me)), t(12, i = ft(e, n)), "opacity" in me && t(13, _ = me.opacity), "width" in me && t(14, g = me.width), "height" in me && t(15, A = me.height), "blur" in me && t(16, v = me.blur), "far" in me && t(17, y = me.far), "smooth" in me && t(18, w = me.smooth), "resolution" in me && t(19, E = me.resolution), "frames" in me && t(20, I = me.frames), "scale" in me && t(21, C = me.scale), "color" in me && t(22, B = me.color), "depthWrite" in me && t(23, T = me.depthWrite), "$$scope" in me && t(29, m = me.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*width, scale*/
    2113536 && R.memoize([g, C]), s.$$.dirty[0] & /*height, scale*/
    2129920 && P.memoize(A, C), s.$$.dirty[0] & /*resolution*/
    524288 && L.memoize(E), s.$$.dirty[0] & /*resolution*/
    524288 && V.memoize(E), s.$$.dirty[0] & /*$scaledWidth, $scaledHeight*/
    100663296 && U.memoize(f, u), s.$$.dirty[0] & /*$planeGeometry*/
    1 && Q.memoize(a), s.$$.dirty[0] & /*color*/
    4194304 && q.memoize(B);
  }, [
    a,
    h,
    R,
    P,
    L,
    V,
    U,
    Q,
    q,
    k,
    X,
    Y,
    i,
    _,
    g,
    A,
    v,
    y,
    w,
    E,
    I,
    C,
    B,
    T,
    j,
    u,
    f,
    d,
    pe,
    m
  ];
}
class _U extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      AU,
      gU,
      _t,
      {
        opacity: 13,
        width: 14,
        height: 15,
        blur: 16,
        far: 17,
        smooth: 18,
        resolution: 19,
        frames: 20,
        scale: 21,
        color: 22,
        depthWrite: 23,
        refresh: 24
      },
      null,
      [-1, -1]
    );
  }
  get opacity() {
    return this.$$.ctx[13];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), ne();
  }
  get width() {
    return this.$$.ctx[14];
  }
  set width(e) {
    this.$$set({ width: e }), ne();
  }
  get height() {
    return this.$$.ctx[15];
  }
  set height(e) {
    this.$$set({ height: e }), ne();
  }
  get blur() {
    return this.$$.ctx[16];
  }
  set blur(e) {
    this.$$set({ blur: e }), ne();
  }
  get far() {
    return this.$$.ctx[17];
  }
  set far(e) {
    this.$$set({ far: e }), ne();
  }
  get smooth() {
    return this.$$.ctx[18];
  }
  set smooth(e) {
    this.$$set({ smooth: e }), ne();
  }
  get resolution() {
    return this.$$.ctx[19];
  }
  set resolution(e) {
    this.$$set({ resolution: e }), ne();
  }
  get frames() {
    return this.$$.ctx[20];
  }
  set frames(e) {
    this.$$set({ frames: e }), ne();
  }
  get scale() {
    return this.$$.ctx[21];
  }
  set scale(e) {
    this.$$set({ scale: e }), ne();
  }
  get color() {
    return this.$$.ctx[22];
  }
  set color(e) {
    this.$$set({ color: e }), ne();
  }
  get depthWrite() {
    return this.$$.ctx[23];
  }
  set depthWrite(e) {
    this.$$set({ depthWrite: e }), ne();
  }
  get refresh() {
    return this.$$.ctx[24];
  }
}
St(_U, { opacity: {}, width: {}, height: {}, blur: {}, far: {}, smooth: { type: "Boolean" }, resolution: {}, frames: {}, scale: {}, color: {}, depthWrite: { type: "Boolean" } }, ["default"], ["refresh"], !0);
class hE extends bw {
  constructor(e) {
    super(e), this.type = Ri;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const a = function(B, T) {
      switch (B) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (T || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (T || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (T || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (T || ""));
      }
    }, u = `
`, f = function(B, T, S) {
      T = T || 1024;
      let R = B.pos, P = -1, L = 0, V = "", U = String.fromCharCode.apply(null, new Uint16Array(B.subarray(R, R + 128)));
      for (; 0 > (P = U.indexOf(u)) && L < T && R < B.byteLength; )
        V += U, L += U.length, R += 128, U += String.fromCharCode.apply(null, new Uint16Array(B.subarray(R, R + 128)));
      return -1 < P ? (S !== !1 && (B.pos += L + P + 1), V + U.slice(0, P)) : !1;
    }, h = function(B) {
      const T = /^#\?(\S+)/, S = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, D = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, R = /^\s*FORMAT=(\S+)\s*$/, P = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, L = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let V, U;
      for ((B.pos >= B.byteLength || !(V = f(B))) && a(1, "no header found"), (U = V.match(T)) || a(3, "bad initial token"), L.valid |= 1, L.programtype = U[1], L.string += V + `
`; V = f(B), V !== !1; ) {
        if (L.string += V + `
`, V.charAt(0) === "#") {
          L.comments += V + `
`;
          continue;
        }
        if ((U = V.match(S)) && (L.gamma = parseFloat(U[1])), (U = V.match(D)) && (L.exposure = parseFloat(U[1])), (U = V.match(R)) && (L.valid |= 2, L.format = U[1]), (U = V.match(P)) && (L.valid |= 4, L.height = parseInt(U[1], 10), L.width = parseInt(U[2], 10)), L.valid & 2 && L.valid & 4)
          break;
      }
      return L.valid & 2 || a(3, "missing format specifier"), L.valid & 4 || a(3, "missing image size specifier"), L;
    }, d = function(B, T, S) {
      const D = T;
      if (
        // run length encoding is not allowed so read flat
        D < 8 || D > 32767 || // this file is not run length encoded
        B[0] !== 2 || B[1] !== 2 || B[2] & 128
      )
        return new Uint8Array(B);
      D !== (B[2] << 8 | B[3]) && a(3, "wrong scanline width");
      const R = new Uint8Array(4 * T * S);
      R.length || a(4, "unable to allocate buffer space");
      let P = 0, L = 0;
      const V = 4 * D, U = new Uint8Array(4), Q = new Uint8Array(V);
      let q = S;
      for (; q > 0 && L < B.byteLength; ) {
        L + 4 > B.byteLength && a(1), U[0] = B[L++], U[1] = B[L++], U[2] = B[L++], U[3] = B[L++], (U[0] != 2 || U[1] != 2 || (U[2] << 8 | U[3]) != D) && a(3, "bad rgbe scanline format");
        let oe = 0, le;
        for (; oe < V && L < B.byteLength; ) {
          le = B[L++];
          const X = le > 128;
          if (X && (le -= 128), (le === 0 || oe + le > V) && a(3, "bad scanline data"), X) {
            const fe = B[L++];
            for (let te = 0; te < le; te++)
              Q[oe++] = fe;
          } else
            Q.set(B.subarray(L, L + le), oe), oe += le, L += le;
        }
        const k = D;
        for (let X = 0; X < k; X++) {
          let fe = 0;
          R[P] = Q[X + fe], fe += D, R[P + 1] = Q[X + fe], fe += D, R[P + 2] = Q[X + fe], fe += D, R[P + 3] = Q[X + fe], P += 4;
        }
        q--;
      }
      return R;
    }, m = function(B, T, S, D) {
      const R = B[T + 3], P = Math.pow(2, R - 128) / 255;
      S[D + 0] = B[T + 0] * P, S[D + 1] = B[T + 1] * P, S[D + 2] = B[T + 2] * P, S[D + 3] = 1;
    }, _ = function(B, T, S, D) {
      const R = B[T + 3], P = Math.pow(2, R - 128) / 255;
      S[D + 0] = Wc.toHalfFloat(Math.min(B[T + 0] * P, 65504)), S[D + 1] = Wc.toHalfFloat(Math.min(B[T + 1] * P, 65504)), S[D + 2] = Wc.toHalfFloat(Math.min(B[T + 2] * P, 65504)), S[D + 3] = Wc.toHalfFloat(1);
    }, g = new Uint8Array(e);
    g.pos = 0;
    const A = h(g), v = A.width, y = A.height, w = d(g.subarray(g.pos), v, y);
    let E, I, C;
    switch (this.type) {
      case hn:
        C = w.length / 4;
        const B = new Float32Array(C * 4);
        for (let S = 0; S < C; S++)
          m(w, S * 4, B, S * 4);
        E = B, I = hn;
        break;
      case Ri:
        C = w.length / 4;
        const T = new Uint16Array(C * 4);
        for (let S = 0; S < C; S++)
          _(w, S * 4, T, S * 4);
        E = T, I = Ri;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: v,
      height: y,
      data: E,
      header: A.string,
      gamma: A.gamma,
      exposure: A.exposure,
      type: I
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, i) {
    function r(a, o) {
      switch (a.type) {
        case hn:
        case Ri:
          a.colorSpace = Bn, a.minFilter = Yt, a.magFilter = Yt, a.generateMipmaps = !1, a.flipY = !0;
          break;
      }
      t && t(a, o);
    }
    return super.load(e, r, n, i);
  }
}
class bU extends ai {
  constructor(e) {
    super(e), this.hdrLoader = new hE(), this.type = Ri;
  }
  load(e, t, n, i) {
    const r = new Xl();
    switch (r.type = this.type, r.type) {
      case hn:
        r.colorSpace = Bn, r.minFilter = Yt, r.magFilter = Yt, r.generateMipmaps = !1;
        break;
      case Ri:
        r.colorSpace = Bn, r.minFilter = Yt, r.magFilter = Yt, r.generateMipmaps = !1;
        break;
    }
    const a = this;
    let o = 0;
    function l(c, u, f, h) {
      new ri(a.manager).setPath(a.path).setResponseType("arraybuffer").setWithCredentials(a.withCredentials).load(e[c], function(d) {
        o++;
        const m = a.hdrLoader.parse(d);
        if (m) {
          if (m.data !== void 0) {
            const _ = new Di(m.data, m.width, m.height);
            _.type = r.type, _.colorSpace = r.colorSpace, _.format = r.format, _.minFilter = r.minFilter, _.magFilter = r.magFilter, _.generateMipmaps = r.generateMipmaps, r.images[c] = _;
          }
          o === 6 && (r.needsUpdate = !0, u && u(r));
        }
      }, f, h);
    }
    for (let c = 0; c < e.length; c++)
      l(c, t, n, i);
    return r;
  }
  setDataType(e) {
    return this.type = e, this.hdrLoader.setDataType(e), this;
  }
}
const va = Number.parseInt($l.replace("dev", ""));
function hv(s) {
  let e, t, n = {
    ctx: s,
    current: null,
    token: null,
    hasCatch: !1,
    pending: xU,
    then: yU,
    catch: vU,
    value: 4,
    blocks: [, , ,]
  };
  return rA(
    /*module*/
    s[1],
    n
  ), {
    c() {
      e = ji(), n.block.c();
    },
    m(i, r) {
      we(i, e, r), n.block.m(i, n.anchor = r), n.mount = () => e.parentNode, n.anchor = e, t = !0;
    },
    p(i, r) {
      s = i, sA(n, s, r);
    },
    i(i) {
      t || (O(n.block), t = !0);
    },
    o(i) {
      for (let r = 0; r < 3; r += 1) {
        const a = n.blocks[r];
        N(a);
      }
      t = !1;
    },
    d(i) {
      i && xe(e), n.block.d(i), n.token = null, n = null;
    }
  };
}
function vU(s) {
  return {
    c: rt,
    m: rt,
    p: rt,
    i: rt,
    o: rt,
    d: rt
  };
}
function yU(s) {
  let e, t;
  const n = [
    {
      is: va > 160 ? (
        /*result*/
        s[4].GroundedSkybox
      ) : (
        /*result*/
        s[4].GroundProjectedSkybox
      )
    },
    { args: [
      /*envMap*/
      s[0]
    ] },
    /*$$restProps*/
    s[2]
  ];
  let i = {};
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*module, envMap, $$restProps*/
      7 ? jt(n, [
        a & /*module*/
        2 && {
          is: va > 160 ? (
            /*result*/
            r[4].GroundedSkybox
          ) : (
            /*result*/
            r[4].GroundProjectedSkybox
          )
        },
        a & /*envMap*/
        1 && { args: [
          /*envMap*/
          r[0]
        ] },
        a & /*$$restProps*/
        4 && Kt(
          /*$$restProps*/
          r[2]
        )
      ]) : {};
      e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      J(e, r);
    }
  };
}
function xU(s) {
  return {
    c: rt,
    m: rt,
    p: rt,
    i: rt,
    o: rt,
    d: rt
  };
}
function wU(s) {
  let e, t, n = (
    /*envMap*/
    s[0] && hv(s)
  );
  return {
    c() {
      n && n.c(), e = ji();
    },
    m(i, r) {
      n && n.m(i, r), we(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*envMap*/
      i[0] ? n ? (n.p(i, r), r & /*envMap*/
      1 && O(n, 1)) : (n = hv(i), n.c(), O(n, 1), n.m(e.parentNode, e)) : n && (Li(), N(n, 1, 1, () => {
        n = null;
      }), ki());
    },
    i(i) {
      t || (O(n), t = !0);
    },
    o(i) {
      N(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function EU(s, e, t) {
  const n = ["envMap"];
  let i = ft(e, n), { envMap: r } = e;
  const o = import(va > 160 ? "three/examples/jsm/objects/GroundedSkybox.js" : "three/examples/jsm/objects/GroundProjectedSkybox.js");
  return s.$$set = (l) => {
    e = We(We({}, e), rn(l)), t(2, i = ft(e, n)), "envMap" in l && t(0, r = l.envMap);
  }, [r, o, i];
}
class dE extends Mt {
  constructor(e) {
    super(), Ct(this, e, EU, wU, _t, { envMap: 0 });
  }
  get envMap() {
    return this.$$.ctx[0];
  }
  set envMap(e) {
    this.$$set({ envMap: e }), ne();
  }
}
St(dE, { envMap: {} }, [], [], !0);
function dv(s) {
  let e, t;
  const n = [
    /*groundProjection*/
    s[0],
    { envMap: (
      /*previousEnvMap*/
      s[1]
    ) }
  ];
  let i = {};
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new dE({ props: i }), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*groundProjection, previousEnvMap*/
      3 ? jt(n, [
        a & /*groundProjection*/
        1 && Kt(
          /*groundProjection*/
          r[0]
        ),
        a & /*previousEnvMap*/
        2 && { envMap: (
          /*previousEnvMap*/
          r[1]
        ) }
      ]) : {};
      e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      J(e, r);
    }
  };
}
function CU(s) {
  let e, t, n = (
    /*groundProjection*/
    s[0] && dv(s)
  );
  return {
    c() {
      n && n.c(), e = ji();
    },
    m(i, r) {
      n && n.m(i, r), we(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*groundProjection*/
      i[0] ? n ? (n.p(i, r), r & /*groundProjection*/
      1 && O(n, 1)) : (n = dv(i), n.c(), O(n, 1), n.m(e.parentNode, e)) : n && (Li(), N(n, 1, 1, () => {
        n = null;
      }), ki());
    },
    i(i) {
      t || (O(n), t = !0);
    },
    o(i) {
      N(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function SU(s, e, t) {
  let n, i, r, { path: a = "" } = e, { files: o } = e, { isBackground: l = void 0 } = e, { groundProjection: c = void 0 } = e, { format: u = void 0 } = e, { colorSpace: f = void 0 } = e;
  const h = (S) => !!S.isScene, { scene: d, invalidate: m } = un(), _ = Er();
  lt(s, _, (S) => t(13, r = S));
  let g = d;
  h(r) && (g = r);
  let A = g.environment, v = g.background, y = i, w, E;
  const I = () => {
    const S = u || (Array.isArray(o) ? o[0] : o).split(".").pop() == "hdr" ? "hdr" : "ldr";
    return n && S == "ldr" ? _w : !n && S == "ldr" ? Su : n && S == "hdr" ? bU : !n && S == "hdr" ? hE : Su;
  }, { remember: C } = Fw(), B = rc(), T = async () => {
    var V;
    const S = I(), D = new S();
    (V = D.setDataType) == null || V.call(D, hn);
    const R = Array.isArray(o) ? o.join(",") : o, L = await C(
      async () => B(new Promise((U, Q) => {
        D.setPath(a).load(o, (q) => {
          U(q);
        });
      })),
      [S, a, R]
    );
    L.mapping = n ? as : kl, L.colorSpace = f ?? n ? Bn : Qn, t(1, w = L), t(8, g.environment = w, g), l && t(8, g.background = w, g), m(), t(10, E = u || void 0), t(9, y = i);
  };
  return Sn(() => {
    t(8, g.environment = A, g), t(8, g.background = v, g), w && w.dispose(), t(0, c = void 0), m();
  }), s.$$set = (S) => {
    "path" in S && t(3, a = S.path), "files" in S && t(4, o = S.files), "isBackground" in S && t(5, l = S.isBackground), "groundProjection" in S && t(0, c = S.groundProjection), "format" in S && t(6, u = S.format), "colorSpace" in S && t(7, f = S.colorSpace);
  }, s.$$.update = () => {
    s.$$.dirty & /*files*/
    16 && (n = Array.isArray(o)), s.$$.dirty & /*path, files*/
    24 && t(11, i = `${a}${o}`), s.$$.dirty & /*envPath, previousEnvPath, format, previousFormat, previousEnvMap, groundProjection, isBackground, scene*/
    3939 && ((i != y || u != E) && (w && w.dispose(), T(), t(0, c), t(11, i), t(9, y), t(6, u), t(10, E), t(1, w), t(5, l), t(8, g), t(3, a), t(4, o)), !l && g.background && (t(8, g.background = null, g), m()), l && !g.background && w && (t(8, g.background = w, g), m()));
  }, [
    c,
    w,
    _,
    a,
    o,
    l,
    u,
    f,
    g,
    y,
    E,
    i
  ];
}
class MU extends Mt {
  constructor(e) {
    super(), Ct(this, e, SU, CU, _t, {
      path: 3,
      files: 4,
      isBackground: 5,
      groundProjection: 0,
      format: 6,
      colorSpace: 7
    });
  }
  get path() {
    return this.$$.ctx[3];
  }
  set path(e) {
    this.$$set({ path: e }), ne();
  }
  get files() {
    return this.$$.ctx[4];
  }
  set files(e) {
    this.$$set({ files: e }), ne();
  }
  get isBackground() {
    return this.$$.ctx[5];
  }
  set isBackground(e) {
    this.$$set({ isBackground: e }), ne();
  }
  get groundProjection() {
    return this.$$.ctx[0];
  }
  set groundProjection(e) {
    this.$$set({ groundProjection: e }), ne();
  }
  get format() {
    return this.$$.ctx[6];
  }
  set format(e) {
    this.$$set({ format: e }), ne();
  }
  get colorSpace() {
    return this.$$.ctx[7];
  }
  set colorSpace(e) {
    this.$$set({ colorSpace: e }), ne();
  }
}
St(MU, { path: {}, files: {}, isBackground: {}, groundProjection: {}, format: {}, colorSpace: {} }, [], [], !0);
const IU = (
  /* glsl */
  `
varying vec2 vUv;
varying vec2 vPos;
void main () {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
  vUv = uv;
  vPos = position.xy;
}
`
), TU = (
  /* glsl */
  `
// Majority from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
varying vec2 vUv;
varying vec2 vPos;
uniform vec2 scale;
uniform vec2 imageBounds;
uniform float resolution;
uniform vec3 color;
uniform sampler2D map;
uniform sampler2D colorProccessingTexture;
uniform float radius;
uniform float zoom;
uniform float alphaThreshold;
uniform float alphaSmoothing;
uniform float brightness;
uniform float contrast;
uniform float monochromeStrength;
uniform vec3 monochromeColor;
uniform float negative;
uniform vec3 hsl;
uniform float grayscale;
uniform float opacity;
uniform int colorProcessingEnabled;
uniform int colorProcessingTextureOverride;

#define PI 3.14159265;

vec2 aspect(vec2 size) {
  return size / min(size.x, size.y);
}

// from https://iquilezles.org/articles/distfunctions
float udRoundBox(vec2 p, vec2 b, float r) {
  return length(max(abs(p) - b + r, 0.0)) - r;
}

float hueToRgb(float p, float q, float t) {
  if (t < 0.0f)
    t += 1.0f;
  if (t > 1.0f)
    t -= 1.0f;
  if (t < 1.0f / 6.0f)
    return p + (q - p) * 6.0f * t;
  if (t < 1.0f / 2.0f)
    return q;
  if (t < 2.0f / 3.0f)
    return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
  return p;
}

vec3 rgbToHsl(vec3 color) {
  float max = max(max(color.r, color.g), color.b);
  float min = min(min(color.r, color.g), color.b);
  float h, s, l = (max + min) / 2.0f;

  if (max == min) {
    h = s = 0.0f;
  } else {
    float d = max - min;
    s = l > 0.5f ? d / (2.0f - max - min) : d / (max + min);
    if (max == color.r) {
      h = (color.g - color.b) / d + (color.g < color.b ? 6.0f : 0.0f);
    } else if (max == color.g) {
      h = (color.b - color.r) / d + 2.0f;
    } else if (max == color.b) {
      h = (color.r - color.g) / d + 4.0f;
    }
    h /= 6.0f;
  }

  return vec3(h, s, l);
}

vec3 hslToRgb(vec3 hsl) {
  float h = hsl.x;
  float s = hsl.y;
  float l = hsl.z;

  float r, g, b;

  if (s == 0.0f) {
    r = g = b = l;
  } else {
    float q = l < 0.5f ? l * (1.0f + s) : l + s - l * s;
    float p = 2.0f * l - q;
    r = hueToRgb(p, q, h + 1.0f / 3.0f);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1.0f / 3.0f);
  }

  return vec3(r, g, b);
}

vec3 monochrome(float x, vec3 col) {
  return col * exp(4.0 * x - 1.0);
}

void processColors (inout vec4 colors) {
	vec4 strength = vec4(1.0);

	if (colorProcessingTextureOverride == 1) {
		strength = texture2D(colorProccessingTexture, vUv);

		float smoothedAlpha = smoothstep(1.0 - alphaThreshold - alphaSmoothing, 1.0 - alphaThreshold, strength.a + 0.0001);
		colors.a *= smoothedAlpha;

		if (gl_FragColor.a == 0.0) {
			discard;
			return;
		}
	}

	// BRIGHTNESS
	colors.rgb = max(colors.rgb + brightness, 0.0);

	// CONTRAST
  colors.rgb = max(((colors.rgb - 0.5) * max(contrast + 1.0, 0.0)) + 0.5, 0.0);

	// HSL
	vec3 hslColor = rgbToHsl(colors.rgb);
	hslColor.x = mod(hslColor.x + hsl.x * strength.r ,1.0);
	hslColor.y *= (1.0 + hsl.y * strength.g);
	hslColor.z += hsl.z * strength.b;
	colors.rgb = max(hslToRgb(hslColor), vec3(0.0));

	// MONOCHROME
	colors.rgb = mix(colors.rgb, monochrome(hslColor.z, monochromeColor), monochromeStrength);
}

void main() {
  vec2 s = aspect(scale);
  vec2 i = aspect(imageBounds);
  float rs = s.x / s.y;
  float ri = i.x / i.y;
  vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
  vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
  vec2 uv = vUv * s / new + offset;
  vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

  vec2 res = vec2(scale * resolution);
  vec2 halfRes = 0.5 * res;
  float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);
  vec3 a = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 1.0, b));

	gl_FragColor = texture2D(map, zUv) * vec4(color, opacity * a);

	if (colorProcessingEnabled == 1) {
	  processColors(gl_FragColor);
	}

	if (gl_FragColor.a == 0.0) {
	  discard;
	}

  #include <tonemapping_fragment>
  #include <${va >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
	gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0) - gl_FragColor.rgb, negative);
}
`
), BU = (s) => ({ ref: s[0] & /*ref*/
8 }), pv = (s) => ({ ref: (
  /*ref*/
  s[3]
) });
function PU(s) {
  let e;
  const t = (
    /*#slots*/
    s[30].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[32],
    pv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[0] & /*ref*/
      8 | r[1] & /*$$scope*/
      2) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[32],
        e ? xt(
          t,
          /*$$scope*/
          i[32],
          r,
          BU
        ) : Et(
          /*$$scope*/
          i[32]
        ),
        pv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function RU(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[3]
    ) },
    { uniforms: (
      /*uniforms*/
      s[4]
    ) },
    { toneMapped: (
      /*toneMapped*/
      s[0]
    ) },
    { transparent: (
      /*transparent*/
      s[1]
    ) },
    { side: (
      /*side*/
      s[2]
    ) },
    { vertexShader: IU },
    { fragmentShader: TU },
    /*$$restProps*/
    s[10]
  ];
  let i = {
    $$slots: { default: [PU] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[31](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a[0] & /*ref, uniforms, toneMapped, transparent, side, $$restProps*/
      1055 ? jt(n, [
        a[0] & /*ref*/
        8 && { is: (
          /*ref*/
          r[3]
        ) },
        a[0] & /*uniforms*/
        16 && { uniforms: (
          /*uniforms*/
          r[4]
        ) },
        a[0] & /*toneMapped*/
        1 && { toneMapped: (
          /*toneMapped*/
          r[0]
        ) },
        a[0] & /*transparent*/
        2 && { transparent: (
          /*transparent*/
          r[1]
        ) },
        a[0] & /*side*/
        4 && { side: (
          /*side*/
          r[2]
        ) },
        n[5],
        n[6],
        a[0] & /*$$restProps*/
        1024 && Kt(
          /*$$restProps*/
          r[10]
        )
      ]) : {};
      a[0] & /*ref*/
      8 | a[1] & /*$$scope*/
      2 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[31](null), J(e, r);
    }
  };
}
function DU(s, e, t) {
  let n;
  const i = [
    "color",
    "zoom",
    "radius",
    "alphaThreshold",
    "alphaSmoothing",
    "brightness",
    "contrast",
    "hue",
    "saturation",
    "lightness",
    "negative",
    "opacity",
    "toneMapped",
    "transparent",
    "texture",
    "monochromeColor",
    "monochromeStrength",
    "colorProcessingTexture",
    "side",
    "url",
    "ref"
  ];
  let r = ft(e, i), a, o, l = rt, c = () => (l(), l = Bu(n, (j) => t(28, o = j)), n), u, f;
  s.$$.on_destroy.push(() => l());
  let { $$slots: h = {}, $$scope: d } = e, { color: m = "white" } = e, { zoom: _ = 1 } = e, { radius: g = 0 } = e, { alphaThreshold: A = 0 } = e, { alphaSmoothing: v = 0.1 } = e, { brightness: y = 0 } = e, { contrast: w = 0 } = e, { hue: E = 0 } = e, { saturation: I = 0 } = e, { lightness: C = 0 } = e, { negative: B = !1 } = e, { opacity: T = 1 } = e, { toneMapped: S = !0 } = e, { transparent: D = !1 } = e, { texture: R = void 0 } = e, { monochromeColor: P = void 0 } = e, { monochromeStrength: L = void 0 } = e, { colorProcessingTexture: V = void 0 } = e, { side: U = void 0 } = e, { url: Q = void 0 } = e, { ref: q = new Hn() } = e;
  const oe = rc();
  let { size: le } = un();
  lt(s, le, (j) => t(29, u = j));
  const k = Er();
  lt(s, k, (j) => t(33, a = j));
  const X = {
    color: { value: new Je(m) },
    scale: { value: new ke() },
    imageBounds: { value: new ke(1, 1) },
    resolution: { value: 1024 },
    map: { value: null },
    zoom: { value: _ },
    radius: { value: g },
    alphaThreshold: { value: A },
    alphaSmoothing: { value: v },
    brightness: { value: y },
    contrast: { value: w },
    monochromeColor: { value: new Je(P) },
    monochromeStrength: { value: L ?? 0 },
    negative: { value: B ? 1 : 0 },
    opacity: { value: T },
    hsl: { value: new H(0, 0, 0) },
    colorProccessingTexture: { value: null },
    colorProcessingTextureOverride: { value: 0 },
    colorProcessingEnabled: { value: 1 }
  };
  On(() => {
    const j = a;
    if (j === void 0)
      return;
    X.scale.value.set(j.scale.x, j.scale.y);
    const Ae = j.geometry;
    if (Ae !== void 0 && "parameters" in Ae) {
      const { width: Y, height: pe } = Ae.parameters;
      X.scale.value.set(X.scale.value.x * Y, X.scale.value.y * pe);
    }
  });
  const fe = An();
  lt(s, fe, (j) => t(6, f = j));
  function te(j) {
    Ut[j ? "unshift" : "push"](() => {
      f = j, fe.set(f);
    });
  }
  return s.$$set = (j) => {
    e = We(We({}, e), rn(j)), t(10, r = ft(e, i)), "color" in j && t(11, m = j.color), "zoom" in j && t(12, _ = j.zoom), "radius" in j && t(13, g = j.radius), "alphaThreshold" in j && t(14, A = j.alphaThreshold), "alphaSmoothing" in j && t(15, v = j.alphaSmoothing), "brightness" in j && t(16, y = j.brightness), "contrast" in j && t(17, w = j.contrast), "hue" in j && t(18, E = j.hue), "saturation" in j && t(19, I = j.saturation), "lightness" in j && t(20, C = j.lightness), "negative" in j && t(21, B = j.negative), "opacity" in j && t(22, T = j.opacity), "toneMapped" in j && t(0, S = j.toneMapped), "transparent" in j && t(1, D = j.transparent), "texture" in j && t(23, R = j.texture), "monochromeColor" in j && t(24, P = j.monochromeColor), "monochromeStrength" in j && t(25, L = j.monochromeStrength), "colorProcessingTexture" in j && t(26, V = j.colorProcessingTexture), "side" in j && t(2, U = j.side), "url" in j && t(27, Q = j.url), "ref" in j && t(3, q = j.ref), "$$scope" in j && t(32, d = j.$$scope);
  }, s.$$.update = () => {
    if (s.$$.dirty[0] & /*url, texture*/
    142606336 && c(t(5, n = oe(Q ? aE(Q) : Dl(Promise.resolve(R))))), s.$$.dirty[0] & /*$size*/
    536870912 && t(4, X.resolution.value = Math.max(u.width, u.height), X), s.$$.dirty[0] & /*zoom*/
    4096 && t(4, X.zoom.value = _, X), s.$$.dirty[0] & /*radius*/
    8192 && t(4, X.radius.value = g, X), s.$$.dirty[0] & /*opacity*/
    4194304 && t(4, X.opacity.value = T, X), s.$$.dirty[0] & /*alphaThreshold*/
    16384 && t(4, X.alphaThreshold.value = A, X), s.$$.dirty[0] & /*alphaSmoothing*/
    32768 && t(4, X.alphaSmoothing.value = v, X), s.$$.dirty[0] & /*brightness*/
    65536 && t(4, X.brightness.value = y, X), s.$$.dirty[0] & /*contrast*/
    131072 && t(4, X.contrast.value = w, X), s.$$.dirty[0] & /*hue*/
    262144 && t(4, X.hsl.value.x = E, X), s.$$.dirty[0] & /*saturation*/
    524288 && t(4, X.hsl.value.y = I, X), s.$$.dirty[0] & /*lightness*/
    1048576 && t(4, X.hsl.value.z = C, X), s.$$.dirty[0] & /*negative*/
    2097152 && t(4, X.negative.value = B ? 1 : 0, X), s.$$.dirty[0] & /*$textureStore*/
    268435456 && t(4, X.map.value = o ?? null, X), s.$$.dirty[0] & /*colorProcessingTexture*/
    67108864 && t(4, X.colorProccessingTexture.value = V ?? null, X), s.$$.dirty[0] & /*colorProcessingTexture*/
    67108864 && t(4, X.colorProcessingTextureOverride.value = V ? 1 : 0, X), s.$$.dirty[0] & /*monochromeColor, uniforms, monochromeStrength*/
    50331664 && (P !== void 0 ? (X.monochromeColor.value.set(P), t(4, X.monochromeStrength.value = L ?? 1, X)) : t(4, X.monochromeStrength.value = 0, X)), s.$$.dirty[0] & /*monochromeColor, monochromeStrength, brightness, contrast, hue, saturation, lightness, colorProcessingTexture*/
    119472128) {
      let j = 0;
      const Ae = (P ? 1 : 0) * (L === void 0 ? 1 : L);
      for (const Y of [
        y,
        w,
        E,
        I,
        C,
        Ae,
        V ? 1 : 0
      ])
        if (Y !== 0) {
          j = 1;
          break;
        }
      t(4, X.colorProcessingEnabled.value = j, X);
    }
    s.$$.dirty[0] & /*uniforms, color*/
    2064 && X.color.value.set(m), s.$$.dirty[0] & /*uniforms, $textureStore*/
    268435472 && X.imageBounds.value.set((o == null ? void 0 : o.image.width) ?? 0, (o == null ? void 0 : o.image.height) ?? 0);
  }, [
    S,
    D,
    U,
    q,
    X,
    n,
    f,
    le,
    k,
    fe,
    r,
    m,
    _,
    g,
    A,
    v,
    y,
    w,
    E,
    I,
    C,
    B,
    T,
    R,
    P,
    L,
    V,
    Q,
    o,
    u,
    h,
    te,
    d
  ];
}
class LU extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      DU,
      RU,
      _t,
      {
        color: 11,
        zoom: 12,
        radius: 13,
        alphaThreshold: 14,
        alphaSmoothing: 15,
        brightness: 16,
        contrast: 17,
        hue: 18,
        saturation: 19,
        lightness: 20,
        negative: 21,
        opacity: 22,
        toneMapped: 0,
        transparent: 1,
        texture: 23,
        monochromeColor: 24,
        monochromeStrength: 25,
        colorProcessingTexture: 26,
        side: 2,
        url: 27,
        ref: 3
      },
      null,
      [-1, -1]
    );
  }
  get color() {
    return this.$$.ctx[11];
  }
  set color(e) {
    this.$$set({ color: e }), ne();
  }
  get zoom() {
    return this.$$.ctx[12];
  }
  set zoom(e) {
    this.$$set({ zoom: e }), ne();
  }
  get radius() {
    return this.$$.ctx[13];
  }
  set radius(e) {
    this.$$set({ radius: e }), ne();
  }
  get alphaThreshold() {
    return this.$$.ctx[14];
  }
  set alphaThreshold(e) {
    this.$$set({ alphaThreshold: e }), ne();
  }
  get alphaSmoothing() {
    return this.$$.ctx[15];
  }
  set alphaSmoothing(e) {
    this.$$set({ alphaSmoothing: e }), ne();
  }
  get brightness() {
    return this.$$.ctx[16];
  }
  set brightness(e) {
    this.$$set({ brightness: e }), ne();
  }
  get contrast() {
    return this.$$.ctx[17];
  }
  set contrast(e) {
    this.$$set({ contrast: e }), ne();
  }
  get hue() {
    return this.$$.ctx[18];
  }
  set hue(e) {
    this.$$set({ hue: e }), ne();
  }
  get saturation() {
    return this.$$.ctx[19];
  }
  set saturation(e) {
    this.$$set({ saturation: e }), ne();
  }
  get lightness() {
    return this.$$.ctx[20];
  }
  set lightness(e) {
    this.$$set({ lightness: e }), ne();
  }
  get negative() {
    return this.$$.ctx[21];
  }
  set negative(e) {
    this.$$set({ negative: e }), ne();
  }
  get opacity() {
    return this.$$.ctx[22];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), ne();
  }
  get toneMapped() {
    return this.$$.ctx[0];
  }
  set toneMapped(e) {
    this.$$set({ toneMapped: e }), ne();
  }
  get transparent() {
    return this.$$.ctx[1];
  }
  set transparent(e) {
    this.$$set({ transparent: e }), ne();
  }
  get texture() {
    return this.$$.ctx[23];
  }
  set texture(e) {
    this.$$set({ texture: e }), ne();
  }
  get monochromeColor() {
    return this.$$.ctx[24];
  }
  set monochromeColor(e) {
    this.$$set({ monochromeColor: e }), ne();
  }
  get monochromeStrength() {
    return this.$$.ctx[25];
  }
  set monochromeStrength(e) {
    this.$$set({ monochromeStrength: e }), ne();
  }
  get colorProcessingTexture() {
    return this.$$.ctx[26];
  }
  set colorProcessingTexture(e) {
    this.$$set({ colorProcessingTexture: e }), ne();
  }
  get side() {
    return this.$$.ctx[2];
  }
  set side(e) {
    this.$$set({ side: e }), ne();
  }
  get url() {
    return this.$$.ctx[27];
  }
  set url(e) {
    this.$$set({ url: e }), ne();
  }
  get ref() {
    return this.$$.ctx[3];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
}
St(LU, { color: {}, zoom: {}, radius: {}, alphaThreshold: {}, alphaSmoothing: {}, brightness: {}, contrast: {}, hue: {}, saturation: {}, lightness: {}, negative: { type: "Boolean" }, opacity: {}, toneMapped: { type: "Boolean" }, transparent: { type: "Boolean" }, texture: {}, monochromeColor: {}, monochromeStrength: {}, colorProcessingTexture: {}, side: {}, url: {}, ref: {} }, ["default"], [], !0);
const kU = (
  /*glsl*/
  `
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`
), UU = (
  /*glsl*/
  `
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(worldCamProjPosition, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <${va < 154 ? "encodings_fragment" : "colorspace_fragment"}>
	}
`
), FU = (s) => ({ ref: s[0] & /*ref*/
1 }), mv = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function OU(s) {
  let e, t;
  return e = new ee.PlaneGeometry({
    props: {
      args: typeof /*gridSize*/
      s[1] == "number" ? [
        /*gridSize*/
        s[1],
        /*gridSize*/
        s[1]
      ] : (
        /*gridSize*/
        s[1]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*gridSize*/
      2 && (r.args = typeof /*gridSize*/
      n[1] == "number" ? [
        /*gridSize*/
        n[1],
        /*gridSize*/
        n[1]
      ] : (
        /*gridSize*/
        n[1]
      )), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function NU(s) {
  let e, t, n;
  e = new ee.ShaderMaterial({
    props: {
      fragmentShader: UU,
      vertexShader: kU,
      uniforms: (
        /*uniforms*/
        s[3]
      ),
      transparent: !0,
      side: (
        /*side*/
        s[2]
      )
    }
  });
  const i = (
    /*#slots*/
    s[25].default
  ), r = yt(
    i,
    s,
    /*$$scope*/
    s[28],
    mv
  ), a = r || OU(s);
  return {
    c() {
      Z(e.$$.fragment), t = Me(), a && a.c();
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), a && a.m(o, l), n = !0;
    },
    p(o, l) {
      const c = {};
      l[0] & /*uniforms*/
      8 && (c.uniforms = /*uniforms*/
      o[3]), l[0] & /*side*/
      4 && (c.side = /*side*/
      o[2]), e.$set(c), r ? r.p && (!n || l[0] & /*$$scope, ref*/
      268435457) && wt(
        r,
        i,
        o,
        /*$$scope*/
        o[28],
        n ? xt(
          i,
          /*$$scope*/
          o[28],
          l,
          FU
        ) : Et(
          /*$$scope*/
          o[28]
        ),
        mv
      ) : a && a.p && (!n || l[0] & /*gridSize*/
      2) && a.p(o, n ? l : [-1, -1]);
    },
    i(o) {
      n || (O(e.$$.fragment, o), O(a, o), n = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(a, o), n = !1;
    },
    d(o) {
      o && xe(t), J(e, o), a && a.d(o);
    }
  };
}
function GU(s) {
  let e, t, n;
  const i = [
    { frustumCulled: !1 },
    /*$$restProps*/
    s[6]
  ];
  function r(o) {
    s[27](o);
  }
  let a = {
    $$slots: {
      default: [NU, ({ ref: o }) => ({ 0: o }), ({ ref: o }) => [o ? 1 : 0]]
    },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < i.length; o += 1)
    a = We(a, i[o]);
  return (
    /*ref*/
    s[0] !== void 0 && (a.ref = /*ref*/
    s[0]), e = new ee.Mesh({ props: a }), s[26](e), Ut.push(() => ar(e, "ref", r)), {
      c() {
        Z(e.$$.fragment);
      },
      m(o, l) {
        K(e, o, l), n = !0;
      },
      p(o, l) {
        const c = l[0] & /*$$restProps*/
        64 ? jt(i, [i[0], Kt(
          /*$$restProps*/
          o[6]
        )]) : {};
        l[0] & /*$$scope, gridSize, ref, uniforms, side*/
        268435471 && (c.$$scope = { dirty: l, ctx: o }), !t && l[0] & /*ref*/
        1 && (t = !0, c.ref = /*ref*/
        o[0], or(() => t = !1)), e.$set(c);
      },
      i(o) {
        n || (O(e.$$.fragment, o), n = !0);
      },
      o(o) {
        N(e.$$.fragment, o), n = !1;
      },
      d(o) {
        s[26](null), J(e, o);
      }
    }
  );
}
function QU(s, e, t) {
  const n = [
    "cellColor",
    "sectionColor",
    "cellSize",
    "backgroundColor",
    "backgroundOpacity",
    "sectionSize",
    "plane",
    "gridSize",
    "followCamera",
    "infiniteGrid",
    "fadeDistance",
    "fadeStrength",
    "cellThickness",
    "sectionThickness",
    "side",
    "type",
    "axis",
    "maxRadius",
    "cellDividers",
    "sectionDividers",
    "ref"
  ];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { cellColor: l = "#000000" } = e, { sectionColor: c = "#0000ee" } = e, { cellSize: u = 1 } = e, { backgroundColor: f = "#dadada" } = e, { backgroundOpacity: h = 0 } = e, { sectionSize: d = 10 } = e, { plane: m = "xz" } = e, { gridSize: _ = [20, 20] } = e, { followCamera: g = !1 } = e, { infiniteGrid: A = !1 } = e, { fadeDistance: v = 100 } = e, { fadeStrength: y = 1 } = e, { cellThickness: w = 1 } = e, { sectionThickness: E = 2 } = e, { side: I = zn } = e, { type: C = "grid" } = e, { axis: B = "x" } = e, { maxRadius: T = 0 } = e, { cellDividers: S = 6 } = e, { sectionDividers: D = 2 } = e, { ref: R } = e;
  const { invalidate: P, camera: L } = un(), V = new _r(), U = new H(0, 1, 0), Q = new H(0, 0, 0), q = { x: 0, y: 1, z: 2 }, oe = { xz: "xzy", xy: "xyz", zy: "zyx" }, le = { grid: 0, lines: 1, circular: 2, polar: 3 }, k = {
    cellSize: { value: u },
    sectionSize: { value: d },
    cellColor: { value: new Je(l) },
    sectionColor: { value: new Je(c) },
    backgroundColor: { value: new Je(f) },
    backgroundOpacity: { value: h },
    fadeDistance: { value: v },
    fadeStrength: { value: y },
    cellThickness: { value: w },
    sectionThickness: { value: E },
    infiniteGrid: { value: A },
    followCamera: { value: g },
    coord0: { value: 0 },
    coord1: { value: 2 },
    coord2: { value: 1 },
    gridType: { value: le.grid },
    lineGridCoord: { value: q[B] },
    circleGridMaxRadius: { value: T },
    polarCellDividers: { value: S },
    polarSectionDividers: { value: D },
    worldCamProjPosition: { value: new H() },
    worldPlanePosition: { value: new H() }
  };
  On(() => {
    V.setFromNormalAndCoplanarPoint(U, Q).applyMatrix4(R.matrixWorld);
    const j = R.material, Ae = j.uniforms.worldCamProjPosition, Y = j.uniforms.worldPlanePosition;
    V.projectPoint(L.current.position, Ae.value), Y.value.set(0, 0, 0).applyMatrix4(R.matrixWorld), P();
  });
  const X = An();
  lt(s, X, (j) => t(4, r = j));
  function fe(j) {
    Ut[j ? "unshift" : "push"](() => {
      r = j, X.set(r);
    });
  }
  function te(j) {
    R = j, t(0, R);
  }
  return s.$$set = (j) => {
    e = We(We({}, e), rn(j)), t(6, i = ft(e, n)), "cellColor" in j && t(7, l = j.cellColor), "sectionColor" in j && t(8, c = j.sectionColor), "cellSize" in j && t(9, u = j.cellSize), "backgroundColor" in j && t(10, f = j.backgroundColor), "backgroundOpacity" in j && t(11, h = j.backgroundOpacity), "sectionSize" in j && t(12, d = j.sectionSize), "plane" in j && t(13, m = j.plane), "gridSize" in j && t(1, _ = j.gridSize), "followCamera" in j && t(14, g = j.followCamera), "infiniteGrid" in j && t(15, A = j.infiniteGrid), "fadeDistance" in j && t(16, v = j.fadeDistance), "fadeStrength" in j && t(17, y = j.fadeStrength), "cellThickness" in j && t(18, w = j.cellThickness), "sectionThickness" in j && t(19, E = j.sectionThickness), "side" in j && t(2, I = j.side), "type" in j && t(20, C = j.type), "axis" in j && t(21, B = j.axis), "maxRadius" in j && t(22, T = j.maxRadius), "cellDividers" in j && t(23, S = j.cellDividers), "sectionDividers" in j && t(24, D = j.sectionDividers), "ref" in j && t(0, R = j.ref), "$$scope" in j && t(28, o = j.$$scope);
  }, s.$$.update = () => {
    if (s.$$.dirty[0] & /*plane*/
    8192) {
      const j = oe[m], Ae = j.charAt(0), Y = j.charAt(1), pe = j.charAt(2);
      t(3, k.coord0.value = q[Ae], k), t(3, k.coord1.value = q[Y], k), t(3, k.coord2.value = q[pe], k);
    }
    if (s.$$.dirty[0] & /*cellSize*/
    512 && t(3, k.cellSize.value = u, k), s.$$.dirty[0] & /*sectionSize*/
    4096 && t(3, k.sectionSize.value = d, k), s.$$.dirty[0] & /*backgroundOpacity*/
    2048 && t(3, k.backgroundOpacity.value = h, k), s.$$.dirty[0] & /*fadeDistance*/
    65536 && t(3, k.fadeDistance.value = v, k), s.$$.dirty[0] & /*fadeStrength*/
    131072 && t(3, k.fadeStrength.value = y, k), s.$$.dirty[0] & /*cellThickness*/
    262144 && t(3, k.cellThickness.value = w, k), s.$$.dirty[0] & /*sectionThickness*/
    524288 && t(3, k.sectionThickness.value = E, k), s.$$.dirty[0] & /*followCamera*/
    16384 && t(3, k.followCamera.value = g, k), s.$$.dirty[0] & /*infiniteGrid*/
    32768 && t(3, k.infiniteGrid.value = A, k), s.$$.dirty[0] & /*type, axis, maxRadius, cellDividers, sectionDividers*/
    32505856) {
      switch (C) {
        case "grid": {
          t(3, k.gridType.value = le.grid, k);
          break;
        }
        case "lines": {
          t(3, k.gridType.value = le.lines, k), t(3, k.lineGridCoord.value = q[B], k);
          break;
        }
        case "circular": {
          t(3, k.gridType.value = le.circular, k), t(3, k.circleGridMaxRadius.value = T, k);
          break;
        }
        case "polar": {
          t(3, k.gridType.value = le.polar, k), t(3, k.circleGridMaxRadius.value = T, k), t(3, k.polarCellDividers.value = S, k), t(3, k.polarSectionDividers.value = D, k);
          break;
        }
      }
      P();
    }
    s.$$.dirty[0] & /*uniforms, cellColor*/
    136 && k.cellColor.value.set(l), s.$$.dirty[0] & /*uniforms, sectionColor*/
    264 && k.sectionColor.value.set(c), s.$$.dirty[0] & /*uniforms, backgroundColor*/
    1032 && k.backgroundColor.value.set(f);
  }, [
    R,
    _,
    I,
    k,
    r,
    X,
    i,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    g,
    A,
    v,
    y,
    w,
    E,
    C,
    B,
    T,
    S,
    D,
    a,
    fe,
    te,
    o
  ];
}
class zU extends Mt {
  constructor(e) {
    super(), Ct(
      this,
      e,
      QU,
      GU,
      _t,
      {
        cellColor: 7,
        sectionColor: 8,
        cellSize: 9,
        backgroundColor: 10,
        backgroundOpacity: 11,
        sectionSize: 12,
        plane: 13,
        gridSize: 1,
        followCamera: 14,
        infiniteGrid: 15,
        fadeDistance: 16,
        fadeStrength: 17,
        cellThickness: 18,
        sectionThickness: 19,
        side: 2,
        type: 20,
        axis: 21,
        maxRadius: 22,
        cellDividers: 23,
        sectionDividers: 24,
        ref: 0
      },
      null,
      [-1, -1]
    );
  }
  get cellColor() {
    return this.$$.ctx[7];
  }
  set cellColor(e) {
    this.$$set({ cellColor: e }), ne();
  }
  get sectionColor() {
    return this.$$.ctx[8];
  }
  set sectionColor(e) {
    this.$$set({ sectionColor: e }), ne();
  }
  get cellSize() {
    return this.$$.ctx[9];
  }
  set cellSize(e) {
    this.$$set({ cellSize: e }), ne();
  }
  get backgroundColor() {
    return this.$$.ctx[10];
  }
  set backgroundColor(e) {
    this.$$set({ backgroundColor: e }), ne();
  }
  get backgroundOpacity() {
    return this.$$.ctx[11];
  }
  set backgroundOpacity(e) {
    this.$$set({ backgroundOpacity: e }), ne();
  }
  get sectionSize() {
    return this.$$.ctx[12];
  }
  set sectionSize(e) {
    this.$$set({ sectionSize: e }), ne();
  }
  get plane() {
    return this.$$.ctx[13];
  }
  set plane(e) {
    this.$$set({ plane: e }), ne();
  }
  get gridSize() {
    return this.$$.ctx[1];
  }
  set gridSize(e) {
    this.$$set({ gridSize: e }), ne();
  }
  get followCamera() {
    return this.$$.ctx[14];
  }
  set followCamera(e) {
    this.$$set({ followCamera: e }), ne();
  }
  get infiniteGrid() {
    return this.$$.ctx[15];
  }
  set infiniteGrid(e) {
    this.$$set({ infiniteGrid: e }), ne();
  }
  get fadeDistance() {
    return this.$$.ctx[16];
  }
  set fadeDistance(e) {
    this.$$set({ fadeDistance: e }), ne();
  }
  get fadeStrength() {
    return this.$$.ctx[17];
  }
  set fadeStrength(e) {
    this.$$set({ fadeStrength: e }), ne();
  }
  get cellThickness() {
    return this.$$.ctx[18];
  }
  set cellThickness(e) {
    this.$$set({ cellThickness: e }), ne();
  }
  get sectionThickness() {
    return this.$$.ctx[19];
  }
  set sectionThickness(e) {
    this.$$set({ sectionThickness: e }), ne();
  }
  get side() {
    return this.$$.ctx[2];
  }
  set side(e) {
    this.$$set({ side: e }), ne();
  }
  get type() {
    return this.$$.ctx[20];
  }
  set type(e) {
    this.$$set({ type: e }), ne();
  }
  get axis() {
    return this.$$.ctx[21];
  }
  set axis(e) {
    this.$$set({ axis: e }), ne();
  }
  get maxRadius() {
    return this.$$.ctx[22];
  }
  set maxRadius(e) {
    this.$$set({ maxRadius: e }), ne();
  }
  get cellDividers() {
    return this.$$.ctx[23];
  }
  set cellDividers(e) {
    this.$$set({ cellDividers: e }), ne();
  }
  get sectionDividers() {
    return this.$$.ctx[24];
  }
  set sectionDividers(e) {
    this.$$set({ sectionDividers: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
}
St(zU, { cellColor: {}, sectionColor: {}, cellSize: {}, backgroundColor: {}, backgroundOpacity: {}, sectionSize: {}, plane: {}, gridSize: {}, followCamera: { type: "Boolean" }, infiniteGrid: { type: "Boolean" }, fadeDistance: {}, fadeStrength: {}, cellThickness: {}, sectionThickness: {}, side: {}, type: {}, axis: {}, maxRadius: {}, cellDividers: {}, sectionDividers: {}, ref: {} }, ["default"], [], !0);
const $U = (s) => ({ ref: s & /*ref*/
131072 }), gv = (s) => ({ ref: (
  /*ref*/
  s[17]
) });
function VU(s) {
  let e;
  const t = (
    /*#slots*/
    s[12].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[15],
    gv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      163840) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[15],
        e ? xt(
          t,
          /*$$scope*/
          i[15],
          r,
          $U
        ) : Et(
          /*$$scope*/
          i[15]
        ),
        gv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function HU(s) {
  let e, t, n = {
    args: [
      /*shape*/
      s[2],
      /*params*/
      s[1]
    ],
    $$slots: {
      default: [
        VU,
        ({ ref: i }) => ({ 17: i }),
        ({ ref: i }) => i ? 131072 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  return e = new ee.ExtrudeGeometry({ props: n }), s[13](e), e.$on(
    "create",
    /*create_handler*/
    s[14]
  ), {
    c() {
      Z(e.$$.fragment);
    },
    m(i, r) {
      K(e, i, r), t = !0;
    },
    p(i, [r]) {
      const a = {};
      r & /*shape, params*/
      6 && (a.args = [
        /*shape*/
        i[2],
        /*params*/
        i[1]
      ]), r & /*$$scope, ref*/
      163840 && (a.$$scope = { dirty: r, ctx: i }), e.$set(a);
    },
    i(i) {
      t || (O(e.$$.fragment, i), t = !0);
    },
    o(i) {
      N(e.$$.fragment, i), t = !1;
    },
    d(i) {
      s[13](null), J(e, i);
    }
  };
}
const Kr = 1e-5;
function jU(s, e, t) {
  let n, i, r, a, o, l, { $$slots: c = {}, $$scope: u } = e;
  const f = An();
  lt(s, f, (w) => t(3, l = w));
  let { args: h = [] } = e, { radius: d = 0.05 } = e, { smoothness: m = 4 } = e, { creaseAngle: _ = 0.4 } = e, { steps: g = 1 } = e;
  const A = (w, E, I) => {
    const C = new ho(), B = I - Kr;
    return C.absarc(Kr, Kr, Kr, -Math.PI / 2, -Math.PI, !0), C.absarc(Kr, E - B * 2, Kr, Math.PI, Math.PI / 2, !0), C.absarc(w - B * 2, E - B * 2, Kr, Math.PI / 2, 0, !0), C.absarc(w - B * 2, Kr, Kr, 0, -Math.PI / 2, !0), C;
  };
  function v(w) {
    Ut[w ? "unshift" : "push"](() => {
      l = w, f.set(l);
    });
  }
  const y = ({ ref: w }) => {
    w.center(), XA(w, _);
  };
  return s.$$set = (w) => {
    "args" in w && t(5, h = w.args), "radius" in w && t(6, d = w.radius), "smoothness" in w && t(7, m = w.smoothness), "creaseAngle" in w && t(0, _ = w.creaseAngle), "steps" in w && t(8, g = w.steps), "$$scope" in w && t(15, u = w.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*args*/
    32 && t(11, n = h[0] ?? 1), s.$$.dirty & /*args*/
    32 && t(10, i = h[1] ?? 1), s.$$.dirty & /*args*/
    32 && t(9, r = h[2] ?? 1), s.$$.dirty & /*width, height, radius*/
    3136 && t(2, a = A(n, i, d)), s.$$.dirty & /*depth, radius, smoothness, steps*/
    960 && t(1, o = {
      depth: r - d * 2,
      bevelEnabled: !0,
      bevelSegments: m * 2,
      steps: g,
      bevelSize: d - Kr,
      bevelThickness: d,
      curveSegments: m
    });
  }, [
    _,
    o,
    a,
    l,
    f,
    h,
    d,
    m,
    g,
    r,
    i,
    n,
    c,
    v,
    y,
    u
  ];
}
class WU extends Mt {
  constructor(e) {
    super(), Ct(this, e, jU, HU, _t, {
      args: 5,
      radius: 6,
      smoothness: 7,
      creaseAngle: 0,
      steps: 8
    });
  }
  get args() {
    return this.$$.ctx[5];
  }
  set args(e) {
    this.$$set({ args: e }), ne();
  }
  get radius() {
    return this.$$.ctx[6];
  }
  set radius(e) {
    this.$$set({ radius: e }), ne();
  }
  get smoothness() {
    return this.$$.ctx[7];
  }
  set smoothness(e) {
    this.$$set({ smoothness: e }), ne();
  }
  get creaseAngle() {
    return this.$$.ctx[0];
  }
  set creaseAngle(e) {
    this.$$set({ creaseAngle: e }), ne();
  }
  get steps() {
    return this.$$.ctx[8];
  }
  set steps(e) {
    this.$$set({ steps: e }), ne();
  }
}
St(WU, { args: {}, radius: {}, smoothness: {}, creaseAngle: {}, steps: {} }, ["default"], [], !0);
const Yo = new zu(), Bi = new H(), ro = new H(), Tn = new en(), Av = {
  X: new H(1, 0, 0),
  Y: new H(0, 1, 0),
  Z: new H(0, 0, 1)
}, Am = { type: "change" }, _v = { type: "mouseDown" }, bv = { type: "mouseUp", mode: null }, vv = { type: "objectChange" };
class qU extends Gt {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const n = new eF();
    this._gizmo = n, this.add(n);
    const i = new tF();
    this._plane = i, this.add(i);
    const r = this;
    function a(v, y) {
      let w = y;
      Object.defineProperty(r, v, {
        get: function() {
          return w !== void 0 ? w : y;
        },
        set: function(E) {
          w !== E && (w = E, i[v] = E, n[v] = E, r.dispatchEvent({ type: v + "-changed", value: E }), r.dispatchEvent(Am));
        }
      }), r[v] = y, i[v] = y, n[v] = y;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new H(), l = new H(), c = new en(), u = new en(), f = new H(), h = new en(), d = new H(), m = new H(), _ = new H(), g = 0, A = new H();
    a("worldPosition", o), a("worldPositionStart", l), a("worldQuaternion", c), a("worldQuaternionStart", u), a("cameraPosition", f), a("cameraQuaternion", h), a("pointStart", d), a("pointEnd", m), a("rotationAxis", _), a("rotationAngle", g), a("eye", A), this._offset = new H(), this._startNorm = new H(), this._endNorm = new H(), this._cameraScale = new H(), this._parentPosition = new H(), this._parentQuaternion = new en(), this._parentQuaternionInv = new en(), this._parentScale = new H(), this._worldScaleStart = new H(), this._worldQuaternionInv = new en(), this._worldScale = new H(), this._positionStart = new H(), this._quaternionStart = new en(), this._scaleStart = new H(), this._getPointer = XU.bind(this), this._onPointerDown = KU.bind(this), this._onPointerHover = YU.bind(this), this._onPointerMove = JU.bind(this), this._onPointerUp = ZU.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    e !== null && Yo.setFromCamera(e, this.camera);
    const t = _m(this._gizmo.picker[this.mode], Yo);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && Yo.setFromCamera(e, this.camera);
      const t = _m(this._plane, Yo, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, _v.mode = this.mode, this.dispatchEvent(_v);
    }
  }
  pointerMove(e) {
    const t = this.axis, n = this.mode, i = this.object;
    let r = this.space;
    if (n === "scale" ? r = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (r = "world"), i === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1)
      return;
    e !== null && Yo.setFromCamera(e, this.camera);
    const a = _m(this._plane, Yo, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), r === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), r === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (r === "local" && (i.position.applyQuaternion(Tn.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), r === "world" && (i.parent && i.position.add(Bi.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(Bi.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (n === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), ro.set(o, o, o);
        } else
          Bi.copy(this.pointStart), ro.copy(this.pointEnd), Bi.applyQuaternion(this._worldQuaternionInv), ro.applyQuaternion(this._worldQuaternionInv), ro.divide(Bi), t.search("X") === -1 && (ro.x = 1), t.search("Y") === -1 && (ro.y = 1), t.search("Z") === -1 && (ro.z = 1);
        i.scale.copy(this._scaleStart).multiply(ro), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(Bi.setFromMatrixPosition(this.camera.matrixWorld));
        let l = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Bi.copy(this.rotationAxis).cross(this.eye)) * o) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(Av[t]), Bi.copy(Av[t]), r === "local" && Bi.applyQuaternion(this.worldQuaternion), Bi.cross(this.eye), Bi.length() === 0 ? l = !0 : this.rotationAngle = this._offset.dot(Bi.normalize()) * o), (t === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), r === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(Tn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(Tn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Am), this.dispatchEvent(vv);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (bv.mode = this.mode, this.dispatchEvent(bv)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Am), this.dispatchEvent(vv), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Yo;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function XU(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function YU(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function KU(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function JU(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function ZU(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function _m(s, e, t) {
  const n = e.intersectObject(s, !0);
  for (let i = 0; i < n.length; i++)
    if (n[i].object.visible || t)
      return n[i];
  return !1;
}
const Zf = new Ui(), bn = new H(0, 1, 0), yv = new H(0, 0, 0), xv = new st(), eh = new en(), Ph = new en(), Jr = new H(), wv = new st(), Xc = new H(1, 0, 0), ia = new H(0, 1, 0), Yc = new H(0, 0, 1), th = new H(), Dc = new H(), Lc = new H();
class eF extends Gt {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new $n({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new Jn({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = e.clone();
    n.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const r = e.clone();
    r.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const l = e.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const c = e.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(255), u.opacity = 0.5;
    const f = e.clone();
    f.opacity = 0.25;
    const h = e.clone();
    h.color.setHex(16776960), h.opacity = 0.25, e.clone().color.setHex(16776960);
    const m = e.clone();
    m.color.setHex(7895160);
    const _ = new Wn(0, 0.04, 0.1, 12);
    _.translate(0, 0.05, 0);
    const g = new Pn(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const A = new Dt();
    A.setAttribute("position", new ht([0, 0, 0, 1, 0, 0], 3));
    const v = new Wn(75e-4, 75e-4, 0.5, 3);
    v.translate(0, 0.25, 0);
    function y(V, U) {
      const Q = new Ms(V, 75e-4, 3, 64, U * Math.PI * 2);
      return Q.rotateY(Math.PI / 2), Q.rotateX(Math.PI / 2), Q;
    }
    function w() {
      const V = new Dt();
      return V.setAttribute("position", new ht([0, 0, 0, 1, 1, 1], 3)), V;
    }
    const E = {
      X: [
        [new tt(_, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(_, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new tt(v, r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new tt(_, a), [0, 0.5, 0]],
        [new tt(_, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new tt(v, a)]
      ],
      Z: [
        [new tt(_, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new tt(_, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new tt(v, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Bs(0.1, 0), f.clone()), [0, 0, 0]]
      ],
      XY: [
        [new tt(new Pn(0.15, 0.15, 0.01), u.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Pn(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Pn(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, I = {
      X: [
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Bs(0.2, 0), n)]
      ],
      XY: [
        [new tt(new Pn(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Pn(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Pn(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, C = {
      START: [
        [new tt(new Bs(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new tt(new Bs(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new qn(w(), i), null, null, null, "helper"]
      ],
      X: [
        [new qn(A, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new qn(A, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new qn(A, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, B = {
      XYZE: [
        [new tt(y(0.5, 1), m), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new tt(y(0.5, 0.5), r)]
      ],
      Y: [
        [new tt(y(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new tt(y(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new tt(y(0.75, 1), h), null, [0, Math.PI / 2, 0]]
      ]
    }, T = {
      AXIS: [
        [new qn(A, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, S = {
      XYZE: [
        [new tt(new tc(0.25, 10, 8), n)]
      ],
      X: [
        [new tt(new Ms(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new tt(new Ms(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new tt(new Ms(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new tt(new Ms(0.75, 0.1, 2, 24), n)]
      ]
    }, D = {
      X: [
        [new tt(g, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(v, r), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(g, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new tt(g, a), [0, 0.5, 0]],
        [new tt(v, a)],
        [new tt(g, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new tt(g, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new tt(v, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new tt(g, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new tt(new Pn(0.15, 0.15, 0.01), u), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Pn(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Pn(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Pn(0.1, 0.1, 0.1), f.clone())]
      ]
    }, R = {
      X: [
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new tt(new Wn(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new tt(new Pn(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Pn(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Pn(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Pn(0.2, 0.2, 0.2), n), [0, 0, 0]]
      ]
    }, P = {
      X: [
        [new qn(A, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new qn(A, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new qn(A, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function L(V) {
      const U = new Gt();
      for (const Q in V)
        for (let q = V[Q].length; q--; ) {
          const oe = V[Q][q][0].clone(), le = V[Q][q][1], k = V[Q][q][2], X = V[Q][q][3], fe = V[Q][q][4];
          oe.name = Q, oe.tag = fe, le && oe.position.set(le[0], le[1], le[2]), k && oe.rotation.set(k[0], k[1], k[2]), X && oe.scale.set(X[0], X[1], X[2]), oe.updateMatrix();
          const te = oe.geometry.clone();
          te.applyMatrix4(oe.matrix), oe.geometry = te, oe.renderOrder = 1 / 0, oe.position.set(0, 0, 0), oe.rotation.set(0, 0, 0), oe.scale.set(1, 1, 1), U.add(oe);
        }
      return U;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = L(E)), this.add(this.gizmo.rotate = L(B)), this.add(this.gizmo.scale = L(D)), this.add(this.picker.translate = L(I)), this.add(this.picker.rotate = L(S)), this.add(this.picker.scale = L(R)), this.add(this.helper.translate = L(C)), this.add(this.helper.rotate = L(T)), this.add(this.helper.scale = L(P)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const n = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Ph;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let r = 0; r < i.length; r++) {
      const a = i[r];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (Tn.setFromEuler(Zf.set(0, 0, 0)), a.quaternion.copy(n).multiply(Tn), Math.abs(bn.copy(Xc).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (Tn.setFromEuler(Zf.set(0, 0, Math.PI / 2)), a.quaternion.copy(n).multiply(Tn), Math.abs(bn.copy(ia).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (Tn.setFromEuler(Zf.set(0, Math.PI / 2, 0)), a.quaternion.copy(n).multiply(Tn), Math.abs(bn.copy(Yc).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (Tn.setFromEuler(Zf.set(0, Math.PI / 2, 0)), bn.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(xv.lookAt(yv, bn, ia)), a.quaternion.multiply(Tn), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), Bi.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Bi.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(Bi), a.visible = this.dragging) : (a.quaternion.copy(n), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(n), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(bn.copy(Xc).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(bn.copy(ia).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(bn.copy(Yc).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(bn.copy(Yc).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(bn.copy(Xc).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(bn.copy(ia).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (eh.copy(n), bn.copy(this.eye).applyQuaternion(Tn.copy(n).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(xv.lookAt(this.eye, yv, ia)), a.name === "X" && (Tn.setFromAxisAngle(Xc, Math.atan2(-bn.y, bn.z)), Tn.multiplyQuaternions(eh, Tn), a.quaternion.copy(Tn)), a.name === "Y" && (Tn.setFromAxisAngle(ia, Math.atan2(bn.x, bn.z)), Tn.multiplyQuaternions(eh, Tn), a.quaternion.copy(Tn)), a.name === "Z" && (Tn.setFromAxisAngle(Yc, Math.atan2(bn.y, bn.x)), Tn.multiplyQuaternions(eh, Tn), a.quaternion.copy(Tn))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(l) {
        return a.name === l;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class tF extends tt {
  constructor() {
    super(
      new Fi(1e5, 1e5, 2, 2),
      new $n({ visible: !1, wireframe: !0, side: zn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), th.copy(Xc).applyQuaternion(t === "local" ? this.worldQuaternion : Ph), Dc.copy(ia).applyQuaternion(t === "local" ? this.worldQuaternion : Ph), Lc.copy(Yc).applyQuaternion(t === "local" ? this.worldQuaternion : Ph), bn.copy(Dc), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            bn.copy(this.eye).cross(th), Jr.copy(th).cross(bn);
            break;
          case "Y":
            bn.copy(this.eye).cross(Dc), Jr.copy(Dc).cross(bn);
            break;
          case "Z":
            bn.copy(this.eye).cross(Lc), Jr.copy(Lc).cross(bn);
            break;
          case "XY":
            Jr.copy(Lc);
            break;
          case "YZ":
            Jr.copy(th);
            break;
          case "XZ":
            bn.copy(Lc), Jr.copy(Dc);
            break;
          case "XYZ":
          case "E":
            Jr.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Jr.set(0, 0, 0);
    }
    Jr.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (wv.lookAt(Bi.set(0, 0, 0), Jr, bn), this.quaternion.setFromRotationMatrix(wv)), super.updateMatrixWorld(e);
  }
}
const KA = () => qA("threlte-controls", {
  orbitControls: Ft(void 0),
  trackballControls: Ft(void 0)
}), nF = (s) => ({ ref: s & /*ref*/
536870912 }), Ev = (s) => ({ ref: (
  /*ref*/
  s[29]
) });
function iF(s) {
  let e, t;
  const n = [
    { is: (
      /*$controlsStore*/
      s[1]
    ) },
    /*transformProps*/
    s[2]
  ];
  let i = {};
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[15](e), e.$on(
    "dragging-changed",
    /*onDraggingChanged*/
    s[7]
  ), e.$on(
    "change",
    /*invalidate*/
    s[5]
  ), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*$controlsStore, transformProps*/
      6 ? jt(n, [
        a & /*$controlsStore*/
        2 && { is: (
          /*$controlsStore*/
          r[1]
        ) },
        a & /*transformProps*/
        4 && Kt(
          /*transformProps*/
          r[2]
        )
      ]) : {};
      e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[15](null), J(e, r);
    }
  };
}
function rF(s) {
  let e;
  const t = (
    /*#slots*/
    s[14].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[18],
    Ev
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      537133056) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[18],
        e ? xt(
          t,
          /*$$scope*/
          i[18],
          r,
          nF
        ) : Et(
          /*$$scope*/
          i[18]
        ),
        Ev
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function sF(s) {
  let e, t, n, i;
  e = new ic({
    props: {
      onChildMount: (
        /*func*/
        s[16]
      ),
      onChildDestroy: (
        /*func_1*/
        s[17]
      ),
      $$slots: { default: [iF] },
      $$scope: { ctx: s }
    }
  });
  const r = [
    { is: (
      /*group*/
      s[0]
    ) },
    /*objectProps*/
    s[3]
  ];
  let a = {
    $$slots: {
      default: [
        rF,
        ({ ref: o }) => ({ 29: o }),
        ({ ref: o }) => o ? 536870912 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < r.length; o += 1)
    a = We(a, r[o]);
  return n = new ee({ props: a }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), i = !0;
    },
    p(o, [l]) {
      const c = {};
      l & /*$$scope, $controlsStore, transformProps, $component*/
      262166 && (c.$$scope = { dirty: l, ctx: o }), e.$set(c);
      const u = l & /*group, objectProps*/
      9 ? jt(r, [
        l & /*group*/
        1 && { is: (
          /*group*/
          o[0]
        ) },
        l & /*objectProps*/
        8 && Kt(
          /*objectProps*/
          o[3]
        )
      ]) : {};
      l & /*$$scope, ref*/
      537133056 && (u.$$scope = { dirty: l, ctx: o }), n.$set(u);
    },
    i(o) {
      i || (O(e.$$.fragment, o), O(n.$$.fragment, o), i = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), i = !1;
    },
    d(o) {
      o && xe(t), J(e, o), J(n, o);
    }
  };
}
function oF(s, e, t) {
  const n = [
    "autoPauseOrbitControls",
    "autoPauseTrackballControls",
    "object",
    "group",
    "controls"
  ];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e, { autoPauseOrbitControls: c = !0 } = e, { autoPauseTrackballControls: u = !0 } = e, { object: f = void 0 } = e;
  const { camera: h, renderer: d, invalidate: m, scene: _ } = un(), { orbitControls: g, trackballControls: A } = KA(), v = Ft(!1), y = Ft(c ?? !0), w = Ft(u ?? !0), E = (Q) => {
    v.set(Q.value);
  };
  tn([g, v, y], ([Q, q, oe]) => {
    if (!(!Q || !Q.enabled && q))
      return Q.enabled = !(q && oe), () => {
        Q.enabled = !0;
      };
  }), tn([A, v, w], ([Q, q, oe]) => {
    if (!(!Q || !Q.enabled && q))
      return Q.enabled = !(q && oe), () => {
        Q.enabled = !0;
      };
  });
  const I = new Xn(), C = hi(h, (Q) => new qU(Q, d.domElement));
  lt(s, C, (Q) => t(1, r = Q));
  let { controls: B = r } = e;
  const T = Ft(f ?? I);
  tn([C, T], ([Q, q]) => (Q.attach(q), () => {
    Q.detach();
  }));
  const S = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible"
  ];
  let D = {}, R = {};
  const P = An();
  lt(s, P, (Q) => t(4, a = Q));
  function L(Q) {
    Ut[Q ? "unshift" : "push"](() => {
      a = Q, P.set(a);
    });
  }
  const V = (Q) => {
    _.add(Q);
  }, U = (Q) => {
    _.remove(Q);
  };
  return s.$$set = (Q) => {
    e = We(We({}, e), rn(Q)), t(28, i = ft(e, n)), "autoPauseOrbitControls" in Q && t(11, c = Q.autoPauseOrbitControls), "autoPauseTrackballControls" in Q && t(12, u = Q.autoPauseTrackballControls), "object" in Q && t(13, f = Q.object), "controls" in Q && t(10, B = Q.controls), "$$scope" in Q && t(18, l = Q.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*autoPauseOrbitControls*/
    2048 && y.set(c ?? !0), s.$$.dirty & /*autoPauseTrackballControls*/
    4096 && w.set(u ?? !0), s.$$.dirty & /*$controlsStore*/
    2 && t(10, B = r);
    {
      t(2, D = {}), t(3, R = {});
      for (let [Q, q] of Object.entries(i))
        S.includes(Q) ? t(2, D[Q] = q, D) : t(3, R[Q] = q, R);
    }
  }, [
    I,
    r,
    D,
    R,
    a,
    m,
    _,
    E,
    C,
    P,
    B,
    c,
    u,
    f,
    o,
    L,
    V,
    U,
    l
  ];
}
class aF extends Mt {
  constructor(e) {
    super(), Ct(this, e, oF, sF, _t, {
      autoPauseOrbitControls: 11,
      autoPauseTrackballControls: 12,
      object: 13,
      group: 0,
      controls: 10
    });
  }
  get autoPauseOrbitControls() {
    return this.$$.ctx[11];
  }
  set autoPauseOrbitControls(e) {
    this.$$set({ autoPauseOrbitControls: e }), ne();
  }
  get autoPauseTrackballControls() {
    return this.$$.ctx[12];
  }
  set autoPauseTrackballControls(e) {
    this.$$set({ autoPauseTrackballControls: e }), ne();
  }
  get object() {
    return this.$$.ctx[13];
  }
  set object(e) {
    this.$$set({ object: e }), ne();
  }
  get group() {
    return this.$$.ctx[0];
  }
  get controls() {
    return this.$$.ctx[10];
  }
  set controls(e) {
    this.$$set({ controls: e }), ne();
  }
}
St(aF, { autoPauseOrbitControls: { type: "Boolean" }, autoPauseTrackballControls: { type: "Boolean" }, object: {}, controls: {} }, ["default"], ["group"], !0);
const Cv = { type: "change" }, bm = { type: "start" }, Sv = { type: "end" }, nh = new wa(), Mv = new _r(), lF = Math.cos(70 * ls.DEG2RAD);
let cF = class extends Qr {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new H(), this.cursor = new H(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: ts.ROTATE, MIDDLE: ts.DOLLY, RIGHT: ts.PAN }, this.touches = { ONE: ea.ROTATE, TWO: ea.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return o.phi;
    }, this.getAzimuthalAngle = function() {
      return o.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function($) {
      $.addEventListener("keydown", he), this._domElementKeyEvents = $;
    }, this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", he), this._domElementKeyEvents = null;
    }, this.saveState = function() {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = function() {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Cv), n.update(), r = i.NONE;
    }, this.update = function() {
      const $ = new H(), ge = new en().setFromUnitVectors(e.up, new H(0, 1, 0)), be = ge.clone().invert(), Ue = new H(), je = new en(), it = new H(), nt = 2 * Math.PI;
      return function(bt = null) {
        const Xe = n.object.position;
        $.copy(Xe).sub(n.target), $.applyQuaternion(ge), o.setFromVector3($), n.autoRotate && r === i.NONE && R(S(bt)), n.enableDamping ? (o.theta += l.theta * n.dampingFactor, o.phi += l.phi * n.dampingFactor) : (o.theta += l.theta, o.phi += l.phi);
        let dt = n.minAzimuthAngle, at = n.maxAzimuthAngle;
        isFinite(dt) && isFinite(at) && (dt < -Math.PI ? dt += nt : dt > Math.PI && (dt -= nt), at < -Math.PI ? at += nt : at > Math.PI && (at -= nt), dt <= at ? o.theta = Math.max(dt, Math.min(at, o.theta)) : o.theta = o.theta > (dt + at) / 2 ? Math.max(dt, o.theta) : Math.min(at, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), n.target.sub(n.cursor), n.target.clampLength(n.minTargetRadius, n.maxTargetRadius), n.target.add(n.cursor);
        let At = !1;
        if (n.zoomToCursor && I || n.object.isOrthographicCamera)
          o.radius = le(o.radius);
        else {
          const It = o.radius;
          o.radius = le(o.radius * c), At = It != o.radius;
        }
        if ($.setFromSpherical(o), $.applyQuaternion(be), Xe.copy(n.target).add($), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), u.set(0, 0, 0)), n.zoomToCursor && I) {
          let It = null;
          if (n.object.isPerspectiveCamera) {
            const Qt = $.length();
            It = le(Qt * c);
            const Tt = Qt - It;
            n.object.position.addScaledVector(w, Tt), n.object.updateMatrixWorld(), At = !!Tt;
          } else if (n.object.isOrthographicCamera) {
            const Qt = new H(E.x, E.y, 0);
            Qt.unproject(n.object);
            const Tt = n.object.zoom;
            n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), At = Tt !== n.object.zoom;
            const $t = new H(E.x, E.y, 0);
            $t.unproject(n.object), n.object.position.sub($t).add(Qt), n.object.updateMatrixWorld(), It = $.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          It !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(It).add(n.object.position) : (nh.origin.copy(n.object.position), nh.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(nh.direction)) < lF ? e.lookAt(n.target) : (Mv.setFromNormalAndCoplanarPoint(n.object.up, n.target), nh.intersectPlane(Mv, n.target))));
        } else if (n.object.isOrthographicCamera) {
          const It = n.object.zoom;
          n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), It !== n.object.zoom && (n.object.updateProjectionMatrix(), At = !0);
        }
        return c = 1, I = !1, At || Ue.distanceToSquared(n.object.position) > a || 8 * (1 - je.dot(n.object.quaternion)) > a || it.distanceToSquared(n.target) > a ? (n.dispatchEvent(Cv), Ue.copy(n.object.position), je.copy(n.object.quaternion), it.copy(n.target), !0) : !1;
      };
    }(), this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", Ye), n.domElement.removeEventListener("pointerdown", W), n.domElement.removeEventListener("pointercancel", se), n.domElement.removeEventListener("wheel", ue), n.domElement.removeEventListener("pointermove", G), n.domElement.removeEventListener("pointerup", se), n.domElement.getRootNode().removeEventListener("keydown", Ge, { capture: !0 }), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", he), n._domElementKeyEvents = null);
    };
    const n = this, i = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let r = i.NONE;
    const a = 1e-6, o = new ed(), l = new ed();
    let c = 1;
    const u = new H(), f = new ke(), h = new ke(), d = new ke(), m = new ke(), _ = new ke(), g = new ke(), A = new ke(), v = new ke(), y = new ke(), w = new H(), E = new ke();
    let I = !1;
    const C = [], B = {};
    let T = !1;
    function S($) {
      return $ !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * $ : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function D($) {
      const ge = Math.abs($ * 0.01);
      return Math.pow(0.95, n.zoomSpeed * ge);
    }
    function R($) {
      l.theta -= $;
    }
    function P($) {
      l.phi -= $;
    }
    const L = function() {
      const $ = new H();
      return function(be, Ue) {
        $.setFromMatrixColumn(Ue, 0), $.multiplyScalar(-be), u.add($);
      };
    }(), V = function() {
      const $ = new H();
      return function(be, Ue) {
        n.screenSpacePanning === !0 ? $.setFromMatrixColumn(Ue, 1) : ($.setFromMatrixColumn(Ue, 0), $.crossVectors(n.object.up, $)), $.multiplyScalar(be), u.add($);
      };
    }(), U = function() {
      const $ = new H();
      return function(be, Ue) {
        const je = n.domElement;
        if (n.object.isPerspectiveCamera) {
          const it = n.object.position;
          $.copy(it).sub(n.target);
          let nt = $.length();
          nt *= Math.tan(n.object.fov / 2 * Math.PI / 180), L(2 * be * nt / je.clientHeight, n.object.matrix), V(2 * Ue * nt / je.clientHeight, n.object.matrix);
        } else
          n.object.isOrthographicCamera ? (L(be * (n.object.right - n.object.left) / n.object.zoom / je.clientWidth, n.object.matrix), V(Ue * (n.object.top - n.object.bottom) / n.object.zoom / je.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    }();
    function Q($) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c /= $ : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function q($) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c *= $ : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function oe($, ge) {
      if (!n.zoomToCursor)
        return;
      I = !0;
      const be = n.domElement.getBoundingClientRect(), Ue = $ - be.left, je = ge - be.top, it = be.width, nt = be.height;
      E.x = Ue / it * 2 - 1, E.y = -(je / nt) * 2 + 1, w.set(E.x, E.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function le($) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, $));
    }
    function k($) {
      f.set($.clientX, $.clientY);
    }
    function X($) {
      oe($.clientX, $.clientX), A.set($.clientX, $.clientY);
    }
    function fe($) {
      m.set($.clientX, $.clientY);
    }
    function te($) {
      h.set($.clientX, $.clientY), d.subVectors(h, f).multiplyScalar(n.rotateSpeed);
      const ge = n.domElement;
      R(2 * Math.PI * d.x / ge.clientHeight), P(2 * Math.PI * d.y / ge.clientHeight), f.copy(h), n.update();
    }
    function j($) {
      v.set($.clientX, $.clientY), y.subVectors(v, A), y.y > 0 ? Q(D(y.y)) : y.y < 0 && q(D(y.y)), A.copy(v), n.update();
    }
    function Ae($) {
      _.set($.clientX, $.clientY), g.subVectors(_, m).multiplyScalar(n.panSpeed), U(g.x, g.y), m.copy(_), n.update();
    }
    function Y($) {
      oe($.clientX, $.clientY), $.deltaY < 0 ? q(D($.deltaY)) : $.deltaY > 0 && Q(D($.deltaY)), n.update();
    }
    function pe($) {
      let ge = !1;
      switch ($.code) {
        case n.keys.UP:
          $.ctrlKey || $.metaKey || $.shiftKey ? P(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(0, n.keyPanSpeed), ge = !0;
          break;
        case n.keys.BOTTOM:
          $.ctrlKey || $.metaKey || $.shiftKey ? P(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(0, -n.keyPanSpeed), ge = !0;
          break;
        case n.keys.LEFT:
          $.ctrlKey || $.metaKey || $.shiftKey ? R(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(n.keyPanSpeed, 0), ge = !0;
          break;
        case n.keys.RIGHT:
          $.ctrlKey || $.metaKey || $.shiftKey ? R(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : U(-n.keyPanSpeed, 0), ge = !0;
          break;
      }
      ge && ($.preventDefault(), n.update());
    }
    function me($) {
      if (C.length === 1)
        f.set($.pageX, $.pageY);
      else {
        const ge = Ze($), be = 0.5 * ($.pageX + ge.x), Ue = 0.5 * ($.pageY + ge.y);
        f.set(be, Ue);
      }
    }
    function re($) {
      if (C.length === 1)
        m.set($.pageX, $.pageY);
      else {
        const ge = Ze($), be = 0.5 * ($.pageX + ge.x), Ue = 0.5 * ($.pageY + ge.y);
        m.set(be, Ue);
      }
    }
    function ye($) {
      const ge = Ze($), be = $.pageX - ge.x, Ue = $.pageY - ge.y, je = Math.sqrt(be * be + Ue * Ue);
      A.set(0, je);
    }
    function ae($) {
      n.enableZoom && ye($), n.enablePan && re($);
    }
    function De($) {
      n.enableZoom && ye($), n.enableRotate && me($);
    }
    function Ee($) {
      if (C.length == 1)
        h.set($.pageX, $.pageY);
      else {
        const be = Ze($), Ue = 0.5 * ($.pageX + be.x), je = 0.5 * ($.pageY + be.y);
        h.set(Ue, je);
      }
      d.subVectors(h, f).multiplyScalar(n.rotateSpeed);
      const ge = n.domElement;
      R(2 * Math.PI * d.x / ge.clientHeight), P(2 * Math.PI * d.y / ge.clientHeight), f.copy(h);
    }
    function Ie($) {
      if (C.length === 1)
        _.set($.pageX, $.pageY);
      else {
        const ge = Ze($), be = 0.5 * ($.pageX + ge.x), Ue = 0.5 * ($.pageY + ge.y);
        _.set(be, Ue);
      }
      g.subVectors(_, m).multiplyScalar(n.panSpeed), U(g.x, g.y), m.copy(_);
    }
    function Ce($) {
      const ge = Ze($), be = $.pageX - ge.x, Ue = $.pageY - ge.y, je = Math.sqrt(be * be + Ue * Ue);
      v.set(0, je), y.set(0, Math.pow(v.y / A.y, n.zoomSpeed)), Q(y.y), A.copy(v);
      const it = ($.pageX + ge.x) * 0.5, nt = ($.pageY + ge.y) * 0.5;
      oe(it, nt);
    }
    function ze($) {
      n.enableZoom && Ce($), n.enablePan && Ie($);
    }
    function Fe($) {
      n.enableZoom && Ce($), n.enableRotate && Ee($);
    }
    function W($) {
      n.enabled !== !1 && (C.length === 0 && (n.domElement.setPointerCapture($.pointerId), n.domElement.addEventListener("pointermove", G), n.domElement.addEventListener("pointerup", se)), !He($) && ($e($), $.pointerType === "touch" ? Se($) : _e($)));
    }
    function G($) {
      n.enabled !== !1 && ($.pointerType === "touch" ? Ve($) : ve($));
    }
    function se($) {
      switch (Ne($), C.length) {
        case 0:
          n.domElement.releasePointerCapture($.pointerId), n.domElement.removeEventListener("pointermove", G), n.domElement.removeEventListener("pointerup", se), n.dispatchEvent(Sv), r = i.NONE;
          break;
        case 1:
          const ge = C[0], be = B[ge];
          Se({ pointerId: ge, pageX: be.x, pageY: be.y });
          break;
      }
    }
    function _e($) {
      let ge;
      switch ($.button) {
        case 0:
          ge = n.mouseButtons.LEFT;
          break;
        case 1:
          ge = n.mouseButtons.MIDDLE;
          break;
        case 2:
          ge = n.mouseButtons.RIGHT;
          break;
        default:
          ge = -1;
      }
      switch (ge) {
        case ts.DOLLY:
          if (n.enableZoom === !1)
            return;
          X($), r = i.DOLLY;
          break;
        case ts.ROTATE:
          if ($.ctrlKey || $.metaKey || $.shiftKey) {
            if (n.enablePan === !1)
              return;
            fe($), r = i.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            k($), r = i.ROTATE;
          }
          break;
        case ts.PAN:
          if ($.ctrlKey || $.metaKey || $.shiftKey) {
            if (n.enableRotate === !1)
              return;
            k($), r = i.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            fe($), r = i.PAN;
          }
          break;
        default:
          r = i.NONE;
      }
      r !== i.NONE && n.dispatchEvent(bm);
    }
    function ve($) {
      switch (r) {
        case i.ROTATE:
          if (n.enableRotate === !1)
            return;
          te($);
          break;
        case i.DOLLY:
          if (n.enableZoom === !1)
            return;
          j($);
          break;
        case i.PAN:
          if (n.enablePan === !1)
            return;
          Ae($);
          break;
      }
    }
    function ue($) {
      n.enabled === !1 || n.enableZoom === !1 || r !== i.NONE || ($.preventDefault(), n.dispatchEvent(bm), Y(Te($)), n.dispatchEvent(Sv));
    }
    function Te($) {
      const ge = $.deltaMode, be = {
        clientX: $.clientX,
        clientY: $.clientY,
        deltaY: $.deltaY
      };
      switch (ge) {
        case 1:
          be.deltaY *= 16;
          break;
        case 2:
          be.deltaY *= 100;
          break;
      }
      return $.ctrlKey && !T && (be.deltaY *= 10), be;
    }
    function Ge($) {
      $.key === "Control" && (T = !0, n.domElement.getRootNode().addEventListener("keyup", Pe, { passive: !0, capture: !0 }));
    }
    function Pe($) {
      $.key === "Control" && (T = !1, n.domElement.getRootNode().removeEventListener("keyup", Pe, { passive: !0, capture: !0 }));
    }
    function he($) {
      n.enabled === !1 || n.enablePan === !1 || pe($);
    }
    function Se($) {
      switch (Qe($), C.length) {
        case 1:
          switch (n.touches.ONE) {
            case ea.ROTATE:
              if (n.enableRotate === !1)
                return;
              me($), r = i.TOUCH_ROTATE;
              break;
            case ea.PAN:
              if (n.enablePan === !1)
                return;
              re($), r = i.TOUCH_PAN;
              break;
            default:
              r = i.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case ea.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              ae($), r = i.TOUCH_DOLLY_PAN;
              break;
            case ea.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              De($), r = i.TOUCH_DOLLY_ROTATE;
              break;
            default:
              r = i.NONE;
          }
          break;
        default:
          r = i.NONE;
      }
      r !== i.NONE && n.dispatchEvent(bm);
    }
    function Ve($) {
      switch (Qe($), r) {
        case i.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          Ee($), n.update();
          break;
        case i.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          Ie($), n.update();
          break;
        case i.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          ze($), n.update();
          break;
        case i.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          Fe($), n.update();
          break;
        default:
          r = i.NONE;
      }
    }
    function Ye($) {
      n.enabled !== !1 && $.preventDefault();
    }
    function $e($) {
      C.push($.pointerId);
    }
    function Ne($) {
      delete B[$.pointerId];
      for (let ge = 0; ge < C.length; ge++)
        if (C[ge] == $.pointerId) {
          C.splice(ge, 1);
          return;
        }
    }
    function He($) {
      for (let ge = 0; ge < C.length; ge++)
        if (C[ge] == $.pointerId)
          return !0;
      return !1;
    }
    function Qe($) {
      let ge = B[$.pointerId];
      ge === void 0 && (ge = new ke(), B[$.pointerId] = ge), ge.set($.pageX, $.pageY);
    }
    function Ze($) {
      const ge = $.pointerId === C[0] ? C[1] : C[0];
      return B[ge];
    }
    n.domElement.addEventListener("contextmenu", Ye), n.domElement.addEventListener("pointerdown", W), n.domElement.addEventListener("pointercancel", se), n.domElement.addEventListener("wheel", ue, { passive: !1 }), n.domElement.getRootNode().addEventListener("keydown", Ge, { passive: !0, capture: !0 }), this.update();
  }
};
const uF = (s) => ({ ref: s & /*ref*/
1 }), Iv = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function fF(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[8],
    Iv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      257) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? xt(
          t,
          /*$$scope*/
          i[8],
          r,
          uF
        ) : Et(
          /*$$scope*/
          i[8]
        ),
        Iv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function hF(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[5]
  ];
  let i = {
    $$slots: {
      default: [fF, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[7](e), e.$on(
    "change",
    /*invalidate*/
    s[3]
  ), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      33 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        32 && Kt(
          /*$$restProps*/
          r[5]
        )
      ]) : {};
      a & /*$$scope, ref*/
      257 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[7](null), J(e, r);
    }
  };
}
function dF(s, e, t) {
  const n = ["ref"];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e;
  const c = Er();
  lt(s, c, (y) => t(9, r = y));
  const u = (y) => y.isCamera, { renderer: f, invalidate: h } = un();
  if (!u(r))
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  const d = new cF(r, f.domElement), { start: m, stop: _ } = On(d.update, { autoStart: !1, autoInvalidate: !1 }), g = An();
  lt(s, g, (y) => t(1, a = y));
  const { orbitControls: A } = KA();
  A.set(d), Sn(() => A.set(void 0));
  function v(y) {
    Ut[y ? "unshift" : "push"](() => {
      a = y, g.set(a);
    });
  }
  return s.$$set = (y) => {
    e = We(We({}, e), rn(y)), t(5, i = ft(e, n)), "$$scope" in y && t(8, l = y.$$scope);
  }, s.$$.update = () => {
    i.autoRotate || i.enableDamping ? m() : _();
  }, [
    d,
    a,
    c,
    h,
    g,
    i,
    o,
    v,
    l
  ];
}
class pE extends Mt {
  constructor(e) {
    super(), Ct(this, e, dF, hF, _t, { ref: 0 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
St(pE, {}, ["default"], ["ref"], !0);
const vm = { type: "change" }, ym = { type: "start" }, xm = { type: "end" };
let pF = class extends Qr {
  constructor(e, t) {
    super();
    const n = this, i = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
    this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: ts.ROTATE, MIDDLE: ts.DOLLY, RIGHT: ts.PAN }, this.target = new H();
    const r = 1e-6, a = new H();
    let o = 1, l = i.NONE, c = i.NONE, u = 0, f = 0, h = 0;
    const d = new H(), m = new ke(), _ = new ke(), g = new H(), A = new ke(), v = new ke(), y = new ke(), w = new ke(), E = [], I = {};
    this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.up0 = this.object.up.clone(), this.zoom0 = this.object.zoom, this.handleResize = function() {
      const Y = n.domElement.getBoundingClientRect(), pe = n.domElement.ownerDocument.documentElement;
      n.screen.left = Y.left + window.pageXOffset - pe.clientLeft, n.screen.top = Y.top + window.pageYOffset - pe.clientTop, n.screen.width = Y.width, n.screen.height = Y.height;
    };
    const C = function() {
      const Y = new ke();
      return function(me, re) {
        return Y.set(
          (me - n.screen.left) / n.screen.width,
          (re - n.screen.top) / n.screen.height
        ), Y;
      };
    }(), B = function() {
      const Y = new ke();
      return function(me, re) {
        return Y.set(
          (me - n.screen.width * 0.5 - n.screen.left) / (n.screen.width * 0.5),
          (n.screen.height + 2 * (n.screen.top - re)) / n.screen.width
          // screen.width intentional
        ), Y;
      };
    }();
    this.rotateCamera = function() {
      const Y = new H(), pe = new en(), me = new H(), re = new H(), ye = new H(), ae = new H();
      return function() {
        ae.set(_.x - m.x, _.y - m.y, 0);
        let Ee = ae.length();
        Ee ? (d.copy(n.object.position).sub(n.target), me.copy(d).normalize(), re.copy(n.object.up).normalize(), ye.crossVectors(re, me).normalize(), re.setLength(_.y - m.y), ye.setLength(_.x - m.x), ae.copy(re.add(ye)), Y.crossVectors(ae, d).normalize(), Ee *= n.rotateSpeed, pe.setFromAxisAngle(Y, Ee), d.applyQuaternion(pe), n.object.up.applyQuaternion(pe), g.copy(Y), h = Ee) : !n.staticMoving && h && (h *= Math.sqrt(1 - n.dynamicDampingFactor), d.copy(n.object.position).sub(n.target), pe.setFromAxisAngle(g, h), d.applyQuaternion(pe), n.object.up.applyQuaternion(pe)), m.copy(_);
      };
    }(), this.zoomCamera = function() {
      let Y;
      l === i.TOUCH_ZOOM_PAN ? (Y = u / f, u = f, n.object.isPerspectiveCamera ? d.multiplyScalar(Y) : n.object.isOrthographicCamera ? (n.object.zoom = ls.clamp(n.object.zoom / Y, n.minZoom, n.maxZoom), o !== n.object.zoom && n.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (Y = 1 + (v.y - A.y) * n.zoomSpeed, Y !== 1 && Y > 0 && (n.object.isPerspectiveCamera ? d.multiplyScalar(Y) : n.object.isOrthographicCamera ? (n.object.zoom = ls.clamp(n.object.zoom / Y, n.minZoom, n.maxZoom), o !== n.object.zoom && n.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), n.staticMoving ? A.copy(v) : A.y += (v.y - A.y) * this.dynamicDampingFactor);
    }, this.panCamera = function() {
      const Y = new ke(), pe = new H(), me = new H();
      return function() {
        if (Y.copy(w).sub(y), Y.lengthSq()) {
          if (n.object.isOrthographicCamera) {
            const ye = (n.object.right - n.object.left) / n.object.zoom / n.domElement.clientWidth, ae = (n.object.top - n.object.bottom) / n.object.zoom / n.domElement.clientWidth;
            Y.x *= ye, Y.y *= ae;
          }
          Y.multiplyScalar(d.length() * n.panSpeed), me.copy(d).cross(n.object.up).setLength(Y.x), me.add(pe.copy(n.object.up).setLength(Y.y)), n.object.position.add(me), n.target.add(me), n.staticMoving ? y.copy(w) : y.add(Y.subVectors(w, y).multiplyScalar(n.dynamicDampingFactor));
        }
      };
    }(), this.checkDistances = function() {
      (!n.noZoom || !n.noPan) && (d.lengthSq() > n.maxDistance * n.maxDistance && (n.object.position.addVectors(n.target, d.setLength(n.maxDistance)), A.copy(v)), d.lengthSq() < n.minDistance * n.minDistance && (n.object.position.addVectors(n.target, d.setLength(n.minDistance)), A.copy(v)));
    }, this.update = function() {
      d.subVectors(n.object.position, n.target), n.noRotate || n.rotateCamera(), n.noZoom || n.zoomCamera(), n.noPan || n.panCamera(), n.object.position.addVectors(n.target, d), n.object.isPerspectiveCamera ? (n.checkDistances(), n.object.lookAt(n.target), a.distanceToSquared(n.object.position) > r && (n.dispatchEvent(vm), a.copy(n.object.position))) : n.object.isOrthographicCamera ? (n.object.lookAt(n.target), (a.distanceToSquared(n.object.position) > r || o !== n.object.zoom) && (n.dispatchEvent(vm), a.copy(n.object.position), o = n.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type");
    }, this.reset = function() {
      l = i.NONE, c = i.NONE, n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.up.copy(n.up0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), d.subVectors(n.object.position, n.target), n.object.lookAt(n.target), n.dispatchEvent(vm), a.copy(n.object.position), o = n.object.zoom;
    };
    function T(Y) {
      n.enabled !== !1 && (E.length === 0 && (n.domElement.setPointerCapture(Y.pointerId), n.domElement.addEventListener("pointermove", S), n.domElement.addEventListener("pointerup", D)), fe(Y), Y.pointerType === "touch" ? oe(Y) : V(Y));
    }
    function S(Y) {
      n.enabled !== !1 && (Y.pointerType === "touch" ? le(Y) : U(Y));
    }
    function D(Y) {
      n.enabled !== !1 && (Y.pointerType === "touch" ? k(Y) : Q(), te(Y), E.length === 0 && (n.domElement.releasePointerCapture(Y.pointerId), n.domElement.removeEventListener("pointermove", S), n.domElement.removeEventListener("pointerup", D)));
    }
    function R(Y) {
      te(Y);
    }
    function P(Y) {
      n.enabled !== !1 && (window.removeEventListener("keydown", P), c === i.NONE && (Y.code === n.keys[i.ROTATE] && !n.noRotate ? c = i.ROTATE : Y.code === n.keys[i.ZOOM] && !n.noZoom ? c = i.ZOOM : Y.code === n.keys[i.PAN] && !n.noPan && (c = i.PAN)));
    }
    function L() {
      n.enabled !== !1 && (c = i.NONE, window.addEventListener("keydown", P));
    }
    function V(Y) {
      if (l === i.NONE)
        switch (Y.button) {
          case n.mouseButtons.LEFT:
            l = i.ROTATE;
            break;
          case n.mouseButtons.MIDDLE:
            l = i.ZOOM;
            break;
          case n.mouseButtons.RIGHT:
            l = i.PAN;
            break;
        }
      const pe = c !== i.NONE ? c : l;
      pe === i.ROTATE && !n.noRotate ? (_.copy(B(Y.pageX, Y.pageY)), m.copy(_)) : pe === i.ZOOM && !n.noZoom ? (A.copy(C(Y.pageX, Y.pageY)), v.copy(A)) : pe === i.PAN && !n.noPan && (y.copy(C(Y.pageX, Y.pageY)), w.copy(y)), n.dispatchEvent(ym);
    }
    function U(Y) {
      const pe = c !== i.NONE ? c : l;
      pe === i.ROTATE && !n.noRotate ? (m.copy(_), _.copy(B(Y.pageX, Y.pageY))) : pe === i.ZOOM && !n.noZoom ? v.copy(C(Y.pageX, Y.pageY)) : pe === i.PAN && !n.noPan && w.copy(C(Y.pageX, Y.pageY));
    }
    function Q() {
      l = i.NONE, n.dispatchEvent(xm);
    }
    function q(Y) {
      if (n.enabled !== !1 && n.noZoom !== !0) {
        switch (Y.preventDefault(), Y.deltaMode) {
          case 2:
            A.y -= Y.deltaY * 0.025;
            break;
          case 1:
            A.y -= Y.deltaY * 0.01;
            break;
          default:
            A.y -= Y.deltaY * 25e-5;
            break;
        }
        n.dispatchEvent(ym), n.dispatchEvent(xm);
      }
    }
    function oe(Y) {
      switch (j(Y), E.length) {
        case 1:
          l = i.TOUCH_ROTATE, _.copy(B(E[0].pageX, E[0].pageY)), m.copy(_);
          break;
        default:
          l = i.TOUCH_ZOOM_PAN;
          const pe = E[0].pageX - E[1].pageX, me = E[0].pageY - E[1].pageY;
          f = u = Math.sqrt(pe * pe + me * me);
          const re = (E[0].pageX + E[1].pageX) / 2, ye = (E[0].pageY + E[1].pageY) / 2;
          y.copy(C(re, ye)), w.copy(y);
          break;
      }
      n.dispatchEvent(ym);
    }
    function le(Y) {
      switch (j(Y), E.length) {
        case 1:
          m.copy(_), _.copy(B(Y.pageX, Y.pageY));
          break;
        default:
          const pe = Ae(Y), me = Y.pageX - pe.x, re = Y.pageY - pe.y;
          f = Math.sqrt(me * me + re * re);
          const ye = (Y.pageX + pe.x) / 2, ae = (Y.pageY + pe.y) / 2;
          w.copy(C(ye, ae));
          break;
      }
    }
    function k(Y) {
      switch (E.length) {
        case 0:
          l = i.NONE;
          break;
        case 1:
          l = i.TOUCH_ROTATE, _.copy(B(Y.pageX, Y.pageY)), m.copy(_);
          break;
        case 2:
          l = i.TOUCH_ZOOM_PAN;
          for (let pe = 0; pe < E.length; pe++)
            if (E[pe].pointerId !== Y.pointerId) {
              const me = I[E[pe].pointerId];
              _.copy(B(me.x, me.y)), m.copy(_);
              break;
            }
          break;
      }
      n.dispatchEvent(xm);
    }
    function X(Y) {
      n.enabled !== !1 && Y.preventDefault();
    }
    function fe(Y) {
      E.push(Y);
    }
    function te(Y) {
      delete I[Y.pointerId];
      for (let pe = 0; pe < E.length; pe++)
        if (E[pe].pointerId == Y.pointerId) {
          E.splice(pe, 1);
          return;
        }
    }
    function j(Y) {
      let pe = I[Y.pointerId];
      pe === void 0 && (pe = new ke(), I[Y.pointerId] = pe), pe.set(Y.pageX, Y.pageY);
    }
    function Ae(Y) {
      const pe = Y.pointerId === E[0].pointerId ? E[1] : E[0];
      return I[pe.pointerId];
    }
    this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", X), n.domElement.removeEventListener("pointerdown", T), n.domElement.removeEventListener("pointercancel", R), n.domElement.removeEventListener("wheel", q), n.domElement.removeEventListener("pointermove", S), n.domElement.removeEventListener("pointerup", D), window.removeEventListener("keydown", P), window.removeEventListener("keyup", L);
    }, this.domElement.addEventListener("contextmenu", X), this.domElement.addEventListener("pointerdown", T), this.domElement.addEventListener("pointercancel", R), this.domElement.addEventListener("wheel", q, { passive: !1 }), window.addEventListener("keydown", P), window.addEventListener("keyup", L), this.handleResize(), this.update();
  }
};
const mF = (s) => ({ ref: s & /*ref*/
1 }), Tv = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function gF(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[8],
    Tv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      257) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? xt(
          t,
          /*$$scope*/
          i[8],
          r,
          mF
        ) : Et(
          /*$$scope*/
          i[8]
        ),
        Tv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function AF(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[5]
  ];
  let i = {
    $$slots: {
      default: [gF, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[7](e), e.$on(
    "change",
    /*invalidate*/
    s[3]
  ), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      33 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        32 && Kt(
          /*$$restProps*/
          r[5]
        )
      ]) : {};
      a & /*$$scope, ref*/
      257 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[7](null), J(e, r);
    }
  };
}
function _F(s, e, t) {
  const n = ["ref"];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e;
  const c = Er();
  lt(s, c, (A) => t(9, r = A));
  const u = (A) => A.isCamera, { renderer: f, invalidate: h } = un();
  if (!u(r))
    throw new Error("Parent missing: <TrackballControls> need to be a child of a <Camera>");
  const d = new pF(r, f.domElement);
  On(d.update, { autoInvalidate: !1 });
  const m = An();
  lt(s, m, (A) => t(1, a = A));
  const { trackballControls: _ } = KA();
  _.set(d), Sn(() => _.set(void 0));
  function g(A) {
    Ut[A ? "unshift" : "push"](() => {
      a = A, m.set(a);
    });
  }
  return s.$$set = (A) => {
    e = We(We({}, e), rn(A)), t(5, i = ft(e, n)), "$$scope" in A && t(8, l = A.$$scope);
  }, [
    d,
    a,
    c,
    h,
    m,
    i,
    o,
    g,
    l
  ];
}
class bF extends Mt {
  constructor(e) {
    super(), Ct(this, e, _F, AF, _t, { ref: 0 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
St(bF, {}, ["default"], ["ref"], !0);
const mE = (s) => `threlte-instanced-mesh-${s}`, vF = (s, e) => {
  const t = {
    instancedMesh: xn(s),
    addInstance(n) {
      t.instances.update((i) => (i.push(n), i));
    },
    removeInstance(n) {
      t.instances.update((i) => {
        const r = i.indexOf(n);
        return r > -1 && i.splice(r, 1), i;
      });
    },
    instances: xn([])
  };
  return xi(mE(e), t), t;
}, yF = (s) => {
  const e = wi(mE(s));
  if (!e)
    throw new Error(`No <InstancedMesh> component found for id ${s}`);
  return e;
};
function xF(s) {
  let e, t, n, i, r;
  e = new ee.InstancedBufferAttribute({
    props: {
      attach: "instanceMatrix",
      count: (
        /*matrices*/
        s[1].length / 16
      ),
      array: (
        /*matrices*/
        s[1]
      ),
      itemSize: 16,
      usage: Pl
    }
  }), n = new ee.InstancedBufferAttribute({
    props: {
      attach: "instanceColor",
      count: (
        /*colors*/
        s[2].length / 3
      ),
      array: (
        /*colors*/
        s[2]
      ),
      itemSize: 3,
      usage: Pl
    }
  });
  const a = (
    /*#slots*/
    s[10].default
  ), o = yt(
    a,
    s,
    /*$$scope*/
    s[9],
    null
  );
  return {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), o && o.c();
    },
    m(l, c) {
      K(e, l, c), we(l, t, c), K(n, l, c), we(l, i, c), o && o.m(l, c), r = !0;
    },
    p(l, [c]) {
      o && o.p && (!r || c & /*$$scope*/
      512) && wt(
        o,
        a,
        l,
        /*$$scope*/
        l[9],
        r ? xt(
          a,
          /*$$scope*/
          l[9],
          c,
          null
        ) : Et(
          /*$$scope*/
          l[9]
        ),
        null
      );
    },
    i(l) {
      r || (O(e.$$.fragment, l), O(n.$$.fragment, l), O(o, l), r = !0);
    },
    o(l) {
      N(e.$$.fragment, l), N(n.$$.fragment, l), N(o, l), r = !1;
    },
    d(l) {
      l && (xe(t), xe(i)), J(e, l), J(n, l), o && o.d(l);
    }
  };
}
function wF(s, e, t) {
  let n, { $$slots: i = {}, $$scope: r } = e, { instancedMesh: a } = e, { id: o } = e, { limit: l } = e, { range: c } = e, { update: u } = e;
  const { instances: f } = vF(a, o);
  lt(s, f, (E) => t(8, n = E));
  const h = new st(), d = new Float32Array(l * 16);
  for (let E = 0; E < l; E++)
    h.identity().toArray(d, E * 16);
  const m = new Float32Array(l * 3).fill(1), _ = new st(), g = new st(), A = new H(), v = new en(), y = new H();
  let w = !1;
  return On(() => {
    if (a.updateMatrix(), u || !w) {
      a.updateMatrixWorld(), _.copy(a.matrixWorld).invert(), a.instanceColor && t(3, a.instanceColor.needsUpdate = !0, a), t(3, a.instanceMatrix.needsUpdate = !0, a);
      for (let E = 0; E < f.current.length; E++) {
        const I = f.current[E];
        I.matrixWorld.decompose(A, v, y), g.compose(A, v, y).premultiply(_), g.toArray(d, E * 16), I.color.toArray(m, E * 3);
      }
      w = !0;
    }
  }), s.$$set = (E) => {
    "instancedMesh" in E && t(3, a = E.instancedMesh), "id" in E && t(4, o = E.id), "limit" in E && t(5, l = E.limit), "range" in E && t(6, c = E.range), "update" in E && t(7, u = E.update), "$$scope" in E && t(9, r = E.$$scope);
  }, s.$$.update = () => {
    if (s.$$.dirty & /*limit, range, $instances, instancedMesh*/
    360) {
      const E = Math.min(l, c !== void 0 ? c : l, n.length);
      t(3, a.count = E, a), Tg >= 159 ? (a.instanceMatrix.clearUpdateRanges(), a.instanceMatrix.addUpdateRange(0, E * 16)) : t(3, a.instanceMatrix.updateRange.count = E * 16, a), a.instanceColor && (Tg >= 159 ? (a.instanceColor.clearUpdateRanges(), a.instanceColor.addUpdateRange(0, E * 3)) : t(3, a.instanceColor.updateRange.count = E * 3, a));
    }
  }, [
    f,
    d,
    m,
    a,
    o,
    l,
    c,
    u,
    n,
    r,
    i
  ];
}
class gE extends Mt {
  constructor(e) {
    super(), Ct(this, e, wF, xF, _t, {
      instancedMesh: 3,
      id: 4,
      limit: 5,
      range: 6,
      update: 7
    });
  }
  get instancedMesh() {
    return this.$$.ctx[3];
  }
  set instancedMesh(e) {
    this.$$set({ instancedMesh: e }), ne();
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get limit() {
    return this.$$.ctx[5];
  }
  set limit(e) {
    this.$$set({ limit: e }), ne();
  }
  get range() {
    return this.$$.ctx[6];
  }
  set range(e) {
    this.$$set({ range: e }), ne();
  }
  get update() {
    return this.$$.ctx[7];
  }
  set update(e) {
    this.$$set({ update: e }), ne();
  }
}
St(gE, { instancedMesh: {}, id: {}, limit: {}, range: {}, update: {} }, ["default"], [], !0);
const EF = (s) => ({}), Bv = (s) => ({ ref: (
  /*ref*/
  s[4]
) });
function CF(s) {
  let e;
  const t = (
    /*#slots*/
    s[9].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[11],
    Bv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      2048) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[11],
        e ? xt(
          t,
          /*$$scope*/
          i[11],
          r,
          EF
        ) : Et(
          /*$$scope*/
          i[11]
        ),
        Bv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function SF(s) {
  let e, t;
  return e = new gE({
    props: {
      instancedMesh: (
        /*ref*/
        s[4]
      ),
      id: (
        /*id*/
        s[0]
      ),
      limit: (
        /*limit*/
        s[1]
      ),
      range: (
        /*range*/
        s[2]
      ),
      update: (
        /*update*/
        s[3]
      ),
      $$slots: { default: [CF] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*id*/
      1 && (r.id = /*id*/
      n[0]), i & /*limit*/
      2 && (r.limit = /*limit*/
      n[1]), i & /*range*/
      4 && (r.range = /*range*/
      n[2]), i & /*update*/
      8 && (r.update = /*update*/
      n[3]), i & /*$$scope*/
      2048 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function MF(s) {
  let e, t, n;
  const i = [
    { is: (
      /*ref*/
      s[4]
    ) },
    { raycast: IF },
    { matrixAutoUpdate: !1 },
    { args: (
      /*args*/
      s[7]
    ) },
    /*$$restProps*/
    s[8]
  ];
  function r(o) {
    s[10](o);
  }
  let a = {
    $$slots: { default: [SF] },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < i.length; o += 1)
    a = We(a, i[o]);
  return (
    /*$dispatchingComponent*/
    s[5] !== void 0 && (a.bind = /*$dispatchingComponent*/
    s[5]), e = new ee({ props: a }), Ut.push(() => ar(e, "bind", r)), {
      c() {
        Z(e.$$.fragment);
      },
      m(o, l) {
        K(e, o, l), n = !0;
      },
      p(o, [l]) {
        const c = l & /*ref, args, $$restProps*/
        400 ? jt(i, [
          l & /*ref*/
          16 && { is: (
            /*ref*/
            o[4]
          ) },
          i[1],
          i[2],
          l & /*args*/
          128 && { args: (
            /*args*/
            o[7]
          ) },
          l & /*$$restProps*/
          256 && Kt(
            /*$$restProps*/
            o[8]
          )
        ]) : {};
        l & /*$$scope, id, limit, range, update*/
        2063 && (c.$$scope = { dirty: l, ctx: o }), !t && l & /*$dispatchingComponent*/
        32 && (t = !0, c.bind = /*$dispatchingComponent*/
        o[5], or(() => t = !1)), e.$set(c);
      },
      i(o) {
        n || (O(e.$$.fragment, o), n = !0);
      },
      o(o) {
        N(e.$$.fragment, o), n = !1;
      },
      d(o) {
        J(e, o);
      }
    }
  );
}
const IF = () => null;
function TF(s, e, t) {
  const n = ["id", "limit", "range", "update", "ref"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { id: l = "default" } = e, { limit: c = 1e3 } = e, { range: u = 1e3 } = e, { update: f = !0 } = e;
  const h = new Zl(null, null, 0), d = An();
  lt(s, d, (g) => t(5, r = g));
  const m = [null, null, 0];
  function _(g) {
    r = g, d.set(r);
  }
  return s.$$set = (g) => {
    e = We(We({}, e), rn(g)), t(8, i = ft(e, n)), "id" in g && t(0, l = g.id), "limit" in g && t(1, c = g.limit), "range" in g && t(2, u = g.range), "update" in g && t(3, f = g.update), "$$scope" in g && t(11, o = g.$$scope);
  }, [
    l,
    c,
    u,
    f,
    h,
    r,
    d,
    m,
    i,
    a,
    _,
    o
  ];
}
class AE extends Mt {
  constructor(e) {
    super(), Ct(this, e, TF, MF, _t, {
      id: 0,
      limit: 1,
      range: 2,
      update: 3,
      ref: 4
    });
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get limit() {
    return this.$$.ctx[1];
  }
  set limit(e) {
    this.$$set({ limit: e }), ne();
  }
  get range() {
    return this.$$.ctx[2];
  }
  set range(e) {
    this.$$set({ range: e }), ne();
  }
  get update() {
    return this.$$.ctx[3];
  }
  set update(e) {
    this.$$set({ update: e }), ne();
  }
  get ref() {
    return this.$$.ctx[4];
  }
}
St(AE, { id: {}, limit: {}, range: {}, update: { type: "Boolean" } }, ["default"], ["ref"], !0);
const Pv = new st(), Rv = new st(), ih = [], kc = new tt(), BF = (s) => s.isMaterial;
class PF extends Xn {
  constructor(t, n) {
    super();
    qt(this, "color");
    qt(this, "instancedMesh");
    qt(this, "instances");
    this.color = new Je("white"), this.instancedMesh = t, this.instances = n;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var t;
    return (t = this.instancedMesh.current) == null ? void 0 : t.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(t, n) {
    var o;
    const i = this.instancedMesh.current;
    if (!i || !i.geometry || !i.material)
      return;
    kc.geometry = i.geometry;
    const r = i.matrixWorld, a = this.instances.current.indexOf(this);
    if (!(a === -1 || a > i.count)) {
      i.getMatrixAt(a, Pv), Rv.multiplyMatrices(r, Pv), kc.matrixWorld = Rv, BF(i.material) ? kc.material.side = i.material.side : kc.material.side = ((o = i.material[0]) == null ? void 0 : o.side) ?? Hi, kc.raycast(t, ih);
      for (let l = 0, c = ih.length; l < c; l++) {
        const u = ih[l];
        u.instanceId = a, u.object = this, n.push(u);
      }
      ih.length = 0;
    }
  }
}
const RF = (s) => ({}), Dv = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function DF(s) {
  let e;
  const t = (
    /*#slots*/
    s[5].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    Dv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      128) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          RF
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        Dv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function LF(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [DF] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[6](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope*/
      128 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[6](null), J(e, r);
    }
  };
}
function kF(s, e, t) {
  const n = ["id", "ref"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { id: l = "default" } = e;
  const { addInstance: c, removeInstance: u, instancedMesh: f, instances: h } = yF(l), d = new PF(f, h);
  c(d), Sn(() => {
    u(d);
  });
  const m = An();
  lt(s, m, (g) => t(1, r = g));
  function _(g) {
    Ut[g ? "unshift" : "push"](() => {
      r = g, m.set(r);
    });
  }
  return s.$$set = (g) => {
    e = We(We({}, e), rn(g)), t(3, i = ft(e, n)), "id" in g && t(4, l = g.id), "$$scope" in g && t(7, o = g.$$scope);
  }, [
    d,
    r,
    m,
    i,
    l,
    a,
    _,
    o
  ];
}
class _E extends Mt {
  constructor(e) {
    super(), Ct(this, e, kF, LF, _t, { id: 4, ref: 0 });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
St(_E, { id: {} }, ["default"], ["ref"], !0);
function UF(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      256) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? xt(
          t,
          /*$$scope*/
          i[8],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[8]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function FF(s) {
  let e, t;
  const n = [
    { geometry: (
      /*mesh*/
      s[2].geometry
    ) },
    { material: (
      /*mesh*/
      s[2].material
    ) },
    { id: (
      /*mesh*/
      s[2].uuid
    ) },
    /*$$restProps*/
    s[4]
  ];
  let i = {
    $$slots: { default: [NF] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new AE({ props: i }), s[7](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*mesh, $$restProps*/
      20 ? jt(n, [
        a & /*mesh*/
        4 && { geometry: (
          /*mesh*/
          r[2].geometry
        ) },
        a & /*mesh*/
        4 && { material: (
          /*mesh*/
          r[2].material
        ) },
        a & /*mesh*/
        4 && { id: (
          /*mesh*/
          r[2].uuid
        ) },
        a & /*$$restProps*/
        16 && Kt(
          /*$$restProps*/
          r[4]
        )
      ]) : {};
      a & /*$$scope*/
      256 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[7](null), J(e, r);
    }
  };
}
function OF(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      256) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? xt(
          t,
          /*$$scope*/
          i[8],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[8]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function NF(s) {
  let e, t;
  return e = new JA({
    props: {
      meshes: (
        /*copiedArray*/
        s[1]
      ),
      $$slots: { default: [OF] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      256 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function GF(s) {
  let e, t, n, i;
  const r = [FF, UF], a = [];
  function o(l, c) {
    return (
      /*mesh*/
      l[2] ? 0 : 1
    );
  }
  return e = o(s), t = a[e] = r[e](s), {
    c() {
      t.c(), n = ji();
    },
    m(l, c) {
      a[e].m(l, c), we(l, n, c), i = !0;
    },
    p(l, [c]) {
      t.p(l, c);
    },
    i(l) {
      i || (O(t), i = !0);
    },
    o(l) {
      N(t), i = !1;
    },
    d(l) {
      l && xe(n), a[e].d(l);
    }
  };
}
function QF(s, e, t) {
  const n = ["meshes"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { meshes: l } = e;
  const c = [...l], u = c.pop(), f = An();
  lt(s, f, (d) => t(0, r = d));
  function h(d) {
    Ut[d ? "unshift" : "push"](() => {
      r = d, f.set(r);
    });
  }
  return s.$$set = (d) => {
    e = We(We({}, e), rn(d)), t(4, i = ft(e, n)), "meshes" in d && t(5, l = d.meshes), "$$scope" in d && t(8, o = d.$$scope);
  }, [
    r,
    c,
    u,
    f,
    i,
    l,
    a,
    h,
    o
  ];
}
class JA extends Mt {
  constructor(e) {
    super(), Ct(this, e, QF, GF, _t, { meshes: 5 });
  }
  get meshes() {
    return this.$$.ctx[5];
  }
  set meshes(e) {
    this.$$set({ meshes: e }), ne();
  }
}
St(JA, { meshes: {} }, ["default"], [], !0);
const zF = (s) => ({ components: s & /*components*/
2 }), Lv = (s) => ({ components: (
  /*components*/
  s[1]
) });
function $F(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[9],
    Lv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, components*/
      514) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? xt(
          t,
          /*$$scope*/
          i[9],
          r,
          zF
        ) : Et(
          /*$$scope*/
          i[9]
        ),
        Lv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function VF(s) {
  let e, t;
  const n = [
    { meshes: (
      /*filteredMeshesArray*/
      s[0]
    ) },
    /*$$restProps*/
    s[4]
  ];
  let i = {
    $$slots: { default: [$F] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new JA({ props: i }), s[8](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*filteredMeshesArray, $$restProps*/
      17 ? jt(n, [
        a & /*filteredMeshesArray*/
        1 && { meshes: (
          /*filteredMeshesArray*/
          r[0]
        ) },
        a & /*$$restProps*/
        16 && Kt(
          /*$$restProps*/
          r[4]
        )
      ]) : {};
      a & /*$$scope, components*/
      514 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), J(e, r);
    }
  };
}
function HF(s, e, t) {
  let n, i, r;
  const a = ["meshes"];
  let o = ft(e, a), l, { $$slots: c = {}, $$scope: u } = e, { meshes: f } = e;
  const h = (A) => new Proxy(
    _E,
    {
      construct(v, y) {
        const w = {
          ...y[0],
          props: { ...y[0].props, id: A }
        };
        return new v(w);
      }
    }
  ), d = (A) => A.filter((v) => v.isMesh).map((v) => h(v.uuid)), m = (A) => Object.entries(A).reduce(
    (v, [y, w]) => (w.isMesh && (v[y] = h(w.uuid)), v),
    {}
  ), _ = An();
  lt(s, _, (A) => t(2, l = A));
  function g(A) {
    Ut[A ? "unshift" : "push"](() => {
      l = A, _.set(l);
    });
  }
  return s.$$set = (A) => {
    e = We(We({}, e), rn(A)), t(4, o = ft(e, a)), "meshes" in A && t(5, f = A.meshes), "$$scope" in A && t(9, u = A.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*meshes*/
    32 && t(1, n = Array.isArray(f) ? d(f) : m(f)), s.$$.dirty & /*meshes*/
    32 && t(6, i = Array.isArray(f) ? f : Object.values(f)), s.$$.dirty & /*meshesArray*/
    64 && t(0, r = i.filter((A) => A.isMesh));
  }, [
    r,
    n,
    l,
    _,
    o,
    f,
    i,
    c,
    g,
    u
  ];
}
class jF extends Mt {
  constructor(e) {
    super(), Ct(this, e, HF, VF, _t, { meshes: 5 });
  }
  get meshes() {
    return this.$$.ctx[5];
  }
  set meshes(e) {
    this.$$set({ meshes: e }), ne();
  }
}
St(jF, { meshes: {} }, ["default"], [], !0);
function WF(s, e, t) {
  let n;
  const { renderer: i, camera: r, scene: a } = un();
  let { size: o = 25 } = e, { focus: l = 0 } = e, { samples: c = 10 } = e;
  const u = gt.shadowmap_pars_fragment, f = () => {
    gt.shadowmap_pars_fragment = u.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
` + n).replace("#if defined( SHADOWMAP_TYPE_PCF )", `
return PCSS(shadowMap, shadowCoord);
#if defined( SHADOWMAP_TYPE_PCF )`), h();
  }, h = () => {
    a.traverse((d) => {
      var _, g;
      const m = d;
      m.material && (i == null || i.properties.remove(m.material), (g = (_ = m.material).dispose) == null || g.call(_));
    }), i != null && i.info.programs && (i.info.programs.length = 0), i == null || i.compile(a, r.current);
  };
  return Sn(() => {
    gt.shadowmap_pars_fragment = u, h();
  }), s.$$set = (d) => {
    "size" in d && t(0, o = d.size), "focus" in d && t(1, l = d.focus), "samples" in d && t(2, c = d.samples);
  }, s.$$.update = () => {
    s.$$.dirty & /*size, focus, samples*/
    7 && t(3, n = `
		#define PENUMBRA_FILTER_SIZE float(${o})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${l});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${c}; i ++) {
				offset = (vogelDiskSample(j, ${c}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${c}; i++) {
				vogelSample = vogelDiskSample(j, ${c}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${o}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${c}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`), s.$$.dirty & /*pcss*/
    8 && f();
  }, [o, l, c, n];
}
class qF extends Mt {
  constructor(e) {
    super(), Ct(this, e, WF, null, _t, { size: 0, focus: 1, samples: 2 });
  }
  get size() {
    return this.$$.ctx[0];
  }
  set size(e) {
    this.$$set({ size: e }), ne();
  }
  get focus() {
    return this.$$.ctx[1];
  }
  set focus(e) {
    this.$$set({ focus: e }), ne();
  }
  get samples() {
    return this.$$.ctx[2];
  }
  set samples(e) {
    this.$$set({ samples: e }), ne();
  }
}
St(qF, { size: {}, focus: {}, samples: {} }, [], [], !0);
const XF = (s) => ({}), kv = (s) => ({ ref: (
  /*geometry*/
  s[1]
) });
function YF(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[9],
    kv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? xt(
          t,
          /*$$scope*/
          i[9],
          r,
          XF
        ) : Et(
          /*$$scope*/
          i[9]
        ),
        kv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function KF(s) {
  let e, t;
  const n = [
    { is: (
      /*geometry*/
      s[1]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [YF] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[8](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*geometry, $$restProps*/
      10 ? jt(n, [
        a & /*geometry*/
        2 && { is: (
          /*geometry*/
          r[1]
        ) },
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope*/
      512 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), J(e, r);
    }
  };
}
function JF(s, e, t) {
  const n = ["points", "shape", "shapeFunction"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { points: l = [] } = e, { shape: c = "none" } = e, { shapeFunction: u = (T) => 1 } = e, f = l.length;
  const { invalidate: h } = un(), d = new Rt(new Float32Array(f * 6), 3), m = new Rt(new Float32Array(f * 6), 3), _ = new Rt(new Float32Array(f * 6), 3), g = new Rt(new Float32Array(f * 2), 1), A = new Rt(new Float32Array(f * 2), 1), v = new Rt(new Float32Array(f * 2), 1), y = new Rt(new Float32Array(f * 4), 2), w = new Rt(new Uint16Array(f * 6), 1);
  c === "taper" && (u = (T) => 1 * Math.pow(4 * T * (1 - T), 1));
  for (let T = 0, S = 0, D = 0, R = 0; T < f; T += 1, S += 2, D += 4, R += 6) {
    g.setX(S, T / l.length), g.setX(S + 1, T / l.length), A.setX(S, 1), A.setX(S + 1, -1);
    const P = c === "none" ? 1 : u(T / (f - 1));
    if (v.setX(S, P), v.setX(S + 1, P), y.setXYZW(D, T / (f - 1), 0, T / (f - 1), 1), T < f - 1) {
      const L = T * 2;
      w.setX(R + 0, L + 0), w.setX(R + 1, L + 1), w.setX(R + 2, L + 2), w.setX(R + 3, L + 2), w.setX(R + 4, L + 1), w.setX(R + 5, L + 3);
    }
  }
  const E = new Dt();
  E.setAttribute("position", d), E.setAttribute("previous", m), E.setAttribute("next", _), E.setAttribute("counters", g), E.setAttribute("side", A), E.setAttribute("width", v), E.setAttribute("uv", y), E.setIndex(w);
  const I = (T) => {
    if (T.length === 0 || T.length !== f)
      return;
    let S = 0, D = 0, R = 0;
    const P = T[0];
    m.setXYZ(D, P.x, P.y, P.z), D += 1, m.setXYZ(D, P.x, P.y, P.z), D += 1;
    for (let V = 0; V < f; V++) {
      const U = T[V];
      d.setXYZ(S, U.x, U.y, U.z), S += 1, d.setXYZ(S, U.x, U.y, U.z), S += 1, V < f - 1 && (m.setXYZ(D, U.x, U.y, U.z), D += 1, m.setXYZ(D, U.x, U.y, U.z), D += 1), V > 0 && V + 1 <= f && (_.setXYZ(R, U.x, U.y, U.z), R += 1, _.setXYZ(R, U.x, U.y, U.z), R += 1);
    }
    const L = T[f - 1];
    _.setXYZ(R, L.x, L.y, L.z), R += 1, _.setXYZ(R, L.x, L.y, L.z), R += 1, d.needsUpdate = !0, m.needsUpdate = !0, _.needsUpdate = !0, E.computeBoundingSphere(), h();
  }, C = An();
  lt(s, C, (T) => t(0, r = T));
  function B(T) {
    Ut[T ? "unshift" : "push"](() => {
      r = T, C.set(r);
    });
  }
  return s.$$set = (T) => {
    e = We(We({}, e), rn(T)), t(3, i = ft(e, n)), "points" in T && t(5, l = T.points), "shape" in T && t(6, c = T.shape), "shapeFunction" in T && t(4, u = T.shapeFunction), "$$scope" in T && t(9, o = T.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*points*/
    32 && I(l);
  }, [
    r,
    E,
    C,
    i,
    u,
    l,
    c,
    a,
    B,
    o
  ];
}
class ZF extends Mt {
  constructor(e) {
    super(), Ct(this, e, JF, KF, _t, { points: 5, shape: 6, shapeFunction: 4 });
  }
  get points() {
    return this.$$.ctx[5];
  }
  set points(e) {
    this.$$set({ points: e }), ne();
  }
  get shape() {
    return this.$$.ctx[6];
  }
  set shape(e) {
    this.$$set({ shape: e }), ne();
  }
  get shapeFunction() {
    return this.$$.ctx[4];
  }
  set shapeFunction(e) {
    this.$$set({ shapeFunction: e }), ne();
  }
}
St(ZF, { points: {}, shape: {}, shapeFunction: {} }, ["default"], [], !0);
const eO = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

void main()	{
	#include <logdepthbuf_fragment>
	#include <${va < 154 ? "encodings_fragment" : "colorspace_fragment"}>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = LinearTosRGB(c);
}
`, tO = `
    ${gt.logdepthbuf_pars_vertex}
    ${gt.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${gt.logdepthbuf_vertex}
        ${gt.fog_vertex}
    }
`, nO = (s) => ({}), Uv = (s) => ({ ref: (
  /*material*/
  s[2]
) });
function iO(s) {
  let e;
  const t = (
    /*#slots*/
    s[16].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[18],
    Uv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      262144) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[18],
        e ? xt(
          t,
          /*$$scope*/
          i[18],
          r,
          nO
        ) : Et(
          /*$$scope*/
          i[18]
        ),
        Uv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function rO(s) {
  let e, t;
  const n = [
    { is: (
      /*material*/
      s[2]
    ) },
    /*$$restProps*/
    s[4],
    { fragmentShader: eO },
    { vertexShader: tO }
  ];
  let i = {
    $$slots: { default: [iO] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[17](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*material, $$restProps*/
      20 ? jt(n, [
        a & /*material*/
        4 && { is: (
          /*material*/
          r[2]
        ) },
        a & /*$$restProps*/
        16 && Kt(
          /*$$restProps*/
          r[4]
        ),
        n[2],
        n[3]
      ]) : {};
      a & /*$$scope*/
      262144 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[17](null), J(e, r);
    }
  };
}
function sO(s, e, t) {
  const n = [
    "opacity",
    "color",
    "dashOffset",
    "dashArray",
    "dashRatio",
    "attenuate",
    "width",
    "scaleDown",
    "alphaMap"
  ];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e, { opacity: c = 1 } = e, { color: u = "#ffffff" } = e, { dashOffset: f = 0 } = e, { dashArray: h = 0 } = e, { dashRatio: d = 0 } = e, { attenuate: m = !0 } = e, { width: _ = 1 } = e, { scaleDown: g = 0 } = e, { alphaMap: A = void 0 } = e, { invalidate: v, size: y } = un();
  lt(s, y, (B) => t(15, r = B));
  const w = {
    lineWidth: { value: _ },
    color: { value: new Je(u) },
    opacity: { value: c },
    resolution: { value: new ke(1, 1) },
    sizeAttenuation: { value: m ? 1 : 0 },
    dashArray: { value: h },
    dashOffset: { value: f },
    dashRatio: { value: d },
    useDash: { value: h > 0 ? 1 : 0 },
    scaleDown: { value: g / 10 },
    alphaTest: { value: 0 },
    alphaMap: { value: A },
    useAlphaMap: { value: A ? 1 : 0 }
  }, E = new Hn({ uniforms: w }), I = An();
  lt(s, I, (B) => t(0, a = B));
  function C(B) {
    Ut[B ? "unshift" : "push"](() => {
      a = B, I.set(a);
    });
  }
  return s.$$set = (B) => {
    e = We(We({}, e), rn(B)), t(4, i = ft(e, n)), "opacity" in B && t(5, c = B.opacity), "color" in B && t(6, u = B.color), "dashOffset" in B && t(7, f = B.dashOffset), "dashArray" in B && t(8, h = B.dashArray), "dashRatio" in B && t(9, d = B.dashRatio), "attenuate" in B && t(10, m = B.attenuate), "width" in B && t(11, _ = B.width), "scaleDown" in B && t(12, g = B.scaleDown), "alphaMap" in B && t(13, A = B.alphaMap), "$$scope" in B && t(18, l = B.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*dashRatio, dashArray, dashOffset, width, opacity, uniforms, color*/
    19424 && (t(14, w.dashRatio.value = d, w), t(14, w.dashArray.value = h, w), t(14, w.dashOffset.value = f, w), t(14, w.lineWidth.value = _, w), t(14, w.opacity.value = c, w), w.color.value.set(u), v()), s.$$.dirty & /*uniforms, $size*/
    49152 && (w.resolution.value.set(r.width, r.height), v());
  }, [
    a,
    y,
    E,
    I,
    i,
    c,
    u,
    f,
    h,
    d,
    m,
    _,
    g,
    A,
    w,
    r,
    o,
    C,
    l
  ];
}
class oO extends Mt {
  constructor(e) {
    super(), Ct(this, e, sO, rO, _t, {
      opacity: 5,
      color: 6,
      dashOffset: 7,
      dashArray: 8,
      dashRatio: 9,
      attenuate: 10,
      width: 11,
      scaleDown: 12,
      alphaMap: 13
    });
  }
  get opacity() {
    return this.$$.ctx[5];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), ne();
  }
  get color() {
    return this.$$.ctx[6];
  }
  set color(e) {
    this.$$set({ color: e }), ne();
  }
  get dashOffset() {
    return this.$$.ctx[7];
  }
  set dashOffset(e) {
    this.$$set({ dashOffset: e }), ne();
  }
  get dashArray() {
    return this.$$.ctx[8];
  }
  set dashArray(e) {
    this.$$set({ dashArray: e }), ne();
  }
  get dashRatio() {
    return this.$$.ctx[9];
  }
  set dashRatio(e) {
    this.$$set({ dashRatio: e }), ne();
  }
  get attenuate() {
    return this.$$.ctx[10];
  }
  set attenuate(e) {
    this.$$set({ attenuate: e }), ne();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(e) {
    this.$$set({ width: e }), ne();
  }
  get scaleDown() {
    return this.$$.ctx[12];
  }
  set scaleDown(e) {
    this.$$set({ scaleDown: e }), ne();
  }
  get alphaMap() {
    return this.$$.ctx[13];
  }
  set alphaMap(e) {
    this.$$set({ alphaMap: e }), ne();
  }
}
St(oO, { opacity: {}, color: {}, dashOffset: {}, dashArray: {}, dashRatio: {}, attenuate: { type: "Boolean" }, width: {}, scaleDown: {}, alphaMap: {} }, ["default"], [], !0);
class Fd extends tt {
  constructor() {
    const e = Fd.SkyShader, t = new Hn({
      name: e.name,
      uniforms: ql.clone(e.uniforms),
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      side: Kn,
      depthWrite: !1
    });
    super(new Pn(1, 1, 1), t), this.isSky = !0;
  }
}
Fd.SkyShader = {
  name: "SkyShader",
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new H() },
    up: { value: new H(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const aO = (s) => ({ renderTarget: s & /*renderTarget*/
1 }), Fv = (s) => ({
  sunPosition: (
    /*sunPosition*/
    s[2]
  ),
  renderTarget: (
    /*renderTarget*/
    s[0]
  )
});
function lO(s) {
  let e;
  const t = (
    /*#slots*/
    s[13].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[14],
    Fv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, renderTarget*/
      16385) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[14],
        e ? xt(
          t,
          /*$$scope*/
          i[14],
          r,
          aO
        ) : Et(
          /*$$scope*/
          i[14]
        ),
        Fv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function cO(s) {
  let e, t;
  return e = new ee({
    props: {
      is: (
        /*sky*/
        s[1]
      ),
      $$slots: { default: [lO] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, [i]) {
      const r = {};
      i & /*$$scope, renderTarget*/
      16385 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function uO(s, e, t) {
  let { $$slots: n = {}, $$scope: i } = e, { scale: r = 1e3 } = e, { turbidity: a = 10 } = e, { rayleigh: o = 3 } = e, { mieCoefficient: l = 5e-3 } = e, { mieDirectionalG: c = 0.7 } = e, { elevation: u = 2 } = e, { azimuth: f = 180 } = e, { setEnvironment: h = !0 } = e, { cubeMapSize: d = 128 } = e, { webGLRenderTargetOptions: m = {} } = e;
  const _ = new Fd(), g = new H(), A = _.material.uniforms, { renderer: v, scene: y, invalidate: w } = un();
  let E, I;
  const C = () => {
    t(0, E = new bA(
      d,
      {
        type: Ri,
        generateMipmaps: !0,
        minFilter: Yi,
        ...m
      }
    )), I = new _A(1, 1.1, E);
  }, B = y.environment, { start: T, stop: S } = On(
    () => {
      _.scale.setScalar(r), A.turbidity.value = a, A.rayleigh.value = o, A.mieCoefficient.value = l, A.mieDirectionalG.value = c;
      const D = ls.degToRad(90 - u), R = ls.degToRad(f);
      g.setFromSphericalCoords(1, D, R), A.sunPosition.value.copy(g), h && ((!E || !I) && C(), I == null || I.update(v, _)), w(), S();
    },
    { autoStart: !1, autoInvalidate: !1 }
  );
  return Sn(() => {
    _.material.dispose(), y.environment = B;
    try {
      E == null || E.dispose();
    } catch (D) {
      console.warn("Could not dispose renderTarget:", D);
    }
  }), s.$$set = (D) => {
    "scale" in D && t(3, r = D.scale), "turbidity" in D && t(4, a = D.turbidity), "rayleigh" in D && t(5, o = D.rayleigh), "mieCoefficient" in D && t(6, l = D.mieCoefficient), "mieDirectionalG" in D && t(7, c = D.mieDirectionalG), "elevation" in D && t(8, u = D.elevation), "azimuth" in D && t(9, f = D.azimuth), "setEnvironment" in D && t(10, h = D.setEnvironment), "cubeMapSize" in D && t(11, d = D.cubeMapSize), "webGLRenderTargetOptions" in D && t(12, m = D.webGLRenderTargetOptions), "$$scope" in D && t(14, i = D.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*setEnvironment, renderTarget*/
    1025 && (h && E ? (y.environment = E.texture, w()) : h || (y.environment = B, w())), s.$$.dirty & /*scale, turbidity, rayleigh, mieCoefficient, mieDirectionalG, elevation, azimuth*/
    1016 && T();
  }, [
    E,
    _,
    g,
    r,
    a,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    n,
    i
  ];
}
class fO extends Mt {
  constructor(e) {
    super(), Ct(this, e, uO, cO, _t, {
      scale: 3,
      turbidity: 4,
      rayleigh: 5,
      mieCoefficient: 6,
      mieDirectionalG: 7,
      elevation: 8,
      azimuth: 9,
      setEnvironment: 10,
      cubeMapSize: 11,
      webGLRenderTargetOptions: 12
    });
  }
  get scale() {
    return this.$$.ctx[3];
  }
  set scale(e) {
    this.$$set({ scale: e }), ne();
  }
  get turbidity() {
    return this.$$.ctx[4];
  }
  set turbidity(e) {
    this.$$set({ turbidity: e }), ne();
  }
  get rayleigh() {
    return this.$$.ctx[5];
  }
  set rayleigh(e) {
    this.$$set({ rayleigh: e }), ne();
  }
  get mieCoefficient() {
    return this.$$.ctx[6];
  }
  set mieCoefficient(e) {
    this.$$set({ mieCoefficient: e }), ne();
  }
  get mieDirectionalG() {
    return this.$$.ctx[7];
  }
  set mieDirectionalG(e) {
    this.$$set({ mieDirectionalG: e }), ne();
  }
  get elevation() {
    return this.$$.ctx[8];
  }
  set elevation(e) {
    this.$$set({ elevation: e }), ne();
  }
  get azimuth() {
    return this.$$.ctx[9];
  }
  set azimuth(e) {
    this.$$set({ azimuth: e }), ne();
  }
  get setEnvironment() {
    return this.$$.ctx[10];
  }
  set setEnvironment(e) {
    this.$$set({ setEnvironment: e }), ne();
  }
  get cubeMapSize() {
    return this.$$.ctx[11];
  }
  set cubeMapSize(e) {
    this.$$set({ cubeMapSize: e }), ne();
  }
  get webGLRenderTargetOptions() {
    return this.$$.ctx[12];
  }
  set webGLRenderTargetOptions(e) {
    this.$$set({ webGLRenderTargetOptions: e }), ne();
  }
}
St(fO, { scale: {}, turbidity: {}, rayleigh: {}, mieCoefficient: {}, mieDirectionalG: {}, elevation: {}, azimuth: {}, setEnvironment: { type: "Boolean" }, cubeMapSize: {}, webGLRenderTargetOptions: {} }, ["default"], [], !0);
const hO = (s) => s.isObject3D, dO = (s) => {
  WA("align-plugin", ({ ref: e }) => {
    if (!hO(e))
      return;
    Us(() => (s(), s));
    const t = async () => {
      await rd(), s();
    };
    return {
      onRefChange() {
        t();
      }
    };
  });
}, pO = (s) => ({ ref: s & /*ref*/
2097152 }), Ov = (s) => ({
  align: (
    /*scheduleAligning*/
    s[4]
  ),
  ref: (
    /*ref*/
    s[21]
  )
});
function mO(s) {
  let e;
  const t = (
    /*#slots*/
    s[15].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[17],
    Ov
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      2228224) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[17],
        e ? xt(
          t,
          /*$$scope*/
          i[17],
          r,
          pO
        ) : Et(
          /*$$scope*/
          i[17]
        ),
        Ov
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function gO(s) {
  let e, t;
  return e = new ee({
    props: {
      is: (
        /*innerGroup*/
        s[2]
      ),
      $$slots: { default: [mO] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, ref*/
      2228224 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function AO(s) {
  let e, t;
  return e = new ee({
    props: {
      is: (
        /*outerGroup*/
        s[3]
      ),
      $$slots: { default: [gO] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, ref*/
      2228224 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function _O(s) {
  let e, t;
  const n = [
    { is: (
      /*containerGroup*/
      s[1]
    ) },
    /*$$restProps*/
    s[6]
  ];
  let i = {
    $$slots: {
      default: [
        AO,
        ({ ref: r }) => ({ 21: r }),
        ({ ref: r }) => r ? 2097152 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[16](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*containerGroup, $$restProps*/
      66 ? jt(n, [
        a & /*containerGroup*/
        2 && { is: (
          /*containerGroup*/
          r[1]
        ) },
        a & /*$$restProps*/
        64 && Kt(
          /*$$restProps*/
          r[6]
        )
      ]) : {};
      a & /*$$scope, ref*/
      2228224 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[16](null), J(e, r);
    }
  };
}
function bO(s, e, t) {
  const n = ["x", "y", "z", "precise", "auto", "calculate", "align"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { x: l = 0 } = e, { y: c = 0 } = e, { z: u = 0 } = e, { precise: f = !1 } = e, { auto: h = !1 } = e;
  const d = us(), { invalidate: m } = un(), _ = new Xn(), g = new Xn(), A = new Xn();
  let v = !1;
  Us(() => {
    t(14, v = !0);
  });
  const y = () => {
    if (!v || l === !1 && c === !1 && u === !1)
      return;
    A.matrixWorld.identity();
    const T = new dn().setFromObject(g, f), S = new H(), D = new Vn(), R = T.max.x - T.min.x, P = T.max.y - T.min.y, L = T.max.z - T.min.z;
    T.getCenter(S), T.getBoundingSphere(D);
    const V = (c || 0) * P / 2, U = (l || 0) * R / 2, Q = (u || 0) * L / 2;
    A.position.set(l === !1 ? 0 : -S.x + U, c === !1 ? 0 : -S.y + V, u === !1 ? 0 : -S.z + Q);
    const q = {
      boundingBox: T,
      center: A.position.clone(),
      boundingSphere: D,
      container: _,
      depth: L,
      depthAlignment: Q,
      height: P,
      verticalAlignment: V,
      width: R,
      horizontalAlignment: U
    };
    d("align", q);
  }, { start: w, stop: E } = On(
    () => {
      y(), m(), E();
    },
    { autoStart: !1, autoInvalidate: !1 }
  ), I = () => {
    w();
  };
  h && dO(w);
  const C = An();
  lt(s, C, (T) => t(0, r = T));
  function B(T) {
    Ut[T ? "unshift" : "push"](() => {
      r = T, C.set(r);
    });
  }
  return s.$$set = (T) => {
    e = We(We({}, e), rn(T)), t(6, i = ft(e, n)), "x" in T && t(7, l = T.x), "y" in T && t(8, c = T.y), "z" in T && t(9, u = T.z), "precise" in T && t(10, f = T.precise), "auto" in T && t(11, h = T.auto), "$$scope" in T && t(17, o = T.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*mounted, x, y, z, precise*/
    18304 && w();
  }, [
    r,
    _,
    g,
    A,
    w,
    C,
    i,
    l,
    c,
    u,
    f,
    h,
    y,
    I,
    v,
    a,
    B,
    o
  ];
}
class vO extends Mt {
  constructor(e) {
    super(), Ct(this, e, bO, _O, _t, {
      x: 7,
      y: 8,
      z: 9,
      precise: 10,
      auto: 11,
      calculate: 12,
      align: 13
    });
  }
  get x() {
    return this.$$.ctx[7];
  }
  set x(e) {
    this.$$set({ x: e }), ne();
  }
  get y() {
    return this.$$.ctx[8];
  }
  set y(e) {
    this.$$set({ y: e }), ne();
  }
  get z() {
    return this.$$.ctx[9];
  }
  set z(e) {
    this.$$set({ z: e }), ne();
  }
  get precise() {
    return this.$$.ctx[10];
  }
  set precise(e) {
    this.$$set({ precise: e }), ne();
  }
  get auto() {
    return this.$$.ctx[11];
  }
  set auto(e) {
    this.$$set({ auto: e }), ne();
  }
  get calculate() {
    return this.$$.ctx[12];
  }
  get align() {
    return this.$$.ctx[13];
  }
}
St(vO, { x: {}, y: {}, z: {}, precise: { type: "Boolean" }, auto: { type: "Boolean" } }, ["default"], ["calculate", "align"], !0);
const wm = new st();
class Od {
  constructor(e) {
    e = e || {}, this.vertices = {
      near: [
        new H(),
        new H(),
        new H(),
        new H()
      ],
      far: [
        new H(),
        new H(),
        new H(),
        new H()
      ]
    }, e.projectionMatrix !== void 0 && this.setFromProjectionMatrix(e.projectionMatrix, e.maxFar || 1e4);
  }
  setFromProjectionMatrix(e, t) {
    const n = e.elements[11] === 0;
    return wm.copy(e).invert(), this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(i) {
      i.applyMatrix4(wm);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(i) {
      i.applyMatrix4(wm);
      const r = Math.abs(i.z);
      n ? i.z *= Math.min(t / r, 1) : i.multiplyScalar(Math.min(t / r, 1));
    }), this.vertices;
  }
  split(e, t) {
    for (; e.length > t.length; )
      t.push(new Od());
    t.length = e.length;
    for (let n = 0; n < e.length; n++) {
      const i = t[n];
      if (n === 0)
        for (let r = 0; r < 4; r++)
          i.vertices.near[r].copy(this.vertices.near[r]);
      else
        for (let r = 0; r < 4; r++)
          i.vertices.near[r].lerpVectors(this.vertices.near[r], this.vertices.far[r], e[n - 1]);
      if (n === e.length - 1)
        for (let r = 0; r < 4; r++)
          i.vertices.far[r].copy(this.vertices.far[r]);
      else
        for (let r = 0; r < 4; r++)
          i.vertices.far[r].lerpVectors(this.vertices.near[r], this.vertices.far[r], e[n]);
    }
  }
  toSpace(e, t) {
    for (let n = 0; n < 4; n++)
      t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(e), t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(e);
  }
}
const Nv = {
  lights_fragment_begin: (
    /* glsl */
    `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
		vec2 cascade;
		float cascadeCenter;
		float closestEdge;
		float margin;
		float csmx;
		float csmy;

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
				// NOTE: Depth gets larger away from the camera.
				// cascade.x is closer, cascade.y is further
				cascade = CSM_cascades[ i ];
				cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
				closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
				margin = 0.25 * pow( closestEdge, 2.0 );
				csmx = cascade.x - margin / 2.0;
				csmy = cascade.y + margin / 2.0;
				if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

					float dist = min( linearDepth - csmx, csmy - linearDepth );
					float ratio = clamp( dist / margin, 0.0, 1.0 );

					vec3 prevColor = directLight.color;
					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
					directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

					ReflectedLight prevLight = reflectedLight;
					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

					bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
					float blendRatio = shouldBlend ? ratio : 1.0;

					reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
					reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
					reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
					reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

				}
			#endif

		}
		#pragma unroll_loop_end
	#elif defined (USE_SHADOWMAP)

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				directionalLightShadow = directionalLightShadows[ i ];
				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )
		// note: no loop here - all CSM lights are in fact one light only
		getDirectionalLightInfo( directionalLights[0], directLight );
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + gt.lights_pars_begin
  )
}, Gv = new st(), Em = new Od(), ws = new H(), Uc = new dn(), Cm = [], Sm = [], Mm = new st(), Qv = new st(), yO = new H(0, 1, 0);
class xO {
  constructor(e) {
    this.camera = e.camera, this.parent = e.parent, this.cascades = e.cascades || 3, this.maxFar = e.maxFar || 1e5, this.mode = e.mode || "practical", this.shadowMapSize = e.shadowMapSize || 2048, this.shadowBias = e.shadowBias || 1e-6, this.lightDirection = e.lightDirection || new H(1, -1, 1).normalize(), this.lightIntensity = e.lightIntensity || 3, this.lightNear = e.lightNear || 1, this.lightFar = e.lightFar || 2e3, this.lightMargin = e.lightMargin || 200, this.customSplitsCallback = e.customSplitsCallback, this.fade = !1, this.mainFrustum = new Od(), this.frustums = [], this.breaks = [], this.lights = [], this.shaders = /* @__PURE__ */ new Map(), this.createLights(), this.updateFrustums(), this.injectInclude();
  }
  createLights() {
    for (let e = 0; e < this.cascades; e++) {
      const t = new Rd(16777215, this.lightIntensity);
      t.castShadow = !0, t.shadow.mapSize.width = this.shadowMapSize, t.shadow.mapSize.height = this.shadowMapSize, t.shadow.camera.near = this.lightNear, t.shadow.camera.far = this.lightFar, t.shadow.bias = this.shadowBias, this.parent.add(t), this.parent.add(t.target), this.lights.push(t);
    }
  }
  initCascades() {
    const e = this.camera;
    e.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxFar), this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const e = this.frustums;
    for (let t = 0; t < e.length; t++) {
      const i = this.lights[t].shadow.camera, r = this.frustums[t], a = r.vertices.near, o = r.vertices.far, l = o[0];
      let c;
      l.distanceTo(o[2]) > l.distanceTo(a[2]) ? c = o[2] : c = a[2];
      let u = l.distanceTo(c);
      if (this.fade) {
        const f = this.camera, h = Math.max(f.far, this.maxFar), d = r.vertices.far[0].z / (h - f.near), m = 0.25 * Math.pow(d, 2) * (h - f.near);
        u += m;
      }
      i.left = -u / 2, i.right = u / 2, i.top = u / 2, i.bottom = -u / 2, i.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const e = this.camera, t = Math.min(e.far, this.maxFar);
    switch (this.breaks.length = 0, this.mode) {
      case "uniform":
        n(this.cascades, e.near, t, this.breaks);
        break;
      case "logarithmic":
        i(this.cascades, e.near, t, this.breaks);
        break;
      case "practical":
        r(this.cascades, e.near, t, 0.5, this.breaks);
        break;
      case "custom":
        this.customSplitsCallback === void 0 && console.error("CSM: Custom split scheme callback not defined."), this.customSplitsCallback(this.cascades, e.near, t, this.breaks);
        break;
    }
    function n(a, o, l, c) {
      for (let u = 1; u < a; u++)
        c.push((o + (l - o) * u / a) / l);
      c.push(1);
    }
    function i(a, o, l, c) {
      for (let u = 1; u < a; u++)
        c.push(o * (l / o) ** (u / a) / l);
      c.push(1);
    }
    function r(a, o, l, c, u) {
      Cm.length = 0, Sm.length = 0, i(a, o, l, Sm), n(a, o, l, Cm);
      for (let f = 1; f < a; f++)
        u.push(ls.lerp(Cm[f - 1], Sm[f - 1], c));
      u.push(1);
    }
  }
  update() {
    const e = this.camera, t = this.frustums;
    Mm.lookAt(new H(), this.lightDirection, yO), Qv.copy(Mm).invert();
    for (let n = 0; n < t.length; n++) {
      const i = this.lights[n], r = i.shadow.camera, a = (r.right - r.left) / this.shadowMapSize, o = (r.top - r.bottom) / this.shadowMapSize;
      Gv.multiplyMatrices(Qv, e.matrixWorld), t[n].toSpace(Gv, Em);
      const l = Em.vertices.near, c = Em.vertices.far;
      Uc.makeEmpty();
      for (let u = 0; u < 4; u++)
        Uc.expandByPoint(l[u]), Uc.expandByPoint(c[u]);
      Uc.getCenter(ws), ws.z = Uc.max.z + this.lightMargin, ws.x = Math.floor(ws.x / a) * a, ws.y = Math.floor(ws.y / o) * o, ws.applyMatrix4(Mm), i.position.copy(ws), i.target.position.copy(ws), i.target.position.x += this.lightDirection.x, i.target.position.y += this.lightDirection.y, i.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    gt.lights_fragment_begin = Nv.lights_fragment_begin, gt.lights_pars_begin = Nv.lights_pars_begin;
  }
  setupMaterial(e) {
    e.defines = e.defines || {}, e.defines.USE_CSM = 1, e.defines.CSM_CASCADES = this.cascades, this.fade && (e.defines.CSM_FADE = "");
    const t = [], n = this, i = this.shaders;
    e.onBeforeCompile = function(r) {
      const a = Math.min(n.camera.far, n.maxFar);
      n.getExtendedBreaks(t), r.uniforms.CSM_cascades = { value: t }, r.uniforms.cameraNear = { value: n.camera.near }, r.uniforms.shadowFar = { value: a }, i.set(e, r);
    }, i.set(e, null);
  }
  updateUniforms() {
    const e = Math.min(this.camera.far, this.maxFar);
    this.shaders.forEach(function(n, i) {
      if (n !== null) {
        const r = n.uniforms;
        this.getExtendedBreaks(r.CSM_cascades.value), r.cameraNear.value = this.camera.near, r.shadowFar.value = e;
      }
      !this.fade && "CSM_FADE" in i.defines ? (delete i.defines.CSM_FADE, i.needsUpdate = !0) : this.fade && !("CSM_FADE" in i.defines) && (i.defines.CSM_FADE = "", i.needsUpdate = !0);
    }, this);
  }
  getExtendedBreaks(e) {
    for (; e.length < this.breaks.length; )
      e.push(new ke());
    e.length = this.breaks.length;
    for (let t = 0; t < this.cascades; t++) {
      const n = this.breaks[t], i = this.breaks[t - 1] || 0;
      e[t].x = i, e[t].y = n;
    }
  }
  updateFrustums() {
    this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
  }
  remove() {
    for (let e = 0; e < this.lights.length; e++)
      this.parent.remove(this.lights[e].target), this.parent.remove(this.lights[e]);
  }
  dispose() {
    const e = this.shaders;
    e.forEach(function(t, n) {
      delete n.onBeforeCompile, delete n.defines.USE_CSM, delete n.defines.CSM_CASCADES, delete n.defines.CSM_FADE, t !== null && (delete t.uniforms.CSM_cascades, delete t.uniforms.cameraNear, delete t.uniforms.shadowFar), n.needsUpdate = !0;
    }), e.clear();
  }
}
const wO = () => {
  let s;
  const e = /* @__PURE__ */ new Set(), t = (o) => o.isMeshStandardMaterial || o.isMeshPhongMaterial, n = (o) => o.isMesh, i = (o) => {
    e.has(o) || (e.add(o), s == null || s(o));
  }, r = (o) => {
    t(o) ? i(o) : n(o) && (Array.isArray(o.material) ? o.material.forEach((l) => {
      t(l) && i(l);
    }) : t(o.material) && i(o.material));
  }, a = (o) => {
    s = o;
  };
  return WA("csm", ({ ref: o }) => {
    Us(() => {
      r(o);
    });
  }), Sn(() => s = void 0), { onNewMaterial: a, allMaterials: e };
}, EO = (s) => ({}), zv = (s) => ({});
function $v(s) {
  let e;
  const t = (
    /*#slots*/
    s[10].disabled
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[9],
    zv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? xt(
          t,
          /*$$scope*/
          i[9],
          r,
          EO
        ) : Et(
          /*$$scope*/
          i[9]
        ),
        zv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function CO(s) {
  let e, t, n;
  const i = (
    /*#slots*/
    s[10].default
  ), r = yt(
    i,
    s,
    /*$$scope*/
    s[9],
    null
  );
  let a = !/*enabled*/
  s[0] && $v(s);
  return {
    c() {
      r && r.c(), e = Me(), a && a.c(), t = ji();
    },
    m(o, l) {
      r && r.m(o, l), we(o, e, l), a && a.m(o, l), we(o, t, l), n = !0;
    },
    p(o, [l]) {
      r && r.p && (!n || l & /*$$scope*/
      512) && wt(
        r,
        i,
        o,
        /*$$scope*/
        o[9],
        n ? xt(
          i,
          /*$$scope*/
          o[9],
          l,
          null
        ) : Et(
          /*$$scope*/
          o[9]
        ),
        null
      ), /*enabled*/
      o[0] ? a && (Li(), N(a, 1, 1, () => {
        a = null;
      }), ki()) : a ? (a.p(o, l), l & /*enabled*/
      1 && O(a, 1)) : (a = $v(o), a.c(), O(a, 1), a.m(t.parentNode, t));
    },
    i(o) {
      n || (O(r, o), O(a), n = !0);
    },
    o(o) {
      N(r, o), N(a), n = !1;
    },
    d(o) {
      o && (xe(e), xe(t)), r && r.d(o), a && a.d(o);
    }
  };
}
function SO(s, e, t) {
  let n, i, { $$slots: r = {}, $$scope: a } = e, { enabled: o = !0 } = e, { args: l = {} } = e, { camera: c = void 0 } = e, { configure: u = void 0 } = e, { lightIntensity: f = void 0 } = e, { lightColor: h = void 0 } = e, { lightDirection: d = [1, -1, 1] } = e;
  const m = Ft(o), { camera: _, scene: g, size: A, useLegacyLights: v } = un();
  lt(s, _, (D) => t(12, i = D));
  const y = xn(void 0);
  lt(s, y, (D) => t(11, n = D)), On(() => n == null ? void 0 : n.update(), { autoInvalidate: !1 });
  const { onNewMaterial: w, allMaterials: E } = wO(), I = () => {
    n == null || n.remove(), n == null || n.dispose(), n_(y, n = void 0, n);
  };
  tn([A, y], ([D, R]) => {
    R && R.updateFrustums();
  });
  const C = Ft(c);
  tn([_, C, y], ([D, R, P]) => {
    P && (P.camera = R ?? D, l.maxFar !== void 0 && (P.maxFar = l.maxFar), l.mode !== void 0 && (P.mode = l.mode), P.updateFrustums());
  }), tn(m, (D) => {
    if (D) {
      n_(
        y,
        n = new xO({
          camera: c ?? i,
          parent: g,
          ...l
        }),
        n
      ), u == null || u(n);
      for (const R of E)
        n.setupMaterial(R);
      w((R) => n == null ? void 0 : n.setupMaterial(R));
    } else
      w(void 0), I();
  });
  const B = Ft(f), T = Ft(h);
  tn([y, B, T, v], ([D, R, P, L]) => {
    D == null || D.lights.forEach((V) => {
      R !== void 0 && (V.intensity = R / (L ? 1 : Math.PI)), P !== void 0 && V.color.set(P);
    });
  });
  const S = Ft(d);
  return tn([y, S], ([D, R]) => {
    D == null || D.lightDirection.set(...R).normalize();
  }), Sn(I), s.$$set = (D) => {
    "enabled" in D && t(0, o = D.enabled), "args" in D && t(3, l = D.args), "camera" in D && t(4, c = D.camera), "configure" in D && t(5, u = D.configure), "lightIntensity" in D && t(6, f = D.lightIntensity), "lightColor" in D && t(7, h = D.lightColor), "lightDirection" in D && t(8, d = D.lightDirection), "$$scope" in D && t(9, a = D.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*enabled*/
    1 && m.set(o), s.$$.dirty & /*camera*/
    16 && C.set(c), s.$$.dirty & /*lightIntensity*/
    64 && B.set(f), s.$$.dirty & /*lightColor*/
    128 && T.set(h), s.$$.dirty & /*lightDirection*/
    256 && S.set(d);
  }, [
    o,
    _,
    y,
    l,
    c,
    u,
    f,
    h,
    d,
    a,
    r
  ];
}
class MO extends Mt {
  constructor(e) {
    super(), Ct(this, e, SO, CO, _t, {
      enabled: 0,
      args: 3,
      camera: 4,
      configure: 5,
      lightIntensity: 6,
      lightColor: 7,
      lightDirection: 8
    });
  }
  get enabled() {
    return this.$$.ctx[0];
  }
  set enabled(e) {
    this.$$set({ enabled: e }), ne();
  }
  get args() {
    return this.$$.ctx[3];
  }
  set args(e) {
    this.$$set({ args: e }), ne();
  }
  get camera() {
    return this.$$.ctx[4];
  }
  set camera(e) {
    this.$$set({ camera: e }), ne();
  }
  get configure() {
    return this.$$.ctx[5];
  }
  set configure(e) {
    this.$$set({ configure: e }), ne();
  }
  get lightIntensity() {
    return this.$$.ctx[6];
  }
  set lightIntensity(e) {
    this.$$set({ lightIntensity: e }), ne();
  }
  get lightColor() {
    return this.$$.ctx[7];
  }
  set lightColor(e) {
    this.$$set({ lightColor: e }), ne();
  }
  get lightDirection() {
    return this.$$.ctx[8];
  }
  set lightDirection(e) {
    this.$$set({ lightDirection: e }), ne();
  }
}
St(MO, { enabled: { type: "Boolean" }, args: {}, camera: {}, configure: {}, lightIntensity: {}, lightColor: {}, lightDirection: {} }, ["default", "disabled"], [], !0);
const IO = (s) => ({ ref: s & /*localRef*/
1 }), Vv = (s) => ({ ref: (
  /*localRef*/
  s[0]
) });
function TO(s) {
  let e;
  const t = (
    /*#slots*/
    s[8].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[11],
    Vv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, localRef*/
      2049) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[11],
        e ? xt(
          t,
          /*$$scope*/
          i[11],
          r,
          IO
        ) : Et(
          /*$$scope*/
          i[11]
        ),
        Vv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function BO(s) {
  let e, t, n;
  function i(a) {
    s[9](a);
  }
  let r = {
    $$slots: { default: [TO] },
    $$scope: { ctx: s }
  };
  return (
    /*inner*/
    s[1] !== void 0 && (r.ref = /*inner*/
    s[1]), e = new ee.Group({ props: r }), Ut.push(() => ar(e, "ref", i)), {
      c() {
        Z(e.$$.fragment);
      },
      m(a, o) {
        K(e, a, o), n = !0;
      },
      p(a, o) {
        const l = {};
        o & /*$$scope, localRef*/
        2049 && (l.$$scope = { dirty: o, ctx: a }), !t && o & /*inner*/
        2 && (t = !0, l.ref = /*inner*/
        a[1], or(() => t = !1)), e.$set(l);
      },
      i(a) {
        n || (O(e.$$.fragment, a), n = !0);
      },
      o(a) {
        N(e.$$.fragment, a), n = !1;
      },
      d(a) {
        J(e, a);
      }
    }
  );
}
function PO(s) {
  let e, t, n;
  const i = [
    { matrixAutoUpdate: !1 },
    { matrixWorldAutoUpdate: !1 },
    /*$$restProps*/
    s[3]
  ];
  function r(o) {
    s[10](o);
  }
  let a = {
    $$slots: { default: [BO] },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < i.length; o += 1)
    a = We(a, i[o]);
  return (
    /*localRef*/
    s[0] !== void 0 && (a.ref = /*localRef*/
    s[0]), e = new ee.Group({ props: a }), Ut.push(() => ar(e, "ref", r)), {
      c() {
        Z(e.$$.fragment);
      },
      m(o, l) {
        K(e, o, l), n = !0;
      },
      p(o, [l]) {
        const c = l & /*$$restProps*/
        8 ? jt(i, [
          i[0],
          i[1],
          Kt(
            /*$$restProps*/
            o[3]
          )
        ]) : {};
        l & /*$$scope, inner, localRef*/
        2051 && (c.$$scope = { dirty: l, ctx: o }), !t && l & /*localRef*/
        1 && (t = !0, c.ref = /*localRef*/
        o[0], or(() => t = !1)), e.$set(c);
      },
      i(o) {
        n || (O(e.$$.fragment, o), n = !0);
      },
      o(o) {
        N(e.$$.fragment, o), n = !1;
      },
      d(o) {
        J(e, o);
      }
    }
  );
}
function RO(s, e, t) {
  const n = ["follow", "lockX", "lockY", "lockZ"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { follow: l = !0 } = e, { lockX: c = !1 } = e, { lockY: u = !1 } = e, { lockZ: f = !1 } = e, h, d;
  const { camera: m } = un();
  lt(s, m, (E) => t(12, r = E));
  const _ = new en(), g = new Ui(), { start: A, stop: v } = On(
    () => {
      g.copy(d.rotation), d.updateMatrix(), d.updateWorldMatrix(!1, !1), d.getWorldQuaternion(_), r.getWorldQuaternion(h.quaternion).premultiply(_.invert()), c && t(0, d.rotation.x = g.x, d), u && t(0, d.rotation.y = g.y, d), f && t(0, d.rotation.z = g.z, d);
    },
    { autoStart: !1 }
  );
  function y(E) {
    h = E, t(1, h);
  }
  function w(E) {
    d = E, t(0, d);
  }
  return s.$$set = (E) => {
    e = We(We({}, e), rn(E)), t(3, i = ft(e, n)), "follow" in E && t(4, l = E.follow), "lockX" in E && t(5, c = E.lockX), "lockY" in E && t(6, u = E.lockY), "lockZ" in E && t(7, f = E.lockZ), "$$scope" in E && t(11, o = E.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*follow, localRef*/
    17 && (l && d ? A() : v());
  }, [
    d,
    h,
    m,
    i,
    l,
    c,
    u,
    f,
    a,
    y,
    w,
    o
  ];
}
class DO extends Mt {
  constructor(e) {
    super(), Ct(this, e, RO, PO, _t, { follow: 4, lockX: 5, lockY: 6, lockZ: 7 });
  }
  get follow() {
    return this.$$.ctx[4];
  }
  set follow(e) {
    this.$$set({ follow: e }), ne();
  }
  get lockX() {
    return this.$$.ctx[5];
  }
  set lockX(e) {
    this.$$set({ lockX: e }), ne();
  }
  get lockY() {
    return this.$$.ctx[6];
  }
  set lockY(e) {
    this.$$set({ lockY: e }), ne();
  }
  get lockZ() {
    return this.$$.ctx[7];
  }
  set lockZ(e) {
    this.$$set({ lockZ: e }), ne();
  }
}
St(DO, { follow: { type: "Boolean" }, lockX: { type: "Boolean" }, lockY: { type: "Boolean" }, lockZ: { type: "Boolean" } }, ["default"], [], !0);
const LO = `
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${gt.tonemapping_fragment}
	${gt.colorspace_fragment}
}`, kO = `varying vec3 vPosition;
varying vec3 vNormal;

void main() {
	vec4 modelPosition = modelMatrix * vec4(position, 1.0);
	gl_Position = projectionMatrix * viewMatrix * modelPosition;
	vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
	vPosition = modelPosition.xyz;
	vNormal = modelNormal.xyz;
}`, UO = (s) => ({ ref: s & /*material*/
1 }), Hv = (s) => ({ ref: (
  /*material*/
  s[0]
) });
function FO(s) {
  let e;
  const t = (
    /*#slots*/
    s[8].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[10],
    Hv
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, material*/
      1025) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[10],
        e ? xt(
          t,
          /*$$scope*/
          i[10],
          r,
          UO
        ) : Et(
          /*$$scope*/
          i[10]
        ),
        Hv
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function OO(s) {
  let e, t;
  const n = [
    { is: (
      /*material*/
      s[0]
    ) },
    { fragmentShader: LO },
    { vertexShader: kO },
    { transparent: !0 },
    { blending: uu },
    { depthTest: !1 },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [FO] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[9](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*material, $$restProps*/
      9 ? jt(n, [
        a & /*material*/
        1 && { is: (
          /*material*/
          r[0]
        ) },
        n[1],
        n[2],
        n[3],
        n[4],
        n[5],
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, material*/
      1025 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[9](null), J(e, r);
    }
  };
}
function NO(s, e, t) {
  const n = ["falloff", "glowInternalRadius", "glowColor", "glowSharpness"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { falloff: l = 0.1 } = e, { glowInternalRadius: c = 6 } = e, { glowColor: u = "green" } = e, { glowSharpness: f = 1 } = e, h = new Hn({
    uniforms: {
      falloff: { value: l },
      glowInternalRadius: { value: c },
      glowColor: { value: new Je(u) },
      glowSharpness: { value: f }
    }
  }), { invalidate: d } = un();
  const m = An();
  lt(s, m, (g) => t(1, r = g));
  function _(g) {
    Ut[g ? "unshift" : "push"](() => {
      r = g, m.set(r);
    });
  }
  return s.$$set = (g) => {
    e = We(We({}, e), rn(g)), t(3, i = ft(e, n)), "falloff" in g && t(4, l = g.falloff), "glowInternalRadius" in g && t(5, c = g.glowInternalRadius), "glowColor" in g && t(6, u = g.glowColor), "glowSharpness" in g && t(7, f = g.glowSharpness), "$$scope" in g && t(10, o = g.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*falloff, glowInternalRadius, glowColor, glowSharpness*/
    240 && (t(0, h.uniforms.falloff.value = l, h), t(0, h.uniforms.glowInternalRadius.value = c, h), t(0, h.uniforms.glowColor.value = new Je(u), h), t(0, h.uniforms.glowSharpness.value = f, h), d());
  }, [
    h,
    r,
    m,
    i,
    l,
    c,
    u,
    f,
    a,
    _,
    o
  ];
}
class GO extends Mt {
  constructor(e) {
    super(), Ct(this, e, NO, OO, _t, {
      falloff: 4,
      glowInternalRadius: 5,
      glowColor: 6,
      glowSharpness: 7
    });
  }
  get falloff() {
    return this.$$.ctx[4];
  }
  set falloff(e) {
    this.$$set({ falloff: e }), ne();
  }
  get glowInternalRadius() {
    return this.$$.ctx[5];
  }
  set glowInternalRadius(e) {
    this.$$set({ glowInternalRadius: e }), ne();
  }
  get glowColor() {
    return this.$$.ctx[6];
  }
  set glowColor(e) {
    this.$$set({ glowColor: e }), ne();
  }
  get glowSharpness() {
    return this.$$.ctx[7];
  }
  set glowSharpness(e) {
    this.$$set({ glowSharpness: e }), ne();
  }
}
St(GO, { falloff: {}, glowInternalRadius: {}, glowColor: {}, glowSharpness: {} }, ["default"], [], !0);
const QO = `
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${gt.tonemapping_fragment}
	${gt.colorspace_fragment}
}`, zO = `uniform float time;
attribute float size;
varying vec3 vColor;
void main() {
	vColor = color;
	vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
	gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
	gl_Position = projectionMatrix * mvPosition;
}`, $O = (s) => ({ ref: s & /*ref*/
33554432 }), jv = (s) => ({ ref: (
  /*ref*/
  s[25]
) });
function VO(s) {
  let e, t, n, i, r, a;
  return e = new ee.BufferAttribute({
    props: {
      attach: WO,
      args: [
        /*positionsArray*/
        s[2],
        3
      ]
    }
  }), n = new ee.BufferAttribute({
    props: {
      attach: qO,
      args: [
        /*colorsArray*/
        s[3],
        3
      ]
    }
  }), r = new ee.BufferAttribute({
    props: {
      attach: XO,
      args: [
        /*sizesArray*/
        s[4],
        1
      ]
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p(o, l) {
      const c = {};
      l & /*positionsArray*/
      4 && (c.args = [
        /*positionsArray*/
        o[2],
        3
      ]), e.$set(c);
      const u = {};
      l & /*colorsArray*/
      8 && (u.args = [
        /*colorsArray*/
        o[3],
        3
      ]), n.$set(u);
      const f = {};
      l & /*sizesArray*/
      16 && (f.args = [
        /*sizesArray*/
        o[4],
        1
      ]), r.$set(f);
    },
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function HO(s) {
  let e, t, n, i, r;
  e = new ee.BufferGeometry({
    props: {
      $$slots: { default: [VO] },
      $$scope: { ctx: s }
    }
  }), n = new ee({
    props: {
      is: (
        /*material*/
        s[8]
      ),
      blending: uu,
      "uniforms.fade.value": (
        /*fade*/
        s[0] ? 1 : 0
      ),
      "uniforms.time.value": (
        /*time*/
        s[5]
      ),
      "uniforms.opacity.value": (
        /*opacity*/
        s[1]
      ),
      depthWrite: !1,
      transparent: !0,
      vertexColors: !0
    }
  });
  const a = (
    /*#slots*/
    s[17].default
  ), o = yt(
    a,
    s,
    /*$$scope*/
    s[19],
    jv
  );
  return {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), o && o.c();
    },
    m(l, c) {
      K(e, l, c), we(l, t, c), K(n, l, c), we(l, i, c), o && o.m(l, c), r = !0;
    },
    p(l, c) {
      const u = {};
      c & /*$$scope, sizesArray, colorsArray, positionsArray*/
      524316 && (u.$$scope = { dirty: c, ctx: l }), e.$set(u);
      const f = {};
      c & /*fade*/
      1 && (f["uniforms.fade.value"] = /*fade*/
      l[0] ? 1 : 0), c & /*time*/
      32 && (f["uniforms.time.value"] = /*time*/
      l[5]), c & /*opacity*/
      2 && (f["uniforms.opacity.value"] = /*opacity*/
      l[1]), n.$set(f), o && o.p && (!r || c & /*$$scope, ref*/
      34078720) && wt(
        o,
        a,
        l,
        /*$$scope*/
        l[19],
        r ? xt(
          a,
          /*$$scope*/
          l[19],
          c,
          $O
        ) : Et(
          /*$$scope*/
          l[19]
        ),
        jv
      );
    },
    i(l) {
      r || (O(e.$$.fragment, l), O(n.$$.fragment, l), O(o, l), r = !0);
    },
    o(l) {
      N(e.$$.fragment, l), N(n.$$.fragment, l), N(o, l), r = !1;
    },
    d(l) {
      l && (xe(t), xe(i)), J(e, l), J(n, l), o && o.d(l);
    }
  };
}
function jO(s) {
  let e, t;
  const n = [
    /*$$restProps*/
    s[9]
  ];
  let i = {
    $$slots: {
      default: [
        HO,
        ({ ref: r }) => ({ 25: r }),
        ({ ref: r }) => r ? 33554432 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee.Points({ props: i }), s[18](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*$$restProps*/
      512 ? jt(n, [Kt(
        /*$$restProps*/
        r[9]
      )]) : {};
      a & /*$$scope, ref, fade, time, opacity, sizesArray, colorsArray, positionsArray*/
      34078783 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[18](null), J(e, r);
    }
  };
}
const WO = (s, e) => (s.setAttribute("position", e), () => {
}), qO = (s, e) => (s.setAttribute("color", e), () => {
}), XO = (s, e) => (s.setAttribute("size", e), () => {
});
function YO(s, e, t) {
  const n = [
    "count",
    "radius",
    "depth",
    "factor",
    "saturation",
    "lightness",
    "speed",
    "fade",
    "opacity"
  ];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { count: l = 5e3 } = e, { radius: c = 50 } = e, { depth: u = 50 } = e, { factor: f = 6 } = e, { saturation: h = 1 } = e, { lightness: d = 0.8 } = e, { speed: m = 1 } = e, { fade: _ = !0 } = e, { opacity: g = 1 } = e;
  const A = new H(), v = new ed(), y = (P) => A.setFromSpherical(v.set(P, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
  let w, E, I;
  const C = An();
  lt(s, C, (P) => t(6, r = P));
  let B = 0;
  const { stop: T, start: S } = On(
    (P) => {
      t(5, B += P * m);
    },
    { autoStart: !1 }
  ), D = new Hn({
    uniforms: {
      time: { value: 0 },
      fade: { value: 1 },
      opacity: { value: 1 }
    },
    vertexShader: zO,
    fragmentShader: QO
  });
  function R(P) {
    Ut[P ? "unshift" : "push"](() => {
      r = P, C.set(r);
    });
  }
  return s.$$set = (P) => {
    e = We(We({}, e), rn(P)), t(9, i = ft(e, n)), "count" in P && t(10, l = P.count), "radius" in P && t(11, c = P.radius), "depth" in P && t(12, u = P.depth), "factor" in P && t(13, f = P.factor), "saturation" in P && t(14, h = P.saturation), "lightness" in P && t(15, d = P.lightness), "speed" in P && t(16, m = P.speed), "fade" in P && t(0, _ = P.fade), "opacity" in P && t(1, g = P.opacity), "$$scope" in P && t(19, o = P.$$scope);
  }, s.$$.update = () => {
    if (s.$$.dirty & /*count, factor, radius, depth, saturation, lightness*/
    64512) {
      const P = [], L = [], V = Array.from({ length: l }, () => (0.5 + 0.5 * Math.random()) * f), U = new Je();
      let Q = c + u;
      const q = u / l;
      for (let oe = 0; oe < l; oe++) {
        Q -= q * Math.random();
        const le = y(Q);
        P.push(le.x, le.y, le.z), U.setHSL(oe / l, h, d), L.push(U.r, U.g, U.b);
      }
      t(2, w = new Float32Array(P)), t(3, E = new Float32Array(L)), t(4, I = new Float32Array(V));
    }
    s.$$.dirty & /*speed*/
    65536 && (m !== 0 ? S() : T());
  }, [
    _,
    g,
    w,
    E,
    I,
    B,
    r,
    C,
    D,
    i,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    a,
    R,
    o
  ];
}
class KO extends Mt {
  constructor(e) {
    super(), Ct(this, e, YO, jO, _t, {
      count: 10,
      radius: 11,
      depth: 12,
      factor: 13,
      saturation: 14,
      lightness: 15,
      speed: 16,
      fade: 0,
      opacity: 1
    });
  }
  get count() {
    return this.$$.ctx[10];
  }
  set count(e) {
    this.$$set({ count: e }), ne();
  }
  get radius() {
    return this.$$.ctx[11];
  }
  set radius(e) {
    this.$$set({ radius: e }), ne();
  }
  get depth() {
    return this.$$.ctx[12];
  }
  set depth(e) {
    this.$$set({ depth: e }), ne();
  }
  get factor() {
    return this.$$.ctx[13];
  }
  set factor(e) {
    this.$$set({ factor: e }), ne();
  }
  get saturation() {
    return this.$$.ctx[14];
  }
  set saturation(e) {
    this.$$set({ saturation: e }), ne();
  }
  get lightness() {
    return this.$$.ctx[15];
  }
  set lightness(e) {
    this.$$set({ lightness: e }), ne();
  }
  get speed() {
    return this.$$.ctx[16];
  }
  set speed(e) {
    this.$$set({ speed: e }), ne();
  }
  get fade() {
    return this.$$.ctx[0];
  }
  set fade(e) {
    this.$$set({ fade: e }), ne();
  }
  get opacity() {
    return this.$$.ctx[1];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), ne();
  }
}
St(KO, { count: {}, radius: {}, depth: {}, factor: {}, saturation: {}, lightness: {}, speed: {}, fade: { type: "Boolean" }, opacity: {} }, ["default"], [], !0);
const bE = 0, JO = 1, vE = 2, Wv = 2, Im = 1.25, qv = 1, mo = 6 * 4 + 4 + 4, Nd = 65535, ZO = Math.pow(2, -24), Tm = Symbol("SKIP_GENERATION");
function yE(s) {
  return s.index ? s.index.count : s.attributes.position.count;
}
function sc(s) {
  return yE(s) / 3;
}
function xE(s, e = ArrayBuffer) {
  return s > 65535 ? new Uint32Array(new e(4 * s)) : new Uint16Array(new e(2 * s));
}
function eN(s, e) {
  if (!s.index) {
    const t = s.attributes.position.count, n = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = xE(t, n);
    s.setIndex(new Rt(i, 1));
    for (let r = 0; r < t; r++)
      i[r] = r;
  }
}
function wE(s) {
  const e = sc(s), t = s.drawRange, n = t.start / 3, i = (t.start + t.count) / 3, r = Math.max(0, n), a = Math.min(e, i) - r;
  return [{
    offset: Math.floor(r),
    count: Math.floor(a)
  }];
}
function EE(s) {
  if (!s.groups || !s.groups.length)
    return wE(s);
  const e = [], t = /* @__PURE__ */ new Set(), n = s.drawRange, i = n.start / 3, r = (n.start + n.count) / 3;
  for (const o of s.groups) {
    const l = o.start / 3, c = (o.start + o.count) / 3;
    t.add(Math.max(i, l)), t.add(Math.min(r, c));
  }
  const a = Array.from(t.values()).sort((o, l) => o - l);
  for (let o = 0; o < a.length - 1; o++) {
    const l = a[o], c = a[o + 1];
    e.push({
      offset: Math.floor(l),
      count: Math.floor(c - l)
    });
  }
  return e;
}
function tN(s) {
  if (s.groups.length === 0)
    return !1;
  const e = sc(s), t = EE(s).sort((r, a) => r.offset - a.offset), n = t[t.length - 1];
  n.count = Math.min(e - n.offset, n.count);
  let i = 0;
  return t.forEach(({ count: r }) => i += r), e !== i;
}
function Bm(s, e, t, n, i) {
  let r = 1 / 0, a = 1 / 0, o = 1 / 0, l = -1 / 0, c = -1 / 0, u = -1 / 0, f = 1 / 0, h = 1 / 0, d = 1 / 0, m = -1 / 0, _ = -1 / 0, g = -1 / 0;
  for (let A = e * 6, v = (e + t) * 6; A < v; A += 6) {
    const y = s[A + 0], w = s[A + 1], E = y - w, I = y + w;
    E < r && (r = E), I > l && (l = I), y < f && (f = y), y > m && (m = y);
    const C = s[A + 2], B = s[A + 3], T = C - B, S = C + B;
    T < a && (a = T), S > c && (c = S), C < h && (h = C), C > _ && (_ = C);
    const D = s[A + 4], R = s[A + 5], P = D - R, L = D + R;
    P < o && (o = P), L > u && (u = L), D < d && (d = D), D > g && (g = D);
  }
  n[0] = r, n[1] = a, n[2] = o, n[3] = l, n[4] = c, n[5] = u, i[0] = f, i[1] = h, i[2] = d, i[3] = m, i[4] = _, i[5] = g;
}
function nN(s, e = null, t = null, n = null) {
  const i = s.attributes.position, r = s.index ? s.index.array : null, a = sc(s), o = i.normalized;
  let l;
  e === null ? (l = new Float32Array(a * 6 * 4), t = 0, n = a) : (l = e, t = t || 0, n = n || a);
  const c = i.array, u = i.offset || 0;
  let f = 3;
  i.isInterleavedBufferAttribute && (f = i.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let d = t; d < t + n; d++) {
    const m = d * 3, _ = d * 6;
    let g = m + 0, A = m + 1, v = m + 2;
    r && (g = r[g], A = r[A], v = r[v]), o || (g = g * f + u, A = A * f + u, v = v * f + u);
    for (let y = 0; y < 3; y++) {
      let w, E, I;
      o ? (w = i[h[y]](g), E = i[h[y]](A), I = i[h[y]](v)) : (w = c[g + y], E = c[A + y], I = c[v + y]);
      let C = w;
      E < C && (C = E), I < C && (C = I);
      let B = w;
      E > B && (B = E), I > B && (B = I);
      const T = (B - C) / 2, S = y * 2;
      l[_ + S + 0] = C + T, l[_ + S + 1] = T + (Math.abs(C) + T) * ZO;
    }
  }
  return l;
}
function kn(s, e, t) {
  return t.min.x = e[s], t.min.y = e[s + 1], t.min.z = e[s + 2], t.max.x = e[s + 3], t.max.y = e[s + 4], t.max.z = e[s + 5], t;
}
function Xv(s) {
  let e = -1, t = -1 / 0;
  for (let n = 0; n < 3; n++) {
    const i = s[n + 3] - s[n];
    i > t && (t = i, e = n);
  }
  return e;
}
function Yv(s, e) {
  e.set(s);
}
function Kv(s, e, t) {
  let n, i;
  for (let r = 0; r < 3; r++) {
    const a = r + 3;
    n = s[r], i = e[r], t[r] = n < i ? n : i, n = s[a], i = e[a], t[a] = n > i ? n : i;
  }
}
function rh(s, e, t) {
  for (let n = 0; n < 3; n++) {
    const i = e[s + 2 * n], r = e[s + 2 * n + 1], a = i - r, o = i + r;
    a < t[n] && (t[n] = a), o > t[n + 3] && (t[n + 3] = o);
  }
}
function Fc(s) {
  const e = s[3] - s[0], t = s[4] - s[1], n = s[5] - s[2];
  return 2 * (e * t + t * n + n * e);
}
const Cs = 32, iN = (s, e) => s.candidate - e.candidate, so = new Array(Cs).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), sh = new Float32Array(6);
function rN(s, e, t, n, i, r) {
  let a = -1, o = 0;
  if (r === bE)
    a = Xv(e), a !== -1 && (o = (e[a] + e[a + 3]) / 2);
  else if (r === JO)
    a = Xv(s), a !== -1 && (o = sN(t, n, i, a));
  else if (r === vE) {
    const l = Fc(s);
    let c = Im * i;
    const u = n * 6, f = (n + i) * 6;
    for (let h = 0; h < 3; h++) {
      const d = e[h], g = (e[h + 3] - d) / Cs;
      if (i < Cs / 4) {
        const A = [...so];
        A.length = i;
        let v = 0;
        for (let w = u; w < f; w += 6, v++) {
          const E = A[v];
          E.candidate = t[w + 2 * h], E.count = 0;
          const {
            bounds: I,
            leftCacheBounds: C,
            rightCacheBounds: B
          } = E;
          for (let T = 0; T < 3; T++)
            B[T] = 1 / 0, B[T + 3] = -1 / 0, C[T] = 1 / 0, C[T + 3] = -1 / 0, I[T] = 1 / 0, I[T + 3] = -1 / 0;
          rh(w, t, I);
        }
        A.sort(iN);
        let y = i;
        for (let w = 0; w < y; w++) {
          const E = A[w];
          for (; w + 1 < y && A[w + 1].candidate === E.candidate; )
            A.splice(w + 1, 1), y--;
        }
        for (let w = u; w < f; w += 6) {
          const E = t[w + 2 * h];
          for (let I = 0; I < y; I++) {
            const C = A[I];
            E >= C.candidate ? rh(w, t, C.rightCacheBounds) : (rh(w, t, C.leftCacheBounds), C.count++);
          }
        }
        for (let w = 0; w < y; w++) {
          const E = A[w], I = E.count, C = i - E.count, B = E.leftCacheBounds, T = E.rightCacheBounds;
          let S = 0;
          I !== 0 && (S = Fc(B) / l);
          let D = 0;
          C !== 0 && (D = Fc(T) / l);
          const R = qv + Im * (S * I + D * C);
          R < c && (a = h, c = R, o = E.candidate);
        }
      } else {
        for (let y = 0; y < Cs; y++) {
          const w = so[y];
          w.count = 0, w.candidate = d + g + y * g;
          const E = w.bounds;
          for (let I = 0; I < 3; I++)
            E[I] = 1 / 0, E[I + 3] = -1 / 0;
        }
        for (let y = u; y < f; y += 6) {
          let I = ~~((t[y + 2 * h] - d) / g);
          I >= Cs && (I = Cs - 1);
          const C = so[I];
          C.count++, rh(y, t, C.bounds);
        }
        const A = so[Cs - 1];
        Yv(A.bounds, A.rightCacheBounds);
        for (let y = Cs - 2; y >= 0; y--) {
          const w = so[y], E = so[y + 1];
          Kv(w.bounds, E.rightCacheBounds, w.rightCacheBounds);
        }
        let v = 0;
        for (let y = 0; y < Cs - 1; y++) {
          const w = so[y], E = w.count, I = w.bounds, B = so[y + 1].rightCacheBounds;
          E !== 0 && (v === 0 ? Yv(I, sh) : Kv(I, sh, sh)), v += E;
          let T = 0, S = 0;
          v !== 0 && (T = Fc(sh) / l);
          const D = i - v;
          D !== 0 && (S = Fc(B) / l);
          const R = qv + Im * (T * v + S * D);
          R < c && (a = h, c = R, o = w.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);
  return { axis: a, pos: o };
}
function sN(s, e, t, n) {
  let i = 0;
  for (let r = e, a = e + t; r < a; r++)
    i += s[r * 6 + n * 2];
  return i / t;
}
class Pm {
  constructor() {
    this.boundingData = new Float32Array(6);
  }
}
function oN(s, e, t, n, i, r) {
  let a = n, o = n + i - 1;
  const l = r.pos, c = r.axis * 2;
  for (; ; ) {
    for (; a <= o && t[a * 6 + c] < l; )
      a++;
    for (; a <= o && t[o * 6 + c] >= l; )
      o--;
    if (a < o) {
      for (let u = 0; u < 3; u++) {
        let f = e[a * 3 + u];
        e[a * 3 + u] = e[o * 3 + u], e[o * 3 + u] = f;
      }
      for (let u = 0; u < 6; u++) {
        let f = t[a * 6 + u];
        t[a * 6 + u] = t[o * 6 + u], t[o * 6 + u] = f;
      }
      a++, o--;
    } else
      return a;
  }
}
function aN(s, e, t, n, i, r) {
  let a = n, o = n + i - 1;
  const l = r.pos, c = r.axis * 2;
  for (; ; ) {
    for (; a <= o && t[a * 6 + c] < l; )
      a++;
    for (; a <= o && t[o * 6 + c] >= l; )
      o--;
    if (a < o) {
      let u = s[a];
      s[a] = s[o], s[o] = u;
      for (let f = 0; f < 6; f++) {
        let h = t[a * 6 + f];
        t[a * 6 + f] = t[o * 6 + f], t[o * 6 + f] = h;
      }
      a++, o--;
    } else
      return a;
  }
}
function Vi(s, e) {
  return e[s + 15] === 65535;
}
function Ki(s, e) {
  return e[s + 6];
}
function lr(s, e) {
  return e[s + 14];
}
function vr(s) {
  return s + 8;
}
function cr(s, e) {
  return e[s + 6];
}
function ZA(s, e) {
  return e[s + 7];
}
let CE, Kc, Rh, SE;
const lN = Math.pow(2, 32);
function Lg(s) {
  return "count" in s ? 1 : 1 + Lg(s.left) + Lg(s.right);
}
function cN(s, e, t) {
  return CE = new Float32Array(t), Kc = new Uint32Array(t), Rh = new Uint16Array(t), SE = new Uint8Array(t), kg(s, e);
}
function kg(s, e) {
  const t = s / 4, n = s / 2, i = "count" in e, r = e.boundingData;
  for (let a = 0; a < 6; a++)
    CE[t + a] = r[a];
  if (i)
    if (e.buffer) {
      const a = e.buffer;
      SE.set(new Uint8Array(a), s);
      for (let o = s, l = s + a.byteLength; o < l; o += mo) {
        const c = o / 2;
        Vi(c, Rh) || (Kc[o / 4 + 6] += t);
      }
      return s + a.byteLength;
    } else {
      const a = e.offset, o = e.count;
      return Kc[t + 6] = a, Rh[n + 14] = o, Rh[n + 15] = Nd, s + mo;
    }
  else {
    const a = e.left, o = e.right, l = e.splitAxis;
    let c;
    if (c = kg(s + mo, a), c / 4 > lN)
      throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
    return Kc[t + 6] = c / 4, c = kg(c, o), Kc[t + 7] = l, c;
  }
}
function uN(s, e) {
  const t = (s.index ? s.index.count : s.attributes.position.count) / 3, n = t > 2 ** 16, i = n ? 4 : 2, r = e ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i), a = n ? new Uint32Array(r) : new Uint16Array(r);
  for (let o = 0, l = a.length; o < l; o++)
    a[o] = o;
  return a;
}
function fN(s, e, t, n, i) {
  const {
    maxDepth: r,
    verbose: a,
    maxLeafTris: o,
    strategy: l,
    onProgress: c,
    indirect: u
  } = i, f = s._indirectBuffer, h = s.geometry, d = h.index ? h.index.array : null, m = u ? aN : oN, _ = sc(h), g = new Float32Array(6);
  let A = !1;
  const v = new Pm();
  return Bm(e, t, n, v.boundingData, g), w(v, t, n, g), v;
  function y(E) {
    c && c(E / _);
  }
  function w(E, I, C, B = null, T = 0) {
    if (!A && T >= r && (A = !0, a && (console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`), console.warn(h))), C <= o || T >= r)
      return y(I + C), E.offset = I, E.count = C, E;
    const S = rN(E.boundingData, B, e, I, C, l);
    if (S.axis === -1)
      return y(I + C), E.offset = I, E.count = C, E;
    const D = m(f, d, e, I, C, S);
    if (D === I || D === I + C)
      y(I + C), E.offset = I, E.count = C;
    else {
      E.splitAxis = S.axis;
      const R = new Pm(), P = I, L = D - I;
      E.left = R, Bm(e, P, L, R.boundingData, g), w(R, P, L, g, T + 1);
      const V = new Pm(), U = D, Q = C - L;
      E.right = V, Bm(e, U, Q, V.boundingData, g), w(V, U, Q, g, T + 1);
    }
    return E;
  }
}
function hN(s, e) {
  const t = s.geometry;
  e.indirect && (s._indirectBuffer = uN(t, e.useSharedArrayBuffer), tN(t) && !e.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), s._indirectBuffer || eN(t, e);
  const n = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = nN(t), r = e.indirect ? wE(t) : EE(t);
  s._roots = r.map((a) => {
    const o = fN(s, i, a.offset, a.count, e), l = Lg(o), c = new n(mo * l);
    return cN(0, o, c), c;
  });
}
class ks {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(e, t) {
    let n = 1 / 0, i = -1 / 0;
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r][t];
      n = l < n ? l : n, i = l > i ? l : i;
    }
    this.min = n, this.max = i;
  }
  setFromPoints(e, t) {
    let n = 1 / 0, i = -1 / 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const o = t[r], l = e.dot(o);
      n = l < n ? l : n, i = l > i ? l : i;
    }
    this.min = n, this.max = i;
  }
  isSeparated(e) {
    return this.min > e.max || e.min > this.max;
  }
}
ks.prototype.setFromBox = function() {
  const s = new H();
  return function(t, n) {
    const i = n.min, r = n.max;
    let a = 1 / 0, o = -1 / 0;
    for (let l = 0; l <= 1; l++)
      for (let c = 0; c <= 1; c++)
        for (let u = 0; u <= 1; u++) {
          s.x = i.x * l + r.x * (1 - l), s.y = i.y * c + r.y * (1 - c), s.z = i.z * u + r.z * (1 - u);
          const f = t.dot(s);
          a = Math.min(f, a), o = Math.max(f, o);
        }
    this.min = a, this.max = o;
  };
}();
const dN = function() {
  const s = new H(), e = new H(), t = new H();
  return function(i, r, a) {
    const o = i.start, l = s, c = r.start, u = e;
    t.subVectors(o, c), s.subVectors(i.end, i.start), e.subVectors(r.end, r.start);
    const f = t.dot(u), h = u.dot(l), d = u.dot(u), m = t.dot(l), g = l.dot(l) * d - h * h;
    let A, v;
    g !== 0 ? A = (f * h - m * d) / g : A = 0, v = (f + A * h) / d, a.x = A, a.y = v;
  };
}(), e0 = function() {
  const s = new ke(), e = new H(), t = new H();
  return function(i, r, a, o) {
    dN(i, r, s);
    let l = s.x, c = s.y;
    if (l >= 0 && l <= 1 && c >= 0 && c <= 1) {
      i.at(l, a), r.at(c, o);
      return;
    } else if (l >= 0 && l <= 1) {
      c < 0 ? r.at(0, o) : r.at(1, o), i.closestPointToPoint(o, !0, a);
      return;
    } else if (c >= 0 && c <= 1) {
      l < 0 ? i.at(0, a) : i.at(1, a), r.closestPointToPoint(a, !0, o);
      return;
    } else {
      let u;
      l < 0 ? u = i.start : u = i.end;
      let f;
      c < 0 ? f = r.start : f = r.end;
      const h = e, d = t;
      if (i.closestPointToPoint(f, !0, e), r.closestPointToPoint(u, !0, t), h.distanceToSquared(f) <= d.distanceToSquared(u)) {
        a.copy(h), o.copy(f);
        return;
      } else {
        a.copy(u), o.copy(d);
        return;
      }
    }
  };
}(), pN = function() {
  const s = new H(), e = new H(), t = new _r(), n = new os();
  return function(r, a) {
    const { radius: o, center: l } = r, { a: c, b: u, c: f } = a;
    if (n.start = c, n.end = u, n.closestPointToPoint(l, !0, s).distanceTo(l) <= o || (n.start = c, n.end = f, n.closestPointToPoint(l, !0, s).distanceTo(l) <= o) || (n.start = u, n.end = f, n.closestPointToPoint(l, !0, s).distanceTo(l) <= o))
      return !0;
    const _ = a.getPlane(t);
    if (Math.abs(_.distanceToPoint(l)) <= o) {
      const A = _.projectPoint(l, e);
      if (a.containsPoint(A))
        return !0;
    }
    return !1;
  };
}(), mN = 1e-15;
function Rm(s) {
  return Math.abs(s) < mN;
}
class Nr extends di {
  constructor(...e) {
    super(...e), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new H()), this.satBounds = new Array(4).fill().map(() => new ks()), this.points = [this.a, this.b, this.c], this.sphere = new Vn(), this.plane = new _r(), this.needsUpdate = !0;
  }
  intersectsSphere(e) {
    return pN(e, this);
  }
  update() {
    const e = this.a, t = this.b, n = this.c, i = this.points, r = this.satAxes, a = this.satBounds, o = r[0], l = a[0];
    this.getNormal(o), l.setFromPoints(o, i);
    const c = r[1], u = a[1];
    c.subVectors(e, t), u.setFromPoints(c, i);
    const f = r[2], h = a[2];
    f.subVectors(t, n), h.setFromPoints(f, i);
    const d = r[3], m = a[3];
    d.subVectors(n, e), m.setFromPoints(d, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, e), this.needsUpdate = !1;
  }
}
Nr.prototype.closestPointToSegment = function() {
  const s = new H(), e = new H(), t = new os();
  return function(i, r = null, a = null) {
    const { start: o, end: l } = i, c = this.points;
    let u, f = 1 / 0;
    for (let h = 0; h < 3; h++) {
      const d = (h + 1) % 3;
      t.start.copy(c[h]), t.end.copy(c[d]), e0(t, i, s, e), u = s.distanceToSquared(e), u < f && (f = u, r && r.copy(s), a && a.copy(e));
    }
    return this.closestPointToPoint(o, s), u = o.distanceToSquared(s), u < f && (f = u, r && r.copy(s), a && a.copy(o)), this.closestPointToPoint(l, s), u = l.distanceToSquared(s), u < f && (f = u, r && r.copy(s), a && a.copy(l)), Math.sqrt(f);
  };
}();
Nr.prototype.intersectsTriangle = function() {
  const s = new Nr(), e = new Array(3), t = new Array(3), n = new ks(), i = new ks(), r = new H(), a = new H(), o = new H(), l = new H(), c = new H(), u = new os(), f = new os(), h = new os(), d = new H();
  function m(_, g, A) {
    const v = _.points;
    let y = 0, w = -1;
    for (let E = 0; E < 3; E++) {
      const { start: I, end: C } = u;
      I.copy(v[E]), C.copy(v[(E + 1) % 3]), u.delta(a);
      const B = Rm(g.distanceToPoint(I));
      if (Rm(g.normal.dot(a)) && B) {
        A.copy(u), y = 2;
        break;
      }
      const T = g.intersectLine(u, d);
      if (!T && B && d.copy(I), (T || B) && !Rm(d.distanceTo(C))) {
        if (y <= 1)
          (y === 1 ? A.start : A.end).copy(d), B && (w = y);
        else if (y >= 2) {
          (w === 1 ? A.start : A.end).copy(d), y = 2;
          break;
        }
        if (y++, y === 2 && w === -1)
          break;
      }
    }
    return y;
  }
  return function(g, A = null, v = !1) {
    this.needsUpdate && this.update(), g.isExtendedTriangle ? g.needsUpdate && g.update() : (s.copy(g), s.update(), g = s);
    const y = this.plane, w = g.plane;
    if (Math.abs(y.normal.dot(w.normal)) > 1 - 1e-10) {
      const E = this.satBounds, I = this.satAxes;
      t[0] = g.a, t[1] = g.b, t[2] = g.c;
      for (let T = 0; T < 4; T++) {
        const S = E[T], D = I[T];
        if (n.setFromPoints(D, t), S.isSeparated(n))
          return !1;
      }
      const C = g.satBounds, B = g.satAxes;
      e[0] = this.a, e[1] = this.b, e[2] = this.c;
      for (let T = 0; T < 4; T++) {
        const S = C[T], D = B[T];
        if (n.setFromPoints(D, e), S.isSeparated(n))
          return !1;
      }
      for (let T = 0; T < 4; T++) {
        const S = I[T];
        for (let D = 0; D < 4; D++) {
          const R = B[D];
          if (r.crossVectors(S, R), n.setFromPoints(r, e), i.setFromPoints(r, t), n.isSeparated(i))
            return !1;
        }
      }
      return A && (v || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), A.start.set(0, 0, 0), A.end.set(0, 0, 0)), !0;
    } else {
      const E = m(this, w, f);
      if (E === 1 && g.containsPoint(f.end))
        return A && (A.start.copy(f.end), A.end.copy(f.end)), !0;
      if (E !== 2)
        return !1;
      const I = m(g, y, h);
      if (I === 1 && this.containsPoint(h.end))
        return A && (A.start.copy(h.end), A.end.copy(h.end)), !0;
      if (I !== 2)
        return !1;
      if (f.delta(o), h.delta(l), o.dot(l) < 0) {
        let P = h.start;
        h.start = h.end, h.end = P;
      }
      const C = f.start.dot(o), B = f.end.dot(o), T = h.start.dot(o), S = h.end.dot(o), D = B < T, R = C < S;
      return C !== S && T !== B && D === R ? !1 : (A && (c.subVectors(f.start, h.start), c.dot(o) > 0 ? A.start.copy(f.start) : A.start.copy(h.start), c.subVectors(f.end, h.end), c.dot(o) < 0 ? A.end.copy(f.end) : A.end.copy(h.end)), !0);
    }
  };
}();
Nr.prototype.distanceToPoint = function() {
  const s = new H();
  return function(t) {
    return this.closestPointToPoint(t, s), t.distanceTo(s);
  };
}();
Nr.prototype.distanceToTriangle = function() {
  const s = new H(), e = new H(), t = ["a", "b", "c"], n = new os(), i = new os();
  return function(a, o = null, l = null) {
    const c = o || l ? n : null;
    if (this.intersectsTriangle(a, c))
      return (o || l) && (o && c.getCenter(o), l && c.getCenter(l)), 0;
    let u = 1 / 0;
    for (let f = 0; f < 3; f++) {
      let h;
      const d = t[f], m = a[d];
      this.closestPointToPoint(m, s), h = m.distanceToSquared(s), h < u && (u = h, o && o.copy(s), l && l.copy(m));
      const _ = this[d];
      a.closestPointToPoint(_, s), h = _.distanceToSquared(s), h < u && (u = h, o && o.copy(_), l && l.copy(s));
    }
    for (let f = 0; f < 3; f++) {
      const h = t[f], d = t[(f + 1) % 3];
      n.set(this[h], this[d]);
      for (let m = 0; m < 3; m++) {
        const _ = t[m], g = t[(m + 1) % 3];
        i.set(a[_], a[g]), e0(n, i, s, e);
        const A = s.distanceToSquared(e);
        A < u && (u = A, o && o.copy(s), l && l.copy(e));
      }
    }
    return Math.sqrt(u);
  };
}();
class Wi {
  constructor(e, t, n) {
    this.isOrientedBox = !0, this.min = new H(), this.max = new H(), this.matrix = new st(), this.invMatrix = new st(), this.points = new Array(8).fill().map(() => new H()), this.satAxes = new Array(3).fill().map(() => new H()), this.satBounds = new Array(3).fill().map(() => new ks()), this.alignedSatBounds = new Array(3).fill().map(() => new ks()), this.needsUpdate = !1, e && this.min.copy(e), t && this.max.copy(t), n && this.matrix.copy(n);
  }
  set(e, t, n) {
    this.min.copy(e), this.max.copy(t), this.matrix.copy(n), this.needsUpdate = !0;
  }
  copy(e) {
    this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = !0;
  }
}
Wi.prototype.update = function() {
  return function() {
    const e = this.matrix, t = this.min, n = this.max, i = this.points;
    for (let c = 0; c <= 1; c++)
      for (let u = 0; u <= 1; u++)
        for (let f = 0; f <= 1; f++) {
          const h = 1 * c | 2 * u | 4 * f, d = i[h];
          d.x = c ? n.x : t.x, d.y = u ? n.y : t.y, d.z = f ? n.z : t.z, d.applyMatrix4(e);
        }
    const r = this.satBounds, a = this.satAxes, o = i[0];
    for (let c = 0; c < 3; c++) {
      const u = a[c], f = r[c], h = 1 << c, d = i[h];
      u.subVectors(o, d), f.setFromPoints(u, i);
    }
    const l = this.alignedSatBounds;
    l[0].setFromPointsField(i, "x"), l[1].setFromPointsField(i, "y"), l[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
}();
Wi.prototype.intersectsBox = function() {
  const s = new ks();
  return function(t) {
    this.needsUpdate && this.update();
    const n = t.min, i = t.max, r = this.satBounds, a = this.satAxes, o = this.alignedSatBounds;
    if (s.min = n.x, s.max = i.x, o[0].isSeparated(s) || (s.min = n.y, s.max = i.y, o[1].isSeparated(s)) || (s.min = n.z, s.max = i.z, o[2].isSeparated(s)))
      return !1;
    for (let l = 0; l < 3; l++) {
      const c = a[l], u = r[l];
      if (s.setFromBox(c, t), u.isSeparated(s))
        return !1;
    }
    return !0;
  };
}();
Wi.prototype.intersectsTriangle = function() {
  const s = new Nr(), e = new Array(3), t = new ks(), n = new ks(), i = new H();
  return function(a) {
    this.needsUpdate && this.update(), a.isExtendedTriangle ? a.needsUpdate && a.update() : (s.copy(a), s.update(), a = s);
    const o = this.satBounds, l = this.satAxes;
    e[0] = a.a, e[1] = a.b, e[2] = a.c;
    for (let h = 0; h < 3; h++) {
      const d = o[h], m = l[h];
      if (t.setFromPoints(m, e), d.isSeparated(t))
        return !1;
    }
    const c = a.satBounds, u = a.satAxes, f = this.points;
    for (let h = 0; h < 3; h++) {
      const d = c[h], m = u[h];
      if (t.setFromPoints(m, f), d.isSeparated(t))
        return !1;
    }
    for (let h = 0; h < 3; h++) {
      const d = l[h];
      for (let m = 0; m < 4; m++) {
        const _ = u[m];
        if (i.crossVectors(d, _), t.setFromPoints(i, e), n.setFromPoints(i, f), t.isSeparated(n))
          return !1;
      }
    }
    return !0;
  };
}();
Wi.prototype.closestPointToPoint = function() {
  return function(e, t) {
    return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
Wi.prototype.distanceToPoint = function() {
  const s = new H();
  return function(t) {
    return this.closestPointToPoint(t, s), t.distanceTo(s);
  };
}();
Wi.prototype.distanceToBox = function() {
  const s = ["x", "y", "z"], e = new Array(12).fill().map(() => new os()), t = new Array(12).fill().map(() => new os()), n = new H(), i = new H();
  return function(a, o = 0, l = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(a))
      return (l || c) && (a.getCenter(i), this.closestPointToPoint(i, n), a.closestPointToPoint(n, i), l && l.copy(n), c && c.copy(i)), 0;
    const u = o * o, f = a.min, h = a.max, d = this.points;
    let m = 1 / 0;
    for (let g = 0; g < 8; g++) {
      const A = d[g];
      i.copy(A).clamp(f, h);
      const v = A.distanceToSquared(i);
      if (v < m && (m = v, l && l.copy(A), c && c.copy(i), v < u))
        return Math.sqrt(v);
    }
    let _ = 0;
    for (let g = 0; g < 3; g++)
      for (let A = 0; A <= 1; A++)
        for (let v = 0; v <= 1; v++) {
          const y = (g + 1) % 3, w = (g + 2) % 3, E = A << y | v << w, I = 1 << g | A << y | v << w, C = d[E], B = d[I];
          e[_].set(C, B);
          const S = s[g], D = s[y], R = s[w], P = t[_], L = P.start, V = P.end;
          L[S] = f[S], L[D] = A ? f[D] : h[D], L[R] = v ? f[R] : h[D], V[S] = h[S], V[D] = A ? f[D] : h[D], V[R] = v ? f[R] : h[D], _++;
        }
    for (let g = 0; g <= 1; g++)
      for (let A = 0; A <= 1; A++)
        for (let v = 0; v <= 1; v++) {
          i.x = g ? h.x : f.x, i.y = A ? h.y : f.y, i.z = v ? h.z : f.z, this.closestPointToPoint(i, n);
          const y = i.distanceToSquared(n);
          if (y < m && (m = y, l && l.copy(n), c && c.copy(i), y < u))
            return Math.sqrt(y);
        }
    for (let g = 0; g < 12; g++) {
      const A = e[g];
      for (let v = 0; v < 12; v++) {
        const y = t[v];
        e0(A, y, n, i);
        const w = n.distanceToSquared(i);
        if (w < m && (m = w, l && l.copy(n), c && c.copy(i), w < u))
          return Math.sqrt(w);
      }
    }
    return Math.sqrt(m);
  };
}();
class t0 {
  constructor(e) {
    this._getNewPrimitive = e, this._primitives = [];
  }
  getPrimitive() {
    const e = this._primitives;
    return e.length === 0 ? this._getNewPrimitive() : e.pop();
  }
  releasePrimitive(e) {
    this._primitives.push(e);
  }
}
class gN extends t0 {
  constructor() {
    super(() => new Nr());
  }
}
const yr = /* @__PURE__ */ new gN();
class AN {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const e = [];
    let t = null;
    this.setBuffer = (n) => {
      t && e.push(t), t = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, e.length !== 0 && this.setBuffer(e.pop());
    };
  }
}
const Cn = new AN();
let fo, El;
const al = [], oh = /* @__PURE__ */ new t0(() => new dn());
function _N(s, e, t, n, i, r) {
  fo = oh.getPrimitive(), El = oh.getPrimitive(), al.push(fo, El), Cn.setBuffer(s._roots[e]);
  const a = Ug(0, s.geometry, t, n, i, r);
  Cn.clearBuffer(), oh.releasePrimitive(fo), oh.releasePrimitive(El), al.pop(), al.pop();
  const o = al.length;
  return o > 0 && (El = al[o - 1], fo = al[o - 2]), a;
}
function Ug(s, e, t, n, i = null, r = 0, a = 0) {
  const { float32Array: o, uint16Array: l, uint32Array: c } = Cn;
  let u = s * 2;
  if (Vi(u, l)) {
    const m = Ki(s, c), _ = lr(u, l);
    return kn(s, o, fo), n(m, _, !1, a, r + s, fo);
  } else {
    let R = function(L) {
      const { uint16Array: V, uint32Array: U } = Cn;
      let Q = L * 2;
      for (; !Vi(Q, V); )
        L = vr(L), Q = L * 2;
      return Ki(L, U);
    }, P = function(L) {
      const { uint16Array: V, uint32Array: U } = Cn;
      let Q = L * 2;
      for (; !Vi(Q, V); )
        L = cr(L, U), Q = L * 2;
      return Ki(L, U) + lr(Q, V);
    };
    var h = R, d = P;
    const m = vr(s), _ = cr(s, c);
    let g = m, A = _, v, y, w, E;
    if (i && (w = fo, E = El, kn(g, o, w), kn(A, o, E), v = i(w), y = i(E), y < v)) {
      g = _, A = m;
      const L = v;
      v = y, y = L, w = E;
    }
    w || (w = fo, kn(g, o, w));
    const I = Vi(g * 2, l), C = t(w, I, v, a + 1, r + g);
    let B;
    if (C === Wv) {
      const L = R(g), U = P(g) - L;
      B = n(L, U, !0, a + 1, r + g, w);
    } else
      B = C && Ug(
        g,
        e,
        t,
        n,
        i,
        r,
        a + 1
      );
    if (B)
      return !0;
    E = El, kn(A, o, E);
    const T = Vi(A * 2, l), S = t(E, T, y, a + 1, r + A);
    let D;
    if (S === Wv) {
      const L = R(A), U = P(A) - L;
      D = n(L, U, !0, a + 1, r + A, E);
    } else
      D = S && Ug(
        A,
        e,
        t,
        n,
        i,
        r,
        a + 1
      );
    return !!D;
  }
}
const Oc = /* @__PURE__ */ new H(), Dm = /* @__PURE__ */ new H();
function bN(s, e, t = {}, n = 0, i = 1 / 0) {
  const r = n * n, a = i * i;
  let o = 1 / 0, l = null;
  if (s.shapecast(
    {
      boundsTraverseOrder: (u) => (Oc.copy(e).clamp(u.min, u.max), Oc.distanceToSquared(e)),
      intersectsBounds: (u, f, h) => h < o && h < a,
      intersectsTriangle: (u, f) => {
        u.closestPointToPoint(e, Oc);
        const h = e.distanceToSquared(Oc);
        return h < o && (Dm.copy(Oc), o = h, l = f), h < r;
      }
    }
  ), o === 1 / 0)
    return null;
  const c = Math.sqrt(o);
  return t.point ? t.point.copy(Dm) : t.point = Dm.clone(), t.distance = c, t.faceIndex = l, t;
}
const ll = /* @__PURE__ */ new H(), cl = /* @__PURE__ */ new H(), ul = /* @__PURE__ */ new H(), ah = /* @__PURE__ */ new ke(), lh = /* @__PURE__ */ new ke(), ch = /* @__PURE__ */ new ke(), Jv = /* @__PURE__ */ new H(), Zv = /* @__PURE__ */ new H(), ey = /* @__PURE__ */ new H(), uh = /* @__PURE__ */ new H();
function vN(s, e, t, n, i, r) {
  let a;
  return r === Kn ? a = s.intersectTriangle(n, t, e, !0, i) : a = s.intersectTriangle(e, t, n, r !== zn, i), a === null ? null : {
    distance: s.origin.distanceTo(i),
    point: i.clone()
  };
}
function yN(s, e, t, n, i, r, a, o, l) {
  ll.fromBufferAttribute(e, r), cl.fromBufferAttribute(e, a), ul.fromBufferAttribute(e, o);
  const c = vN(s, ll, cl, ul, uh, l);
  if (c) {
    n && (ah.fromBufferAttribute(n, r), lh.fromBufferAttribute(n, a), ch.fromBufferAttribute(n, o), c.uv = di.getInterpolation(uh, ll, cl, ul, ah, lh, ch, new ke())), i && (ah.fromBufferAttribute(i, r), lh.fromBufferAttribute(i, a), ch.fromBufferAttribute(i, o), c.uv1 = di.getInterpolation(uh, ll, cl, ul, ah, lh, ch, new ke())), t && (Jv.fromBufferAttribute(t, r), Zv.fromBufferAttribute(t, a), ey.fromBufferAttribute(t, o), c.normal = di.getInterpolation(uh, ll, cl, ul, Jv, Zv, ey, new H()), c.normal.dot(s.direction) > 0 && c.normal.multiplyScalar(-1));
    const u = {
      a: r,
      b: a,
      c: o,
      normal: new H(),
      materialIndex: 0
    };
    di.getNormal(ll, cl, ul, u.normal), c.face = u, c.faceIndex = r;
  }
  return c;
}
function Gd(s, e, t, n, i) {
  const r = n * 3;
  let a = r + 0, o = r + 1, l = r + 2;
  const c = s.index;
  s.index && (a = c.getX(a), o = c.getX(o), l = c.getX(l));
  const { position: u, normal: f, uv: h, uv1: d } = s.attributes, m = yN(t, u, f, h, d, a, o, l, e);
  return m ? (m.faceIndex = n, i && i.push(m), m) : null;
}
function Yn(s, e, t, n) {
  const i = s.a, r = s.b, a = s.c;
  let o = e, l = e + 1, c = e + 2;
  t && (o = t.getX(o), l = t.getX(l), c = t.getX(c)), i.x = n.getX(o), i.y = n.getY(o), i.z = n.getZ(o), r.x = n.getX(l), r.y = n.getY(l), r.z = n.getZ(l), a.x = n.getX(c), a.y = n.getY(c), a.z = n.getZ(c);
}
function xN(s, e, t, n, i, r) {
  const { geometry: a, _indirectBuffer: o } = s;
  for (let l = n, c = n + i; l < c; l++)
    Gd(a, e, t, l, r);
}
function wN(s, e, t, n, i) {
  const { geometry: r, _indirectBuffer: a } = s;
  let o = 1 / 0, l = null;
  for (let c = n, u = n + i; c < u; c++) {
    let f;
    f = Gd(r, e, t, c), f && f.distance < o && (l = f, o = f.distance);
  }
  return l;
}
function EN(s, e, t, n, i, r, a) {
  const { geometry: o } = t, { index: l } = o, c = o.attributes.position;
  for (let u = s, f = e + s; u < f; u++) {
    let h;
    if (h = u, Yn(a, h * 3, l, c), a.needsUpdate = !0, n(a, h, i, r))
      return !0;
  }
  return !1;
}
function CN(s, e = null) {
  e && Array.isArray(e) && (e = new Set(e));
  const t = s.geometry, n = t.index ? t.index.array : null, i = t.attributes.position;
  let r, a, o, l, c = 0;
  const u = s._roots;
  for (let h = 0, d = u.length; h < d; h++)
    r = u[h], a = new Uint32Array(r), o = new Uint16Array(r), l = new Float32Array(r), f(0, c), c += r.byteLength;
  function f(h, d, m = !1) {
    const _ = h * 2;
    if (o[_ + 15] === Nd) {
      const A = a[h + 6], v = o[_ + 14];
      let y = 1 / 0, w = 1 / 0, E = 1 / 0, I = -1 / 0, C = -1 / 0, B = -1 / 0;
      for (let T = 3 * A, S = 3 * (A + v); T < S; T++) {
        let D = n[T];
        const R = i.getX(D), P = i.getY(D), L = i.getZ(D);
        R < y && (y = R), R > I && (I = R), P < w && (w = P), P > C && (C = P), L < E && (E = L), L > B && (B = L);
      }
      return l[h + 0] !== y || l[h + 1] !== w || l[h + 2] !== E || l[h + 3] !== I || l[h + 4] !== C || l[h + 5] !== B ? (l[h + 0] = y, l[h + 1] = w, l[h + 2] = E, l[h + 3] = I, l[h + 4] = C, l[h + 5] = B, !0) : !1;
    } else {
      const A = h + 8, v = a[h + 6], y = A + d, w = v + d;
      let E = m, I = !1, C = !1;
      e ? E || (I = e.has(y), C = e.has(w), E = !I && !C) : (I = !0, C = !0);
      const B = E || I, T = E || C;
      let S = !1;
      B && (S = f(A, d, E));
      let D = !1;
      T && (D = f(v, d, E));
      const R = S || D;
      if (R)
        for (let P = 0; P < 3; P++) {
          const L = A + P, V = v + P, U = l[L], Q = l[L + 3], q = l[V], oe = l[V + 3];
          l[h + P] = U < q ? U : q, l[h + P + 3] = Q > oe ? Q : oe;
        }
      return R;
    }
  }
}
function bo(s, e, t) {
  let n, i, r, a, o, l;
  const c = 1 / t.direction.x, u = 1 / t.direction.y, f = 1 / t.direction.z, h = t.origin.x, d = t.origin.y, m = t.origin.z;
  let _ = e[s], g = e[s + 3], A = e[s + 1], v = e[s + 3 + 1], y = e[s + 2], w = e[s + 3 + 2];
  return c >= 0 ? (n = (_ - h) * c, i = (g - h) * c) : (n = (g - h) * c, i = (_ - h) * c), u >= 0 ? (r = (A - d) * u, a = (v - d) * u) : (r = (v - d) * u, a = (A - d) * u), !(n > a || r > i || ((r > n || isNaN(n)) && (n = r), (a < i || isNaN(i)) && (i = a), f >= 0 ? (o = (y - m) * f, l = (w - m) * f) : (o = (w - m) * f, l = (y - m) * f), n > l || o > i) || ((l < i || i !== i) && (i = l), i < 0));
}
function SN(s, e, t, n, i, r) {
  const { geometry: a, _indirectBuffer: o } = s;
  for (let l = n, c = n + i; l < c; l++) {
    let u = o ? o[l] : l;
    Gd(a, e, t, u, r);
  }
}
function MN(s, e, t, n, i) {
  const { geometry: r, _indirectBuffer: a } = s;
  let o = 1 / 0, l = null;
  for (let c = n, u = n + i; c < u; c++) {
    let f;
    f = Gd(r, e, t, a ? a[c] : c), f && f.distance < o && (l = f, o = f.distance);
  }
  return l;
}
function IN(s, e, t, n, i, r, a) {
  const { geometry: o } = t, { index: l } = o, c = o.attributes.position;
  for (let u = s, f = e + s; u < f; u++) {
    let h;
    if (h = t.resolveTriangleIndex(u), Yn(a, h * 3, l, c), a.needsUpdate = !0, n(a, h, i, r))
      return !0;
  }
  return !1;
}
function TN(s, e, t, n, i) {
  Cn.setBuffer(s._roots[e]), Fg(0, s, t, n, i), Cn.clearBuffer();
}
function Fg(s, e, t, n, i) {
  const { float32Array: r, uint16Array: a, uint32Array: o } = Cn, l = s * 2;
  if (Vi(l, a)) {
    const u = Ki(s, o), f = lr(l, a);
    xN(e, t, n, u, f, i);
  } else {
    const u = vr(s);
    bo(u, r, n) && Fg(u, e, t, n, i);
    const f = cr(s, o);
    bo(f, r, n) && Fg(f, e, t, n, i);
  }
}
const BN = ["x", "y", "z"];
function PN(s, e, t, n) {
  Cn.setBuffer(s._roots[e]);
  const i = Og(0, s, t, n);
  return Cn.clearBuffer(), i;
}
function Og(s, e, t, n) {
  const { float32Array: i, uint16Array: r, uint32Array: a } = Cn;
  let o = s * 2;
  if (Vi(o, r)) {
    const c = Ki(s, a), u = lr(o, r);
    return wN(e, t, n, c, u);
  } else {
    const c = ZA(s, a), u = BN[c], h = n.direction[u] >= 0;
    let d, m;
    h ? (d = vr(s), m = cr(s, a)) : (d = cr(s, a), m = vr(s));
    const g = bo(d, i, n) ? Og(d, e, t, n) : null;
    if (g) {
      const y = g.point[u];
      if (h ? y <= i[m + c] : (
        // min bounding data
        y >= i[m + c + 3]
      ))
        return g;
    }
    const v = bo(m, i, n) ? Og(m, e, t, n) : null;
    return g && v ? g.distance <= v.distance ? g : v : g || v || null;
  }
}
const fh = /* @__PURE__ */ new dn(), fl = /* @__PURE__ */ new Nr(), hl = /* @__PURE__ */ new Nr(), Nc = /* @__PURE__ */ new st(), ty = /* @__PURE__ */ new Wi(), hh = /* @__PURE__ */ new Wi();
function RN(s, e, t, n) {
  Cn.setBuffer(s._roots[e]);
  const i = Ng(0, s, t, n);
  return Cn.clearBuffer(), i;
}
function Ng(s, e, t, n, i = null) {
  const { float32Array: r, uint16Array: a, uint32Array: o } = Cn;
  let l = s * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), ty.set(t.boundingBox.min, t.boundingBox.max, n), i = ty), Vi(l, a)) {
    const u = e.geometry, f = u.index, h = u.attributes.position, d = t.index, m = t.attributes.position, _ = Ki(s, o), g = lr(l, a);
    if (Nc.copy(n).invert(), t.boundsTree)
      return kn(s, r, hh), hh.matrix.copy(Nc), hh.needsUpdate = !0, t.boundsTree.shapecast({
        intersectsBounds: (v) => hh.intersectsBox(v),
        intersectsTriangle: (v) => {
          v.a.applyMatrix4(n), v.b.applyMatrix4(n), v.c.applyMatrix4(n), v.needsUpdate = !0;
          for (let y = _ * 3, w = (g + _) * 3; y < w; y += 3)
            if (Yn(hl, y, f, h), hl.needsUpdate = !0, v.intersectsTriangle(hl))
              return !0;
          return !1;
        }
      });
    for (let A = _ * 3, v = (g + _) * 3; A < v; A += 3) {
      Yn(fl, A, f, h), fl.a.applyMatrix4(Nc), fl.b.applyMatrix4(Nc), fl.c.applyMatrix4(Nc), fl.needsUpdate = !0;
      for (let y = 0, w = d.count; y < w; y += 3)
        if (Yn(hl, y, d, m), hl.needsUpdate = !0, fl.intersectsTriangle(hl))
          return !0;
    }
  } else {
    const u = s + 8, f = o[s + 6];
    return kn(u, r, fh), !!(i.intersectsBox(fh) && Ng(u, e, t, n, i) || (kn(f, r, fh), i.intersectsBox(fh) && Ng(f, e, t, n, i)));
  }
}
const dh = /* @__PURE__ */ new st(), Lm = /* @__PURE__ */ new Wi(), Gc = /* @__PURE__ */ new Wi(), DN = /* @__PURE__ */ new H(), LN = /* @__PURE__ */ new H(), kN = /* @__PURE__ */ new H(), UN = /* @__PURE__ */ new H();
function FN(s, e, t, n = {}, i = {}, r = 0, a = 1 / 0) {
  e.boundingBox || e.computeBoundingBox(), Lm.set(e.boundingBox.min, e.boundingBox.max, t), Lm.needsUpdate = !0;
  const o = s.geometry, l = o.attributes.position, c = o.index, u = e.attributes.position, f = e.index, h = yr.getPrimitive(), d = yr.getPrimitive();
  let m = DN, _ = LN, g = null, A = null;
  i && (g = kN, A = UN);
  let v = 1 / 0, y = null, w = null;
  return dh.copy(t).invert(), Gc.matrix.copy(dh), s.shapecast(
    {
      boundsTraverseOrder: (E) => Lm.distanceToBox(E),
      intersectsBounds: (E, I, C) => C < v && C < a ? (I && (Gc.min.copy(E.min), Gc.max.copy(E.max), Gc.needsUpdate = !0), !0) : !1,
      intersectsRange: (E, I) => {
        if (e.boundsTree)
          return e.boundsTree.shapecast({
            boundsTraverseOrder: (B) => Gc.distanceToBox(B),
            intersectsBounds: (B, T, S) => S < v && S < a,
            intersectsRange: (B, T) => {
              for (let S = B, D = B + T; S < D; S++) {
                Yn(d, 3 * S, f, u), d.a.applyMatrix4(t), d.b.applyMatrix4(t), d.c.applyMatrix4(t), d.needsUpdate = !0;
                for (let R = E, P = E + I; R < P; R++) {
                  Yn(h, 3 * R, c, l), h.needsUpdate = !0;
                  const L = h.distanceToTriangle(d, m, g);
                  if (L < v && (_.copy(m), A && A.copy(g), v = L, y = R, w = S), L < r)
                    return !0;
                }
              }
            }
          });
        {
          const C = sc(e);
          for (let B = 0, T = C; B < T; B++) {
            Yn(d, 3 * B, f, u), d.a.applyMatrix4(t), d.b.applyMatrix4(t), d.c.applyMatrix4(t), d.needsUpdate = !0;
            for (let S = E, D = E + I; S < D; S++) {
              Yn(h, 3 * S, c, l), h.needsUpdate = !0;
              const R = h.distanceToTriangle(d, m, g);
              if (R < v && (_.copy(m), A && A.copy(g), v = R, y = S, w = B), R < r)
                return !0;
            }
          }
        }
      }
    }
  ), yr.releasePrimitive(h), yr.releasePrimitive(d), v === 1 / 0 ? null : (n.point ? n.point.copy(_) : n.point = _.clone(), n.distance = v, n.faceIndex = y, i && (i.point ? i.point.copy(A) : i.point = A.clone(), i.point.applyMatrix4(dh), _.applyMatrix4(dh), i.distance = _.sub(i.point).length(), i.faceIndex = w), n);
}
function ON(s, e = null) {
  e && Array.isArray(e) && (e = new Set(e));
  const t = s.geometry, n = t.index ? t.index.array : null, i = t.attributes.position;
  let r, a, o, l, c = 0;
  const u = s._roots;
  for (let h = 0, d = u.length; h < d; h++)
    r = u[h], a = new Uint32Array(r), o = new Uint16Array(r), l = new Float32Array(r), f(0, c), c += r.byteLength;
  function f(h, d, m = !1) {
    const _ = h * 2;
    if (o[_ + 15] === Nd) {
      const A = a[h + 6], v = o[_ + 14];
      let y = 1 / 0, w = 1 / 0, E = 1 / 0, I = -1 / 0, C = -1 / 0, B = -1 / 0;
      for (let T = A, S = A + v; T < S; T++) {
        const D = 3 * s.resolveTriangleIndex(T);
        for (let R = 0; R < 3; R++) {
          let P = D + R;
          P = n ? n[P] : P;
          const L = i.getX(P), V = i.getY(P), U = i.getZ(P);
          L < y && (y = L), L > I && (I = L), V < w && (w = V), V > C && (C = V), U < E && (E = U), U > B && (B = U);
        }
      }
      return l[h + 0] !== y || l[h + 1] !== w || l[h + 2] !== E || l[h + 3] !== I || l[h + 4] !== C || l[h + 5] !== B ? (l[h + 0] = y, l[h + 1] = w, l[h + 2] = E, l[h + 3] = I, l[h + 4] = C, l[h + 5] = B, !0) : !1;
    } else {
      const A = h + 8, v = a[h + 6], y = A + d, w = v + d;
      let E = m, I = !1, C = !1;
      e ? E || (I = e.has(y), C = e.has(w), E = !I && !C) : (I = !0, C = !0);
      const B = E || I, T = E || C;
      let S = !1;
      B && (S = f(A, d, E));
      let D = !1;
      T && (D = f(v, d, E));
      const R = S || D;
      if (R)
        for (let P = 0; P < 3; P++) {
          const L = A + P, V = v + P, U = l[L], Q = l[L + 3], q = l[V], oe = l[V + 3];
          l[h + P] = U < q ? U : q, l[h + P + 3] = Q > oe ? Q : oe;
        }
      return R;
    }
  }
}
function NN(s, e, t, n, i) {
  Cn.setBuffer(s._roots[e]), Gg(0, s, t, n, i), Cn.clearBuffer();
}
function Gg(s, e, t, n, i) {
  const { float32Array: r, uint16Array: a, uint32Array: o } = Cn, l = s * 2;
  if (Vi(l, a)) {
    const u = Ki(s, o), f = lr(l, a);
    SN(e, t, n, u, f, i);
  } else {
    const u = vr(s);
    bo(u, r, n) && Gg(u, e, t, n, i);
    const f = cr(s, o);
    bo(f, r, n) && Gg(f, e, t, n, i);
  }
}
const GN = ["x", "y", "z"];
function QN(s, e, t, n) {
  Cn.setBuffer(s._roots[e]);
  const i = Qg(0, s, t, n);
  return Cn.clearBuffer(), i;
}
function Qg(s, e, t, n) {
  const { float32Array: i, uint16Array: r, uint32Array: a } = Cn;
  let o = s * 2;
  if (Vi(o, r)) {
    const c = Ki(s, a), u = lr(o, r);
    return MN(e, t, n, c, u);
  } else {
    const c = ZA(s, a), u = GN[c], h = n.direction[u] >= 0;
    let d, m;
    h ? (d = vr(s), m = cr(s, a)) : (d = cr(s, a), m = vr(s));
    const g = bo(d, i, n) ? Qg(d, e, t, n) : null;
    if (g) {
      const y = g.point[u];
      if (h ? y <= i[m + c] : (
        // min bounding data
        y >= i[m + c + 3]
      ))
        return g;
    }
    const v = bo(m, i, n) ? Qg(m, e, t, n) : null;
    return g && v ? g.distance <= v.distance ? g : v : g || v || null;
  }
}
const ph = /* @__PURE__ */ new dn(), dl = /* @__PURE__ */ new Nr(), pl = /* @__PURE__ */ new Nr(), Qc = /* @__PURE__ */ new st(), ny = /* @__PURE__ */ new Wi(), mh = /* @__PURE__ */ new Wi();
function zN(s, e, t, n) {
  Cn.setBuffer(s._roots[e]);
  const i = zg(0, s, t, n);
  return Cn.clearBuffer(), i;
}
function zg(s, e, t, n, i = null) {
  const { float32Array: r, uint16Array: a, uint32Array: o } = Cn;
  let l = s * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), ny.set(t.boundingBox.min, t.boundingBox.max, n), i = ny), Vi(l, a)) {
    const u = e.geometry, f = u.index, h = u.attributes.position, d = t.index, m = t.attributes.position, _ = Ki(s, o), g = lr(l, a);
    if (Qc.copy(n).invert(), t.boundsTree)
      return kn(s, r, mh), mh.matrix.copy(Qc), mh.needsUpdate = !0, t.boundsTree.shapecast({
        intersectsBounds: (v) => mh.intersectsBox(v),
        intersectsTriangle: (v) => {
          v.a.applyMatrix4(n), v.b.applyMatrix4(n), v.c.applyMatrix4(n), v.needsUpdate = !0;
          for (let y = _, w = g + _; y < w; y++)
            if (Yn(pl, 3 * e.resolveTriangleIndex(y), f, h), pl.needsUpdate = !0, v.intersectsTriangle(pl))
              return !0;
          return !1;
        }
      });
    for (let A = _, v = g + _; A < v; A++) {
      const y = e.resolveTriangleIndex(A);
      Yn(dl, 3 * y, f, h), dl.a.applyMatrix4(Qc), dl.b.applyMatrix4(Qc), dl.c.applyMatrix4(Qc), dl.needsUpdate = !0;
      for (let w = 0, E = d.count; w < E; w += 3)
        if (Yn(pl, w, d, m), pl.needsUpdate = !0, dl.intersectsTriangle(pl))
          return !0;
    }
  } else {
    const u = s + 8, f = o[s + 6];
    return kn(u, r, ph), !!(i.intersectsBox(ph) && zg(u, e, t, n, i) || (kn(f, r, ph), i.intersectsBox(ph) && zg(f, e, t, n, i)));
  }
}
const gh = /* @__PURE__ */ new st(), km = /* @__PURE__ */ new Wi(), zc = /* @__PURE__ */ new Wi(), $N = /* @__PURE__ */ new H(), VN = /* @__PURE__ */ new H(), HN = /* @__PURE__ */ new H(), jN = /* @__PURE__ */ new H();
function WN(s, e, t, n = {}, i = {}, r = 0, a = 1 / 0) {
  e.boundingBox || e.computeBoundingBox(), km.set(e.boundingBox.min, e.boundingBox.max, t), km.needsUpdate = !0;
  const o = s.geometry, l = o.attributes.position, c = o.index, u = e.attributes.position, f = e.index, h = yr.getPrimitive(), d = yr.getPrimitive();
  let m = $N, _ = VN, g = null, A = null;
  i && (g = HN, A = jN);
  let v = 1 / 0, y = null, w = null;
  return gh.copy(t).invert(), zc.matrix.copy(gh), s.shapecast(
    {
      boundsTraverseOrder: (E) => km.distanceToBox(E),
      intersectsBounds: (E, I, C) => C < v && C < a ? (I && (zc.min.copy(E.min), zc.max.copy(E.max), zc.needsUpdate = !0), !0) : !1,
      intersectsRange: (E, I) => {
        if (e.boundsTree) {
          const C = e.boundsTree;
          return C.shapecast({
            boundsTraverseOrder: (B) => zc.distanceToBox(B),
            intersectsBounds: (B, T, S) => S < v && S < a,
            intersectsRange: (B, T) => {
              for (let S = B, D = B + T; S < D; S++) {
                const R = C.resolveTriangleIndex(S);
                Yn(d, 3 * R, f, u), d.a.applyMatrix4(t), d.b.applyMatrix4(t), d.c.applyMatrix4(t), d.needsUpdate = !0;
                for (let P = E, L = E + I; P < L; P++) {
                  const V = s.resolveTriangleIndex(P);
                  Yn(h, 3 * V, c, l), h.needsUpdate = !0;
                  const U = h.distanceToTriangle(d, m, g);
                  if (U < v && (_.copy(m), A && A.copy(g), v = U, y = P, w = S), U < r)
                    return !0;
                }
              }
            }
          });
        } else {
          const C = sc(e);
          for (let B = 0, T = C; B < T; B++) {
            Yn(d, 3 * B, f, u), d.a.applyMatrix4(t), d.b.applyMatrix4(t), d.c.applyMatrix4(t), d.needsUpdate = !0;
            for (let S = E, D = E + I; S < D; S++) {
              const R = s.resolveTriangleIndex(S);
              Yn(h, 3 * R, c, l), h.needsUpdate = !0;
              const P = h.distanceToTriangle(d, m, g);
              if (P < v && (_.copy(m), A && A.copy(g), v = P, y = S, w = B), P < r)
                return !0;
            }
          }
        }
      }
    }
  ), yr.releasePrimitive(h), yr.releasePrimitive(d), v === 1 / 0 ? null : (n.point ? n.point.copy(_) : n.point = _.clone(), n.distance = v, n.faceIndex = y, i && (i.point ? i.point.copy(A) : i.point = A.clone(), i.point.applyMatrix4(gh), _.applyMatrix4(gh), i.distance = _.sub(i.point).length(), i.faceIndex = w), n);
}
function qN() {
  return typeof SharedArrayBuffer < "u";
}
const ru = new Cn.constructor(), td = new Cn.constructor(), lo = new t0(() => new dn()), ml = new dn(), gl = new dn(), Um = new dn(), Fm = new dn();
let Om = !1;
function XN(s, e, t, n) {
  if (Om)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Om = !0;
  const i = s._roots, r = e._roots;
  let a, o = 0, l = 0;
  const c = new st().copy(t).invert();
  for (let u = 0, f = i.length; u < f; u++) {
    ru.setBuffer(i[u]), l = 0;
    const h = lo.getPrimitive();
    kn(0, ru.float32Array, h), h.applyMatrix4(c);
    for (let d = 0, m = r.length; d < m && (td.setBuffer(r[u]), a = kr(
      0,
      0,
      t,
      c,
      n,
      o,
      l,
      0,
      0,
      h
    ), td.clearBuffer(), l += r[d].length, !a); d++)
      ;
    if (lo.releasePrimitive(h), ru.clearBuffer(), o += i[u].length, a)
      break;
  }
  return Om = !1, a;
}
function kr(s, e, t, n, i, r = 0, a = 0, o = 0, l = 0, c = null, u = !1) {
  let f, h;
  u ? (f = td, h = ru) : (f = ru, h = td);
  const d = f.float32Array, m = f.uint32Array, _ = f.uint16Array, g = h.float32Array, A = h.uint32Array, v = h.uint16Array, y = s * 2, w = e * 2, E = Vi(y, _), I = Vi(w, v);
  let C = !1;
  if (I && E)
    u ? C = i(
      Ki(e, A),
      lr(e * 2, v),
      Ki(s, m),
      lr(s * 2, _),
      l,
      a + e,
      o,
      r + s
    ) : C = i(
      Ki(s, m),
      lr(s * 2, _),
      Ki(e, A),
      lr(e * 2, v),
      o,
      r + s,
      l,
      a + e
    );
  else if (I) {
    const B = lo.getPrimitive();
    kn(e, g, B), B.applyMatrix4(t);
    const T = vr(s), S = cr(s, m);
    kn(T, d, ml), kn(S, d, gl);
    const D = B.intersectsBox(ml), R = B.intersectsBox(gl);
    C = D && kr(
      e,
      T,
      n,
      t,
      i,
      a,
      r,
      l,
      o + 1,
      B,
      !u
    ) || R && kr(
      e,
      S,
      n,
      t,
      i,
      a,
      r,
      l,
      o + 1,
      B,
      !u
    ), lo.releasePrimitive(B);
  } else {
    const B = vr(e), T = cr(e, A);
    kn(B, g, Um), kn(T, g, Fm);
    const S = c.intersectsBox(Um), D = c.intersectsBox(Fm);
    if (S && D)
      C = kr(
        s,
        B,
        t,
        n,
        i,
        r,
        a,
        o,
        l + 1,
        c,
        u
      ) || kr(
        s,
        T,
        t,
        n,
        i,
        r,
        a,
        o,
        l + 1,
        c,
        u
      );
    else if (S)
      if (E)
        C = kr(
          s,
          B,
          t,
          n,
          i,
          r,
          a,
          o,
          l + 1,
          c,
          u
        );
      else {
        const R = lo.getPrimitive();
        R.copy(Um).applyMatrix4(t);
        const P = vr(s), L = cr(s, m);
        kn(P, d, ml), kn(L, d, gl);
        const V = R.intersectsBox(ml), U = R.intersectsBox(gl);
        C = V && kr(
          B,
          P,
          n,
          t,
          i,
          a,
          r,
          l,
          o + 1,
          R,
          !u
        ) || U && kr(
          B,
          L,
          n,
          t,
          i,
          a,
          r,
          l,
          o + 1,
          R,
          !u
        ), lo.releasePrimitive(R);
      }
    else if (D)
      if (E)
        C = kr(
          s,
          T,
          t,
          n,
          i,
          r,
          a,
          o,
          l + 1,
          c,
          u
        );
      else {
        const R = lo.getPrimitive();
        R.copy(Fm).applyMatrix4(t);
        const P = vr(s), L = cr(s, m);
        kn(P, d, ml), kn(L, d, gl);
        const V = R.intersectsBox(ml), U = R.intersectsBox(gl);
        C = V && kr(
          T,
          P,
          n,
          t,
          i,
          a,
          r,
          l,
          o + 1,
          R,
          !u
        ) || U && kr(
          T,
          L,
          n,
          t,
          i,
          a,
          r,
          l,
          o + 1,
          R,
          !u
        ), lo.releasePrimitive(R);
      }
  }
  return C;
}
const Ah = /* @__PURE__ */ new Wi(), iy = /* @__PURE__ */ new dn(), YN = {
  strategy: bE,
  maxDepth: 40,
  maxLeafTris: 10,
  useSharedArrayBuffer: !1,
  setBoundingBox: !0,
  onProgress: null,
  indirect: !1,
  verbose: !0
};
class n0 {
  static serialize(e, t = {}) {
    t = {
      cloneBuffers: !0,
      ...t
    };
    const n = e.geometry, i = e._roots, r = e._indirectBuffer, a = n.getIndex();
    let o;
    return t.cloneBuffers ? o = {
      roots: i.map((l) => l.slice()),
      index: a ? a.array.slice() : null,
      indirectBuffer: r ? r.slice() : null
    } : o = {
      roots: i,
      index: a ? a.array : null,
      indirectBuffer: r
    }, o;
  }
  static deserialize(e, t, n = {}) {
    n = {
      setIndex: !0,
      indirect: !!e.indirectBuffer,
      ...n
    };
    const { index: i, roots: r, indirectBuffer: a } = e, o = new n0(t, { ...n, [Tm]: !0 });
    if (o._roots = r, o._indirectBuffer = a || null, n.setIndex) {
      const l = t.getIndex();
      if (l === null) {
        const c = new Rt(e.index, 1, !1);
        t.setIndex(c);
      } else
        l.array !== i && (l.array.set(i), l.needsUpdate = !0);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(e, t = {}) {
    if (e.isBufferGeometry) {
      if (e.index && e.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t = Object.assign({
      ...YN,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Tm]: !1
    }, t), t.useSharedArrayBuffer && !qN())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = e, this._roots = null, this._indirectBuffer = null, t[Tm] || (hN(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new dn())));
    const { _indirectBuffer: n } = this;
    this.resolveTriangleIndex = t.indirect ? (i) => n[i] : (i) => i;
  }
  refit(e = null) {
    return (this.indirect ? ON : CN)(this, e);
  }
  traverse(e, t = 0) {
    const n = this._roots[t], i = new Uint32Array(n), r = new Uint16Array(n);
    a(0);
    function a(o, l = 0) {
      const c = o * 2, u = r[c + 15] === Nd;
      if (u) {
        const f = i[o + 6], h = r[c + 14];
        e(l, u, new Float32Array(n, o * 4, 6), f, h);
      } else {
        const f = o + mo / 4, h = i[o + 6], d = i[o + 7];
        e(l, u, new Float32Array(n, o * 4, 6), d) || (a(f, l + 1), a(h, l + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(e, t = Hi) {
    const n = this._roots, i = this.geometry, r = [], a = t.isMaterial, o = Array.isArray(t), l = i.groups, c = a ? t.side : t, u = this.indirect ? NN : TN;
    for (let f = 0, h = n.length; f < h; f++) {
      const d = o ? t[l[f].materialIndex].side : c, m = r.length;
      if (u(this, f, d, e, r), o) {
        const _ = l[f].materialIndex;
        for (let g = m, A = r.length; g < A; g++)
          r[g].face.materialIndex = _;
      }
    }
    return r;
  }
  raycastFirst(e, t = Hi) {
    const n = this._roots, i = this.geometry, r = t.isMaterial, a = Array.isArray(t);
    let o = null;
    const l = i.groups, c = r ? t.side : t, u = this.indirect ? QN : PN;
    for (let f = 0, h = n.length; f < h; f++) {
      const d = a ? t[l[f].materialIndex].side : c, m = u(this, f, d, e);
      m != null && (o == null || m.distance < o.distance) && (o = m, a && (m.face.materialIndex = l[f].materialIndex));
    }
    return o;
  }
  intersectsGeometry(e, t) {
    let n = !1;
    const i = this._roots, r = this.indirect ? zN : RN;
    for (let a = 0, o = i.length; a < o && (n = r(this, a, e, t), !n); a++)
      ;
    return n;
  }
  shapecast(e) {
    const t = yr.getPrimitive(), n = this.indirect ? IN : EN;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: r,
      intersectsRange: a,
      intersectsTriangle: o
    } = e;
    if (a && o) {
      const f = a;
      a = (h, d, m, _, g) => f(h, d, m, _, g) ? !0 : n(h, d, this, o, m, _, t);
    } else
      a || (o ? a = (f, h, d, m) => n(f, h, this, o, d, m, t) : a = (f, h, d) => d);
    let l = !1, c = 0;
    const u = this._roots;
    for (let f = 0, h = u.length; f < h; f++) {
      const d = u[f];
      if (l = _N(this, f, r, a, i, c), l)
        break;
      c += d.byteLength;
    }
    return yr.releasePrimitive(t), l;
  }
  bvhcast(e, t, n) {
    let {
      intersectsRanges: i,
      intersectsTriangles: r
    } = n;
    const a = yr.getPrimitive(), o = this.geometry.index, l = this.geometry.attributes.position, c = this.indirect ? (m) => {
      const _ = this.resolveTriangleIndex(m);
      Yn(a, _ * 3, o, l);
    } : (m) => {
      Yn(a, m * 3, o, l);
    }, u = yr.getPrimitive(), f = e.geometry.index, h = e.geometry.attributes.position, d = e.indirect ? (m) => {
      const _ = e.resolveTriangleIndex(m);
      Yn(u, _ * 3, f, h);
    } : (m) => {
      Yn(u, m * 3, f, h);
    };
    if (r) {
      const m = (_, g, A, v, y, w, E, I) => {
        for (let C = A, B = A + v; C < B; C++) {
          d(C), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = !0;
          for (let T = _, S = _ + g; T < S; T++)
            if (c(T), a.needsUpdate = !0, r(a, u, T, C, y, w, E, I))
              return !0;
        }
        return !1;
      };
      if (i) {
        const _ = i;
        i = function(g, A, v, y, w, E, I, C) {
          return _(g, A, v, y, w, E, I, C) ? !0 : m(g, A, v, y, w, E, I, C);
        };
      } else
        i = m;
    }
    return XN(this, e, t, i);
  }
  /* Derived Cast Functions */
  intersectsBox(e, t) {
    return Ah.set(e.min, e.max, t), Ah.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (n) => Ah.intersectsBox(n),
        intersectsTriangle: (n) => Ah.intersectsTriangle(n)
      }
    );
  }
  intersectsSphere(e) {
    return this.shapecast(
      {
        intersectsBounds: (t) => e.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(e)
      }
    );
  }
  closestPointToGeometry(e, t, n = {}, i = {}, r = 0, a = 1 / 0) {
    return (this.indirect ? WN : FN)(
      this,
      e,
      t,
      n,
      i,
      r,
      a
    );
  }
  closestPointToPoint(e, t = {}, n = 0, i = 1 / 0) {
    return bN(
      this,
      e,
      t,
      n,
      i
    );
  }
  getBoundingBox(e) {
    return e.makeEmpty(), this._roots.forEach((n) => {
      kn(0, new Float32Array(n), iy), e.union(iy);
    }), e;
  }
}
function KN(s) {
  switch (s) {
    case 1:
      return "R";
    case 2:
      return "RG";
    case 3:
      return "RGBA";
    case 4:
      return "RGBA";
  }
  throw new Error();
}
function JN(s) {
  switch (s) {
    case 1:
      return Ts;
    case 2:
      return uo;
    case 3:
      return vn;
    case 4:
      return vn;
  }
}
function ry(s) {
  switch (s) {
    case 1:
      return cd;
    case 2:
      return Ru;
    case 3:
      return Ol;
    case 4:
      return Ol;
  }
}
class ME extends Di {
  constructor() {
    super(), this.minFilter = nn, this.magFilter = nn, this.generateMipmaps = !1, this.overrideItemSize = null, this._forcedType = null;
  }
  updateFrom(e) {
    const t = this.overrideItemSize, n = e.itemSize, i = e.count;
    if (t !== null) {
      if (n * i % t !== 0)
        throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
      e.itemSize = t, e.count = i * n / t;
    }
    const r = e.itemSize, a = e.count, o = e.normalized, l = e.array.constructor, c = l.BYTES_PER_ELEMENT;
    let u = this._forcedType, f = r;
    if (u === null)
      switch (l) {
        case Float32Array:
          u = hn;
          break;
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
          u = xr;
          break;
        case Int8Array:
        case Int16Array:
        case Int32Array:
          u = Bl;
          break;
      }
    let h, d, m, _, g = KN(r);
    switch (u) {
      case hn:
        m = 1, d = JN(r), o && c === 1 ? (_ = l, g += "8", l === Uint8Array ? h = Un : (h = zh, g += "_SNORM")) : (_ = Float32Array, g += "32F", h = hn);
        break;
      case Bl:
        g += c * 8 + "I", m = o ? Math.pow(2, l.BYTES_PER_ELEMENT * 8 - 1) : 1, d = ry(r), c === 1 ? (_ = Int8Array, h = zh) : c === 2 ? (_ = Int16Array, h = cA) : (_ = Int32Array, h = Bl);
        break;
      case xr:
        g += c * 8 + "UI", m = o ? Math.pow(2, l.BYTES_PER_ELEMENT * 8 - 1) : 1, d = ry(r), c === 1 ? (_ = Uint8Array, h = Un) : c === 2 ? (_ = Uint16Array, h = ld) : (_ = Uint32Array, h = xr);
        break;
    }
    f === 3 && (d === vn || d === Ol) && (f = 4);
    const A = Math.ceil(Math.sqrt(a)) || 1, v = f * A * A, y = new _(v), w = e.normalized;
    e.normalized = !1;
    for (let E = 0; E < a; E++) {
      const I = f * E;
      y[I] = e.getX(E) / m, r >= 2 && (y[I + 1] = e.getY(E) / m), r >= 3 && (y[I + 2] = e.getZ(E) / m, f === 4 && (y[I + 3] = 1)), r >= 4 && (y[I + 3] = e.getW(E) / m);
    }
    e.normalized = w, this.internalFormat = g, this.format = d, this.type = h, this.image.width = A, this.image.height = A, this.image.data = y, this.needsUpdate = !0, this.dispose(), e.itemSize = n, e.count = i;
  }
}
class ZN extends ME {
  constructor() {
    super(), this._forcedType = xr;
  }
}
class e4 extends ME {
  constructor() {
    super(), this._forcedType = hn;
  }
}
class sy {
  constructor() {
    this.index = new ZN(), this.position = new e4(), this.bvhBounds = new Di(), this.bvhContents = new Di(), this._cachedIndexAttr = null, this.index.overrideItemSize = 3;
  }
  updateFrom(e) {
    const { geometry: t } = e;
    if (n4(e, this.bvhBounds, this.bvhContents), this.position.updateFrom(t.attributes.position), e.indirect) {
      const n = e._indirectBuffer;
      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== n.length)
        if (t.index)
          this._cachedIndexAttr = t.index.clone();
        else {
          const i = xE(yE(t));
          this._cachedIndexAttr = new Rt(i, 1, !1);
        }
      t4(t, n, this._cachedIndexAttr), this.index.updateFrom(this._cachedIndexAttr);
    } else
      this.index.updateFrom(t.index);
  }
  dispose() {
    const { index: e, position: t, bvhBounds: n, bvhContents: i } = this;
    e && e.dispose(), t && t.dispose(), n && n.dispose(), i && i.dispose();
  }
}
function t4(s, e, t) {
  const n = t.array, i = s.index ? s.index.array : null;
  for (let r = 0, a = e.length; r < a; r++) {
    const o = 3 * r, l = 3 * e[r];
    for (let c = 0; c < 3; c++)
      n[o + c] = i ? i[l + c] : l + c;
  }
}
function n4(s, e, t) {
  const n = s._roots;
  if (n.length !== 1)
    throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
  const i = n[0], r = new Uint16Array(i), a = new Uint32Array(i), o = new Float32Array(i), l = i.byteLength / mo, c = 2 * Math.ceil(Math.sqrt(l / 2)), u = new Float32Array(4 * c * c), f = Math.ceil(Math.sqrt(l)), h = new Uint32Array(2 * f * f);
  for (let d = 0; d < l; d++) {
    const m = d * mo / 4, _ = m * 2, g = m;
    for (let A = 0; A < 3; A++)
      u[8 * d + 0 + A] = o[g + 0 + A], u[8 * d + 4 + A] = o[g + 3 + A];
    if (Vi(_, r)) {
      const A = lr(_, r), v = Ki(m, a), y = 4294901760 | A;
      h[d * 2 + 0] = y, h[d * 2 + 1] = v;
    } else {
      const A = 4 * cr(m, a) / mo, v = ZA(m, a);
      h[d * 2 + 0] = v, h[d * 2 + 1] = A;
    }
  }
  e.image.data = u, e.image.width = c, e.image.height = c, e.format = vn, e.type = hn, e.internalFormat = "RGBA32F", e.minFilter = nn, e.magFilter = nn, e.generateMipmaps = !1, e.needsUpdate = !0, e.dispose(), t.image.data = h, t.image.width = f, t.image.height = f, t.format = Ru, t.type = xr, t.internalFormat = "RG32UI", t.minFilter = nn, t.magFilter = nn, t.generateMipmaps = !1, t.needsUpdate = !0, t.dispose();
}
const i4 = (
  /* glsl */
  `

// A stack of uint32 indices can can store the indices for
// a perfectly balanced tree with a depth up to 31. Lower stack
// depth gets higher performance.
//
// However not all trees are balanced. Best value to set this to
// is the trees max depth.
#ifndef BVH_STACK_DEPTH
#define BVH_STACK_DEPTH 60
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}
`
), r4 = (
  /* glsl */
  `

#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

// Raycasting
bool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	dist = max( t0, 0.0 );

	return t1 >= dist;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	// geometry info and triangle range
	sampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// outputs
	inout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;
		vec3 a = texelFetch1D( positionAttr, indices.x ).rgb;
		vec3 b = texelFetch1D( positionAttr, indices.y ).rgb;
		vec3 c = texelFetch1D( positionAttr, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

bool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {

	uint cni2 = currNodeIndex * 2u;
	vec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;
	vec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );

}

// use a macro to hide the fact that we need to expand the struct into separate fields
#define	bvhIntersectFirstHit(		bvh,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)	_bvhIntersectFirstHit(		bvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,		rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist	)

bool _bvhIntersectFirstHit(
	// bvh info
	sampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,

	// ray
	vec3 rayOrigin, vec3 rayDirection,

	// output variables split into separate variables due to output precision
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ BVH_STACK_DEPTH ];
	stack[ 0 ] = 0u;

	float triangleDistance = INFINITY;
	bool found = false;
	while ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance;
		if (
			! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )
			|| boundsHitDistance > triangleDistance
		) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh_position, bvh_index, offset, count,
				rayOrigin, rayDirection, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`
), s4 = (
  /* glsl */
  `
struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`
), o4 = s4, a4 = `
	${i4}
	${r4}
`, l4 = `#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${o4}
${a4}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${gt.tonemapping_fragment}
	${gt.colorspace_fragment}
}`, c4 = `uniform mat4 viewMatrixInverse;

varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

void main() {
	vec4 transformedNormal = vec4(normal, 0.0);
	vec4 transformedPosition = vec4(position, 1.0);
	#ifdef USE_INSTANCING
		transformedNormal = instanceMatrix * transformedNormal;
		transformedPosition = instanceMatrix * transformedPosition;
	#endif

	#ifdef USE_INSTANCING
		vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
	#else
		vModelMatrixInverse = inverse(modelMatrix);
	#endif

	#ifdef USE_INSTANCING_COLOR
		vInstanceColor = instanceColor.rgb;
	#endif

	vWorldPosition = (modelMatrix * transformedPosition).xyz;
	vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
	gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
}`;
function u4(s) {
  let e, t;
  return e = new ee({
    props: {
      is: (
        /*material*/
        s[5]
      ),
      "uniforms.envMap.value": (
        /*envMap*/
        s[0]
      ),
      "uniforms.bounces.value": (
        /*bounces*/
        s[1]
      ),
      "uniforms.ior.value": (
        /*ior*/
        s[2]
      ),
      "uniforms.fresnel.value": (
        /*fresnel*/
        s[3]
      ),
      "uniforms.aberrationStrength.value": (
        /*aberrationStrength*/
        s[4]
      ),
      "uniforms.color.value": (
        /*colorObj*/
        s[10]
      ),
      "uniforms.resolution.value": [
        /*$size*/
        s[7].width,
        /*$size*/
        s[7].height
      ],
      defines: (
        /*defines*/
        s[6]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, [i]) {
      const r = {};
      i & /*material*/
      32 && (r.is = /*material*/
      n[5]), i & /*envMap*/
      1 && (r["uniforms.envMap.value"] = /*envMap*/
      n[0]), i & /*bounces*/
      2 && (r["uniforms.bounces.value"] = /*bounces*/
      n[1]), i & /*ior*/
      4 && (r["uniforms.ior.value"] = /*ior*/
      n[2]), i & /*fresnel*/
      8 && (r["uniforms.fresnel.value"] = /*fresnel*/
      n[3]), i & /*aberrationStrength*/
      16 && (r["uniforms.aberrationStrength.value"] = /*aberrationStrength*/
      n[4]), i & /*$size*/
      128 && (r["uniforms.resolution.value"] = [
        /*$size*/
        n[7].width,
        /*$size*/
        n[7].height
      ]), i & /*defines*/
      64 && (r.defines = /*defines*/
      n[6]), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function f4(s, e, t) {
  let n, i, { envMap: r } = e, { bounces: a = 2 } = e, { ior: o = 2.4 } = e, { fresnel: l = 0 } = e, { aberrationStrength: c = 0 } = e, { color: u = "white" } = e, { fastChroma: f = !0 } = e, h = new Hn({
    fragmentShader: l4,
    vertexShader: c4,
    uniforms: {
      envMap: { value: null },
      bounces: { value: 2 },
      ior: { value: 2.4 },
      correctMips: { value: !0 },
      aberrationStrength: { value: 0.01 },
      fresnel: { value: 0 },
      bvh: { value: new sy() },
      color: { value: new Je("white") },
      resolution: { value: new ke() },
      viewMatrixInverse: { value: new st() },
      projectionMatrixInverse: { value: new st() }
    }
  });
  const { size: d, invalidate: m, camera: _ } = un();
  lt(s, d, (E) => t(7, i = E));
  const g = Er();
  lt(s, g, (E) => t(13, n = E));
  const A = (E) => E && E.isCubeTexture;
  let v = {};
  const y = (E, I, C) => {
    var U;
    const B = {}, T = A(E), D = ((T ? (U = E.image[0]) == null ? void 0 : U.width : E.image.width) ?? 1024) / 4, R = Math.floor(Math.log2(D)), P = Math.pow(2, R), L = 3 * Math.max(P, 16 * 7), V = 4 * P;
    return T && (B.ENVMAP_TYPE_CUBEM = ""), B.CUBEUV_TEXEL_WIDTH = `${1 / L}`, B.CUBEUV_TEXEL_HEIGHT = `${1 / V}`, B.CUBEUV_MAX_MIP = `${R}.0`, I > 0 && (B.CHROMATIC_ABERRATIONS = ""), C && (B.FAST_CHROMA = ""), B;
  };
  Us(() => {
    n && n instanceof tt && n.geometry && (t(5, h.uniforms.bvh.value = new sy(), h), h.uniforms.bvh.value.updateFrom(new n0(n == null ? void 0 : n.geometry.clone().toNonIndexed(), { strategy: vE })));
  }), On(
    () => {
      t(5, h.uniforms.viewMatrixInverse.value = _.current.matrixWorld, h), t(5, h.uniforms.projectionMatrixInverse.value = _.current.projectionMatrixInverse, h);
    },
    { autoInvalidate: !1 }
  );
  const w = new Je(u);
  return s.$$set = (E) => {
    "envMap" in E && t(0, r = E.envMap), "bounces" in E && t(1, a = E.bounces), "ior" in E && t(2, o = E.ior), "fresnel" in E && t(3, l = E.fresnel), "aberrationStrength" in E && t(4, c = E.aberrationStrength), "color" in E && t(11, u = E.color), "fastChroma" in E && t(12, f = E.fastChroma);
  }, s.$$.update = () => {
    s.$$.dirty & /*envMap, aberrationStrength, fastChroma*/
    4113 && t(6, v = y(r, c, f)), s.$$.dirty & /*color*/
    2048 && (w.set(u), m());
  }, [
    r,
    a,
    o,
    l,
    c,
    h,
    v,
    i,
    d,
    g,
    w,
    u,
    f
  ];
}
class h4 extends Mt {
  constructor(e) {
    super(), Ct(this, e, f4, u4, _t, {
      envMap: 0,
      bounces: 1,
      ior: 2,
      fresnel: 3,
      aberrationStrength: 4,
      color: 11,
      fastChroma: 12
    });
  }
  get envMap() {
    return this.$$.ctx[0];
  }
  set envMap(e) {
    this.$$set({ envMap: e }), ne();
  }
  get bounces() {
    return this.$$.ctx[1];
  }
  set bounces(e) {
    this.$$set({ bounces: e }), ne();
  }
  get ior() {
    return this.$$.ctx[2];
  }
  set ior(e) {
    this.$$set({ ior: e }), ne();
  }
  get fresnel() {
    return this.$$.ctx[3];
  }
  set fresnel(e) {
    this.$$set({ fresnel: e }), ne();
  }
  get aberrationStrength() {
    return this.$$.ctx[4];
  }
  set aberrationStrength(e) {
    this.$$set({ aberrationStrength: e }), ne();
  }
  get color() {
    return this.$$.ctx[11];
  }
  set color(e) {
    this.$$set({ color: e }), ne();
  }
  get fastChroma() {
    return this.$$.ctx[12];
  }
  set fastChroma(e) {
    this.$$set({ fastChroma: e }), ne();
  }
}
St(h4, { envMap: {}, bounces: {}, ior: {}, fresnel: {}, aberrationStrength: {}, color: {}, fastChroma: { type: "Boolean" } }, [], [], !0);
class d4 extends Gu {
  constructor(e, t = {}) {
    const n = t.font;
    if (n === void 0)
      super();
    else {
      const i = n.generateShapes(e, t.size);
      t.depth === void 0 && t.height !== void 0 && console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"), t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50, t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(i, t);
    }
    this.type = "TextGeometry";
  }
}
class p4 extends ai {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new ri(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      const l = r.parse(JSON.parse(o));
      t && t(l);
    }, n, i);
  }
  parse(e) {
    return new m4(e);
  }
}
class m4 {
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  generateShapes(e, t = 100) {
    const n = [], i = g4(e, t, this.data);
    for (let r = 0, a = i.length; r < a; r++)
      n.push(...i[r].toShapes());
    return n;
  }
}
function g4(s, e, t) {
  const n = Array.from(s), i = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];
  let o = 0, l = 0;
  for (let c = 0; c < n.length; c++) {
    const u = n[c];
    if (u === `
`)
      o = 0, l -= r;
    else {
      const f = A4(u, i, o, l, t);
      o += f.offsetX, a.push(f.path);
    }
  }
  return a;
}
function A4(s, e, t, n, i) {
  const r = i.glyphs[s] || i.glyphs["?"];
  if (!r) {
    console.error('THREE.Font: character "' + s + '" does not exists in font family ' + i.familyName + ".");
    return;
  }
  const a = new kw();
  let o, l, c, u, f, h, d, m;
  if (r.o) {
    const _ = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
    for (let g = 0, A = _.length; g < A; )
      switch (_[g++]) {
        case "m":
          o = _[g++] * e + t, l = _[g++] * e + n, a.moveTo(o, l);
          break;
        case "l":
          o = _[g++] * e + t, l = _[g++] * e + n, a.lineTo(o, l);
          break;
        case "q":
          c = _[g++] * e + t, u = _[g++] * e + n, f = _[g++] * e + t, h = _[g++] * e + n, a.quadraticCurveTo(f, h, c, u);
          break;
        case "b":
          c = _[g++] * e + t, u = _[g++] * e + n, f = _[g++] * e + t, h = _[g++] * e + n, d = _[g++] * e + t, m = _[g++] * e + n, a.bezierCurveTo(f, h, d, m, c, u);
          break;
      }
  }
  return { offsetX: r.ha * e, path: a };
}
const _4 = (s) => ({ ref: s & /*ref*/
134217728 }), oy = (s) => ({ ref: (
  /*ref*/
  s[27]
) });
function ay(s) {
  let e, t, n = {
    is: (
      /*$creasedGeometry*/
      s[1]
    ),
    $$slots: {
      default: [
        b4,
        ({ ref: i }) => ({ 27: i }),
        ({ ref: i }) => i ? 134217728 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  return e = new ee({ props: n }), s[24](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(i, r) {
      K(e, i, r), t = !0;
    },
    p(i, r) {
      const a = {};
      r & /*$creasedGeometry*/
      2 && (a.is = /*$creasedGeometry*/
      i[1]), r & /*$$scope, ref*/
      167772160 && (a.$$scope = { dirty: r, ctx: i }), e.$set(a);
    },
    i(i) {
      t || (O(e.$$.fragment, i), t = !0);
    },
    o(i) {
      N(e.$$.fragment, i), t = !1;
    },
    d(i) {
      s[24](null), J(e, i);
    }
  };
}
function b4(s) {
  let e;
  const t = (
    /*#slots*/
    s[23].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[25],
    oy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      167772160) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[25],
        e ? xt(
          t,
          /*$$scope*/
          i[25],
          r,
          _4
        ) : Et(
          /*$$scope*/
          i[25]
        ),
        oy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function v4(s) {
  let e, t, n = (
    /*$creasedGeometry*/
    s[1] && ay(s)
  );
  return {
    c() {
      n && n.c(), e = ji();
    },
    m(i, r) {
      n && n.m(i, r), we(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*$creasedGeometry*/
      i[1] ? n ? (n.p(i, r), r & /*$creasedGeometry*/
      2 && O(n, 1)) : (n = ay(i), n.c(), O(n, 1), n.m(e.parentNode, e)) : n && (Li(), N(n, 1, 1, () => {
        n = null;
      }), ki());
    },
    i(i) {
      t || (O(n), t = !0);
    },
    o(i) {
      N(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function y4(s, e, t) {
  let n, i, r, a, o, l, c = rt, u = () => (c(), c = Bu(o, (U) => t(1, l = U)), o), f;
  s.$$.on_destroy.push(() => c());
  let { $$slots: h = {}, $$scope: d } = e, { text: m } = e, { font: _ = "https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json" } = e, { size: g = void 0 } = e, { height: A = void 0 } = e, { curveSegments: v = void 0 } = e, { bevelEnabled: y = void 0 } = e, { bevelThickness: w = void 0 } = e, { bevelSize: E = void 0 } = e, { bevelOffset: I = void 0 } = e, { bevelSegments: C = void 0 } = e, { smooth: B = void 0 } = e, { depth: T = void 0 } = e, { extrudePath: S = void 0 } = e, { steps: D = void 0 } = e, { UVGenerator: R = void 0 } = e;
  const P = rc(), L = An();
  lt(s, L, (U) => t(2, f = U));
  function V(U) {
    Ut[U ? "unshift" : "push"](() => {
      f = U, L.set(f);
    });
  }
  return s.$$set = (U) => {
    "text" in U && t(4, m = U.text), "font" in U && t(5, _ = U.font), "size" in U && t(6, g = U.size), "height" in U && t(7, A = U.height), "curveSegments" in U && t(8, v = U.curveSegments), "bevelEnabled" in U && t(9, y = U.bevelEnabled), "bevelThickness" in U && t(10, w = U.bevelThickness), "bevelSize" in U && t(11, E = U.bevelSize), "bevelOffset" in U && t(12, I = U.bevelOffset), "bevelSegments" in U && t(13, C = U.bevelSegments), "smooth" in U && t(14, B = U.smooth), "depth" in U && t(15, T = U.depth), "extrudePath" in U && t(16, S = U.extrudePath), "steps" in U && t(17, D = U.steps), "UVGenerator" in U && t(18, R = U.UVGenerator), "$$scope" in U && t(25, d = U.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*font*/
    32 && t(22, n = P(typeof _ == "string" ? $u(p4).load(_) : Dl(new Promise((U) => U(_))))), s.$$.dirty & /*text, size, height, curveSegments, bevelEnabled, bevelThickness, bevelSize, bevelOffset, bevelSegments*/
    16336 && t(21, i = Ft({
      text: m,
      size: g,
      height: A,
      curveSegments: v,
      bevelEnabled: y,
      bevelThickness: w,
      bevelSize: E,
      bevelOffset: I,
      bevelSegments: C
    })), s.$$.dirty & /*loadedFont, options, depth, extrudePath, steps, UVGenerator*/
    6782976 && t(20, r = hi([n, i], ([U, Q]) => {
      if (U)
        return new d4(
          Q.text,
          {
            font: U,
            size: Q.size,
            height: Q.height,
            curveSegments: Q.curveSegments,
            bevelEnabled: Q.bevelEnabled,
            bevelThickness: Q.bevelThickness,
            bevelSize: Q.bevelSize,
            bevelOffset: Q.bevelOffset,
            bevelSegments: Q.bevelSegments,
            depth: T,
            extrudePath: S,
            steps: D,
            UVGenerator: R
          }
        );
    })), s.$$.dirty & /*smooth*/
    16384 && t(19, a = Ft(B)), s.$$.dirty & /*baseGeometry, smoothStore*/
    1572864 && u(t(0, o = hi([r, a], ([U, Q]) => {
      if (U)
        return Q === 0 ? U : XA(U, Q);
    })));
  }, [
    o,
    l,
    f,
    L,
    m,
    _,
    g,
    A,
    v,
    y,
    w,
    E,
    I,
    C,
    B,
    T,
    S,
    D,
    R,
    a,
    r,
    i,
    n,
    h,
    V,
    d
  ];
}
class x4 extends Mt {
  constructor(e) {
    super(), Ct(this, e, y4, v4, _t, {
      text: 4,
      font: 5,
      size: 6,
      height: 7,
      curveSegments: 8,
      bevelEnabled: 9,
      bevelThickness: 10,
      bevelSize: 11,
      bevelOffset: 12,
      bevelSegments: 13,
      smooth: 14,
      depth: 15,
      extrudePath: 16,
      steps: 17,
      UVGenerator: 18
    });
  }
  get text() {
    return this.$$.ctx[4];
  }
  set text(e) {
    this.$$set({ text: e }), ne();
  }
  get font() {
    return this.$$.ctx[5];
  }
  set font(e) {
    this.$$set({ font: e }), ne();
  }
  get size() {
    return this.$$.ctx[6];
  }
  set size(e) {
    this.$$set({ size: e }), ne();
  }
  get height() {
    return this.$$.ctx[7];
  }
  set height(e) {
    this.$$set({ height: e }), ne();
  }
  get curveSegments() {
    return this.$$.ctx[8];
  }
  set curveSegments(e) {
    this.$$set({ curveSegments: e }), ne();
  }
  get bevelEnabled() {
    return this.$$.ctx[9];
  }
  set bevelEnabled(e) {
    this.$$set({ bevelEnabled: e }), ne();
  }
  get bevelThickness() {
    return this.$$.ctx[10];
  }
  set bevelThickness(e) {
    this.$$set({ bevelThickness: e }), ne();
  }
  get bevelSize() {
    return this.$$.ctx[11];
  }
  set bevelSize(e) {
    this.$$set({ bevelSize: e }), ne();
  }
  get bevelOffset() {
    return this.$$.ctx[12];
  }
  set bevelOffset(e) {
    this.$$set({ bevelOffset: e }), ne();
  }
  get bevelSegments() {
    return this.$$.ctx[13];
  }
  set bevelSegments(e) {
    this.$$set({ bevelSegments: e }), ne();
  }
  get smooth() {
    return this.$$.ctx[14];
  }
  set smooth(e) {
    this.$$set({ smooth: e }), ne();
  }
  get depth() {
    return this.$$.ctx[15];
  }
  set depth(e) {
    this.$$set({ depth: e }), ne();
  }
  get extrudePath() {
    return this.$$.ctx[16];
  }
  set extrudePath(e) {
    this.$$set({ extrudePath: e }), ne();
  }
  get steps() {
    return this.$$.ctx[17];
  }
  set steps(e) {
    this.$$set({ steps: e }), ne();
  }
  get UVGenerator() {
    return this.$$.ctx[18];
  }
  set UVGenerator(e) {
    this.$$set({ UVGenerator: e }), ne();
  }
}
St(x4, { text: {}, font: {}, size: {}, height: {}, curveSegments: {}, bevelEnabled: {}, bevelThickness: {}, bevelSize: {}, bevelOffset: {}, bevelSegments: {}, smooth: {}, depth: {}, extrudePath: {}, steps: {}, UVGenerator: {} }, ["default"], [], !0);
var w4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, $g = { exports: {} };
/*! Tweakpane 3.1.10 (c) 2016 cocopon, licensed under the MIT license. */
(function(s, e) {
  (function(t, n) {
    n(e);
  })(w4, function(t) {
    class n {
      /**
       * @hidden
       */
      constructor(p) {
        const [b, M] = p.split("-"), z = b.split(".");
        this.major = parseInt(z[0], 10), this.minor = parseInt(z[1], 10), this.patch = parseInt(z[2], 10), this.prerelease = M ?? null;
      }
      toString() {
        const p = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [p, this.prerelease].join("-") : p;
      }
    }
    class i {
      constructor(p) {
        this.controller_ = p;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(p) {
        this.controller_.viewProps.set("disabled", p);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(p) {
        this.controller_.viewProps.set("hidden", p);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", !0);
      }
    }
    class r {
      constructor(p) {
        this.target = p;
      }
    }
    class a extends r {
      constructor(p, b, M, z) {
        super(p), this.value = b, this.presetKey = M, this.last = z ?? !0;
      }
    }
    class o extends r {
      constructor(p, b, M) {
        super(p), this.value = b, this.presetKey = M;
      }
    }
    class l extends r {
      constructor(p, b) {
        super(p), this.expanded = b;
      }
    }
    class c extends r {
      constructor(p, b) {
        super(p), this.index = b;
      }
    }
    function u(x) {
      return x;
    }
    function f(x) {
      return x == null;
    }
    function h(x, p) {
      if (x.length !== p.length)
        return !1;
      for (let b = 0; b < x.length; b++)
        if (x[b] !== p[b])
          return !1;
      return !0;
    }
    function d(x, p) {
      let b = x;
      do {
        const M = Object.getOwnPropertyDescriptor(b, p);
        if (M && (M.set !== void 0 || M.writable === !0))
          return !0;
        b = Object.getPrototypeOf(b);
      } while (b !== null);
      return !1;
    }
    const m = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (x) => `Invalid parameters for '${x.name}'`,
      nomatchingcontroller: (x) => `No matching controller for '${x.key}'`,
      nomatchingview: (x) => `No matching view for '${JSON.stringify(x.params)}'`,
      notbindable: () => "Value is not bindable",
      propertynotfound: (x) => `Property '${x.name}' not found`,
      shouldneverhappen: () => "This error should never happen"
    };
    class _ {
      static alreadyDisposed() {
        return new _({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new _({
          type: "notbindable"
        });
      }
      static propertyNotFound(p) {
        return new _({
          type: "propertynotfound",
          context: {
            name: p
          }
        });
      }
      static shouldNeverHappen() {
        return new _({ type: "shouldneverhappen" });
      }
      constructor(p) {
        var b;
        this.message = (b = m[p.type](p.context)) !== null && b !== void 0 ? b : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = p.type;
      }
    }
    class g {
      constructor(p, b, M) {
        this.obj_ = p, this.key_ = b, this.presetKey_ = M ?? b;
      }
      static isBindable(p) {
        return !(p === null || typeof p != "object" && typeof p != "function");
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(p) {
        this.obj_[this.key_] = p;
      }
      writeProperty(p, b) {
        const M = this.read();
        if (!g.isBindable(M))
          throw _.notBindable();
        if (!(p in M))
          throw _.propertyNotFound(p);
        M[p] = b;
      }
    }
    class A extends i {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(p) {
        this.controller_.props.set("label", p);
      }
      get title() {
        var p;
        return (p = this.controller_.valueController.props.get("title")) !== null && p !== void 0 ? p : "";
      }
      set title(p) {
        this.controller_.valueController.props.set("title", p);
      }
      on(p, b) {
        const M = b.bind(this);
        return this.controller_.valueController.emitter.on(p, () => {
          M(new r(this));
        }), this;
      }
    }
    class v {
      constructor() {
        this.observers_ = {};
      }
      on(p, b) {
        let M = this.observers_[p];
        return M || (M = this.observers_[p] = []), M.push({
          handler: b
        }), this;
      }
      off(p, b) {
        const M = this.observers_[p];
        return M && (this.observers_[p] = M.filter((z) => z.handler !== b)), this;
      }
      emit(p, b) {
        const M = this.observers_[p];
        M && M.forEach((z) => {
          z.handler(b);
        });
      }
    }
    const y = "tp";
    function w(x) {
      return (b, M) => [
        y,
        "-",
        x,
        "v",
        b ? `_${b}` : "",
        M ? `-${M}` : ""
      ].join("");
    }
    function E(x, p) {
      return (b) => p(x(b));
    }
    function I(x) {
      return x.rawValue;
    }
    function C(x, p) {
      x.emitter.on("change", E(I, p)), p(x.rawValue);
    }
    function B(x, p, b) {
      C(x.value(p), b);
    }
    function T(x, p, b) {
      b ? x.classList.add(p) : x.classList.remove(p);
    }
    function S(x, p) {
      return (b) => {
        T(x, p, b);
      };
    }
    function D(x, p) {
      C(x, (b) => {
        p.textContent = b ?? "";
      });
    }
    const R = w("btn");
    class P {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(R()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("button");
        M.classList.add(R("b")), b.viewProps.bindDisabled(M), this.element.appendChild(M), this.buttonElement = M;
        const z = p.createElement("div");
        z.classList.add(R("t")), D(b.props.value("title"), z), this.buttonElement.appendChild(z);
      }
    }
    class L {
      constructor(p, b) {
        this.emitter = new v(), this.onClick_ = this.onClick_.bind(this), this.props = b.props, this.viewProps = b.viewProps, this.view = new P(p, {
          props: this.props,
          viewProps: this.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class V {
      constructor(p, b) {
        var M;
        this.constraint_ = b == null ? void 0 : b.constraint, this.equals_ = (M = b == null ? void 0 : b.equals) !== null && M !== void 0 ? M : (z, de) => z === de, this.emitter = new v(), this.rawValue_ = p;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(p) {
        this.setRawValue(p, {
          forceEmit: !1,
          last: !0
        });
      }
      setRawValue(p, b) {
        const M = b ?? {
          forceEmit: !1,
          last: !0
        }, z = this.constraint_ ? this.constraint_.constrain(p) : p, de = this.rawValue_;
        this.equals_(de, z) && !M.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.rawValue_ = z, this.emitter.emit("change", {
          options: M,
          previousRawValue: de,
          rawValue: z,
          sender: this
        }));
      }
    }
    class U {
      constructor(p) {
        this.emitter = new v(), this.value_ = p;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(p) {
        this.setRawValue(p, {
          forceEmit: !1,
          last: !0
        });
      }
      setRawValue(p, b) {
        const M = b ?? {
          forceEmit: !1,
          last: !0
        }, z = this.value_;
        z === p && !M.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.value_ = p, this.emitter.emit("change", {
          options: M,
          previousRawValue: z,
          rawValue: this.value_,
          sender: this
        }));
      }
    }
    function Q(x, p) {
      const b = p == null ? void 0 : p.constraint, M = p == null ? void 0 : p.equals;
      return !b && !M ? new U(x) : new V(x, p);
    }
    class q {
      constructor(p) {
        this.emitter = new v(), this.valMap_ = p;
        for (const b in this.valMap_)
          this.valMap_[b].emitter.on("change", () => {
            this.emitter.emit("change", {
              key: b,
              sender: this
            });
          });
      }
      static createCore(p) {
        return Object.keys(p).reduce((M, z) => Object.assign(M, {
          [z]: Q(p[z])
        }), {});
      }
      static fromObject(p) {
        const b = this.createCore(p);
        return new q(b);
      }
      get(p) {
        return this.valMap_[p].rawValue;
      }
      set(p, b) {
        this.valMap_[p].rawValue = b;
      }
      value(p) {
        return this.valMap_[p];
      }
    }
    function oe(x, p) {
      const M = Object.keys(p).reduce((z, de) => {
        if (z === void 0)
          return;
        const Re = p[de], et = Re(x[de]);
        return et.succeeded ? Object.assign(Object.assign({}, z), { [de]: et.value }) : void 0;
      }, {});
      return M;
    }
    function le(x, p) {
      return x.reduce((b, M) => {
        if (b === void 0)
          return;
        const z = p(M);
        if (!(!z.succeeded || z.value === void 0))
          return [...b, z.value];
      }, []);
    }
    function k(x) {
      return x === null ? !1 : typeof x == "object";
    }
    function X(x) {
      return (p) => (b) => {
        if (!p && b === void 0)
          return {
            succeeded: !1,
            value: void 0
          };
        if (p && b === void 0)
          return {
            succeeded: !0,
            value: void 0
          };
        const M = x(b);
        return M !== void 0 ? {
          succeeded: !0,
          value: M
        } : {
          succeeded: !1,
          value: void 0
        };
      };
    }
    function fe(x) {
      return {
        custom: (p) => X(p)(x),
        boolean: X((p) => typeof p == "boolean" ? p : void 0)(x),
        number: X((p) => typeof p == "number" ? p : void 0)(x),
        string: X((p) => typeof p == "string" ? p : void 0)(x),
        function: X((p) => typeof p == "function" ? p : void 0)(x),
        constant: (p) => X((b) => b === p ? p : void 0)(x),
        raw: X((p) => p)(x),
        object: (p) => X((b) => {
          if (k(b))
            return oe(b, p);
        })(x),
        array: (p) => X((b) => {
          if (Array.isArray(b))
            return le(b, p);
        })(x)
      };
    }
    const te = {
      optional: fe(!0),
      required: fe(!1)
    };
    function j(x, p) {
      const b = te.required.object(p)(x);
      return b.succeeded ? b.value : void 0;
    }
    function Ae(x) {
      console.warn([
        `Missing '${x.key}' of ${x.target} in ${x.place}.`,
        "Please rebuild plugins with the latest core package."
      ].join(" "));
    }
    function Y(x) {
      return x && x.parentElement && x.parentElement.removeChild(x), null;
    }
    class pe {
      constructor(p) {
        this.value_ = p;
      }
      static create(p) {
        return [
          new pe(p),
          (b, M) => {
            p.setRawValue(b, M);
          }
        ];
      }
      get emitter() {
        return this.value_.emitter;
      }
      get rawValue() {
        return this.value_.rawValue;
      }
    }
    const me = w("");
    function re(x, p) {
      return S(x, me(void 0, p));
    }
    class ye extends q {
      constructor(p) {
        var b;
        super(p), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = pe.create(Q(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (b = this.get("parent")) === null || b === void 0 || b.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
      }
      static create(p) {
        var b, M, z;
        const de = p ?? {};
        return new ye(q.createCore({
          disabled: (b = de.disabled) !== null && b !== void 0 ? b : !1,
          disposed: !1,
          hidden: (M = de.hidden) !== null && M !== void 0 ? M : !1,
          parent: (z = de.parent) !== null && z !== void 0 ? z : null
        }));
      }
      get globalDisabled() {
        return this.globalDisabled_;
      }
      bindClassModifiers(p) {
        C(this.globalDisabled_, re(p, "disabled")), B(this, "hidden", re(p, "hidden"));
      }
      bindDisabled(p) {
        C(this.globalDisabled_, (b) => {
          p.disabled = b;
        });
      }
      bindTabIndex(p) {
        C(this.globalDisabled_, (b) => {
          p.tabIndex = b ? -1 : 0;
        });
      }
      handleDispose(p) {
        this.value("disposed").emitter.on("change", (b) => {
          b && p();
        });
      }
      getGlobalDisabled_() {
        const p = this.get("parent");
        return (p ? p.globalDisabled.rawValue : !1) || this.get("disabled");
      }
      updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
      }
      onDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentChange_(p) {
        var b;
        const M = p.previousRawValue;
        M == null || M.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (b = this.get("parent")) === null || b === void 0 || b.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
      }
    }
    function ae() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const De = w(""), Ee = {
      veryfirst: "vfst",
      first: "fst",
      last: "lst",
      verylast: "vlst"
    };
    class Ie {
      constructor(p) {
        this.parent_ = null, this.blade = p.blade, this.view = p.view, this.viewProps = p.viewProps;
        const b = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          ae().forEach((M) => {
            b.classList.remove(De(void 0, Ee[M]));
          }), this.blade.get("positions").forEach((M) => {
            b.classList.add(De(void 0, Ee[M]));
          });
        }), this.viewProps.handleDispose(() => {
          Y(b);
        });
      }
      get parent() {
        return this.parent_;
      }
      set parent(p) {
        if (this.parent_ = p, !("parent" in this.viewProps.valMap_)) {
          Ae({
            key: "parent",
            target: ye.name,
            place: "BladeController.parent"
          });
          return;
        }
        this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
      }
    }
    const Ce = "http://www.w3.org/2000/svg";
    function ze(x) {
      x.offsetHeight;
    }
    function Fe(x, p) {
      const b = x.style.transition;
      x.style.transition = "none", p(), x.style.transition = b;
    }
    function W(x) {
      return x.ontouchstart !== void 0;
    }
    function G() {
      return globalThis;
    }
    function se() {
      return G().document;
    }
    function _e(x) {
      const p = x.ownerDocument.defaultView;
      return p && "document" in p ? x.getContext("2d", {
        willReadFrequently: !0
      }) : null;
    }
    const ve = {
      check: '<path d="M2 8l4 4l8 -8"/>',
      dropdown: '<path d="M5 7h6l-3 3 z"/>',
      p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
    };
    function ue(x, p) {
      const b = x.createElementNS(Ce, "svg");
      return b.innerHTML = ve[p], b;
    }
    function Te(x, p, b) {
      x.insertBefore(p, x.children[b]);
    }
    function Ge(x) {
      x.parentElement && x.parentElement.removeChild(x);
    }
    function Pe(x) {
      for (; x.children.length > 0; )
        x.removeChild(x.children[0]);
    }
    function he(x) {
      for (; x.childNodes.length > 0; )
        x.removeChild(x.childNodes[0]);
    }
    function Se(x) {
      return x.relatedTarget ? x.relatedTarget : "explicitOriginalTarget" in x ? x.explicitOriginalTarget : null;
    }
    const Ve = w("lbl");
    function Ye(x, p) {
      const b = x.createDocumentFragment();
      return p.split(`
`).map((z) => x.createTextNode(z)).forEach((z, de) => {
        de > 0 && b.appendChild(x.createElement("br")), b.appendChild(z);
      }), b;
    }
    class $e {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(Ve()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("div");
        M.classList.add(Ve("l")), B(b.props, "label", (de) => {
          f(de) ? this.element.classList.add(Ve(void 0, "nol")) : (this.element.classList.remove(Ve(void 0, "nol")), he(M), M.appendChild(Ye(p, de)));
        }), this.element.appendChild(M), this.labelElement = M;
        const z = p.createElement("div");
        z.classList.add(Ve("v")), this.element.appendChild(z), this.valueElement = z;
      }
    }
    class Ne extends Ie {
      constructor(p, b) {
        const M = b.valueController.viewProps;
        super(Object.assign(Object.assign({}, b), { view: new $e(p, {
          props: b.props,
          viewProps: M
        }), viewProps: M })), this.props = b.props, this.valueController = b.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const He = {
      id: "button",
      type: "blade",
      accept(x) {
        const p = te, b = j(x, {
          title: p.required.string,
          view: p.required.constant("button"),
          label: p.optional.string
        });
        return b ? { params: b } : null;
      },
      controller(x) {
        return new Ne(x.document, {
          blade: x.blade,
          props: q.fromObject({
            label: x.params.label
          }),
          valueController: new L(x.document, {
            props: q.fromObject({
              title: x.params.title
            }),
            viewProps: x.viewProps
          })
        });
      },
      api(x) {
        return !(x.controller instanceof Ne) || !(x.controller.valueController instanceof L) ? null : new A(x.controller);
      }
    };
    class Qe extends Ie {
      constructor(p) {
        super(p), this.value = p.value;
      }
    }
    function Ze() {
      return new q({
        positions: Q([], {
          equals: h
        })
      });
    }
    class Ke extends q {
      constructor(p) {
        super(p);
      }
      static create(p) {
        const b = {
          completed: !0,
          expanded: p,
          expandedHeight: null,
          shouldFixHeight: !1,
          temporaryExpanded: null
        }, M = q.createCore(b);
        return new Ke(M);
      }
      get styleExpanded() {
        var p;
        return (p = this.get("temporaryExpanded")) !== null && p !== void 0 ? p : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded)
          return "0";
        const p = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !f(p) ? `${p}px` : "auto";
      }
      bindExpandedClass(p, b) {
        const M = () => {
          this.styleExpanded ? p.classList.add(b) : p.classList.remove(b);
        };
        B(this, "expanded", M), B(this, "temporaryExpanded", M);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
      }
    }
    function $(x, p) {
      let b = 0;
      return Fe(p, () => {
        x.set("expandedHeight", null), x.set("temporaryExpanded", !0), ze(p), b = p.clientHeight, x.set("temporaryExpanded", null), ze(p);
      }), b;
    }
    function ge(x, p) {
      p.style.height = x.styleHeight;
    }
    function be(x, p) {
      x.value("expanded").emitter.on("beforechange", () => {
        if (x.set("completed", !1), f(x.get("expandedHeight"))) {
          const b = $(x, p);
          b > 0 && x.set("expandedHeight", b);
        }
        x.set("shouldFixHeight", !0), ze(p);
      }), x.emitter.on("change", () => {
        ge(x, p);
      }), ge(x, p), p.addEventListener("transitionend", (b) => {
        b.propertyName === "height" && x.cleanUpTransition();
      });
    }
    class Ue extends i {
      constructor(p, b) {
        super(p), this.rackApi_ = b;
      }
    }
    function je(x, p) {
      return x.addBlade(Object.assign(Object.assign({}, p), { view: "button" }));
    }
    function it(x, p) {
      return x.addBlade(Object.assign(Object.assign({}, p), { view: "folder" }));
    }
    function nt(x, p) {
      const b = p ?? {};
      return x.addBlade(Object.assign(Object.assign({}, b), { view: "separator" }));
    }
    function mt(x, p) {
      return x.addBlade(Object.assign(Object.assign({}, p), { view: "tab" }));
    }
    class bt {
      constructor(p) {
        this.emitter = new v(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = p;
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(p) {
        for (const b of this.allItems())
          if (p(b))
            return b;
        return null;
      }
      includes(p) {
        return this.cache_.has(p);
      }
      add(p, b) {
        if (this.includes(p))
          throw _.shouldNeverHappen();
        const M = b !== void 0 ? b : this.items_.length;
        this.items_.splice(M, 0, p), this.cache_.add(p);
        const z = this.extract_(p);
        z && (z.emitter.on("add", this.onSubListAdd_), z.emitter.on("remove", this.onSubListRemove_), z.allItems().forEach((de) => {
          this.cache_.add(de);
        })), this.emitter.emit("add", {
          index: M,
          item: p,
          root: this,
          target: this
        });
      }
      remove(p) {
        const b = this.items_.indexOf(p);
        if (b < 0)
          return;
        this.items_.splice(b, 1), this.cache_.delete(p);
        const M = this.extract_(p);
        M && (M.emitter.off("add", this.onSubListAdd_), M.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
          index: b,
          item: p,
          root: this,
          target: this
        });
      }
      onSubListAdd_(p) {
        this.cache_.add(p.item), this.emitter.emit("add", {
          index: p.index,
          item: p.item,
          root: this,
          target: p.target
        });
      }
      onSubListRemove_(p) {
        this.cache_.delete(p.item), this.emitter.emit("remove", {
          index: p.index,
          item: p.item,
          root: this,
          target: p.target
        });
      }
    }
    class Xe extends i {
      constructor(p) {
        super(p), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new v(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(p) {
        this.controller_.props.set("label", p);
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(p) {
        const b = p.sender.target.read();
        this.emitter_.emit("change", {
          event: new a(this, b, this.controller_.binding.target.presetKey, p.options.last)
        });
      }
    }
    class dt extends Ne {
      constructor(p, b) {
        super(p, b), this.binding = b.binding;
      }
    }
    class at extends i {
      constructor(p) {
        super(p), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new v(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(p) {
        this.controller_.props.set("label", p);
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(p) {
        const b = p.sender.target.read();
        this.emitter_.emit("update", {
          event: new o(this, b, this.controller_.binding.target.presetKey)
        });
      }
    }
    class At extends Ne {
      constructor(p, b) {
        super(p, b), this.binding = b.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
          this.binding.dispose();
        });
      }
    }
    function It(x) {
      return x instanceof $t ? x.apiSet_ : x instanceof Ue ? x.rackApi_.apiSet_ : null;
    }
    function Qt(x, p) {
      const b = x.find((M) => M.controller_ === p);
      if (!b)
        throw _.shouldNeverHappen();
      return b;
    }
    function Tt(x, p, b) {
      if (!g.isBindable(x))
        throw _.notBindable();
      return new g(x, p, b);
    }
    class $t extends i {
      constructor(p, b) {
        super(p), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new v(), this.apiSet_ = new bt(It), this.pool_ = b;
        const M = this.controller_.rack;
        M.emitter.on("add", this.onRackAdd_), M.emitter.on("remove", this.onRackRemove_), M.emitter.on("inputchange", this.onRackInputChange_), M.emitter.on("monitorupdate", this.onRackMonitorUpdate_), M.children.forEach((z) => {
          this.setUpApi_(z);
        });
      }
      get children() {
        return this.controller_.rack.children.map((p) => Qt(this.apiSet_, p));
      }
      addInput(p, b, M) {
        const z = M ?? {}, de = this.controller_.view.element.ownerDocument, Re = this.pool_.createInput(de, Tt(p, b, z.presetKey), z), et = new Xe(Re);
        return this.add(et, z.index);
      }
      addMonitor(p, b, M) {
        const z = M ?? {}, de = this.controller_.view.element.ownerDocument, Re = this.pool_.createMonitor(de, Tt(p, b), z), et = new at(Re);
        return this.add(et, z.index);
      }
      addFolder(p) {
        return it(this, p);
      }
      addButton(p) {
        return je(this, p);
      }
      addSeparator(p) {
        return nt(this, p);
      }
      addTab(p) {
        return mt(this, p);
      }
      add(p, b) {
        this.controller_.rack.add(p.controller_, b);
        const M = this.apiSet_.find((z) => z.controller_ === p.controller_);
        return M && this.apiSet_.remove(M), this.apiSet_.add(p), p;
      }
      remove(p) {
        this.controller_.rack.remove(p.controller_);
      }
      addBlade(p) {
        const b = this.controller_.view.element.ownerDocument, M = this.pool_.createBlade(b, p), z = this.pool_.createBladeApi(M);
        return this.add(z, p.index);
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
      setUpApi_(p) {
        this.apiSet_.find((M) => M.controller_ === p) || this.apiSet_.add(this.pool_.createBladeApi(p));
      }
      onRackAdd_(p) {
        this.setUpApi_(p.bladeController);
      }
      onRackRemove_(p) {
        if (p.isRoot) {
          const b = Qt(this.apiSet_, p.bladeController);
          this.apiSet_.remove(b);
        }
      }
      onRackInputChange_(p) {
        const b = p.bladeController;
        if (b instanceof dt) {
          const M = Qt(this.apiSet_, b), z = b.binding;
          this.emitter_.emit("change", {
            event: new a(M, z.target.read(), z.target.presetKey, p.options.last)
          });
        } else if (b instanceof Qe) {
          const M = Qt(this.apiSet_, b);
          this.emitter_.emit("change", {
            event: new a(M, b.value.rawValue, void 0, p.options.last)
          });
        }
      }
      onRackMonitorUpdate_(p) {
        if (!(p.bladeController instanceof At))
          throw _.shouldNeverHappen();
        const b = Qt(this.apiSet_, p.bladeController), M = p.bladeController.binding;
        this.emitter_.emit("update", {
          event: new o(b, M.target.read(), M.target.presetKey)
        });
      }
    }
    class Jt extends Ue {
      constructor(p, b) {
        super(p, new $t(p.rackController, b)), this.emitter_ = new v(), this.controller_.foldable.value("expanded").emitter.on("change", (M) => {
          this.emitter_.emit("fold", {
            event: new l(this, M.sender.rawValue)
          });
        }), this.rackApi_.on("change", (M) => {
          this.emitter_.emit("change", {
            event: M
          });
        }), this.rackApi_.on("update", (M) => {
          this.emitter_.emit("update", {
            event: M
          });
        });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(p) {
        this.controller_.foldable.set("expanded", p);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(p) {
        this.controller_.props.set("title", p);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(p, b, M) {
        return this.rackApi_.addInput(p, b, M);
      }
      addMonitor(p, b, M) {
        return this.rackApi_.addMonitor(p, b, M);
      }
      addFolder(p) {
        return this.rackApi_.addFolder(p);
      }
      addButton(p) {
        return this.rackApi_.addButton(p);
      }
      addSeparator(p) {
        return this.rackApi_.addSeparator(p);
      }
      addTab(p) {
        return this.rackApi_.addTab(p);
      }
      add(p, b) {
        return this.rackApi_.add(p, b);
      }
      remove(p) {
        this.rackApi_.remove(p);
      }
      addBlade(p) {
        return this.rackApi_.addBlade(p);
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
    }
    class on extends Ie {
      constructor(p) {
        super({
          blade: p.blade,
          view: p.view,
          viewProps: p.rackController.viewProps
        }), this.rackController = p.rackController;
      }
    }
    class Wt {
      constructor(p, b) {
        const M = w(b.viewName);
        this.element = p.createElement("div"), this.element.classList.add(M()), b.viewProps.bindClassModifiers(this.element);
      }
    }
    function an(x, p) {
      for (let b = 0; b < x.length; b++) {
        const M = x[b];
        if (M instanceof dt && M.binding === p)
          return M;
      }
      return null;
    }
    function Mn(x, p) {
      for (let b = 0; b < x.length; b++) {
        const M = x[b];
        if (M instanceof At && M.binding === p)
          return M;
      }
      return null;
    }
    function Zn(x, p) {
      for (let b = 0; b < x.length; b++) {
        const M = x[b];
        if (M instanceof Qe && M.value === p)
          return M;
      }
      return null;
    }
    function ie(x) {
      return x instanceof Le ? x.rack : x instanceof on ? x.rackController.rack : null;
    }
    function Be(x) {
      const p = ie(x);
      return p ? p.bcSet_ : null;
    }
    class Oe {
      constructor(p) {
        var b, M;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new v(), this.blade_ = (b = p.blade) !== null && b !== void 0 ? b : null, (M = this.blade_) === null || M === void 0 || M.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = p.viewProps, this.bcSet_ = new bt(Be), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(p, b) {
        var M;
        (M = p.parent) === null || M === void 0 || M.remove(p), d(p, "parent") ? p.parent = this : (p.parent_ = this, Ae({
          key: "parent",
          target: "BladeController",
          place: "BladeRack.add"
        })), this.bcSet_.add(p, b);
      }
      remove(p) {
        d(p, "parent") ? p.parent = null : (p.parent_ = null, Ae({
          key: "parent",
          target: "BladeController",
          place: "BladeRack.remove"
        })), this.bcSet_.remove(p);
      }
      find(p) {
        return this.bcSet_.allItems().filter((b) => b instanceof p);
      }
      onSetAdd_(p) {
        this.updatePositions_();
        const b = p.target === p.root;
        if (this.emitter.emit("add", {
          bladeController: p.item,
          index: p.index,
          isRoot: b,
          sender: this
        }), !b)
          return;
        const M = p.item;
        if (M.viewProps.emitter.on("change", this.onChildViewPropsChange_), M.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), M.viewProps.handleDispose(this.onChildDispose_), M instanceof dt)
          M.binding.emitter.on("change", this.onChildInputChange_);
        else if (M instanceof At)
          M.binding.emitter.on("update", this.onChildMonitorUpdate_);
        else if (M instanceof Qe)
          M.value.emitter.on("change", this.onChildValueChange_);
        else {
          const z = ie(M);
          if (z) {
            const de = z.emitter;
            de.on("layout", this.onDescendantLayout_), de.on("inputchange", this.onDescendantInputChange_), de.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(p) {
        this.updatePositions_();
        const b = p.target === p.root;
        if (this.emitter.emit("remove", {
          bladeController: p.item,
          isRoot: b,
          sender: this
        }), !b)
          return;
        const M = p.item;
        if (M instanceof dt)
          M.binding.emitter.off("change", this.onChildInputChange_);
        else if (M instanceof At)
          M.binding.emitter.off("update", this.onChildMonitorUpdate_);
        else if (M instanceof Qe)
          M.value.emitter.off("change", this.onChildValueChange_);
        else {
          const z = ie(M);
          if (z) {
            const de = z.emitter;
            de.off("layout", this.onDescendantLayout_), de.off("inputchange", this.onDescendantInputChange_), de.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const p = this.bcSet_.items.filter((z) => !z.viewProps.get("hidden")), b = p[0], M = p[p.length - 1];
        this.bcSet_.items.forEach((z) => {
          const de = [];
          z === b && (de.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && de.push("veryfirst")), z === M && (de.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && de.push("verylast")), z.blade.set("positions", de);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildViewPropsChange_(p) {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildDispose_() {
        this.bcSet_.items.filter((b) => b.viewProps.get("disposed")).forEach((b) => {
          this.bcSet_.remove(b);
        });
      }
      onChildInputChange_(p) {
        const b = an(this.find(dt), p.sender);
        if (!b)
          throw _.alreadyDisposed();
        this.emitter.emit("inputchange", {
          bladeController: b,
          options: p.options,
          sender: this
        });
      }
      onChildMonitorUpdate_(p) {
        const b = Mn(this.find(At), p.sender);
        if (!b)
          throw _.alreadyDisposed();
        this.emitter.emit("monitorupdate", {
          bladeController: b,
          sender: this
        });
      }
      onChildValueChange_(p) {
        const b = Zn(this.find(Qe), p.sender);
        if (!b)
          throw _.alreadyDisposed();
        this.emitter.emit("inputchange", {
          bladeController: b,
          options: p.options,
          sender: this
        });
      }
      onDescendantLayout_(p) {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onDescendantInputChange_(p) {
        this.emitter.emit("inputchange", {
          bladeController: p.bladeController,
          options: p.options,
          sender: this
        });
      }
      onDescendantMonitorUpdate_(p) {
        this.emitter.emit("monitorupdate", {
          bladeController: p.bladeController,
          sender: this
        });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class Le extends Ie {
      constructor(p, b) {
        super(Object.assign(Object.assign({}, b), { view: new Wt(p, {
          viewName: "brk",
          viewProps: b.viewProps
        }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
        const M = new Oe({
          blade: b.root ? void 0 : b.blade,
          viewProps: b.viewProps
        });
        M.emitter.on("add", this.onRackAdd_), M.emitter.on("remove", this.onRackRemove_), this.rack = M, this.viewProps.handleDispose(() => {
          for (let z = this.rack.children.length - 1; z >= 0; z--)
            this.rack.children[z].viewProps.set("disposed", !0);
        });
      }
      onRackAdd_(p) {
        p.isRoot && Te(this.view.element, p.bladeController.view.element, p.index);
      }
      onRackRemove_(p) {
        p.isRoot && Ge(p.bladeController.view.element);
      }
    }
    const F = w("cnt");
    class ce {
      constructor(p, b) {
        var M;
        this.className_ = w((M = b.viewName) !== null && M !== void 0 ? M : "fld"), this.element = p.createElement("div"), this.element.classList.add(this.className_(), F()), b.viewProps.bindClassModifiers(this.element), this.foldable_ = b.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), B(this.foldable_, "completed", S(this.element, this.className_(void 0, "cpl")));
        const z = p.createElement("button");
        z.classList.add(this.className_("b")), B(b.props, "title", (kt) => {
          f(kt) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
        }), b.viewProps.bindDisabled(z), this.element.appendChild(z), this.buttonElement = z;
        const de = p.createElement("div");
        de.classList.add(this.className_("i")), this.element.appendChild(de);
        const Re = p.createElement("div");
        Re.classList.add(this.className_("t")), D(b.props.value("title"), Re), this.buttonElement.appendChild(Re), this.titleElement = Re;
        const et = p.createElement("div");
        et.classList.add(this.className_("m")), this.buttonElement.appendChild(et);
        const Pt = b.containerElement;
        Pt.classList.add(this.className_("c")), this.element.appendChild(Pt), this.containerElement = Pt;
      }
    }
    class ct extends on {
      constructor(p, b) {
        var M;
        const z = Ke.create((M = b.expanded) !== null && M !== void 0 ? M : !0), de = new Le(p, {
          blade: b.blade,
          root: b.root,
          viewProps: b.viewProps
        });
        super(Object.assign(Object.assign({}, b), { rackController: de, view: new ce(p, {
          containerElement: de.view.element,
          foldable: z,
          props: b.props,
          viewName: b.root ? "rot" : void 0,
          viewProps: b.viewProps
        }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = b.props, this.foldable = z, be(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
          this.foldable.cleanUpTransition();
        }), this.rackController.rack.emitter.on("remove", () => {
          this.foldable.cleanUpTransition();
        }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const ut = {
      id: "folder",
      type: "blade",
      accept(x) {
        const p = te, b = j(x, {
          title: p.required.string,
          view: p.required.constant("folder"),
          expanded: p.optional.boolean
        });
        return b ? { params: b } : null;
      },
      controller(x) {
        return new ct(x.document, {
          blade: x.blade,
          expanded: x.params.expanded,
          props: q.fromObject({
            title: x.params.title
          }),
          viewProps: x.viewProps
        });
      },
      api(x) {
        return x.controller instanceof ct ? new Jt(x.controller, x.pool) : null;
      }
    };
    class pt extends Qe {
      constructor(p, b) {
        const M = b.valueController.viewProps;
        super(Object.assign(Object.assign({}, b), { value: b.valueController.value, view: new $e(p, {
          props: b.props,
          viewProps: M
        }), viewProps: M })), this.props = b.props, this.valueController = b.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class Bt extends i {
    }
    const qe = w("spr");
    class Lt {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(qe()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("hr");
        M.classList.add(qe("r")), this.element.appendChild(M);
      }
    }
    class pn extends Ie {
      constructor(p, b) {
        super(Object.assign(Object.assign({}, b), { view: new Lt(p, {
          viewProps: b.viewProps
        }) }));
      }
    }
    const mn = {
      id: "separator",
      type: "blade",
      accept(x) {
        const b = j(x, {
          view: te.required.constant("separator")
        });
        return b ? { params: b } : null;
      },
      controller(x) {
        return new pn(x.document, {
          blade: x.blade,
          viewProps: x.viewProps
        });
      },
      api(x) {
        return x.controller instanceof pn ? new Bt(x.controller) : null;
      }
    }, _n = w("tbi");
    class pi {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(_n()), b.viewProps.bindClassModifiers(this.element), B(b.props, "selected", (de) => {
          de ? this.element.classList.add(_n(void 0, "sel")) : this.element.classList.remove(_n(void 0, "sel"));
        });
        const M = p.createElement("button");
        M.classList.add(_n("b")), b.viewProps.bindDisabled(M), this.element.appendChild(M), this.buttonElement = M;
        const z = p.createElement("div");
        z.classList.add(_n("t")), D(b.props.value("title"), z), this.buttonElement.appendChild(z), this.titleElement = z;
      }
    }
    class zt {
      constructor(p, b) {
        this.emitter = new v(), this.onClick_ = this.onClick_.bind(this), this.props = b.props, this.viewProps = b.viewProps, this.view = new pi(p, {
          props: b.props,
          viewProps: b.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class vt {
      constructor(p, b) {
        this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new zt(p, {
          props: b.itemProps,
          viewProps: ye.create()
        }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new Le(p, {
          blade: Ze(),
          viewProps: ye.create()
        }), this.props = b.props, B(this.props, "selected", (M) => {
          this.itemController.props.set("selected", M), this.contentController.viewProps.set("hidden", !M);
        });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", !0);
      }
    }
    class Ei {
      constructor(p, b) {
        this.controller_ = p, this.rackApi_ = b;
      }
      get title() {
        var p;
        return (p = this.controller_.itemController.props.get("title")) !== null && p !== void 0 ? p : "";
      }
      set title(p) {
        this.controller_.itemController.props.set("title", p);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(p) {
        this.controller_.props.set("selected", p);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(p) {
        return this.rackApi_.addButton(p);
      }
      addFolder(p) {
        return this.rackApi_.addFolder(p);
      }
      addSeparator(p) {
        return this.rackApi_.addSeparator(p);
      }
      addTab(p) {
        return this.rackApi_.addTab(p);
      }
      add(p, b) {
        this.rackApi_.add(p, b);
      }
      remove(p) {
        this.rackApi_.remove(p);
      }
      addInput(p, b, M) {
        return this.rackApi_.addInput(p, b, M);
      }
      addMonitor(p, b, M) {
        return this.rackApi_.addMonitor(p, b, M);
      }
      addBlade(p) {
        return this.rackApi_.addBlade(p);
      }
    }
    class sn extends Ue {
      constructor(p, b) {
        super(p, new $t(p.rackController, b)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new v(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (M) => {
          this.emitter_.emit("change", {
            event: M
          });
        }), this.rackApi_.on("update", (M) => {
          this.emitter_.emit("update", {
            event: M
          });
        }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((M) => {
          this.setUpPageApi_(M);
        });
      }
      get pages() {
        return this.controller_.pageSet.items.map((p) => {
          const b = this.pageApiMap_.get(p);
          if (!b)
            throw _.shouldNeverHappen();
          return b;
        });
      }
      addPage(p) {
        const b = this.controller_.view.element.ownerDocument, M = new vt(b, {
          itemProps: q.fromObject({
            selected: !1,
            title: p.title
          }),
          props: q.fromObject({
            selected: !1
          })
        });
        this.controller_.add(M, p.index);
        const z = this.pageApiMap_.get(M);
        if (!z)
          throw _.shouldNeverHappen();
        return z;
      }
      removePage(p) {
        this.controller_.remove(p);
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
      setUpPageApi_(p) {
        const b = this.rackApi_.apiSet_.find((z) => z.controller_ === p.contentController);
        if (!b)
          throw _.shouldNeverHappen();
        const M = new Ei(p, b);
        this.pageApiMap_.set(p, M);
      }
      onPageAdd_(p) {
        this.setUpPageApi_(p.item);
      }
      onPageRemove_(p) {
        if (!this.pageApiMap_.get(p.item))
          throw _.shouldNeverHappen();
        this.pageApiMap_.delete(p.item);
      }
      onSelect_(p) {
        this.emitter_.emit("select", {
          event: new c(this, p.rawValue)
        });
      }
    }
    const li = -1;
    class Hr {
      constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = Q(!0), this.selectedIndex = Q(li), this.items_ = [];
      }
      add(p, b) {
        const M = b ?? this.items_.length;
        this.items_.splice(M, 0, p), p.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
      }
      remove(p) {
        const b = this.items_.indexOf(p);
        b < 0 || (this.items_.splice(b, 1), p.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
      }
      keepSelection_() {
        if (this.items_.length === 0) {
          this.selectedIndex.rawValue = li, this.empty.rawValue = !0;
          return;
        }
        const p = this.items_.findIndex((b) => b.rawValue);
        p < 0 ? (this.items_.forEach((b, M) => {
          b.rawValue = M === 0;
        }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((b, M) => {
          b.rawValue = M === p;
        }), this.selectedIndex.rawValue = p), this.empty.rawValue = !1;
      }
      onItemSelectedChange_(p) {
        if (p.rawValue) {
          const b = this.items_.findIndex((M) => M === p.sender);
          this.items_.forEach((M, z) => {
            M.rawValue = z === b;
          }), this.selectedIndex.rawValue = b;
        } else
          this.keepSelection_();
      }
    }
    const ci = w("tab");
    class Cr {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(ci(), F()), b.viewProps.bindClassModifiers(this.element), C(b.empty, S(this.element, ci(void 0, "nop")));
        const M = p.createElement("div");
        M.classList.add(ci("t")), this.element.appendChild(M), this.itemsElement = M;
        const z = p.createElement("div");
        z.classList.add(ci("i")), this.element.appendChild(z);
        const de = b.contentsElement;
        de.classList.add(ci("c")), this.element.appendChild(de), this.contentsElement = de;
      }
    }
    class gn extends on {
      constructor(p, b) {
        const M = new Le(p, {
          blade: b.blade,
          viewProps: b.viewProps
        }), z = new Hr();
        super({
          blade: b.blade,
          rackController: M,
          view: new Cr(p, {
            contentsElement: M.view.element,
            empty: z.empty,
            viewProps: b.viewProps
          })
        }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new bt(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = z;
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(p, b) {
        this.pageSet_.add(p, b);
      }
      remove(p) {
        this.pageSet_.remove(this.pageSet_.items[p]);
      }
      onPageAdd_(p) {
        const b = p.item;
        Te(this.view.itemsElement, b.itemController.view.element, p.index), b.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(b.contentController, p.index), this.tab.add(b.props.value("selected"));
      }
      onPageRemove_(p) {
        const b = p.item;
        Ge(b.itemController.view.element), b.itemController.viewProps.set("parent", null), this.rackController.rack.remove(b.contentController), this.tab.remove(b.props.value("selected"));
      }
    }
    const ui = {
      id: "tab",
      type: "blade",
      accept(x) {
        const p = te, b = j(x, {
          pages: p.required.array(p.required.object({ title: p.required.string })),
          view: p.required.constant("tab")
        });
        return !b || b.pages.length === 0 ? null : { params: b };
      },
      controller(x) {
        const p = new gn(x.document, {
          blade: x.blade,
          viewProps: x.viewProps
        });
        return x.params.pages.forEach((b) => {
          const M = new vt(x.document, {
            itemProps: q.fromObject({
              selected: !1,
              title: b.title
            }),
            props: q.fromObject({
              selected: !1
            })
          });
          p.add(M);
        }), p;
      },
      api(x) {
        return x.controller instanceof gn ? new sn(x.controller, x.pool) : null;
      }
    };
    function Oi(x, p) {
      const b = x.accept(p.params);
      if (!b)
        return null;
      const M = te.optional.boolean(p.params.disabled).value, z = te.optional.boolean(p.params.hidden).value;
      return x.controller({
        blade: Ze(),
        document: p.document,
        params: Object.assign(Object.assign({}, b.params), { disabled: M, hidden: z }),
        viewProps: ye.create({
          disabled: M,
          hidden: z
        })
      });
    }
    class Nn {
      constructor() {
        this.disabled = !1, this.emitter = new v();
      }
      dispose() {
      }
      tick() {
        this.disabled || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class fr {
      constructor(p, b) {
        this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = p, this.emitter = new v(), this.interval_ = b, this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(p) {
        this.disabled_ = p, this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null)
          return;
        const p = this.doc_.defaultView;
        p && p.clearInterval(this.timerId_), this.timerId_ = null;
      }
      setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0)
          return;
        const p = this.doc_.defaultView;
        p && (this.timerId_ = p.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class jr {
      constructor(p) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.reader = p.reader, this.writer = p.writer, this.emitter = new v(), this.value = p.value, this.value.emitter.on("change", this.onValueChange_), this.target = p.target, this.read();
      }
      read() {
        const p = this.target.read();
        p !== void 0 && (this.value.rawValue = this.reader(p));
      }
      write_(p) {
        this.writer(this.target, p);
      }
      onValueChange_(p) {
        this.write_(p.rawValue), this.emitter.emit("change", {
          options: p.options,
          rawValue: p.rawValue,
          sender: this
        });
      }
    }
    function ei(x, p) {
      for (; x.length < p; )
        x.push(void 0);
    }
    function Ma(x) {
      const p = [];
      return ei(p, x), Q(p);
    }
    function fs(x) {
      const p = x.indexOf(void 0);
      return p < 0 ? x : x.slice(0, p);
    }
    function Wr(x, p) {
      const b = [...fs(x), p];
      return b.length > x.length ? b.splice(0, b.length - x.length) : ei(b, x.length), b;
    }
    class Eo {
      constructor(p) {
        this.onTick_ = this.onTick_.bind(this), this.reader_ = p.reader, this.target = p.target, this.emitter = new v(), this.value = p.value, this.ticker = p.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const p = this.target.read();
        if (p === void 0)
          return;
        const b = this.value.rawValue, M = this.reader_(p);
        this.value.rawValue = Wr(b, M), this.emitter.emit("update", {
          rawValue: M,
          sender: this
        });
      }
      onTick_(p) {
        this.read();
      }
    }
    class Zi {
      constructor(p) {
        this.constraints = p;
      }
      constrain(p) {
        return this.constraints.reduce((b, M) => M.constrain(b), p);
      }
    }
    function mi(x, p) {
      if (x instanceof p)
        return x;
      if (x instanceof Zi) {
        const b = x.constraints.reduce((M, z) => M || (z instanceof p ? z : null), null);
        if (b)
          return b;
      }
      return null;
    }
    class er {
      constructor(p) {
        this.values = q.fromObject({
          max: p.max,
          min: p.min
        });
      }
      constrain(p) {
        const b = this.values.get("max"), M = this.values.get("min");
        return Math.min(Math.max(p, M), b);
      }
    }
    class Sr {
      constructor(p) {
        this.values = q.fromObject({
          options: p
        });
      }
      get options() {
        return this.values.get("options");
      }
      constrain(p) {
        const b = this.values.get("options");
        return b.length === 0 || b.filter((z) => z.value === p).length > 0 ? p : b[0].value;
      }
    }
    class Fs {
      constructor(p) {
        this.values = q.fromObject({
          max: p.max,
          min: p.min
        });
      }
      get maxValue() {
        return this.values.get("max");
      }
      get minValue() {
        return this.values.get("min");
      }
      constrain(p) {
        const b = this.values.get("max"), M = this.values.get("min");
        let z = p;
        return f(M) || (z = Math.max(z, M)), f(b) || (z = Math.min(z, b)), z;
      }
    }
    class Mr {
      constructor(p, b = 0) {
        this.step = p, this.origin = b;
      }
      constrain(p) {
        const b = this.origin % this.step, M = Math.round((p - b) / this.step);
        return b + M * this.step;
      }
    }
    const hr = w("lst");
    class Co {
      constructor(p, b) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = b.props, this.element = p.createElement("div"), this.element.classList.add(hr()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("select");
        M.classList.add(hr("s")), b.viewProps.bindDisabled(M), this.element.appendChild(M), this.selectElement = M;
        const z = p.createElement("div");
        z.classList.add(hr("m")), z.appendChild(ue(p, "dropdown")), this.element.appendChild(z), b.value.emitter.on("change", this.onValueChange_), this.value_ = b.value, B(this.props_, "options", (de) => {
          Pe(this.selectElement), de.forEach((Re) => {
            const et = p.createElement("option");
            et.textContent = Re.text, this.selectElement.appendChild(et);
          }), this.update_();
        });
      }
      update_() {
        const p = this.props_.get("options").map((b) => b.value);
        this.selectElement.selectedIndex = p.indexOf(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class tr {
      constructor(p, b) {
        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = b.props, this.value = b.value, this.viewProps = b.viewProps, this.view = new Co(p, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
      }
      onSelectChange_(p) {
        const b = p.currentTarget;
        this.value.rawValue = this.props.get("options")[b.selectedIndex].value;
      }
    }
    const dr = w("pop");
    class Ir {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(dr()), b.viewProps.bindClassModifiers(this.element), C(b.shows, S(this.element, dr(void 0, "v")));
      }
    }
    class Tr {
      constructor(p, b) {
        this.shows = Q(!1), this.viewProps = b.viewProps, this.view = new Ir(p, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      }
    }
    const Os = w("txt");
    class qr {
      constructor(p, b) {
        this.onChange_ = this.onChange_.bind(this), this.element = p.createElement("div"), this.element.classList.add(Os()), b.viewProps.bindClassModifiers(this.element), this.props_ = b.props, this.props_.emitter.on("change", this.onChange_);
        const M = p.createElement("input");
        M.classList.add(Os("i")), M.type = "text", b.viewProps.bindDisabled(M), this.element.appendChild(M), this.inputElement = M, b.value.emitter.on("change", this.onChange_), this.value_ = b.value, this.refresh();
      }
      refresh() {
        const p = this.props_.get("formatter");
        this.inputElement.value = p(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Br {
      constructor(p, b) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = b.parser, this.props = b.props, this.value = b.value, this.viewProps = b.viewProps, this.view = new qr(p, {
          props: b.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(p) {
        const M = p.currentTarget.value, z = this.parser_(M);
        f(z) || (this.value.rawValue = z), this.view.refresh();
      }
    }
    function Ns(x) {
      return String(x);
    }
    function Gs(x) {
      return x === "false" ? !1 : !!x;
    }
    function Xr(x) {
      return Ns(x);
    }
    class Qs {
      constructor(p) {
        this.text = p;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const So = {
      "**": (x, p) => Math.pow(x, p),
      "*": (x, p) => x * p,
      "/": (x, p) => x / p,
      "%": (x, p) => x % p,
      "+": (x, p) => x + p,
      "-": (x, p) => x - p,
      "<<": (x, p) => x << p,
      ">>": (x, p) => x >> p,
      ">>>": (x, p) => x >>> p,
      "&": (x, p) => x & p,
      "^": (x, p) => x ^ p,
      "|": (x, p) => x | p
    };
    class Ci {
      constructor(p, b, M) {
        this.left = b, this.operator = p, this.right = M;
      }
      evaluate() {
        const p = So[this.operator];
        if (!p)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return p(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")"
        ].join(" ");
      }
    }
    const ac = {
      "+": (x) => x,
      "-": (x) => -x,
      "~": (x) => ~x
    };
    class ju {
      constructor(p, b) {
        this.operator = p, this.expression = b;
      }
      evaluate() {
        const p = ac[this.operator];
        if (!p)
          throw new Error(`unexpected unary operator: '${this.operator}`);
        return p(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function Ia(x) {
      return (p, b) => {
        for (let M = 0; M < x.length; M++) {
          const z = x[M](p, b);
          if (z !== "")
            return z;
        }
        return "";
      };
    }
    function hs(x, p) {
      var b;
      const M = x.substr(p).match(/^\s+/);
      return (b = M && M[0]) !== null && b !== void 0 ? b : "";
    }
    function Wu(x, p) {
      const b = x.substr(p, 1);
      return b.match(/^[1-9]$/) ? b : "";
    }
    function zs(x, p) {
      var b;
      const M = x.substr(p).match(/^[0-9]+/);
      return (b = M && M[0]) !== null && b !== void 0 ? b : "";
    }
    function Mo(x, p) {
      const b = zs(x, p);
      if (b !== "")
        return b;
      const M = x.substr(p, 1);
      if (p += 1, M !== "-" && M !== "+")
        return "";
      const z = zs(x, p);
      return z === "" ? "" : M + z;
    }
    function ds(x, p) {
      const b = x.substr(p, 1);
      if (p += 1, b.toLowerCase() !== "e")
        return "";
      const M = Mo(x, p);
      return M === "" ? "" : b + M;
    }
    function Pr(x, p) {
      const b = x.substr(p, 1);
      if (b === "0")
        return b;
      const M = Wu(x, p);
      return p += M.length, M === "" ? "" : M + zs(x, p);
    }
    function qu(x, p) {
      const b = Pr(x, p);
      if (p += b.length, b === "")
        return "";
      const M = x.substr(p, 1);
      if (p += M.length, M !== ".")
        return "";
      const z = zs(x, p);
      return p += z.length, b + M + z + ds(x, p);
    }
    function lc(x, p) {
      const b = x.substr(p, 1);
      if (p += b.length, b !== ".")
        return "";
      const M = zs(x, p);
      return p += M.length, M === "" ? "" : b + M + ds(x, p);
    }
    function cc(x, p) {
      const b = Pr(x, p);
      return p += b.length, b === "" ? "" : b + ds(x, p);
    }
    const Io = Ia([
      qu,
      lc,
      cc
    ]);
    function Xu(x, p) {
      var b;
      const M = x.substr(p).match(/^[01]+/);
      return (b = M && M[0]) !== null && b !== void 0 ? b : "";
    }
    function To(x, p) {
      const b = x.substr(p, 2);
      if (p += b.length, b.toLowerCase() !== "0b")
        return "";
      const M = Xu(x, p);
      return M === "" ? "" : b + M;
    }
    function uc(x, p) {
      var b;
      const M = x.substr(p).match(/^[0-7]+/);
      return (b = M && M[0]) !== null && b !== void 0 ? b : "";
    }
    function Ni(x, p) {
      const b = x.substr(p, 2);
      if (p += b.length, b.toLowerCase() !== "0o")
        return "";
      const M = uc(x, p);
      return M === "" ? "" : b + M;
    }
    function jd(x, p) {
      var b;
      const M = x.substr(p).match(/^[0-9a-f]+/i);
      return (b = M && M[0]) !== null && b !== void 0 ? b : "";
    }
    function Ta(x, p) {
      const b = x.substr(p, 2);
      if (p += b.length, b.toLowerCase() !== "0x")
        return "";
      const M = jd(x, p);
      return M === "" ? "" : b + M;
    }
    const Ba = Ia([
      To,
      Ni,
      Ta
    ]), Yu = Ia([
      Ba,
      Io
    ]);
    function Wd(x, p) {
      const b = Yu(x, p);
      return p += b.length, b === "" ? null : {
        evaluable: new Qs(b),
        cursor: p
      };
    }
    function Si(x, p) {
      const b = x.substr(p, 1);
      if (p += b.length, b !== "(")
        return null;
      const M = o0(x, p);
      if (!M)
        return null;
      p = M.cursor, p += hs(x, p).length;
      const z = x.substr(p, 1);
      return p += z.length, z !== ")" ? null : {
        evaluable: M.evaluable,
        cursor: p
      };
    }
    function nr(x, p) {
      var b;
      return (b = Wd(x, p)) !== null && b !== void 0 ? b : Si(x, p);
    }
    function gi(x, p) {
      const b = nr(x, p);
      if (b)
        return b;
      const M = x.substr(p, 1);
      if (p += M.length, M !== "+" && M !== "-" && M !== "~")
        return null;
      const z = gi(x, p);
      return z ? (p = z.cursor, {
        cursor: p,
        evaluable: new ju(M, z.evaluable)
      }) : null;
    }
    function Yr(x, p, b) {
      b += hs(p, b).length;
      const M = x.filter((z) => p.startsWith(z, b))[0];
      return M ? (b += M.length, b += hs(p, b).length, {
        cursor: b,
        operator: M
      }) : null;
    }
    function Ku(x, p) {
      return (b, M) => {
        const z = x(b, M);
        if (!z)
          return null;
        M = z.cursor;
        let de = z.evaluable;
        for (; ; ) {
          const Re = Yr(p, b, M);
          if (!Re)
            break;
          M = Re.cursor;
          const et = x(b, M);
          if (!et)
            return null;
          M = et.cursor, de = new Ci(Re.operator, de, et.evaluable);
        }
        return de ? {
          cursor: M,
          evaluable: de
        } : null;
      };
    }
    const sC = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"]
    ].reduce((x, p) => Ku(x, p), gi);
    function o0(x, p) {
      return p += hs(x, p).length, sC(x, p);
    }
    function oC(x) {
      const p = o0(x, 0);
      return !p || p.cursor + hs(x, p.cursor).length !== x.length ? null : p.evaluable;
    }
    function ps(x) {
      var p;
      const b = oC(x);
      return (p = b == null ? void 0 : b.evaluate()) !== null && p !== void 0 ? p : null;
    }
    function a0(x) {
      if (typeof x == "number")
        return x;
      if (typeof x == "string") {
        const p = ps(x);
        if (!f(p))
          return p;
      }
      return 0;
    }
    function aC(x) {
      return String(x);
    }
    function Ai(x) {
      return (p) => p.toFixed(Math.max(Math.min(x, 20), 0));
    }
    const lC = Ai(0);
    function Ju(x) {
      return lC(x) + "%";
    }
    function l0(x) {
      return String(x);
    }
    function qd(x) {
      return x;
    }
    function fc({ primary: x, secondary: p, forward: b, backward: M }) {
      let z = !1;
      function de(Re) {
        z || (z = !0, Re(), z = !1);
      }
      x.emitter.on("change", (Re) => {
        de(() => {
          p.setRawValue(b(x, p), Re.options);
        });
      }), p.emitter.on("change", (Re) => {
        de(() => {
          x.setRawValue(M(x, p), Re.options);
        }), de(() => {
          p.setRawValue(b(x, p), Re.options);
        });
      }), de(() => {
        p.setRawValue(b(x, p), {
          forceEmit: !1,
          last: !0
        });
      });
    }
    function qi(x, p) {
      const b = x * (p.altKey ? 0.1 : 1) * (p.shiftKey ? 10 : 1);
      return p.upKey ? +b : p.downKey ? -b : 0;
    }
    function hc(x) {
      return {
        altKey: x.altKey,
        downKey: x.key === "ArrowDown",
        shiftKey: x.shiftKey,
        upKey: x.key === "ArrowUp"
      };
    }
    function ms(x) {
      return {
        altKey: x.altKey,
        downKey: x.key === "ArrowLeft",
        shiftKey: x.shiftKey,
        upKey: x.key === "ArrowRight"
      };
    }
    function cC(x) {
      return x === "ArrowUp" || x === "ArrowDown";
    }
    function c0(x) {
      return cC(x) || x === "ArrowLeft" || x === "ArrowRight";
    }
    function Xd(x, p) {
      var b, M;
      const z = p.ownerDocument.defaultView, de = p.getBoundingClientRect();
      return {
        x: x.pageX - (((b = z && z.scrollX) !== null && b !== void 0 ? b : 0) + de.left),
        y: x.pageY - (((M = z && z.scrollY) !== null && M !== void 0 ? M : 0) + de.top)
      };
    }
    class Bo {
      constructor(p) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = p, this.emitter = new v(), p.addEventListener("touchstart", this.onTouchStart_, {
          passive: !1
        }), p.addEventListener("touchmove", this.onTouchMove_, {
          passive: !0
        }), p.addEventListener("touchend", this.onTouchEnd_), p.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(p) {
        const b = this.elem_.getBoundingClientRect();
        return {
          bounds: {
            width: b.width,
            height: b.height
          },
          point: p ? {
            x: p.x,
            y: p.y
          } : null
        };
      }
      onMouseDown_(p) {
        var b;
        p.preventDefault(), (b = p.currentTarget) === null || b === void 0 || b.focus();
        const M = this.elem_.ownerDocument;
        M.addEventListener("mousemove", this.onDocumentMouseMove_), M.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
          altKey: p.altKey,
          data: this.computePosition_(Xd(p, this.elem_)),
          sender: this,
          shiftKey: p.shiftKey
        });
      }
      onDocumentMouseMove_(p) {
        this.emitter.emit("move", {
          altKey: p.altKey,
          data: this.computePosition_(Xd(p, this.elem_)),
          sender: this,
          shiftKey: p.shiftKey
        });
      }
      onDocumentMouseUp_(p) {
        const b = this.elem_.ownerDocument;
        b.removeEventListener("mousemove", this.onDocumentMouseMove_), b.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
          altKey: p.altKey,
          data: this.computePosition_(Xd(p, this.elem_)),
          sender: this,
          shiftKey: p.shiftKey
        });
      }
      onTouchStart_(p) {
        p.preventDefault();
        const b = p.targetTouches.item(0), M = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: p.altKey,
          data: this.computePosition_(b ? {
            x: b.clientX - M.left,
            y: b.clientY - M.top
          } : void 0),
          sender: this,
          shiftKey: p.shiftKey
        }), this.lastTouch_ = b;
      }
      onTouchMove_(p) {
        const b = p.targetTouches.item(0), M = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: p.altKey,
          data: this.computePosition_(b ? {
            x: b.clientX - M.left,
            y: b.clientY - M.top
          } : void 0),
          sender: this,
          shiftKey: p.shiftKey
        }), this.lastTouch_ = b;
      }
      onTouchEnd_(p) {
        var b;
        const M = (b = p.targetTouches.item(0)) !== null && b !== void 0 ? b : this.lastTouch_, z = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: p.altKey,
          data: this.computePosition_(M ? {
            x: M.clientX - z.left,
            y: M.clientY - z.top
          } : void 0),
          sender: this,
          shiftKey: p.shiftKey
        });
      }
    }
    function In(x, p, b, M, z) {
      const de = (x - p) / (b - p);
      return M + de * (z - M);
    }
    function u0(x) {
      return String(x.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function ti(x, p, b) {
      return Math.min(Math.max(x, p), b);
    }
    function f0(x, p) {
      return (x % p + p) % p;
    }
    const pr = w("txt");
    class uC {
      constructor(p, b) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = b.props, this.props_.emitter.on("change", this.onChange_), this.element = p.createElement("div"), this.element.classList.add(pr(), pr(void 0, "num")), b.arrayPosition && this.element.classList.add(pr(void 0, b.arrayPosition)), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("input");
        M.classList.add(pr("i")), M.type = "text", b.viewProps.bindDisabled(M), this.element.appendChild(M), this.inputElement = M, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = b.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(pr()), this.inputElement.classList.add(pr("i"));
        const z = p.createElement("div");
        z.classList.add(pr("k")), this.element.appendChild(z), this.knobElement = z;
        const de = p.createElementNS(Ce, "svg");
        de.classList.add(pr("g")), this.knobElement.appendChild(de);
        const Re = p.createElementNS(Ce, "path");
        Re.classList.add(pr("gb")), de.appendChild(Re), this.guideBodyElem_ = Re;
        const et = p.createElementNS(Ce, "path");
        et.classList.add(pr("gh")), de.appendChild(et), this.guideHeadElem_ = et;
        const Pt = p.createElement("div");
        Pt.classList.add(w("tt")()), this.knobElement.appendChild(Pt), this.tooltipElem_ = Pt, b.value.emitter.on("change", this.onChange_), this.value = b.value, this.refresh();
      }
      onDraggingChange_(p) {
        if (p.rawValue === null) {
          this.element.classList.remove(pr(void 0, "drg"));
          return;
        }
        this.element.classList.add(pr(void 0, "drg"));
        const b = p.rawValue / this.props_.get("draggingScale"), M = b + (b > 0 ? -1 : b < 0 ? 1 : 0), z = ti(-M, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${M + z},0 L${M},4 L${M + z},8`, `M ${b},-1 L${b},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${b},4`);
        const de = this.props_.get("formatter");
        this.tooltipElem_.textContent = de(this.value.rawValue), this.tooltipElem_.style.left = `${b}px`;
      }
      refresh() {
        const p = this.props_.get("formatter");
        this.inputElement.value = p(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class dc {
      constructor(p, b) {
        var M;
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = b.baseStep, this.parser_ = b.parser, this.props = b.props, this.sliderProps_ = (M = b.sliderProps) !== null && M !== void 0 ? M : null, this.value = b.value, this.viewProps = b.viewProps, this.dragging_ = Q(null), this.view = new uC(p, {
          arrayPosition: b.arrayPosition,
          dragging: this.dragging_,
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const z = new Bo(this.view.knobElement);
        z.emitter.on("down", this.onPointerDown_), z.emitter.on("move", this.onPointerMove_), z.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(p) {
        var b, M;
        const z = (b = this.sliderProps_) === null || b === void 0 ? void 0 : b.get("minValue"), de = (M = this.sliderProps_) === null || M === void 0 ? void 0 : M.get("maxValue");
        let Re = p;
        return z !== void 0 && (Re = Math.max(Re, z)), de !== void 0 && (Re = Math.min(Re, de)), Re;
      }
      onInputChange_(p) {
        const M = p.currentTarget.value, z = this.parser_(M);
        f(z) || (this.value.rawValue = this.constrainValue_(z)), this.view.refresh();
      }
      onInputKeyDown_(p) {
        const b = qi(this.baseStep_, hc(p));
        b !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + b), {
          forceEmit: !1,
          last: !1
        });
      }
      onInputKeyUp_(p) {
        qi(this.baseStep_, hc(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(p) {
        if (!p.point)
          return null;
        const b = p.point.x - p.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + b * this.props.get("draggingScale"));
      }
      onPointerMove_(p) {
        const b = this.computeDraggingValue_(p.data);
        b !== null && (this.value.setRawValue(b, {
          forceEmit: !1,
          last: !1
        }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
      }
      onPointerUp_(p) {
        const b = this.computeDraggingValue_(p.data);
        b !== null && (this.value.setRawValue(b, {
          forceEmit: !0,
          last: !0
        }), this.dragging_.rawValue = null);
      }
    }
    const Yd = w("sld");
    class fC {
      constructor(p, b) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = b.props, this.props_.emitter.on("change", this.onChange_), this.element = p.createElement("div"), this.element.classList.add(Yd()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("div");
        M.classList.add(Yd("t")), b.viewProps.bindTabIndex(M), this.element.appendChild(M), this.trackElement = M;
        const z = p.createElement("div");
        z.classList.add(Yd("k")), this.trackElement.appendChild(z), this.knobElement = z, b.value.emitter.on("change", this.onChange_), this.value = b.value, this.update_();
      }
      update_() {
        const p = ti(In(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
        this.knobElement.style.width = `${p}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class hC {
      constructor(p, b) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = b.baseStep, this.value = b.value, this.viewProps = b.viewProps, this.props = b.props, this.view = new fC(p, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Bo(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(p, b) {
        p.point && this.value.setRawValue(In(ti(p.point.x, 0, p.bounds.width), 0, p.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), b);
      }
      onPointerDownOrMove_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(p) {
        const b = qi(this.baseStep_, ms(p));
        b !== 0 && this.value.setRawValue(this.value.rawValue + b, {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(p) {
        qi(this.baseStep_, ms(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    const Kd = w("sldtxt");
    class dC {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(Kd());
        const M = p.createElement("div");
        M.classList.add(Kd("s")), this.sliderView_ = b.sliderView, M.appendChild(this.sliderView_.element), this.element.appendChild(M);
        const z = p.createElement("div");
        z.classList.add(Kd("t")), this.textView_ = b.textView, z.appendChild(this.textView_.element), this.element.appendChild(z);
      }
    }
    class Jd {
      constructor(p, b) {
        this.value = b.value, this.viewProps = b.viewProps, this.sliderC_ = new hC(p, {
          baseStep: b.baseStep,
          props: b.sliderProps,
          value: b.value,
          viewProps: this.viewProps
        }), this.textC_ = new dc(p, {
          baseStep: b.baseStep,
          parser: b.parser,
          props: b.textProps,
          sliderProps: b.sliderProps,
          value: b.value,
          viewProps: b.viewProps
        }), this.view = new dC(p, {
          sliderView: this.sliderC_.view,
          textView: this.textC_.view
        });
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function pc(x, p) {
      x.write(p);
    }
    function Zu(x) {
      const p = te;
      if (Array.isArray(x))
        return p.required.array(p.required.object({
          text: p.required.string,
          value: p.required.raw
        }))(x).value;
      if (typeof x == "object")
        return p.required.raw(x).value;
    }
    function h0(x) {
      if (x === "inline" || x === "popup")
        return x;
    }
    function $s(x) {
      const p = te;
      return p.required.object({
        max: p.optional.number,
        min: p.optional.number,
        step: p.optional.number
      })(x).value;
    }
    function d0(x) {
      if (Array.isArray(x))
        return x;
      const p = [];
      return Object.keys(x).forEach((b) => {
        p.push({ text: b, value: x[b] });
      }), p;
    }
    function Zd(x) {
      return f(x) ? null : new Sr(d0(x));
    }
    function pC(x) {
      const p = x ? mi(x, Mr) : null;
      return p ? p.step : null;
    }
    function ef(x, p) {
      const b = x && mi(x, Mr);
      return b ? u0(b.step) : Math.max(u0(p), 2);
    }
    function Pa(x) {
      const p = pC(x);
      return p ?? 1;
    }
    function Ra(x, p) {
      var b;
      const M = x && mi(x, Mr), z = Math.abs((b = M == null ? void 0 : M.step) !== null && b !== void 0 ? b : p);
      return z === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(z)) - 1);
    }
    const tf = w("ckb");
    class mC {
      constructor(p, b) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.element = p.createElement("div"), this.element.classList.add(tf()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("label");
        M.classList.add(tf("l")), this.element.appendChild(M);
        const z = p.createElement("input");
        z.classList.add(tf("i")), z.type = "checkbox", M.appendChild(z), this.inputElement = z, b.viewProps.bindDisabled(this.inputElement);
        const de = p.createElement("div");
        de.classList.add(tf("w")), M.appendChild(de);
        const Re = ue(p, "check");
        de.appendChild(Re), b.value.emitter.on("change", this.onValueChange_), this.value = b.value, this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class gC {
      constructor(p, b) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new mC(p, {
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(p) {
        const b = p.currentTarget;
        this.value.rawValue = b.checked;
      }
    }
    function AC(x) {
      const p = [], b = Zd(x.options);
      return b && p.push(b), new Zi(p);
    }
    const _C = {
      id: "input-bool",
      type: "input",
      accept: (x, p) => {
        if (typeof x != "boolean")
          return null;
        const M = j(p, {
          options: te.optional.custom(Zu)
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => Gs,
        constraint: (x) => AC(x.params),
        writer: (x) => pc
      },
      controller: (x) => {
        const p = x.document, b = x.value, M = x.constraint, z = M && mi(M, Sr);
        return z ? new tr(p, {
          props: new q({
            options: z.values.value("options")
          }),
          value: b,
          viewProps: x.viewProps
        }) : new gC(p, {
          value: b,
          viewProps: x.viewProps
        });
      }
    }, Po = w("col");
    class bC {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(Po()), b.foldable.bindExpandedClass(this.element, Po(void 0, "expanded")), B(b.foldable, "completed", S(this.element, Po(void 0, "cpl")));
        const M = p.createElement("div");
        M.classList.add(Po("h")), this.element.appendChild(M);
        const z = p.createElement("div");
        z.classList.add(Po("s")), M.appendChild(z), this.swatchElement = z;
        const de = p.createElement("div");
        if (de.classList.add(Po("t")), M.appendChild(de), this.textElement = de, b.pickerLayout === "inline") {
          const Re = p.createElement("div");
          Re.classList.add(Po("p")), this.element.appendChild(Re), this.pickerElement = Re;
        } else
          this.pickerElement = null;
      }
    }
    function vC(x, p, b) {
      const M = ti(x / 255, 0, 1), z = ti(p / 255, 0, 1), de = ti(b / 255, 0, 1), Re = Math.max(M, z, de), et = Math.min(M, z, de), Pt = Re - et;
      let kt = 0, ln = 0;
      const fn = (et + Re) / 2;
      return Pt !== 0 && (ln = Pt / (1 - Math.abs(Re + et - 1)), M === Re ? kt = (z - de) / Pt : z === Re ? kt = 2 + (de - M) / Pt : kt = 4 + (M - z) / Pt, kt = kt / 6 + (kt < 0 ? 1 : 0)), [kt * 360, ln * 100, fn * 100];
    }
    function yC(x, p, b) {
      const M = (x % 360 + 360) % 360, z = ti(p / 100, 0, 1), de = ti(b / 100, 0, 1), Re = (1 - Math.abs(2 * de - 1)) * z, et = Re * (1 - Math.abs(M / 60 % 2 - 1)), Pt = de - Re / 2;
      let kt, ln, fn;
      return M >= 0 && M < 60 ? [kt, ln, fn] = [Re, et, 0] : M >= 60 && M < 120 ? [kt, ln, fn] = [et, Re, 0] : M >= 120 && M < 180 ? [kt, ln, fn] = [0, Re, et] : M >= 180 && M < 240 ? [kt, ln, fn] = [0, et, Re] : M >= 240 && M < 300 ? [kt, ln, fn] = [et, 0, Re] : [kt, ln, fn] = [Re, 0, et], [(kt + Pt) * 255, (ln + Pt) * 255, (fn + Pt) * 255];
    }
    function xC(x, p, b) {
      const M = ti(x / 255, 0, 1), z = ti(p / 255, 0, 1), de = ti(b / 255, 0, 1), Re = Math.max(M, z, de), et = Math.min(M, z, de), Pt = Re - et;
      let kt;
      Pt === 0 ? kt = 0 : Re === M ? kt = 60 * (((z - de) / Pt % 6 + 6) % 6) : Re === z ? kt = 60 * ((de - M) / Pt + 2) : kt = 60 * ((M - z) / Pt + 4);
      const ln = Re === 0 ? 0 : Pt / Re, fn = Re;
      return [kt, ln * 100, fn * 100];
    }
    function p0(x, p, b) {
      const M = f0(x, 360), z = ti(p / 100, 0, 1), de = ti(b / 100, 0, 1), Re = de * z, et = Re * (1 - Math.abs(M / 60 % 2 - 1)), Pt = de - Re;
      let kt, ln, fn;
      return M >= 0 && M < 60 ? [kt, ln, fn] = [Re, et, 0] : M >= 60 && M < 120 ? [kt, ln, fn] = [et, Re, 0] : M >= 120 && M < 180 ? [kt, ln, fn] = [0, Re, et] : M >= 180 && M < 240 ? [kt, ln, fn] = [0, et, Re] : M >= 240 && M < 300 ? [kt, ln, fn] = [et, 0, Re] : [kt, ln, fn] = [Re, 0, et], [(kt + Pt) * 255, (ln + Pt) * 255, (fn + Pt) * 255];
    }
    function wC(x, p, b) {
      const M = b + p * (100 - Math.abs(2 * b - 100)) / 200;
      return [
        x,
        M !== 0 ? p * (100 - Math.abs(2 * b - 100)) / M : 0,
        b + p * (100 - Math.abs(2 * b - 100)) / (2 * 100)
      ];
    }
    function EC(x, p, b) {
      const M = 100 - Math.abs(b * (200 - p) / 100 - 100);
      return [x, M !== 0 ? p * b / M : 0, b * (200 - p) / (2 * 100)];
    }
    function Ro(x) {
      return [x[0], x[1], x[2]];
    }
    function m0(x, p) {
      return [x[0], x[1], x[2], p];
    }
    const CC = {
      hsl: {
        hsl: (x, p, b) => [x, p, b],
        hsv: wC,
        rgb: yC
      },
      hsv: {
        hsl: EC,
        hsv: (x, p, b) => [x, p, b],
        rgb: p0
      },
      rgb: {
        hsl: vC,
        hsv: xC,
        rgb: (x, p, b) => [x, p, b]
      }
    };
    function nf(x, p) {
      return [
        p === "float" ? 1 : x === "rgb" ? 255 : 360,
        p === "float" ? 1 : x === "rgb" ? 255 : 100,
        p === "float" ? 1 : x === "rgb" ? 255 : 100
      ];
    }
    function SC(x, p) {
      return x === p ? p : f0(x, p);
    }
    function MC(x, p, b) {
      var M;
      const z = nf(p, b);
      return [
        p === "rgb" ? ti(x[0], 0, z[0]) : SC(x[0], z[0]),
        ti(x[1], 0, z[1]),
        ti(x[2], 0, z[2]),
        ti((M = x[3]) !== null && M !== void 0 ? M : 1, 0, 1)
      ];
    }
    function g0(x, p, b, M) {
      const z = nf(p, b), de = nf(p, M);
      return x.map((Re, et) => Re / z[et] * de[et]);
    }
    function IC(x, p, b) {
      const M = g0(x, p.mode, p.type, "int"), z = CC[p.mode][b.mode](...M);
      return g0(z, b.mode, "int", b.type);
    }
    function rf(x, p) {
      return typeof x != "object" || f(x) ? !1 : p in x && typeof x[p] == "number";
    }
    class Vt {
      static black(p = "int") {
        return new Vt([0, 0, 0], "rgb", p);
      }
      static fromObject(p, b = "int") {
        const M = "a" in p ? [p.r, p.g, p.b, p.a] : [p.r, p.g, p.b];
        return new Vt(M, "rgb", b);
      }
      static toRgbaObject(p, b = "int") {
        return p.toRgbaObject(b);
      }
      static isRgbColorObject(p) {
        return rf(p, "r") && rf(p, "g") && rf(p, "b");
      }
      static isRgbaColorObject(p) {
        return this.isRgbColorObject(p) && rf(p, "a");
      }
      static isColorObject(p) {
        return this.isRgbColorObject(p);
      }
      static equals(p, b) {
        if (p.mode !== b.mode)
          return !1;
        const M = p.comps_, z = b.comps_;
        for (let de = 0; de < M.length; de++)
          if (M[de] !== z[de])
            return !1;
        return !0;
      }
      constructor(p, b, M = "int") {
        this.mode = b, this.type = M, this.comps_ = MC(p, b, M);
      }
      getComponents(p, b = "int") {
        return m0(IC(Ro(this.comps_), { mode: this.mode, type: this.type }, { mode: p ?? this.mode, type: b }), this.comps_[3]);
      }
      toRgbaObject(p = "int") {
        const b = this.getComponents("rgb", p);
        return {
          r: b[0],
          g: b[1],
          b: b[2],
          a: b[3]
        };
      }
    }
    const Vs = w("colp");
    class TC {
      constructor(p, b) {
        this.alphaViews_ = null, this.element = p.createElement("div"), this.element.classList.add(Vs()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("div");
        M.classList.add(Vs("hsv"));
        const z = p.createElement("div");
        z.classList.add(Vs("sv")), this.svPaletteView_ = b.svPaletteView, z.appendChild(this.svPaletteView_.element), M.appendChild(z);
        const de = p.createElement("div");
        de.classList.add(Vs("h")), this.hPaletteView_ = b.hPaletteView, de.appendChild(this.hPaletteView_.element), M.appendChild(de), this.element.appendChild(M);
        const Re = p.createElement("div");
        if (Re.classList.add(Vs("rgb")), this.textView_ = b.textView, Re.appendChild(this.textView_.element), this.element.appendChild(Re), b.alphaViews) {
          this.alphaViews_ = {
            palette: b.alphaViews.palette,
            text: b.alphaViews.text
          };
          const et = p.createElement("div");
          et.classList.add(Vs("a"));
          const Pt = p.createElement("div");
          Pt.classList.add(Vs("ap")), Pt.appendChild(this.alphaViews_.palette.element), et.appendChild(Pt);
          const kt = p.createElement("div");
          kt.classList.add(Vs("at")), kt.appendChild(this.alphaViews_.text.element), et.appendChild(kt), this.element.appendChild(et);
        }
      }
      get allFocusableElements() {
        const p = [
          this.svPaletteView_.element,
          this.hPaletteView_.element,
          this.textView_.modeSelectElement,
          ...this.textView_.textViews.map((b) => b.inputElement)
        ];
        return this.alphaViews_ && p.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), p;
      }
    }
    function BC(x) {
      return x === "int" ? "int" : x === "float" ? "float" : void 0;
    }
    function ep(x) {
      const p = te;
      return j(x, {
        alpha: p.optional.boolean,
        color: p.optional.object({
          alpha: p.optional.boolean,
          type: p.optional.custom(BC)
        }),
        expanded: p.optional.boolean,
        picker: p.optional.custom(h0)
      });
    }
    function Do(x) {
      return x ? 0.1 : 1;
    }
    function Lo(x) {
      var p;
      return (p = x.color) === null || p === void 0 ? void 0 : p.type;
    }
    function PC(x, p) {
      return x.alpha === p.alpha && x.mode === p.mode && x.notation === p.notation && x.type === p.type;
    }
    function mr(x, p) {
      const b = x.match(/^(.+)%$/);
      return Math.min(b ? parseFloat(b[1]) * 0.01 * p : parseFloat(x), p);
    }
    const RC = {
      deg: (x) => x,
      grad: (x) => x * 360 / 400,
      rad: (x) => x * 360 / (2 * Math.PI),
      turn: (x) => x * 360
    };
    function A0(x) {
      const p = x.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!p)
        return parseFloat(x);
      const b = parseFloat(p[1]), M = p[2];
      return RC[M](b);
    }
    function _0(x) {
      const p = x.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!p)
        return null;
      const b = [
        mr(p[1], 255),
        mr(p[2], 255),
        mr(p[3], 255)
      ];
      return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) ? null : b;
    }
    function b0(x) {
      return (p) => {
        const b = _0(p);
        return b ? new Vt(b, "rgb", x) : null;
      };
    }
    function v0(x) {
      const p = x.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!p)
        return null;
      const b = [
        mr(p[1], 255),
        mr(p[2], 255),
        mr(p[3], 255),
        mr(p[4], 1)
      ];
      return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) || isNaN(b[3]) ? null : b;
    }
    function y0(x) {
      return (p) => {
        const b = v0(p);
        return b ? new Vt(b, "rgb", x) : null;
      };
    }
    function x0(x) {
      const p = x.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!p)
        return null;
      const b = [
        A0(p[1]),
        mr(p[2], 100),
        mr(p[3], 100)
      ];
      return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) ? null : b;
    }
    function w0(x) {
      return (p) => {
        const b = x0(p);
        return b ? new Vt(b, "hsl", x) : null;
      };
    }
    function E0(x) {
      const p = x.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!p)
        return null;
      const b = [
        A0(p[1]),
        mr(p[2], 100),
        mr(p[3], 100),
        mr(p[4], 1)
      ];
      return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) || isNaN(b[3]) ? null : b;
    }
    function C0(x) {
      return (p) => {
        const b = E0(p);
        return b ? new Vt(b, "hsl", x) : null;
      };
    }
    function S0(x) {
      const p = x.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (p)
        return [
          parseInt(p[1] + p[1], 16),
          parseInt(p[2] + p[2], 16),
          parseInt(p[3] + p[3], 16)
        ];
      const b = x.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return b ? [
        parseInt(b[1], 16),
        parseInt(b[2], 16),
        parseInt(b[3], 16)
      ] : null;
    }
    function DC(x) {
      const p = S0(x);
      return p ? new Vt(p, "rgb", "int") : null;
    }
    function M0(x) {
      const p = x.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (p)
        return [
          parseInt(p[1] + p[1], 16),
          parseInt(p[2] + p[2], 16),
          parseInt(p[3] + p[3], 16),
          In(parseInt(p[4] + p[4], 16), 0, 255, 0, 1)
        ];
      const b = x.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return b ? [
        parseInt(b[1], 16),
        parseInt(b[2], 16),
        parseInt(b[3], 16),
        In(parseInt(b[4], 16), 0, 255, 0, 1)
      ] : null;
    }
    function LC(x) {
      const p = M0(x);
      return p ? new Vt(p, "rgb", "int") : null;
    }
    function I0(x) {
      const p = x.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!p)
        return null;
      const b = [
        parseFloat(p[1]),
        parseFloat(p[2]),
        parseFloat(p[3])
      ];
      return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) ? null : b;
    }
    function T0(x) {
      return (p) => {
        const b = I0(p);
        return b ? new Vt(b, "rgb", x) : null;
      };
    }
    function B0(x) {
      const p = x.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!p)
        return null;
      const b = [
        parseFloat(p[1]),
        parseFloat(p[2]),
        parseFloat(p[3]),
        parseFloat(p[4])
      ];
      return isNaN(b[0]) || isNaN(b[1]) || isNaN(b[2]) || isNaN(b[3]) ? null : b;
    }
    function P0(x) {
      return (p) => {
        const b = B0(p);
        return b ? new Vt(b, "rgb", x) : null;
      };
    }
    const kC = [
      {
        parser: S0,
        result: {
          alpha: !1,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: M0,
        result: {
          alpha: !0,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: _0,
        result: {
          alpha: !1,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: v0,
        result: {
          alpha: !0,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: x0,
        result: {
          alpha: !1,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: E0,
        result: {
          alpha: !0,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: I0,
        result: {
          alpha: !1,
          mode: "rgb",
          notation: "object"
        }
      },
      {
        parser: B0,
        result: {
          alpha: !0,
          mode: "rgb",
          notation: "object"
        }
      }
    ];
    function UC(x) {
      return kC.reduce((p, { parser: b, result: M }) => p || (b(x) ? M : null), null);
    }
    function tp(x, p = "int") {
      const b = UC(x);
      return b ? b.notation === "hex" && p !== "float" ? Object.assign(Object.assign({}, b), { type: "int" }) : b.notation === "func" ? Object.assign(Object.assign({}, b), { type: p }) : null : null;
    }
    const R0 = {
      int: [
        DC,
        LC,
        b0("int"),
        y0("int"),
        w0("int"),
        C0("int"),
        T0("int"),
        P0("int")
      ],
      float: [
        b0("float"),
        y0("float"),
        w0("float"),
        C0("float"),
        T0("float"),
        P0("float")
      ]
    };
    function FC(x) {
      const p = R0[x];
      return (b) => {
        if (typeof b != "string")
          return Vt.black(x);
        const M = p.reduce((z, de) => z || de(b), null);
        return M ?? Vt.black(x);
      };
    }
    function np(x) {
      const p = R0[x];
      return (b) => p.reduce((M, z) => M || z(b), null);
    }
    function D0(x) {
      const p = ti(Math.floor(x), 0, 255).toString(16);
      return p.length === 1 ? `0${p}` : p;
    }
    function L0(x, p = "#") {
      const b = Ro(x.getComponents("rgb")).map(D0).join("");
      return `${p}${b}`;
    }
    function ip(x, p = "#") {
      const b = x.getComponents("rgb"), M = [b[0], b[1], b[2], b[3] * 255].map(D0).join("");
      return `${p}${M}`;
    }
    function k0(x, p) {
      const b = Ai(p === "float" ? 2 : 0);
      return `rgb(${Ro(x.getComponents("rgb", p)).map((z) => b(z)).join(", ")})`;
    }
    function OC(x) {
      return (p) => k0(p, x);
    }
    function sf(x, p) {
      const b = Ai(2), M = Ai(p === "float" ? 2 : 0);
      return `rgba(${x.getComponents("rgb", p).map((de, Re) => (Re === 3 ? b : M)(de)).join(", ")})`;
    }
    function NC(x) {
      return (p) => sf(p, x);
    }
    function GC(x) {
      const p = [
        Ai(0),
        Ju,
        Ju
      ];
      return `hsl(${Ro(x.getComponents("hsl")).map((M, z) => p[z](M)).join(", ")})`;
    }
    function QC(x) {
      const p = [
        Ai(0),
        Ju,
        Ju,
        Ai(2)
      ];
      return `hsla(${x.getComponents("hsl").map((M, z) => p[z](M)).join(", ")})`;
    }
    function U0(x, p) {
      const b = Ai(p === "float" ? 2 : 0), M = ["r", "g", "b"];
      return `{${Ro(x.getComponents("rgb", p)).map((de, Re) => `${M[Re]}: ${b(de)}`).join(", ")}}`;
    }
    function zC(x) {
      return (p) => U0(p, x);
    }
    function F0(x, p) {
      const b = Ai(2), M = Ai(p === "float" ? 2 : 0), z = ["r", "g", "b", "a"];
      return `{${x.getComponents("rgb", p).map((Re, et) => {
        const Pt = et === 3 ? b : M;
        return `${z[et]}: ${Pt(Re)}`;
      }).join(", ")}}`;
    }
    function $C(x) {
      return (p) => F0(p, x);
    }
    const VC = [
      {
        format: {
          alpha: !1,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: L0
      },
      {
        format: {
          alpha: !0,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: ip
      },
      {
        format: {
          alpha: !1,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: GC
      },
      {
        format: {
          alpha: !0,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: QC
      },
      ...["int", "float"].reduce((x, p) => [
        ...x,
        {
          format: {
            alpha: !1,
            mode: "rgb",
            notation: "func",
            type: p
          },
          stringifier: OC(p)
        },
        {
          format: {
            alpha: !0,
            mode: "rgb",
            notation: "func",
            type: p
          },
          stringifier: NC(p)
        },
        {
          format: {
            alpha: !1,
            mode: "rgb",
            notation: "object",
            type: p
          },
          stringifier: zC(p)
        },
        {
          format: {
            alpha: !0,
            mode: "rgb",
            notation: "object",
            type: p
          },
          stringifier: $C(p)
        }
      ], [])
    ];
    function rp(x) {
      return VC.reduce((p, b) => p || (PC(b.format, x) ? b.stringifier : null), null);
    }
    const mc = w("apl");
    class HC {
      constructor(p, b) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = b.value, this.value.emitter.on("change", this.onValueChange_), this.element = p.createElement("div"), this.element.classList.add(mc()), b.viewProps.bindClassModifiers(this.element), b.viewProps.bindTabIndex(this.element);
        const M = p.createElement("div");
        M.classList.add(mc("b")), this.element.appendChild(M);
        const z = p.createElement("div");
        z.classList.add(mc("c")), M.appendChild(z), this.colorElem_ = z;
        const de = p.createElement("div");
        de.classList.add(mc("m")), this.element.appendChild(de), this.markerElem_ = de;
        const Re = p.createElement("div");
        Re.classList.add(mc("p")), this.markerElem_.appendChild(Re), this.previewElem_ = Re, this.update_();
      }
      update_() {
        const p = this.value.rawValue, b = p.getComponents("rgb"), M = new Vt([b[0], b[1], b[2], 0], "rgb"), z = new Vt([b[0], b[1], b[2], 255], "rgb"), de = [
          "to right",
          sf(M),
          sf(z)
        ];
        this.colorElem_.style.background = `linear-gradient(${de.join(",")})`, this.previewElem_.style.backgroundColor = sf(p);
        const Re = In(b[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${Re}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class jC {
      constructor(p, b) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new HC(p, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Bo(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(p, b) {
        if (!p.point)
          return;
        const M = p.point.x / p.bounds.width, z = this.value.rawValue, [de, Re, et] = z.getComponents("hsv");
        this.value.setRawValue(new Vt([de, Re, et, M], "hsv"), b);
      }
      onPointerDown_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(p) {
        const b = qi(Do(!0), ms(p));
        if (b === 0)
          return;
        const M = this.value.rawValue, [z, de, Re, et] = M.getComponents("hsv");
        this.value.setRawValue(new Vt([z, de, Re, et + b], "hsv"), {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(p) {
        qi(Do(!0), ms(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    const Da = w("coltxt");
    function WC(x) {
      const p = x.createElement("select"), b = [
        { text: "RGB", value: "rgb" },
        { text: "HSL", value: "hsl" },
        { text: "HSV", value: "hsv" }
      ];
      return p.appendChild(b.reduce((M, z) => {
        const de = x.createElement("option");
        return de.textContent = z.text, de.value = z.value, M.appendChild(de), M;
      }, x.createDocumentFragment())), p;
    }
    class qC {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(Da()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("div");
        M.classList.add(Da("m")), this.modeElem_ = WC(p), this.modeElem_.classList.add(Da("ms")), M.appendChild(this.modeSelectElement), b.viewProps.bindDisabled(this.modeElem_);
        const z = p.createElement("div");
        z.classList.add(Da("mm")), z.appendChild(ue(p, "dropdown")), M.appendChild(z), this.element.appendChild(M);
        const de = p.createElement("div");
        de.classList.add(Da("w")), this.element.appendChild(de), this.textsElem_ = de, this.textViews_ = b.textViews, this.applyTextViews_(), C(b.colorMode, (Re) => {
          this.modeElem_.value = Re;
        });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(p) {
        this.textViews_ = p, this.applyTextViews_();
      }
      applyTextViews_() {
        Pe(this.textsElem_);
        const p = this.element.ownerDocument;
        this.textViews_.forEach((b) => {
          const M = p.createElement("div");
          M.classList.add(Da("c")), M.appendChild(b.element), this.textsElem_.appendChild(M);
        });
      }
    }
    function XC(x) {
      return Ai(x === "float" ? 2 : 0);
    }
    function YC(x, p, b) {
      const M = nf(x, p)[b];
      return new er({
        min: 0,
        max: M
      });
    }
    function sp(x, p, b) {
      return new dc(x, {
        arrayPosition: b === 0 ? "fst" : b === 3 - 1 ? "lst" : "mid",
        baseStep: Do(!1),
        parser: p.parser,
        props: q.fromObject({
          draggingScale: p.colorType === "float" ? 0.01 : 1,
          formatter: XC(p.colorType)
        }),
        value: Q(0, {
          constraint: YC(p.colorMode, p.colorType, b)
        }),
        viewProps: p.viewProps
      });
    }
    class KC {
      constructor(p, b) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = b.colorType, this.parser_ = b.parser, this.value = b.value, this.viewProps = b.viewProps, this.colorMode = Q(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(p), this.view = new qC(p, {
          colorMode: this.colorMode,
          textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
          viewProps: this.viewProps
        }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
      }
      createComponentControllers_(p) {
        const b = {
          colorMode: this.colorMode.rawValue,
          colorType: this.colorType_,
          parser: this.parser_,
          viewProps: this.viewProps
        }, M = [
          sp(p, b, 0),
          sp(p, b, 1),
          sp(p, b, 2)
        ];
        return M.forEach((z, de) => {
          fc({
            primary: this.value,
            secondary: z.value,
            forward: (Re) => Re.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[de],
            backward: (Re, et) => {
              const Pt = this.colorMode.rawValue, kt = Re.rawValue.getComponents(Pt, this.colorType_);
              return kt[de] = et.rawValue, new Vt(m0(Ro(kt), kt[3]), Pt, this.colorType_);
            }
          });
        }), M;
      }
      onModeSelectChange_(p) {
        const b = p.currentTarget;
        this.colorMode.rawValue = b.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [
          this.ccs_[0].view,
          this.ccs_[1].view,
          this.ccs_[2].view
        ];
      }
    }
    const op = w("hpl");
    class JC {
      constructor(p, b) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = b.value, this.value.emitter.on("change", this.onValueChange_), this.element = p.createElement("div"), this.element.classList.add(op()), b.viewProps.bindClassModifiers(this.element), b.viewProps.bindTabIndex(this.element);
        const M = p.createElement("div");
        M.classList.add(op("c")), this.element.appendChild(M);
        const z = p.createElement("div");
        z.classList.add(op("m")), this.element.appendChild(z), this.markerElem_ = z, this.update_();
      }
      update_() {
        const p = this.value.rawValue, [b] = p.getComponents("hsv");
        this.markerElem_.style.backgroundColor = k0(new Vt([b, 100, 100], "hsv"));
        const M = In(b, 0, 360, 0, 100);
        this.markerElem_.style.left = `${M}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class ZC {
      constructor(p, b) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new JC(p, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Bo(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(p, b) {
        if (!p.point)
          return;
        const M = In(ti(p.point.x, 0, p.bounds.width), 0, p.bounds.width, 0, 360), z = this.value.rawValue, [, de, Re, et] = z.getComponents("hsv");
        this.value.setRawValue(new Vt([M, de, Re, et], "hsv"), b);
      }
      onPointerDown_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(p) {
        const b = qi(Do(!1), ms(p));
        if (b === 0)
          return;
        const M = this.value.rawValue, [z, de, Re, et] = M.getComponents("hsv");
        this.value.setRawValue(new Vt([z + b, de, Re, et], "hsv"), {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(p) {
        qi(Do(!1), ms(p)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    const ap = w("svp"), O0 = 64;
    class eS {
      constructor(p, b) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = b.value, this.value.emitter.on("change", this.onValueChange_), this.element = p.createElement("div"), this.element.classList.add(ap()), b.viewProps.bindClassModifiers(this.element), b.viewProps.bindTabIndex(this.element);
        const M = p.createElement("canvas");
        M.height = O0, M.width = O0, M.classList.add(ap("c")), this.element.appendChild(M), this.canvasElement = M;
        const z = p.createElement("div");
        z.classList.add(ap("m")), this.element.appendChild(z), this.markerElem_ = z, this.update_();
      }
      update_() {
        const p = _e(this.canvasElement);
        if (!p)
          return;
        const M = this.value.rawValue.getComponents("hsv"), z = this.canvasElement.width, de = this.canvasElement.height, Re = p.getImageData(0, 0, z, de), et = Re.data;
        for (let ln = 0; ln < de; ln++)
          for (let fn = 0; fn < z; fn++) {
            const ko = In(fn, 0, z, 0, 100), Ac = In(ln, 0, de, 100, 0), _c = p0(M[0], ko, Ac), of = (ln * z + fn) * 4;
            et[of] = _c[0], et[of + 1] = _c[1], et[of + 2] = _c[2], et[of + 3] = 255;
          }
        p.putImageData(Re, 0, 0);
        const Pt = In(M[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${Pt}%`;
        const kt = In(M[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${kt}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class tS {
      constructor(p, b) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.view = new eS(p, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Bo(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(p, b) {
        if (!p.point)
          return;
        const M = In(p.point.x, 0, p.bounds.width, 0, 100), z = In(p.point.y, 0, p.bounds.height, 100, 0), [de, , , Re] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new Vt([de, M, z, Re], "hsv"), b);
      }
      onPointerDown_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(p) {
        c0(p.key) && p.preventDefault();
        const [b, M, z, de] = this.value.rawValue.getComponents("hsv"), Re = Do(!1), et = qi(Re, ms(p)), Pt = qi(Re, hc(p));
        et === 0 && Pt === 0 || this.value.setRawValue(new Vt([b, M + et, z + Pt, de], "hsv"), {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(p) {
        const b = Do(!1), M = qi(b, ms(p)), z = qi(b, hc(p));
        M === 0 && z === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    class nS {
      constructor(p, b) {
        this.value = b.value, this.viewProps = b.viewProps, this.hPaletteC_ = new ZC(p, {
          value: this.value,
          viewProps: this.viewProps
        }), this.svPaletteC_ = new tS(p, {
          value: this.value,
          viewProps: this.viewProps
        }), this.alphaIcs_ = b.supportsAlpha ? {
          palette: new jC(p, {
            value: this.value,
            viewProps: this.viewProps
          }),
          text: new dc(p, {
            parser: ps,
            baseStep: 0.1,
            props: q.fromObject({
              draggingScale: 0.01,
              formatter: Ai(2)
            }),
            value: Q(0, {
              constraint: new er({ min: 0, max: 1 })
            }),
            viewProps: this.viewProps
          })
        } : null, this.alphaIcs_ && fc({
          primary: this.value,
          secondary: this.alphaIcs_.text.value,
          forward: (M) => M.rawValue.getComponents()[3],
          backward: (M, z) => {
            const de = M.rawValue.getComponents();
            return de[3] = z.rawValue, new Vt(de, M.rawValue.mode);
          }
        }), this.textC_ = new KC(p, {
          colorType: b.colorType,
          parser: ps,
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new TC(p, {
          alphaViews: this.alphaIcs_ ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view
          } : null,
          hPaletteView: this.hPaletteC_.view,
          supportsAlpha: b.supportsAlpha,
          svPaletteView: this.svPaletteC_.view,
          textView: this.textC_.view,
          viewProps: this.viewProps
        });
      }
      get textController() {
        return this.textC_;
      }
    }
    const lp = w("colsw");
    class iS {
      constructor(p, b) {
        this.onValueChange_ = this.onValueChange_.bind(this), b.value.emitter.on("change", this.onValueChange_), this.value = b.value, this.element = p.createElement("div"), this.element.classList.add(lp()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("div");
        M.classList.add(lp("sw")), this.element.appendChild(M), this.swatchElem_ = M;
        const z = p.createElement("button");
        z.classList.add(lp("b")), b.viewProps.bindDisabled(z), this.element.appendChild(z), this.buttonElement = z, this.update_();
      }
      update_() {
        const p = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = ip(p);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class rS {
      constructor(p, b) {
        this.value = b.value, this.viewProps = b.viewProps, this.view = new iS(p, {
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    class cp {
      constructor(p, b) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.foldable_ = Ke.create(b.expanded), this.swatchC_ = new rS(p, {
          value: this.value,
          viewProps: this.viewProps
        });
        const M = this.swatchC_.view.buttonElement;
        M.addEventListener("blur", this.onButtonBlur_), M.addEventListener("click", this.onButtonClick_), this.textC_ = new Br(p, {
          parser: b.parser,
          props: q.fromObject({
            formatter: b.formatter
          }),
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new bC(p, {
          foldable: this.foldable_,
          pickerLayout: b.pickerLayout
        }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = b.pickerLayout === "popup" ? new Tr(p, {
          viewProps: this.viewProps
        }) : null;
        const z = new nS(p, {
          colorType: b.colorType,
          supportsAlpha: b.supportsAlpha,
          value: this.value,
          viewProps: this.viewProps
        });
        z.view.allFocusableElements.forEach((de) => {
          de.addEventListener("blur", this.onPopupChildBlur_), de.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = z, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(z.view.element), fc({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (de) => de.rawValue,
          backward: (de, Re) => Re.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), be(this.foldable_, this.view.pickerElement));
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(p) {
        if (!this.popC_)
          return;
        const b = this.view.element, M = p.relatedTarget;
        (!M || !b.contains(M)) && (this.popC_.shows.rawValue = !1);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(p) {
        if (!this.popC_)
          return;
        const b = this.popC_.view.element, M = Se(p);
        M && b.contains(M) || M && M === this.swatchC_.view.buttonElement && !W(b.ownerDocument) || (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(p) {
        this.popC_ ? p.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && p.key === "Escape" && this.swatchC_.view.buttonElement.focus();
      }
    }
    function sS(x, p) {
      return Vt.isColorObject(x) ? Vt.fromObject(x, p) : Vt.black(p);
    }
    function oS(x) {
      return Ro(x.getComponents("rgb")).reduce((p, b) => p << 8 | Math.floor(b) & 255, 0);
    }
    function aS(x) {
      return x.getComponents("rgb").reduce((p, b, M) => {
        const z = Math.floor(M === 3 ? b * 255 : b) & 255;
        return p << 8 | z;
      }, 0) >>> 0;
    }
    function lS(x) {
      return new Vt([x >> 16 & 255, x >> 8 & 255, x & 255], "rgb");
    }
    function cS(x) {
      return new Vt([
        x >> 24 & 255,
        x >> 16 & 255,
        x >> 8 & 255,
        In(x & 255, 0, 255, 0, 1)
      ], "rgb");
    }
    function uS(x) {
      return typeof x != "number" ? Vt.black() : lS(x);
    }
    function fS(x) {
      return typeof x != "number" ? Vt.black() : cS(x);
    }
    function hS(x) {
      const p = rp(x);
      return p ? (b, M) => {
        pc(b, p(M));
      } : null;
    }
    function dS(x) {
      const p = x ? aS : oS;
      return (b, M) => {
        pc(b, p(M));
      };
    }
    function pS(x, p, b) {
      const M = p.toRgbaObject(b);
      x.writeProperty("r", M.r), x.writeProperty("g", M.g), x.writeProperty("b", M.b), x.writeProperty("a", M.a);
    }
    function mS(x, p, b) {
      const M = p.toRgbaObject(b);
      x.writeProperty("r", M.r), x.writeProperty("g", M.g), x.writeProperty("b", M.b);
    }
    function gS(x, p) {
      return (b, M) => {
        x ? pS(b, M, p) : mS(b, M, p);
      };
    }
    function up(x) {
      var p;
      return !!(x != null && x.alpha || !((p = x == null ? void 0 : x.color) === null || p === void 0) && p.alpha);
    }
    function AS(x) {
      return x ? (p) => ip(p, "0x") : (p) => L0(p, "0x");
    }
    function _S(x) {
      return "color" in x || "view" in x && x.view === "color";
    }
    const bS = {
      id: "input-color-number",
      type: "input",
      accept: (x, p) => {
        if (typeof x != "number" || !_S(p))
          return null;
        const b = ep(p);
        return b ? {
          initialValue: x,
          params: b
        } : null;
      },
      binding: {
        reader: (x) => up(x.params) ? fS : uS,
        equals: Vt.equals,
        writer: (x) => dS(up(x.params))
      },
      controller: (x) => {
        const p = up(x.params), b = "expanded" in x.params ? x.params.expanded : void 0, M = "picker" in x.params ? x.params.picker : void 0;
        return new cp(x.document, {
          colorType: "int",
          expanded: b ?? !1,
          formatter: AS(p),
          parser: np("int"),
          pickerLayout: M ?? "popup",
          supportsAlpha: p,
          value: x.value,
          viewProps: x.viewProps
        });
      }
    };
    function vS(x) {
      return Vt.isRgbaColorObject(x);
    }
    function yS(x) {
      return (p) => sS(p, x);
    }
    function xS(x, p) {
      return (b) => x ? F0(b, p) : U0(b, p);
    }
    const wS = {
      id: "input-color-object",
      type: "input",
      accept: (x, p) => {
        if (!Vt.isColorObject(x))
          return null;
        const b = ep(p);
        return b ? {
          initialValue: x,
          params: b
        } : null;
      },
      binding: {
        reader: (x) => yS(Lo(x.params)),
        equals: Vt.equals,
        writer: (x) => gS(vS(x.initialValue), Lo(x.params))
      },
      controller: (x) => {
        var p;
        const b = Vt.isRgbaColorObject(x.initialValue), M = "expanded" in x.params ? x.params.expanded : void 0, z = "picker" in x.params ? x.params.picker : void 0, de = (p = Lo(x.params)) !== null && p !== void 0 ? p : "int";
        return new cp(x.document, {
          colorType: de,
          expanded: M ?? !1,
          formatter: xS(b, de),
          parser: np(de),
          pickerLayout: z ?? "popup",
          supportsAlpha: b,
          value: x.value,
          viewProps: x.viewProps
        });
      }
    }, ES = {
      id: "input-color-string",
      type: "input",
      accept: (x, p) => {
        if (typeof x != "string" || "view" in p && p.view === "text")
          return null;
        const b = tp(x, Lo(p));
        if (!b || !rp(b))
          return null;
        const z = ep(p);
        return z ? {
          initialValue: x,
          params: z
        } : null;
      },
      binding: {
        reader: (x) => {
          var p;
          return FC((p = Lo(x.params)) !== null && p !== void 0 ? p : "int");
        },
        equals: Vt.equals,
        writer: (x) => {
          const p = tp(x.initialValue, Lo(x.params));
          if (!p)
            throw _.shouldNeverHappen();
          const b = hS(p);
          if (!b)
            throw _.notBindable();
          return b;
        }
      },
      controller: (x) => {
        const p = tp(x.initialValue, Lo(x.params));
        if (!p)
          throw _.shouldNeverHappen();
        const b = rp(p);
        if (!b)
          throw _.shouldNeverHappen();
        const M = "expanded" in x.params ? x.params.expanded : void 0, z = "picker" in x.params ? x.params.picker : void 0;
        return new cp(x.document, {
          colorType: p.type,
          expanded: M ?? !1,
          formatter: b,
          parser: np(p.type),
          pickerLayout: z ?? "popup",
          supportsAlpha: p.alpha,
          value: x.value,
          viewProps: x.viewProps
        });
      }
    };
    class Hs {
      constructor(p) {
        this.components = p.components, this.asm_ = p.assembly;
      }
      constrain(p) {
        const b = this.asm_.toComponents(p).map((M, z) => {
          var de, Re;
          return (Re = (de = this.components[z]) === null || de === void 0 ? void 0 : de.constrain(M)) !== null && Re !== void 0 ? Re : M;
        });
        return this.asm_.fromComponents(b);
      }
    }
    const N0 = w("pndtxt");
    class CS {
      constructor(p, b) {
        this.textViews = b.textViews, this.element = p.createElement("div"), this.element.classList.add(N0()), this.textViews.forEach((M) => {
          const z = p.createElement("div");
          z.classList.add(N0("a")), z.appendChild(M.element), this.element.appendChild(z);
        });
      }
    }
    function SS(x, p, b) {
      return new dc(x, {
        arrayPosition: b === 0 ? "fst" : b === p.axes.length - 1 ? "lst" : "mid",
        baseStep: p.axes[b].baseStep,
        parser: p.parser,
        props: p.axes[b].textProps,
        value: Q(0, {
          constraint: p.axes[b].constraint
        }),
        viewProps: p.viewProps
      });
    }
    class fp {
      constructor(p, b) {
        this.value = b.value, this.viewProps = b.viewProps, this.acs_ = b.axes.map((M, z) => SS(p, b, z)), this.acs_.forEach((M, z) => {
          fc({
            primary: this.value,
            secondary: M.value,
            forward: (de) => b.assembly.toComponents(de.rawValue)[z],
            backward: (de, Re) => {
              const et = b.assembly.toComponents(de.rawValue);
              return et[z] = Re.rawValue, b.assembly.fromComponents(et);
            }
          });
        }), this.view = new CS(p, {
          textViews: this.acs_.map((M) => M.view)
        });
      }
    }
    function G0(x, p) {
      return "step" in x && !f(x.step) ? new Mr(x.step, p) : null;
    }
    function Q0(x) {
      return !f(x.max) && !f(x.min) ? new er({
        max: x.max,
        min: x.min
      }) : !f(x.max) || !f(x.min) ? new Fs({
        max: x.max,
        min: x.min
      }) : null;
    }
    function MS(x) {
      const p = mi(x, er);
      if (p)
        return [p.values.get("min"), p.values.get("max")];
      const b = mi(x, Fs);
      return b ? [b.minValue, b.maxValue] : [void 0, void 0];
    }
    function IS(x, p) {
      const b = [], M = G0(x, p);
      M && b.push(M);
      const z = Q0(x);
      z && b.push(z);
      const de = Zd(x.options);
      return de && b.push(de), new Zi(b);
    }
    const TS = {
      id: "input-number",
      type: "input",
      accept: (x, p) => {
        if (typeof x != "number")
          return null;
        const b = te, M = j(p, {
          format: b.optional.function,
          max: b.optional.number,
          min: b.optional.number,
          options: b.optional.custom(Zu),
          step: b.optional.number
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => a0,
        constraint: (x) => IS(x.params, x.initialValue),
        writer: (x) => pc
      },
      controller: (x) => {
        var p;
        const b = x.value, M = x.constraint, z = M && mi(M, Sr);
        if (z)
          return new tr(x.document, {
            props: new q({
              options: z.values.value("options")
            }),
            value: b,
            viewProps: x.viewProps
          });
        const de = (p = "format" in x.params ? x.params.format : void 0) !== null && p !== void 0 ? p : Ai(ef(M, b.rawValue)), Re = M && mi(M, er);
        return Re ? new Jd(x.document, {
          baseStep: Pa(M),
          parser: ps,
          sliderProps: new q({
            maxValue: Re.values.value("max"),
            minValue: Re.values.value("min")
          }),
          textProps: q.fromObject({
            draggingScale: Ra(M, b.rawValue),
            formatter: de
          }),
          value: b,
          viewProps: x.viewProps
        }) : new dc(x.document, {
          baseStep: Pa(M),
          parser: ps,
          props: q.fromObject({
            draggingScale: Ra(M, b.rawValue),
            formatter: de
          }),
          value: b,
          viewProps: x.viewProps
        });
      }
    };
    class js {
      constructor(p = 0, b = 0) {
        this.x = p, this.y = b;
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(p) {
        if (f(p))
          return !1;
        const b = p.x, M = p.y;
        return !(typeof b != "number" || typeof M != "number");
      }
      static equals(p, b) {
        return p.x === b.x && p.y === b.y;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y
        };
      }
    }
    const z0 = {
      toComponents: (x) => x.getComponents(),
      fromComponents: (x) => new js(...x)
    }, La = w("p2d");
    class BS {
      constructor(p, b) {
        this.element = p.createElement("div"), this.element.classList.add(La()), b.viewProps.bindClassModifiers(this.element), C(b.expanded, S(this.element, La(void 0, "expanded")));
        const M = p.createElement("div");
        M.classList.add(La("h")), this.element.appendChild(M);
        const z = p.createElement("button");
        z.classList.add(La("b")), z.appendChild(ue(p, "p2dpad")), b.viewProps.bindDisabled(z), M.appendChild(z), this.buttonElement = z;
        const de = p.createElement("div");
        if (de.classList.add(La("t")), M.appendChild(de), this.textElement = de, b.pickerLayout === "inline") {
          const Re = p.createElement("div");
          Re.classList.add(La("p")), this.element.appendChild(Re), this.pickerElement = Re;
        } else
          this.pickerElement = null;
      }
    }
    const Ws = w("p2dp");
    class PS {
      constructor(p, b) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = b.invertsY, this.maxValue_ = b.maxValue, this.element = p.createElement("div"), this.element.classList.add(Ws()), b.layout === "popup" && this.element.classList.add(Ws(void 0, "p")), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("div");
        M.classList.add(Ws("p")), b.viewProps.bindTabIndex(M), this.element.appendChild(M), this.padElement = M;
        const z = p.createElementNS(Ce, "svg");
        z.classList.add(Ws("g")), this.padElement.appendChild(z), this.svgElem_ = z;
        const de = p.createElementNS(Ce, "line");
        de.classList.add(Ws("ax")), de.setAttributeNS(null, "x1", "0"), de.setAttributeNS(null, "y1", "50%"), de.setAttributeNS(null, "x2", "100%"), de.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(de);
        const Re = p.createElementNS(Ce, "line");
        Re.classList.add(Ws("ax")), Re.setAttributeNS(null, "x1", "50%"), Re.setAttributeNS(null, "y1", "0"), Re.setAttributeNS(null, "x2", "50%"), Re.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(Re);
        const et = p.createElementNS(Ce, "line");
        et.classList.add(Ws("l")), et.setAttributeNS(null, "x1", "50%"), et.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(et), this.lineElem_ = et;
        const Pt = p.createElement("div");
        Pt.classList.add(Ws("m")), this.padElement.appendChild(Pt), this.markerElem_ = Pt, b.value.emitter.on("change", this.onValueChange_), this.value = b.value, this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [p, b] = this.value.rawValue.getComponents(), M = this.maxValue_, z = In(p, -M, +M, 0, 100), de = In(b, -M, +M, 0, 100), Re = this.invertsY_ ? 100 - de : de;
        this.lineElem_.setAttributeNS(null, "x2", `${z}%`), this.lineElem_.setAttributeNS(null, "y2", `${Re}%`), this.markerElem_.style.left = `${z}%`, this.markerElem_.style.top = `${Re}%`;
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function $0(x, p, b) {
      return [
        qi(p[0], ms(x)),
        qi(p[1], hc(x)) * (b ? 1 : -1)
      ];
    }
    class RS {
      constructor(p, b) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.baseSteps_ = b.baseSteps, this.maxValue_ = b.maxValue, this.invertsY_ = b.invertsY, this.view = new PS(p, {
          invertsY: this.invertsY_,
          layout: b.layout,
          maxValue: this.maxValue_,
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Bo(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(p, b) {
        if (!p.point)
          return;
        const M = this.maxValue_, z = In(p.point.x, 0, p.bounds.width, -M, +M), de = In(this.invertsY_ ? p.bounds.height - p.point.y : p.point.y, 0, p.bounds.height, -M, +M);
        this.value.setRawValue(new js(z, de), b);
      }
      onPointerDown_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(p) {
        this.handlePointerEvent_(p.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onPadKeyDown_(p) {
        c0(p.key) && p.preventDefault();
        const [b, M] = $0(p, this.baseSteps_, this.invertsY_);
        b === 0 && M === 0 || this.value.setRawValue(new js(this.value.rawValue.x + b, this.value.rawValue.y + M), {
          forceEmit: !1,
          last: !1
        });
      }
      onPadKeyUp_(p) {
        const [b, M] = $0(p, this.baseSteps_, this.invertsY_);
        b === 0 && M === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    class DS {
      constructor(p, b) {
        var M, z;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = b.value, this.viewProps = b.viewProps, this.foldable_ = Ke.create(b.expanded), this.popC_ = b.pickerLayout === "popup" ? new Tr(p, {
          viewProps: this.viewProps
        }) : null;
        const de = new RS(p, {
          baseSteps: [b.axes[0].baseStep, b.axes[1].baseStep],
          invertsY: b.invertsY,
          layout: b.pickerLayout,
          maxValue: b.maxValue,
          value: this.value,
          viewProps: this.viewProps
        });
        de.view.allFocusableElements.forEach((Re) => {
          Re.addEventListener("blur", this.onPopupChildBlur_), Re.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = de, this.textC_ = new fp(p, {
          assembly: z0,
          axes: b.axes,
          parser: b.parser,
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new BS(p, {
          expanded: this.foldable_.value("expanded"),
          pickerLayout: b.pickerLayout,
          viewProps: this.viewProps
        }), this.view.textElement.appendChild(this.textC_.view.element), (M = this.view.buttonElement) === null || M === void 0 || M.addEventListener("blur", this.onPadButtonBlur_), (z = this.view.buttonElement) === null || z === void 0 || z.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), fc({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (Re) => Re.rawValue,
          backward: (Re, et) => et.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), be(this.foldable_, this.view.pickerElement));
      }
      onPadButtonBlur_(p) {
        if (!this.popC_)
          return;
        const b = this.view.element, M = p.relatedTarget;
        (!M || !b.contains(M)) && (this.popC_.shows.rawValue = !1);
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(p) {
        if (!this.popC_)
          return;
        const b = this.popC_.view.element, M = Se(p);
        M && b.contains(M) || M && M === this.view.buttonElement && !W(b.ownerDocument) || (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(p) {
        this.popC_ ? p.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && p.key === "Escape" && this.view.buttonElement.focus();
      }
    }
    class ka {
      constructor(p = 0, b = 0, M = 0) {
        this.x = p, this.y = b, this.z = M;
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(p) {
        if (f(p))
          return !1;
        const b = p.x, M = p.y, z = p.z;
        return !(typeof b != "number" || typeof M != "number" || typeof z != "number");
      }
      static equals(p, b) {
        return p.x === b.x && p.y === b.y && p.z === b.z;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z
        };
      }
    }
    const V0 = {
      toComponents: (x) => x.getComponents(),
      fromComponents: (x) => new ka(...x)
    };
    function LS(x) {
      return ka.isObject(x) ? new ka(x.x, x.y, x.z) : new ka();
    }
    function kS(x, p) {
      x.writeProperty("x", p.x), x.writeProperty("y", p.y), x.writeProperty("z", p.z);
    }
    function US(x, p) {
      return new Hs({
        assembly: V0,
        components: [
          gs("x" in x ? x.x : void 0, p.x),
          gs("y" in x ? x.y : void 0, p.y),
          gs("z" in x ? x.z : void 0, p.z)
        ]
      });
    }
    function hp(x, p) {
      return {
        baseStep: Pa(p),
        constraint: p,
        textProps: q.fromObject({
          draggingScale: Ra(p, x),
          formatter: Ai(ef(p, x))
        })
      };
    }
    const FS = {
      id: "input-point3d",
      type: "input",
      accept: (x, p) => {
        if (!ka.isObject(x))
          return null;
        const b = te, M = j(p, {
          x: b.optional.custom($s),
          y: b.optional.custom($s),
          z: b.optional.custom($s)
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => LS,
        constraint: (x) => US(x.params, x.initialValue),
        equals: ka.equals,
        writer: (x) => kS
      },
      controller: (x) => {
        const p = x.value, b = x.constraint;
        if (!(b instanceof Hs))
          throw _.shouldNeverHappen();
        return new fp(x.document, {
          assembly: V0,
          axes: [
            hp(p.rawValue.x, b.components[0]),
            hp(p.rawValue.y, b.components[1]),
            hp(p.rawValue.z, b.components[2])
          ],
          parser: ps,
          value: p,
          viewProps: x.viewProps
        });
      }
    };
    class Ua {
      constructor(p = 0, b = 0, M = 0, z = 0) {
        this.x = p, this.y = b, this.z = M, this.w = z;
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(p) {
        if (f(p))
          return !1;
        const b = p.x, M = p.y, z = p.z, de = p.w;
        return !(typeof b != "number" || typeof M != "number" || typeof z != "number" || typeof de != "number");
      }
      static equals(p, b) {
        return p.x === b.x && p.y === b.y && p.z === b.z && p.w === b.w;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z,
          w: this.w
        };
      }
    }
    const H0 = {
      toComponents: (x) => x.getComponents(),
      fromComponents: (x) => new Ua(...x)
    };
    function OS(x) {
      return Ua.isObject(x) ? new Ua(x.x, x.y, x.z, x.w) : new Ua();
    }
    function NS(x, p) {
      x.writeProperty("x", p.x), x.writeProperty("y", p.y), x.writeProperty("z", p.z), x.writeProperty("w", p.w);
    }
    function GS(x, p) {
      return new Hs({
        assembly: H0,
        components: [
          gs("x" in x ? x.x : void 0, p.x),
          gs("y" in x ? x.y : void 0, p.y),
          gs("z" in x ? x.z : void 0, p.z),
          gs("w" in x ? x.w : void 0, p.w)
        ]
      });
    }
    function QS(x, p) {
      return {
        baseStep: Pa(p),
        constraint: p,
        textProps: q.fromObject({
          draggingScale: Ra(p, x),
          formatter: Ai(ef(p, x))
        })
      };
    }
    const zS = {
      id: "input-point4d",
      type: "input",
      accept: (x, p) => {
        if (!Ua.isObject(x))
          return null;
        const b = te, M = j(p, {
          x: b.optional.custom($s),
          y: b.optional.custom($s),
          z: b.optional.custom($s),
          w: b.optional.custom($s)
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => OS,
        constraint: (x) => GS(x.params, x.initialValue),
        equals: Ua.equals,
        writer: (x) => NS
      },
      controller: (x) => {
        const p = x.value, b = x.constraint;
        if (!(b instanceof Hs))
          throw _.shouldNeverHappen();
        return new fp(x.document, {
          assembly: H0,
          axes: p.rawValue.getComponents().map((M, z) => QS(M, b.components[z])),
          parser: ps,
          value: p,
          viewProps: x.viewProps
        });
      }
    };
    function $S(x) {
      const p = [], b = Zd(x.options);
      return b && p.push(b), new Zi(p);
    }
    const VS = {
      id: "input-string",
      type: "input",
      accept: (x, p) => {
        if (typeof x != "string")
          return null;
        const M = j(p, {
          options: te.optional.custom(Zu)
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => l0,
        constraint: (x) => $S(x.params),
        writer: (x) => pc
      },
      controller: (x) => {
        const p = x.document, b = x.value, M = x.constraint, z = M && mi(M, Sr);
        return z ? new tr(p, {
          props: new q({
            options: z.values.value("options")
          }),
          value: b,
          viewProps: x.viewProps
        }) : new Br(p, {
          parser: (de) => de,
          props: q.fromObject({
            formatter: qd
          }),
          value: b,
          viewProps: x.viewProps
        });
      }
    }, gc = {
      monitor: {
        defaultInterval: 200,
        defaultLineCount: 3
      }
    }, j0 = w("mll");
    class HS {
      constructor(p, b) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = b.formatter, this.element = p.createElement("div"), this.element.classList.add(j0()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("textarea");
        M.classList.add(j0("i")), M.style.height = `calc(var(--bld-us) * ${b.lineCount})`, M.readOnly = !0, b.viewProps.bindDisabled(M), this.element.appendChild(M), this.textareaElem_ = M, b.value.emitter.on("change", this.onValueUpdate_), this.value = b.value, this.update_();
      }
      update_() {
        const p = this.textareaElem_, b = p.scrollTop === p.scrollHeight - p.clientHeight, M = [];
        this.value.rawValue.forEach((z) => {
          z !== void 0 && M.push(this.formatter_(z));
        }), p.textContent = M.join(`
`), b && (p.scrollTop = p.scrollHeight);
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class dp {
      constructor(p, b) {
        this.value = b.value, this.viewProps = b.viewProps, this.view = new HS(p, {
          formatter: b.formatter,
          lineCount: b.lineCount,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const W0 = w("sgl");
    class jS {
      constructor(p, b) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = b.formatter, this.element = p.createElement("div"), this.element.classList.add(W0()), b.viewProps.bindClassModifiers(this.element);
        const M = p.createElement("input");
        M.classList.add(W0("i")), M.readOnly = !0, M.type = "text", b.viewProps.bindDisabled(M), this.element.appendChild(M), this.inputElement = M, b.value.emitter.on("change", this.onValueUpdate_), this.value = b.value, this.update_();
      }
      update_() {
        const p = this.value.rawValue, b = p[p.length - 1];
        this.inputElement.value = b !== void 0 ? this.formatter_(b) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class pp {
      constructor(p, b) {
        this.value = b.value, this.viewProps = b.viewProps, this.view = new jS(p, {
          formatter: b.formatter,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const WS = {
      id: "monitor-bool",
      type: "monitor",
      accept: (x, p) => {
        if (typeof x != "boolean")
          return null;
        const M = j(p, {
          lineCount: te.optional.number
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => Gs
      },
      controller: (x) => {
        var p;
        return x.value.rawValue.length === 1 ? new pp(x.document, {
          formatter: Xr,
          value: x.value,
          viewProps: x.viewProps
        }) : new dp(x.document, {
          formatter: Xr,
          lineCount: (p = x.params.lineCount) !== null && p !== void 0 ? p : gc.monitor.defaultLineCount,
          value: x.value,
          viewProps: x.viewProps
        });
      }
    }, qs = w("grl");
    class qS {
      constructor(p, b) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = p.createElement("div"), this.element.classList.add(qs()), b.viewProps.bindClassModifiers(this.element), this.formatter_ = b.formatter, this.props_ = b.props, this.cursor_ = b.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const M = p.createElementNS(Ce, "svg");
        M.classList.add(qs("g")), M.style.height = `calc(var(--bld-us) * ${b.lineCount})`, this.element.appendChild(M), this.svgElem_ = M;
        const z = p.createElementNS(Ce, "polyline");
        this.svgElem_.appendChild(z), this.lineElem_ = z;
        const de = p.createElement("div");
        de.classList.add(qs("t"), w("tt")()), this.element.appendChild(de), this.tooltipElem_ = de, b.value.emitter.on("change", this.onValueUpdate_), this.value = b.value, this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const p = this.svgElem_.getBoundingClientRect(), b = this.value.rawValue.length - 1, M = this.props_.get("minValue"), z = this.props_.get("maxValue"), de = [];
        this.value.rawValue.forEach((ln, fn) => {
          if (ln === void 0)
            return;
          const ko = In(fn, 0, b, 0, p.width), Ac = In(ln, M, z, p.height, 0);
          de.push([ko, Ac].join(","));
        }), this.lineElem_.setAttributeNS(null, "points", de.join(" "));
        const Re = this.tooltipElem_, et = this.value.rawValue[this.cursor_.rawValue];
        if (et === void 0) {
          Re.classList.remove(qs("t", "a"));
          return;
        }
        const Pt = In(this.cursor_.rawValue, 0, b, 0, p.width), kt = In(et, M, z, p.height, 0);
        Re.style.left = `${Pt}px`, Re.style.top = `${kt}px`, Re.textContent = `${this.formatter_(et)}`, Re.classList.contains(qs("t", "a")) || (Re.classList.add(qs("t", "a"), qs("t", "in")), ze(Re), Re.classList.remove(qs("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class XS {
      constructor(p, b) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = b.props, this.value = b.value, this.viewProps = b.viewProps, this.cursor_ = Q(-1), this.view = new qS(p, {
          cursor: this.cursor_,
          formatter: b.formatter,
          lineCount: b.lineCount,
          props: this.props_,
          value: this.value,
          viewProps: this.viewProps
        }), !W(p))
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        else {
          const M = new Bo(this.view.element);
          M.emitter.on("down", this.onGraphPointerDown_), M.emitter.on("move", this.onGraphPointerMove_), M.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(p) {
        const b = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(In(p.offsetX, 0, b.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(p) {
        this.onGraphPointerMove_(p);
      }
      onGraphPointerMove_(p) {
        if (!p.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(In(p.data.point.x, 0, p.data.bounds.width, 0, this.value.rawValue.length));
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    function mp(x) {
      return "format" in x && !f(x.format) ? x.format : Ai(2);
    }
    function YS(x) {
      var p;
      return x.value.rawValue.length === 1 ? new pp(x.document, {
        formatter: mp(x.params),
        value: x.value,
        viewProps: x.viewProps
      }) : new dp(x.document, {
        formatter: mp(x.params),
        lineCount: (p = x.params.lineCount) !== null && p !== void 0 ? p : gc.monitor.defaultLineCount,
        value: x.value,
        viewProps: x.viewProps
      });
    }
    function KS(x) {
      var p, b, M;
      return new XS(x.document, {
        formatter: mp(x.params),
        lineCount: (p = x.params.lineCount) !== null && p !== void 0 ? p : gc.monitor.defaultLineCount,
        props: q.fromObject({
          maxValue: (b = "max" in x.params ? x.params.max : null) !== null && b !== void 0 ? b : 100,
          minValue: (M = "min" in x.params ? x.params.min : null) !== null && M !== void 0 ? M : 0
        }),
        value: x.value,
        viewProps: x.viewProps
      });
    }
    function q0(x) {
      return "view" in x && x.view === "graph";
    }
    const JS = {
      id: "monitor-number",
      type: "monitor",
      accept: (x, p) => {
        if (typeof x != "number")
          return null;
        const b = te, M = j(p, {
          format: b.optional.function,
          lineCount: b.optional.number,
          max: b.optional.number,
          min: b.optional.number,
          view: b.optional.string
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        defaultBufferSize: (x) => q0(x) ? 64 : 1,
        reader: (x) => a0
      },
      controller: (x) => q0(x.params) ? KS(x) : YS(x)
    }, ZS = {
      id: "monitor-string",
      type: "monitor",
      accept: (x, p) => {
        if (typeof x != "string")
          return null;
        const b = te, M = j(p, {
          lineCount: b.optional.number,
          multiline: b.optional.boolean
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => l0
      },
      controller: (x) => {
        var p;
        const b = x.value;
        return b.rawValue.length > 1 || "multiline" in x.params && x.params.multiline ? new dp(x.document, {
          formatter: qd,
          lineCount: (p = x.params.lineCount) !== null && p !== void 0 ? p : gc.monitor.defaultLineCount,
          value: b,
          viewProps: x.viewProps
        }) : new pp(x.document, {
          formatter: qd,
          value: b,
          viewProps: x.viewProps
        });
      }
    };
    function eM(x, p) {
      var b;
      const M = x.accept(p.target.read(), p.params);
      if (f(M))
        return null;
      const z = te, de = {
        target: p.target,
        initialValue: M.initialValue,
        params: M.params
      }, Re = x.binding.reader(de), et = x.binding.constraint ? x.binding.constraint(de) : void 0, Pt = Q(Re(M.initialValue), {
        constraint: et,
        equals: x.binding.equals
      }), kt = new jr({
        reader: Re,
        target: p.target,
        value: Pt,
        writer: x.binding.writer(de)
      }), ln = z.optional.boolean(p.params.disabled).value, fn = z.optional.boolean(p.params.hidden).value, ko = x.controller({
        constraint: et,
        document: p.document,
        initialValue: M.initialValue,
        params: M.params,
        value: kt.value,
        viewProps: ye.create({
          disabled: ln,
          hidden: fn
        })
      });
      return new dt(p.document, {
        binding: kt,
        blade: Ze(),
        props: q.fromObject({
          label: "label" in p.params ? (b = z.optional.string(p.params.label).value) !== null && b !== void 0 ? b : null : p.target.key
        }),
        valueController: ko
      });
    }
    function tM(x, p) {
      return p === 0 ? new Nn() : new fr(x, p ?? gc.monitor.defaultInterval);
    }
    function nM(x, p) {
      var b, M, z;
      const de = te, Re = x.accept(p.target.read(), p.params);
      if (f(Re))
        return null;
      const et = {
        target: p.target,
        initialValue: Re.initialValue,
        params: Re.params
      }, Pt = x.binding.reader(et), kt = (M = (b = de.optional.number(p.params.bufferSize).value) !== null && b !== void 0 ? b : x.binding.defaultBufferSize && x.binding.defaultBufferSize(Re.params)) !== null && M !== void 0 ? M : 1, ln = de.optional.number(p.params.interval).value, fn = new Eo({
        reader: Pt,
        target: p.target,
        ticker: tM(p.document, ln),
        value: Ma(kt)
      }), ko = de.optional.boolean(p.params.disabled).value, Ac = de.optional.boolean(p.params.hidden).value, _c = x.controller({
        document: p.document,
        params: Re.params,
        value: fn.value,
        viewProps: ye.create({
          disabled: ko,
          hidden: Ac
        })
      });
      return new At(p.document, {
        binding: fn,
        blade: Ze(),
        props: q.fromObject({
          label: "label" in p.params ? (z = de.optional.string(p.params.label).value) !== null && z !== void 0 ? z : null : p.target.key
        }),
        valueController: _c
      });
    }
    class iM {
      constructor() {
        this.pluginsMap_ = {
          blades: [],
          inputs: [],
          monitors: []
        };
      }
      getAll() {
        return [
          ...this.pluginsMap_.blades,
          ...this.pluginsMap_.inputs,
          ...this.pluginsMap_.monitors
        ];
      }
      register(p) {
        p.type === "blade" ? this.pluginsMap_.blades.unshift(p) : p.type === "input" ? this.pluginsMap_.inputs.unshift(p) : p.type === "monitor" && this.pluginsMap_.monitors.unshift(p);
      }
      createInput(p, b, M) {
        const z = b.read();
        if (f(z))
          throw new _({
            context: {
              key: b.key
            },
            type: "nomatchingcontroller"
          });
        const de = this.pluginsMap_.inputs.reduce((Re, et) => Re ?? eM(et, {
          document: p,
          target: b,
          params: M
        }), null);
        if (de)
          return de;
        throw new _({
          context: {
            key: b.key
          },
          type: "nomatchingcontroller"
        });
      }
      createMonitor(p, b, M) {
        const z = this.pluginsMap_.monitors.reduce((de, Re) => de ?? nM(Re, {
          document: p,
          params: M,
          target: b
        }), null);
        if (z)
          return z;
        throw new _({
          context: {
            key: b.key
          },
          type: "nomatchingcontroller"
        });
      }
      createBlade(p, b) {
        const M = this.pluginsMap_.blades.reduce((z, de) => z ?? Oi(de, {
          document: p,
          params: b
        }), null);
        if (!M)
          throw new _({
            type: "nomatchingview",
            context: {
              params: b
            }
          });
        return M;
      }
      createBladeApi(p) {
        if (p instanceof dt)
          return new Xe(p);
        if (p instanceof At)
          return new at(p);
        if (p instanceof Le)
          return new $t(p, this);
        const b = this.pluginsMap_.blades.reduce((M, z) => M ?? z.api({
          controller: p,
          pool: this
        }), null);
        if (!b)
          throw _.shouldNeverHappen();
        return b;
      }
    }
    function rM() {
      const x = new iM();
      return [
        uM,
        FS,
        zS,
        VS,
        TS,
        ES,
        wS,
        bS,
        _C,
        WS,
        ZS,
        JS,
        He,
        ut,
        mn,
        ui
      ].forEach((p) => {
        x.register(p);
      }), x;
    }
    function sM(x) {
      return js.isObject(x) ? new js(x.x, x.y) : new js();
    }
    function oM(x, p) {
      x.writeProperty("x", p.x), x.writeProperty("y", p.y);
    }
    function gs(x, p) {
      if (!x)
        return;
      const b = [], M = G0(x, p);
      M && b.push(M);
      const z = Q0(x);
      return z && b.push(z), new Zi(b);
    }
    function aM(x, p) {
      return new Hs({
        assembly: z0,
        components: [
          gs("x" in x ? x.x : void 0, p.x),
          gs("y" in x ? x.y : void 0, p.y)
        ]
      });
    }
    function X0(x, p) {
      const [b, M] = x ? MS(x) : [];
      if (!f(b) || !f(M))
        return Math.max(Math.abs(b ?? 0), Math.abs(M ?? 0));
      const z = Pa(x);
      return Math.max(Math.abs(z) * 10, Math.abs(p) * 10);
    }
    function lM(x, p) {
      const b = p instanceof Hs ? p.components[0] : void 0, M = p instanceof Hs ? p.components[1] : void 0, z = X0(b, x.x), de = X0(M, x.y);
      return Math.max(z, de);
    }
    function Y0(x, p) {
      return {
        baseStep: Pa(p),
        constraint: p,
        textProps: q.fromObject({
          draggingScale: Ra(p, x),
          formatter: Ai(ef(p, x))
        })
      };
    }
    function cM(x) {
      if (!("y" in x))
        return !1;
      const p = x.y;
      return p && "inverted" in p ? !!p.inverted : !1;
    }
    const uM = {
      id: "input-point2d",
      type: "input",
      accept: (x, p) => {
        if (!js.isObject(x))
          return null;
        const b = te, M = j(p, {
          expanded: b.optional.boolean,
          picker: b.optional.custom(h0),
          x: b.optional.custom($s),
          y: b.optional.object({
            inverted: b.optional.boolean,
            max: b.optional.number,
            min: b.optional.number,
            step: b.optional.number
          })
        });
        return M ? {
          initialValue: x,
          params: M
        } : null;
      },
      binding: {
        reader: (x) => sM,
        constraint: (x) => aM(x.params, x.initialValue),
        equals: js.equals,
        writer: (x) => oM
      },
      controller: (x) => {
        const p = x.document, b = x.value, M = x.constraint;
        if (!(M instanceof Hs))
          throw _.shouldNeverHappen();
        const z = "expanded" in x.params ? x.params.expanded : void 0, de = "picker" in x.params ? x.params.picker : void 0;
        return new DS(p, {
          axes: [
            Y0(b.rawValue.x, M.components[0]),
            Y0(b.rawValue.y, M.components[1])
          ],
          expanded: z ?? !1,
          invertsY: cM(x.params),
          maxValue: lM(b.rawValue, M),
          parser: ps,
          pickerLayout: de ?? "popup",
          value: b,
          viewProps: x.viewProps
        });
      }
    };
    class K0 extends i {
      constructor(p) {
        super(p), this.emitter_ = new v(), this.controller_.valueController.value.emitter.on("change", (b) => {
          this.emitter_.emit("change", {
            event: new a(this, b.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(p) {
        this.controller_.props.set("label", p);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(p) {
        this.controller_.valueController.props.set("options", p);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(p) {
        this.controller_.valueController.value.rawValue = p;
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
    }
    class J0 extends i {
      constructor(p) {
        super(p), this.emitter_ = new v(), this.controller_.valueController.value.emitter.on("change", (b) => {
          this.emitter_.emit("change", {
            event: new a(this, b.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(p) {
        this.controller_.props.set("label", p);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get("maxValue");
      }
      set maxValue(p) {
        this.controller_.valueController.sliderController.props.set("maxValue", p);
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get("minValue");
      }
      set minValue(p) {
        this.controller_.valueController.sliderController.props.set("minValue", p);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(p) {
        this.controller_.valueController.value.rawValue = p;
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
    }
    class Z0 extends i {
      constructor(p) {
        super(p), this.emitter_ = new v(), this.controller_.valueController.value.emitter.on("change", (b) => {
          this.emitter_.emit("change", {
            event: new a(this, b.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(p) {
        this.controller_.props.set("label", p);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(p) {
        this.controller_.valueController.props.set("formatter", p);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(p) {
        this.controller_.valueController.value.rawValue = p;
      }
      on(p, b) {
        const M = b.bind(this);
        return this.emitter_.on(p, (z) => {
          M(z.event);
        }), this;
      }
    }
    const fM = function() {
      return {
        id: "list",
        type: "blade",
        accept(x) {
          const p = te, b = j(x, {
            options: p.required.custom(Zu),
            value: p.required.raw,
            view: p.required.constant("list"),
            label: p.optional.string
          });
          return b ? { params: b } : null;
        },
        controller(x) {
          const p = new Sr(d0(x.params.options)), b = Q(x.params.value, {
            constraint: p
          }), M = new tr(x.document, {
            props: new q({
              options: p.values.value("options")
            }),
            value: b,
            viewProps: x.viewProps
          });
          return new pt(x.document, {
            blade: x.blade,
            props: q.fromObject({
              label: x.params.label
            }),
            valueController: M
          });
        },
        api(x) {
          return !(x.controller instanceof pt) || !(x.controller.valueController instanceof tr) ? null : new K0(x.controller);
        }
      };
    }();
    function hM(x) {
      return x.reduce((p, b) => Object.assign(p, {
        [b.presetKey]: b.read()
      }), {});
    }
    function dM(x, p) {
      x.forEach((b) => {
        const M = p[b.target.presetKey];
        M !== void 0 && b.writer(b.target, b.reader(M));
      });
    }
    class pM extends Jt {
      /**
       * @hidden
       */
      constructor(p, b) {
        super(p, b);
      }
      get element() {
        return this.controller_.view.element;
      }
      /**
       * Imports a preset of all inputs.
       * @param preset The preset object to import.
       */
      importPreset(p) {
        const b = this.controller_.rackController.rack.find(dt).map((M) => M.binding);
        dM(b, p), this.refresh();
      }
      /**
       * Exports a preset of all inputs.
       * @return An exported preset object.
       */
      exportPreset() {
        const p = this.controller_.rackController.rack.find(dt).map((b) => b.binding.target);
        return hM(p);
      }
      /**
       * Refreshes all bindings of the pane.
       */
      refresh() {
        this.controller_.rackController.rack.find(dt).forEach((p) => {
          p.binding.read();
        }), this.controller_.rackController.rack.find(At).forEach((p) => {
          p.binding.read();
        });
      }
    }
    class mM extends ct {
      constructor(p, b) {
        super(p, {
          expanded: b.expanded,
          blade: b.blade,
          props: b.props,
          root: !0,
          viewProps: b.viewProps
        });
      }
    }
    const gM = {
      id: "slider",
      type: "blade",
      accept(x) {
        const p = te, b = j(x, {
          max: p.required.number,
          min: p.required.number,
          view: p.required.constant("slider"),
          format: p.optional.function,
          label: p.optional.string,
          value: p.optional.number
        });
        return b ? { params: b } : null;
      },
      controller(x) {
        var p, b;
        const M = (p = x.params.value) !== null && p !== void 0 ? p : 0, z = new er({
          max: x.params.max,
          min: x.params.min
        }), de = new Jd(x.document, {
          baseStep: 1,
          parser: ps,
          sliderProps: new q({
            maxValue: z.values.value("max"),
            minValue: z.values.value("min")
          }),
          textProps: q.fromObject({
            draggingScale: Ra(void 0, M),
            formatter: (b = x.params.format) !== null && b !== void 0 ? b : aC
          }),
          value: Q(M, {
            constraint: z
          }),
          viewProps: x.viewProps
        });
        return new pt(x.document, {
          blade: x.blade,
          props: q.fromObject({
            label: x.params.label
          }),
          valueController: de
        });
      },
      api(x) {
        return !(x.controller instanceof pt) || !(x.controller.valueController instanceof Jd) ? null : new J0(x.controller);
      }
    }, AM = function() {
      return {
        id: "text",
        type: "blade",
        accept(x) {
          const p = te, b = j(x, {
            parse: p.required.function,
            value: p.required.raw,
            view: p.required.constant("text"),
            format: p.optional.function,
            label: p.optional.string
          });
          return b ? { params: b } : null;
        },
        controller(x) {
          var p;
          const b = new Br(x.document, {
            parser: x.params.parse,
            props: q.fromObject({
              formatter: (p = x.params.format) !== null && p !== void 0 ? p : (M) => String(M)
            }),
            value: Q(x.params.value),
            viewProps: x.viewProps
          });
          return new pt(x.document, {
            blade: x.blade,
            props: q.fromObject({
              label: x.params.label
            }),
            valueController: b
          });
        },
        api(x) {
          return !(x.controller instanceof pt) || !(x.controller.valueController instanceof Br) ? null : new Z0(x.controller);
        }
      };
    }();
    function _M(x) {
      const p = x.createElement("div");
      return p.classList.add(w("dfw")()), x.body && x.body.appendChild(p), p;
    }
    function e_(x, p, b) {
      if (x.querySelector(`style[data-tp-style=${p}]`))
        return;
      const M = x.createElement("style");
      M.dataset.tpStyle = p, M.textContent = b, x.head.appendChild(M);
    }
    class bM extends pM {
      constructor(p) {
        var b, M;
        const z = p ?? {}, de = (b = z.document) !== null && b !== void 0 ? b : se(), Re = rM(), et = new mM(de, {
          expanded: z.expanded,
          blade: Ze(),
          props: q.fromObject({
            title: z.title
          }),
          viewProps: ye.create()
        });
        super(et, Re), this.pool_ = Re, this.containerElem_ = (M = z.container) !== null && M !== void 0 ? M : _M(de), this.containerElem_.appendChild(this.element), this.doc_ = de, this.usesDefaultWrapper_ = !z.container, this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_)
          throw _.alreadyDisposed();
        return this.doc_;
      }
      dispose() {
        const p = this.containerElem_;
        if (!p)
          throw _.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
          const b = p.parentElement;
          b && b.removeChild(p);
        }
        this.containerElem_ = null, this.doc_ = null, super.dispose();
      }
      registerPlugin(p) {
        ("plugin" in p ? [p.plugin] : "plugins" in p ? p.plugins : []).forEach((M) => {
          this.pool_.register(M), this.embedPluginStyle_(M);
        });
      }
      embedPluginStyle_(p) {
        p.css && e_(this.document, `plugin-${p.id}`, p.css);
      }
      setUpDefaultPlugins_() {
        e_(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((p) => {
          this.embedPluginStyle_(p);
        }), this.registerPlugin({
          plugins: [
            gM,
            fM,
            ui,
            AM
          ]
        });
      }
    }
    const vM = new n("3.1.10");
    t.BladeApi = i, t.ButtonApi = A, t.FolderApi = Jt, t.InputBindingApi = Xe, t.ListApi = K0, t.MonitorBindingApi = at, t.Pane = bM, t.SeparatorApi = Bt, t.SliderApi = J0, t.TabApi = sn, t.TabPageApi = Ei, t.TextApi = Z0, t.TpChangeEvent = a, t.VERSION = vM, Object.defineProperty(t, "__esModule", { value: !0 });
  });
})($g, $g.exports);
var E4 = $g.exports;
function C4() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(i, r) {
    var a = i.id, o = i.name, l = i.dependencies;
    l === void 0 && (l = []);
    var c = i.init;
    c === void 0 && (c = function() {
    });
    var u = i.getTransferables;
    if (u === void 0 && (u = null), !s[a])
      try {
        l = l.map(function(h) {
          return h && h.isWorkerModule && (e(h, function(d) {
            if (d instanceof Error)
              throw d;
          }), h = s[h.id].value), h;
        }), c = n("<" + o + ">.init", c), u && (u = n("<" + o + ">.getTransferables", u));
        var f = null;
        typeof c == "function" ? f = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), s[a] = {
          id: a,
          value: f,
          getTransferables: u
        }, r(f);
      } catch (h) {
        h && h.noLog || console.error(h), r(h);
      }
  }
  function t(i, r) {
    var a, o = i.id, l = i.args;
    (!s[o] || typeof s[o].value != "function") && r(new Error("Worker module " + o + ": not found or its 'init' did not return a function"));
    try {
      var c = (a = s[o]).value.apply(a, l);
      c && typeof c.then == "function" ? c.then(u, function(f) {
        return r(f instanceof Error ? f : new Error("" + f));
      }) : u(c);
    } catch (f) {
      r(f);
    }
    function u(f) {
      try {
        var h = s[o].getTransferables && s[o].getTransferables(f);
        (!h || !Array.isArray(h) || !h.length) && (h = void 0), r(f, h);
      } catch (d) {
        console.error(d), r(d);
      }
    }
  }
  function n(i, r) {
    var a = void 0;
    self.troikaDefine = function(l) {
      return a = l;
    };
    var o = URL.createObjectURL(
      new Blob(
        ["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + r + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(o);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(o), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(i) {
    var r = i.data, a = r.messageId, o = r.action, l = r.data;
    try {
      o === "registerModule" && e(l, function(c) {
        c instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof c == "function" }
        });
      }), o === "callModule" && t(l, function(c, u) {
        c instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: c
        }, u || void 0);
      });
    } catch (c) {
      postMessage({
        messageId: a,
        success: !1,
        error: c.stack
      });
    }
  });
}
function S4(s) {
  var e = function() {
    for (var t = [], n = arguments.length; n--; )
      t[n] = arguments[n];
    return e._getInitResult().then(function(i) {
      if (typeof i == "function")
        return i.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = s.dependencies, n = s.init;
    t = Array.isArray(t) ? t.map(
      function(r) {
        return r && r._getInitResult ? r._getInitResult() : r;
      }
    ) : [];
    var i = Promise.all(t).then(function(r) {
      return n.apply(null, r);
    });
    return e._getInitResult = function() {
      return i;
    }, i;
  }, e;
}
var IE = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return IE = function() {
    return s;
  }, s;
}, M4 = 0, I4 = 0, Nm = !1, su = /* @__PURE__ */ Object.create(null), ou = /* @__PURE__ */ Object.create(null), Vg = /* @__PURE__ */ Object.create(null);
function Hu(s) {
  if ((!s || typeof s.init != "function") && !Nm)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, t = s.init, n = s.getTransferables, i = s.workerId;
  if (!IE())
    return S4(s);
  i == null && (i = "#default");
  var r = "workerModule" + ++M4, a = s.name || r, o = null;
  e = e && e.map(function(c) {
    return typeof c == "function" && !c.workerModuleData && (Nm = !0, c = Hu({
      workerId: i,
      name: "<" + a + "> function dependency: " + c.name,
      init: `function(){return (
` + Dh(c) + `
)}`
    }), Nm = !1), c && c.workerModuleData && (c = c.workerModuleData), c;
  });
  function l() {
    for (var c = [], u = arguments.length; u--; )
      c[u] = arguments[u];
    if (!o) {
      o = ly(i, "registerModule", l.workerModuleData);
      var f = function() {
        o = null, ou[i].delete(f);
      };
      (ou[i] || (ou[i] = /* @__PURE__ */ new Set())).add(f);
    }
    return o.then(function(h) {
      var d = h.isCallable;
      if (d)
        return ly(i, "callModule", { id: r, args: c });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return l.workerModuleData = {
    isWorkerModule: !0,
    id: r,
    name: a,
    dependencies: e,
    init: Dh(t),
    getTransferables: n && Dh(n)
  }, l;
}
function T4(s) {
  ou[s] && ou[s].forEach(function(e) {
    e();
  }), su[s] && (su[s].terminate(), delete su[s]);
}
function Dh(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function B4(s) {
  var e = su[s];
  if (!e) {
    var t = Dh(C4);
    e = su[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(n) {
      var i = n.data, r = i.messageId, a = Vg[r];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete Vg[r], a(i);
    };
  }
  return e;
}
function ly(s, e, t) {
  return new Promise(function(n, i) {
    var r = ++I4;
    Vg[r] = function(a) {
      a.success ? n(a.result) : i(new Error("Error in worker " + e + " call: " + a.error));
    }, B4(s).postMessage({
      messageId: r,
      action: e,
      data: t
    });
  });
}
function Qd() {
  var s = function(e) {
    function t(oe, le, k, X, fe, te, j, Ae) {
      var Y = 1 - j;
      Ae.x = Y * Y * oe + 2 * Y * j * k + j * j * fe, Ae.y = Y * Y * le + 2 * Y * j * X + j * j * te;
    }
    function n(oe, le, k, X, fe, te, j, Ae, Y, pe) {
      var me = 1 - Y;
      pe.x = me * me * me * oe + 3 * me * me * Y * k + 3 * me * Y * Y * fe + Y * Y * Y * j, pe.y = me * me * me * le + 3 * me * me * Y * X + 3 * me * Y * Y * te + Y * Y * Y * Ae;
    }
    function i(oe, le) {
      for (var k = /([MLQCZ])([^MLQCZ]*)/g, X, fe, te, j, Ae; X = k.exec(oe); ) {
        var Y = X[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(pe) {
          return parseFloat(pe);
        });
        switch (X[1]) {
          case "M":
            j = fe = Y[0], Ae = te = Y[1];
            break;
          case "L":
            (Y[0] !== j || Y[1] !== Ae) && le("L", j, Ae, j = Y[0], Ae = Y[1]);
            break;
          case "Q": {
            le("Q", j, Ae, j = Y[2], Ae = Y[3], Y[0], Y[1]);
            break;
          }
          case "C": {
            le("C", j, Ae, j = Y[4], Ae = Y[5], Y[0], Y[1], Y[2], Y[3]);
            break;
          }
          case "Z":
            (j !== fe || Ae !== te) && le("L", j, Ae, fe, te);
            break;
        }
      }
    }
    function r(oe, le, k) {
      k === void 0 && (k = 16);
      var X = { x: 0, y: 0 };
      i(oe, function(fe, te, j, Ae, Y, pe, me, re, ye) {
        switch (fe) {
          case "L":
            le(te, j, Ae, Y);
            break;
          case "Q": {
            for (var ae = te, De = j, Ee = 1; Ee < k; Ee++)
              t(
                te,
                j,
                pe,
                me,
                Ae,
                Y,
                Ee / (k - 1),
                X
              ), le(ae, De, X.x, X.y), ae = X.x, De = X.y;
            break;
          }
          case "C": {
            for (var Ie = te, Ce = j, ze = 1; ze < k; ze++)
              n(
                te,
                j,
                pe,
                me,
                re,
                ye,
                Ae,
                Y,
                ze / (k - 1),
                X
              ), le(Ie, Ce, X.x, X.y), Ie = X.x, Ce = X.y;
            break;
          }
        }
      });
    }
    var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", o = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", l = /* @__PURE__ */ new WeakMap(), c = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(oe, le) {
      var k = oe.getContext ? oe.getContext("webgl", c) : oe, X = l.get(k);
      if (!X) {
        let Ie = function(se) {
          var _e = te[se];
          if (!_e && (_e = te[se] = k.getExtension(se), !_e))
            throw new Error(se + " not supported");
          return _e;
        }, Ce = function(se, _e) {
          var ve = k.createShader(_e);
          return k.shaderSource(ve, se), k.compileShader(ve), ve;
        }, ze = function(se, _e, ve, ue) {
          if (!j[se]) {
            var Te = {}, Ge = {}, Pe = k.createProgram();
            k.attachShader(Pe, Ce(_e, k.VERTEX_SHADER)), k.attachShader(Pe, Ce(ve, k.FRAGMENT_SHADER)), k.linkProgram(Pe), j[se] = {
              program: Pe,
              transaction: function(Se) {
                k.useProgram(Pe), Se({
                  setUniform: function(Ye, $e) {
                    for (var Ne = [], He = arguments.length - 2; He-- > 0; )
                      Ne[He] = arguments[He + 2];
                    var Qe = Ge[$e] || (Ge[$e] = k.getUniformLocation(Pe, $e));
                    k["uniform" + Ye].apply(k, [Qe].concat(Ne));
                  },
                  setAttribute: function(Ye, $e, Ne, He, Qe) {
                    var Ze = Te[Ye];
                    Ze || (Ze = Te[Ye] = {
                      buf: k.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: k.getAttribLocation(Pe, Ye),
                      data: null
                    }), k.bindBuffer(k.ARRAY_BUFFER, Ze.buf), k.vertexAttribPointer(Ze.loc, $e, k.FLOAT, !1, 0, 0), k.enableVertexAttribArray(Ze.loc), fe ? k.vertexAttribDivisor(Ze.loc, He) : Ie("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Ze.loc, He), Qe !== Ze.data && (k.bufferData(k.ARRAY_BUFFER, Qe, Ne), Ze.data = Qe);
                  }
                });
              }
            };
          }
          j[se].transaction(ue);
        }, Fe = function(se, _e) {
          Y++;
          try {
            k.activeTexture(k.TEXTURE0 + Y);
            var ve = Ae[se];
            ve || (ve = Ae[se] = k.createTexture(), k.bindTexture(k.TEXTURE_2D, ve), k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MIN_FILTER, k.NEAREST), k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MAG_FILTER, k.NEAREST)), k.bindTexture(k.TEXTURE_2D, ve), _e(ve, Y);
          } finally {
            Y--;
          }
        }, W = function(se, _e, ve) {
          var ue = k.createFramebuffer();
          pe.push(ue), k.bindFramebuffer(k.FRAMEBUFFER, ue), k.activeTexture(k.TEXTURE0 + _e), k.bindTexture(k.TEXTURE_2D, se), k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, se, 0);
          try {
            ve(ue);
          } finally {
            k.deleteFramebuffer(ue), k.bindFramebuffer(k.FRAMEBUFFER, pe[--pe.length - 1] || null);
          }
        }, G = function() {
          te = {}, j = {}, Ae = {}, Y = -1, pe.length = 0;
        };
        var me = Ie, re = Ce, ye = ze, ae = Fe, De = W, Ee = G, fe = typeof WebGL2RenderingContext < "u" && k instanceof WebGL2RenderingContext, te = {}, j = {}, Ae = {}, Y = -1, pe = [];
        k.canvas.addEventListener("webglcontextlost", function(se) {
          G(), se.preventDefault();
        }, !1), l.set(k, X = {
          gl: k,
          isWebGL2: fe,
          getExtension: Ie,
          withProgram: ze,
          withTexture: Fe,
          withTextureFramebuffer: W,
          handleContextLoss: G
        });
      }
      le(X);
    }
    function f(oe, le, k, X, fe, te, j, Ae) {
      j === void 0 && (j = 15), Ae === void 0 && (Ae = null), u(oe, function(Y) {
        var pe = Y.gl, me = Y.withProgram, re = Y.withTexture;
        re("copy", function(ye, ae) {
          pe.texImage2D(pe.TEXTURE_2D, 0, pe.RGBA, fe, te, 0, pe.RGBA, pe.UNSIGNED_BYTE, le), me("copy", a, o, function(De) {
            var Ee = De.setUniform, Ie = De.setAttribute;
            Ie("aUV", 2, pe.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Ee("1i", "image", ae), pe.bindFramebuffer(pe.FRAMEBUFFER, Ae || null), pe.disable(pe.BLEND), pe.colorMask(j & 8, j & 4, j & 2, j & 1), pe.viewport(k, X, fe, te), pe.scissor(k, X, fe, te), pe.drawArrays(pe.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function h(oe, le, k) {
      var X = oe.width, fe = oe.height;
      u(oe, function(te) {
        var j = te.gl, Ae = new Uint8Array(X * fe * 4);
        j.readPixels(0, 0, X, fe, j.RGBA, j.UNSIGNED_BYTE, Ae), oe.width = le, oe.height = k, f(j, Ae, 0, 0, X, fe);
      });
    }
    var d = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: f,
      resizeWebGLCanvasWithoutClearing: h
    });
    function m(oe, le, k, X, fe, te) {
      te === void 0 && (te = 1);
      var j = new Uint8Array(oe * le), Ae = X[2] - X[0], Y = X[3] - X[1], pe = [];
      r(k, function(Ie, Ce, ze, Fe) {
        pe.push({
          x1: Ie,
          y1: Ce,
          x2: ze,
          y2: Fe,
          minX: Math.min(Ie, ze),
          minY: Math.min(Ce, Fe),
          maxX: Math.max(Ie, ze),
          maxY: Math.max(Ce, Fe)
        });
      }), pe.sort(function(Ie, Ce) {
        return Ie.maxX - Ce.maxX;
      });
      for (var me = 0; me < oe; me++)
        for (var re = 0; re < le; re++) {
          var ye = De(
            X[0] + Ae * (me + 0.5) / oe,
            X[1] + Y * (re + 0.5) / le
          ), ae = Math.pow(1 - Math.abs(ye) / fe, te) / 2;
          ye < 0 && (ae = 1 - ae), ae = Math.max(0, Math.min(255, Math.round(ae * 255))), j[re * oe + me] = ae;
        }
      return j;
      function De(Ie, Ce) {
        for (var ze = 1 / 0, Fe = 1 / 0, W = pe.length; W--; ) {
          var G = pe[W];
          if (G.maxX + Fe <= Ie)
            break;
          if (Ie + Fe > G.minX && Ce - Fe < G.maxY && Ce + Fe > G.minY) {
            var se = A(Ie, Ce, G.x1, G.y1, G.x2, G.y2);
            se < ze && (ze = se, Fe = Math.sqrt(ze));
          }
        }
        return Ee(Ie, Ce) && (Fe = -Fe), Fe;
      }
      function Ee(Ie, Ce) {
        for (var ze = 0, Fe = pe.length; Fe--; ) {
          var W = pe[Fe];
          if (W.maxX <= Ie)
            break;
          var G = W.y1 > Ce != W.y2 > Ce && Ie < (W.x2 - W.x1) * (Ce - W.y1) / (W.y2 - W.y1) + W.x1;
          G && (ze += W.y1 < W.y2 ? 1 : -1);
        }
        return ze !== 0;
      }
    }
    function _(oe, le, k, X, fe, te, j, Ae, Y, pe) {
      te === void 0 && (te = 1), Ae === void 0 && (Ae = 0), Y === void 0 && (Y = 0), pe === void 0 && (pe = 0), g(oe, le, k, X, fe, te, j, null, Ae, Y, pe);
    }
    function g(oe, le, k, X, fe, te, j, Ae, Y, pe, me) {
      te === void 0 && (te = 1), Y === void 0 && (Y = 0), pe === void 0 && (pe = 0), me === void 0 && (me = 0);
      for (var re = m(oe, le, k, X, fe, te), ye = new Uint8Array(re.length * 4), ae = 0; ae < re.length; ae++)
        ye[ae * 4 + me] = re[ae];
      f(j, ye, Y, pe, oe, le, 1 << 3 - me, Ae);
    }
    function A(oe, le, k, X, fe, te) {
      var j = fe - k, Ae = te - X, Y = j * j + Ae * Ae, pe = Y ? Math.max(0, Math.min(1, ((oe - k) * j + (le - X) * Ae) / Y)) : 0, me = oe - (k + pe * j), re = le - (X + pe * Ae);
      return me * me + re * re;
    }
    var v = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: m,
      generateIntoCanvas: _,
      generateIntoFramebuffer: g
    }), y = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", w = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", E = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", I = new Float32Array([0, 0, 2, 0, 0, 2]), C = null, B = !1, T = {}, S = /* @__PURE__ */ new WeakMap();
    function D(oe) {
      if (!B && !V(oe))
        throw new Error("WebGL generation not supported");
    }
    function R(oe, le, k, X, fe, te, j) {
      if (te === void 0 && (te = 1), j === void 0 && (j = null), !j && (j = C, !j)) {
        var Ae = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Ae)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        j = C = Ae.getContext("webgl", { depth: !1 });
      }
      D(j);
      var Y = new Uint8Array(oe * le * 4);
      u(j, function(ye) {
        var ae = ye.gl, De = ye.withTexture, Ee = ye.withTextureFramebuffer;
        De("readable", function(Ie, Ce) {
          ae.texImage2D(ae.TEXTURE_2D, 0, ae.RGBA, oe, le, 0, ae.RGBA, ae.UNSIGNED_BYTE, null), Ee(Ie, Ce, function(ze) {
            L(
              oe,
              le,
              k,
              X,
              fe,
              te,
              ae,
              ze,
              0,
              0,
              0
              // red channel
            ), ae.readPixels(0, 0, oe, le, ae.RGBA, ae.UNSIGNED_BYTE, Y);
          });
        });
      });
      for (var pe = new Uint8Array(oe * le), me = 0, re = 0; me < Y.length; me += 4)
        pe[re++] = Y[me];
      return pe;
    }
    function P(oe, le, k, X, fe, te, j, Ae, Y, pe) {
      te === void 0 && (te = 1), Ae === void 0 && (Ae = 0), Y === void 0 && (Y = 0), pe === void 0 && (pe = 0), L(oe, le, k, X, fe, te, j, null, Ae, Y, pe);
    }
    function L(oe, le, k, X, fe, te, j, Ae, Y, pe, me) {
      te === void 0 && (te = 1), Y === void 0 && (Y = 0), pe === void 0 && (pe = 0), me === void 0 && (me = 0), D(j);
      var re = [];
      r(k, function(ye, ae, De, Ee) {
        re.push(ye, ae, De, Ee);
      }), re = new Float32Array(re), u(j, function(ye) {
        var ae = ye.gl, De = ye.isWebGL2, Ee = ye.getExtension, Ie = ye.withProgram, Ce = ye.withTexture, ze = ye.withTextureFramebuffer, Fe = ye.handleContextLoss;
        if (Ce("rawDistances", function(W, G) {
          (oe !== W._lastWidth || le !== W._lastHeight) && ae.texImage2D(
            ae.TEXTURE_2D,
            0,
            ae.RGBA,
            W._lastWidth = oe,
            W._lastHeight = le,
            0,
            ae.RGBA,
            ae.UNSIGNED_BYTE,
            null
          ), Ie("main", y, w, function(se) {
            var _e = se.setAttribute, ve = se.setUniform, ue = !De && Ee("ANGLE_instanced_arrays"), Te = !De && Ee("EXT_blend_minmax");
            _e("aUV", 2, ae.STATIC_DRAW, 0, I), _e("aLineSegment", 4, ae.DYNAMIC_DRAW, 1, re), ve.apply(void 0, ["4f", "uGlyphBounds"].concat(X)), ve("1f", "uMaxDistance", fe), ve("1f", "uExponent", te), ze(W, G, function(Ge) {
              ae.enable(ae.BLEND), ae.colorMask(!0, !0, !0, !0), ae.viewport(0, 0, oe, le), ae.scissor(0, 0, oe, le), ae.blendFunc(ae.ONE, ae.ONE), ae.blendEquationSeparate(ae.FUNC_ADD, De ? ae.MAX : Te.MAX_EXT), ae.clear(ae.COLOR_BUFFER_BIT), De ? ae.drawArraysInstanced(ae.TRIANGLES, 0, 3, re.length / 4) : ue.drawArraysInstancedANGLE(ae.TRIANGLES, 0, 3, re.length / 4);
            });
          }), Ie("post", a, E, function(se) {
            se.setAttribute("aUV", 2, ae.STATIC_DRAW, 0, I), se.setUniform("1i", "tex", G), ae.bindFramebuffer(ae.FRAMEBUFFER, Ae), ae.disable(ae.BLEND), ae.colorMask(me === 0, me === 1, me === 2, me === 3), ae.viewport(Y, pe, oe, le), ae.scissor(Y, pe, oe, le), ae.drawArrays(ae.TRIANGLES, 0, 3);
          });
        }), ae.isContextLost())
          throw Fe(), new Error("webgl context lost");
      });
    }
    function V(oe) {
      var le = !oe || oe === C ? T : oe.canvas || oe, k = S.get(le);
      if (k === void 0) {
        B = !0;
        var X = null;
        try {
          var fe = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], te = R(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            oe
          );
          k = te && fe.length === te.length && te.every(function(j, Ae) {
            return j === fe[Ae];
          }), k || (X = "bad trial run results", console.info(fe, te));
        } catch (j) {
          k = !1, X = j.message;
        }
        X && console.warn("WebGL SDF generation not supported:", X), B = !1, S.set(le, k);
      }
      return k;
    }
    var U = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: R,
      generateIntoCanvas: P,
      generateIntoFramebuffer: L,
      isSupported: V
    });
    function Q(oe, le, k, X, fe, te) {
      fe === void 0 && (fe = Math.max(X[2] - X[0], X[3] - X[1]) / 2), te === void 0 && (te = 1);
      try {
        return R.apply(U, arguments);
      } catch (j) {
        return console.info("WebGL SDF generation failed, falling back to JS", j), m.apply(v, arguments);
      }
    }
    function q(oe, le, k, X, fe, te, j, Ae, Y, pe) {
      fe === void 0 && (fe = Math.max(X[2] - X[0], X[3] - X[1]) / 2), te === void 0 && (te = 1), Ae === void 0 && (Ae = 0), Y === void 0 && (Y = 0), pe === void 0 && (pe = 0);
      try {
        return P.apply(U, arguments);
      } catch (me) {
        return console.info("WebGL SDF generation failed, falling back to JS", me), _.apply(v, arguments);
      }
    }
    return e.forEachPathCommand = i, e.generate = Q, e.generateIntoCanvas = q, e.javascript = v, e.pathToLineSegments = r, e.webgl = U, e.webglUtils = d, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function TE() {
  var s = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, n = {}, i = {};
    n.L = 1, i[1] = "L", Object.keys(t).forEach(function(Fe, W) {
      n[Fe] = 1 << W + 1, i[n[Fe]] = Fe;
    }), Object.freeze(n);
    var r = n.LRI | n.RLI | n.FSI, a = n.L | n.R | n.AL, o = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI, l = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF, c = n.S | n.WS | n.B | r | n.PDI | l, u = null;
    function f() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var Fe = function(G) {
          if (t.hasOwnProperty(G)) {
            var se = 0;
            t[G].split(",").forEach(function(_e) {
              var ve = _e.split("+"), ue = ve[0], Te = ve[1];
              ue = parseInt(ue, 36), Te = Te ? parseInt(Te, 36) : 0, u.set(se += ue, n[G]);
              for (var Ge = 0; Ge < Te; Ge++)
                u.set(++se, n[G]);
            });
          }
        };
        for (var W in t)
          Fe(W);
      }
    }
    function h(Fe) {
      return f(), u.get(Fe.codePointAt(0)) || n.L;
    }
    function d(Fe) {
      return i[h(Fe)];
    }
    var m = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function _(Fe, W) {
      var G = 36, se = 0, _e = /* @__PURE__ */ new Map(), ve = W && /* @__PURE__ */ new Map(), ue;
      return Fe.split(",").forEach(function Te(Ge) {
        if (Ge.indexOf("+") !== -1)
          for (var Pe = +Ge; Pe--; )
            Te(ue);
        else {
          ue = Ge;
          var he = Ge.split(">"), Se = he[0], Ve = he[1];
          Se = String.fromCodePoint(se += parseInt(Se, G)), Ve = String.fromCodePoint(se += parseInt(Ve, G)), _e.set(Se, Ve), W && ve.set(Ve, Se);
        }
      }), { map: _e, reverseMap: ve };
    }
    var g, A, v;
    function y() {
      if (!g) {
        var Fe = _(m.pairs, !0), W = Fe.map, G = Fe.reverseMap;
        g = W, A = G, v = _(m.canonical, !1).map;
      }
    }
    function w(Fe) {
      return y(), g.get(Fe) || null;
    }
    function E(Fe) {
      return y(), A.get(Fe) || null;
    }
    function I(Fe) {
      return y(), v.get(Fe) || null;
    }
    var C = n.L, B = n.R, T = n.EN, S = n.ES, D = n.ET, R = n.AN, P = n.CS, L = n.B, V = n.S, U = n.ON, Q = n.BN, q = n.NSM, oe = n.AL, le = n.LRO, k = n.RLO, X = n.LRE, fe = n.RLE, te = n.PDF, j = n.LRI, Ae = n.RLI, Y = n.FSI, pe = n.PDI;
    function me(Fe, W) {
      for (var G = 125, se = new Uint32Array(Fe.length), _e = 0; _e < Fe.length; _e++)
        se[_e] = h(Fe[_e]);
      var ve = /* @__PURE__ */ new Map();
      function ue(Si, nr) {
        var gi = se[Si];
        se[Si] = nr, ve.set(gi, ve.get(gi) - 1), gi & o && ve.set(o, ve.get(o) - 1), ve.set(nr, (ve.get(nr) || 0) + 1), nr & o && ve.set(o, (ve.get(o) || 0) + 1);
      }
      for (var Te = new Uint8Array(Fe.length), Ge = /* @__PURE__ */ new Map(), Pe = [], he = null, Se = 0; Se < Fe.length; Se++)
        he || Pe.push(he = {
          start: Se,
          end: Fe.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: W === "rtl" ? 1 : W === "ltr" ? 0 : Yu(Se, !1)
        }), se[Se] & L && (he.end = Se, he = null);
      for (var Ve = fe | X | k | le | r | pe | te | L, Ye = function(Si) {
        return Si + (Si & 1 ? 1 : 2);
      }, $e = function(Si) {
        return Si + (Si & 1 ? 2 : 1);
      }, Ne = 0; Ne < Pe.length; Ne++) {
        he = Pe[Ne];
        var He = [{
          _level: he.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Qe = void 0, Ze = 0, Ke = 0, $ = 0;
        ve.clear();
        for (var ge = he.start; ge <= he.end; ge++) {
          var be = se[ge];
          if (Qe = He[He.length - 1], ve.set(be, (ve.get(be) || 0) + 1), be & o && ve.set(o, (ve.get(o) || 0) + 1), be & Ve)
            if (be & (fe | X)) {
              Te[ge] = Qe._level;
              var Ue = (be === fe ? $e : Ye)(Qe._level);
              Ue <= G && !Ze && !Ke ? He.push({
                _level: Ue,
                _override: 0,
                _isolate: 0
              }) : Ze || Ke++;
            } else if (be & (k | le)) {
              Te[ge] = Qe._level;
              var je = (be === k ? $e : Ye)(Qe._level);
              je <= G && !Ze && !Ke ? He.push({
                _level: je,
                _override: be & k ? B : C,
                _isolate: 0
              }) : Ze || Ke++;
            } else if (be & r) {
              be & Y && (be = Yu(ge + 1, !0) === 1 ? Ae : j), Te[ge] = Qe._level, Qe._override && ue(ge, Qe._override);
              var it = (be === Ae ? $e : Ye)(Qe._level);
              it <= G && Ze === 0 && Ke === 0 ? ($++, He.push({
                _level: it,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: ge
              })) : Ze++;
            } else if (be & pe) {
              if (Ze > 0)
                Ze--;
              else if ($ > 0) {
                for (Ke = 0; !He[He.length - 1]._isolate; )
                  He.pop();
                var nt = He[He.length - 1]._isolInitIndex;
                nt != null && (Ge.set(nt, ge), Ge.set(ge, nt)), He.pop(), $--;
              }
              Qe = He[He.length - 1], Te[ge] = Qe._level, Qe._override && ue(ge, Qe._override);
            } else
              be & te ? (Ze === 0 && (Ke > 0 ? Ke-- : !Qe._isolate && He.length > 1 && (He.pop(), Qe = He[He.length - 1])), Te[ge] = Qe._level) : be & L && (Te[ge] = he.level);
          else
            Te[ge] = Qe._level, Qe._override && be !== Q && ue(ge, Qe._override);
        }
        for (var mt = [], bt = null, Xe = he.start; Xe <= he.end; Xe++) {
          var dt = se[Xe];
          if (!(dt & l)) {
            var at = Te[Xe], At = dt & r, It = dt === pe;
            bt && at === bt._level ? (bt._end = Xe, bt._endsWithIsolInit = At) : mt.push(bt = {
              _start: Xe,
              _end: Xe,
              _level: at,
              _startsWithPDI: It,
              _endsWithIsolInit: At
            });
          }
        }
        for (var Qt = [], Tt = 0; Tt < mt.length; Tt++) {
          var $t = mt[Tt];
          if (!$t._startsWithPDI || $t._startsWithPDI && !Ge.has($t._start)) {
            for (var Jt = [bt = $t], on = void 0; bt && bt._endsWithIsolInit && (on = Ge.get(bt._end)) != null; )
              for (var Wt = Tt + 1; Wt < mt.length; Wt++)
                if (mt[Wt]._start === on) {
                  Jt.push(bt = mt[Wt]);
                  break;
                }
            for (var an = [], Mn = 0; Mn < Jt.length; Mn++)
              for (var Zn = Jt[Mn], ie = Zn._start; ie <= Zn._end; ie++)
                an.push(ie);
            for (var Be = Te[an[0]], Oe = he.level, Le = an[0] - 1; Le >= 0; Le--)
              if (!(se[Le] & l)) {
                Oe = Te[Le];
                break;
              }
            var F = an[an.length - 1], ce = Te[F], ct = he.level;
            if (!(se[F] & r)) {
              for (var ut = F + 1; ut <= he.end; ut++)
                if (!(se[ut] & l)) {
                  ct = Te[ut];
                  break;
                }
            }
            Qt.push({
              _seqIndices: an,
              _sosType: Math.max(Oe, Be) % 2 ? B : C,
              _eosType: Math.max(ct, ce) % 2 ? B : C
            });
          }
        }
        for (var pt = 0; pt < Qt.length; pt++) {
          var Bt = Qt[pt], qe = Bt._seqIndices, Lt = Bt._sosType, pn = Bt._eosType, mn = Te[qe[0]] & 1 ? B : C;
          if (ve.get(q))
            for (var _n = 0; _n < qe.length; _n++) {
              var pi = qe[_n];
              if (se[pi] & q) {
                for (var zt = Lt, vt = _n - 1; vt >= 0; vt--)
                  if (!(se[qe[vt]] & l)) {
                    zt = se[qe[vt]];
                    break;
                  }
                ue(pi, zt & (r | pe) ? U : zt);
              }
            }
          if (ve.get(T))
            for (var Ei = 0; Ei < qe.length; Ei++) {
              var sn = qe[Ei];
              if (se[sn] & T)
                for (var li = Ei - 1; li >= -1; li--) {
                  var Hr = li === -1 ? Lt : se[qe[li]];
                  if (Hr & a) {
                    Hr === oe && ue(sn, R);
                    break;
                  }
                }
            }
          if (ve.get(oe))
            for (var ci = 0; ci < qe.length; ci++) {
              var Cr = qe[ci];
              se[Cr] & oe && ue(Cr, B);
            }
          if (ve.get(S) || ve.get(P))
            for (var gn = 1; gn < qe.length - 1; gn++) {
              var ui = qe[gn];
              if (se[ui] & (S | P)) {
                for (var Oi = 0, Nn = 0, fr = gn - 1; fr >= 0 && (Oi = se[qe[fr]], !!(Oi & l)); fr--)
                  ;
                for (var jr = gn + 1; jr < qe.length && (Nn = se[qe[jr]], !!(Nn & l)); jr++)
                  ;
                Oi === Nn && (se[ui] === S ? Oi === T : Oi & (T | R)) && ue(ui, Oi);
              }
            }
          if (ve.get(T))
            for (var ei = 0; ei < qe.length; ei++) {
              var Ma = qe[ei];
              if (se[Ma] & T) {
                for (var fs = ei - 1; fs >= 0 && se[qe[fs]] & (D | l); fs--)
                  ue(qe[fs], T);
                for (ei++; ei < qe.length && se[qe[ei]] & (D | l | T); ei++)
                  se[qe[ei]] !== T && ue(qe[ei], T);
              }
            }
          if (ve.get(D) || ve.get(S) || ve.get(P))
            for (var Wr = 0; Wr < qe.length; Wr++) {
              var Eo = qe[Wr];
              if (se[Eo] & (D | S | P)) {
                ue(Eo, U);
                for (var Zi = Wr - 1; Zi >= 0 && se[qe[Zi]] & l; Zi--)
                  ue(qe[Zi], U);
                for (var mi = Wr + 1; mi < qe.length && se[qe[mi]] & l; mi++)
                  ue(qe[mi], U);
              }
            }
          if (ve.get(T))
            for (var er = 0, Sr = Lt; er < qe.length; er++) {
              var Fs = qe[er], Mr = se[Fs];
              Mr & T ? Sr === C && ue(Fs, C) : Mr & a && (Sr = Mr);
            }
          if (ve.get(o)) {
            var hr = B | T | R, Co = hr | C, tr = [];
            {
              for (var dr = [], Ir = 0; Ir < qe.length; Ir++)
                if (se[qe[Ir]] & o) {
                  var Tr = Fe[qe[Ir]], Os = void 0;
                  if (w(Tr) !== null)
                    if (dr.length < 63)
                      dr.push({ char: Tr, seqIndex: Ir });
                    else
                      break;
                  else if ((Os = E(Tr)) !== null)
                    for (var qr = dr.length - 1; qr >= 0; qr--) {
                      var Br = dr[qr].char;
                      if (Br === Os || Br === E(I(Tr)) || w(I(Br)) === Tr) {
                        tr.push([dr[qr].seqIndex, Ir]), dr.length = qr;
                        break;
                      }
                    }
                }
              tr.sort(function(Si, nr) {
                return Si[0] - nr[0];
              });
            }
            for (var Ns = 0; Ns < tr.length; Ns++) {
              for (var Gs = tr[Ns], Xr = Gs[0], Qs = Gs[1], So = !1, Ci = 0, ac = Xr + 1; ac < Qs; ac++) {
                var ju = qe[ac];
                if (se[ju] & Co) {
                  So = !0;
                  var Ia = se[ju] & hr ? B : C;
                  if (Ia === mn) {
                    Ci = Ia;
                    break;
                  }
                }
              }
              if (So && !Ci) {
                Ci = Lt;
                for (var hs = Xr - 1; hs >= 0; hs--) {
                  var Wu = qe[hs];
                  if (se[Wu] & Co) {
                    var zs = se[Wu] & hr ? B : C;
                    zs !== mn ? Ci = zs : Ci = mn;
                    break;
                  }
                }
              }
              if (Ci) {
                if (se[qe[Xr]] = se[qe[Qs]] = Ci, Ci !== mn) {
                  for (var Mo = Xr + 1; Mo < qe.length; Mo++)
                    if (!(se[qe[Mo]] & l)) {
                      h(Fe[qe[Mo]]) & q && (se[qe[Mo]] = Ci);
                      break;
                    }
                }
                if (Ci !== mn) {
                  for (var ds = Qs + 1; ds < qe.length; ds++)
                    if (!(se[qe[ds]] & l)) {
                      h(Fe[qe[ds]]) & q && (se[qe[ds]] = Ci);
                      break;
                    }
                }
              }
            }
            for (var Pr = 0; Pr < qe.length; Pr++)
              if (se[qe[Pr]] & o) {
                for (var qu = Pr, lc = Pr, cc = Lt, Io = Pr - 1; Io >= 0; Io--)
                  if (se[qe[Io]] & l)
                    qu = Io;
                  else {
                    cc = se[qe[Io]] & hr ? B : C;
                    break;
                  }
                for (var Xu = pn, To = Pr + 1; To < qe.length; To++)
                  if (se[qe[To]] & (o | l))
                    lc = To;
                  else {
                    Xu = se[qe[To]] & hr ? B : C;
                    break;
                  }
                for (var uc = qu; uc <= lc; uc++)
                  se[qe[uc]] = cc === Xu ? cc : mn;
                Pr = lc;
              }
          }
        }
        for (var Ni = he.start; Ni <= he.end; Ni++) {
          var jd = Te[Ni], Ta = se[Ni];
          if (jd & 1 ? Ta & (C | T | R) && Te[Ni]++ : Ta & B ? Te[Ni]++ : Ta & (R | T) && (Te[Ni] += 2), Ta & l && (Te[Ni] = Ni === 0 ? he.level : Te[Ni - 1]), Ni === he.end || h(Fe[Ni]) & (V | L))
            for (var Ba = Ni; Ba >= 0 && h(Fe[Ba]) & c; Ba--)
              Te[Ba] = he.level;
        }
      }
      return {
        levels: Te,
        paragraphs: Pe
      };
      function Yu(Si, nr) {
        for (var gi = Si; gi < Fe.length; gi++) {
          var Yr = se[gi];
          if (Yr & (B | oe))
            return 1;
          if (Yr & (L | C) || nr && Yr === pe)
            return 0;
          if (Yr & r) {
            var Ku = Wd(gi);
            gi = Ku === -1 ? Fe.length : Ku;
          }
        }
        return 0;
      }
      function Wd(Si) {
        for (var nr = 1, gi = Si + 1; gi < Fe.length; gi++) {
          var Yr = se[gi];
          if (Yr & L)
            break;
          if (Yr & pe) {
            if (--nr === 0)
              return gi;
          } else
            Yr & r && nr++;
        }
        return -1;
      }
    }
    var re = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", ye;
    function ae() {
      if (!ye) {
        var Fe = _(re, !0), W = Fe.map, G = Fe.reverseMap;
        G.forEach(function(se, _e) {
          W.set(_e, se);
        }), ye = W;
      }
    }
    function De(Fe) {
      return ae(), ye.get(Fe) || null;
    }
    function Ee(Fe, W, G, se) {
      var _e = Fe.length;
      G = Math.max(0, G == null ? 0 : +G), se = Math.min(_e - 1, se == null ? _e - 1 : +se);
      for (var ve = /* @__PURE__ */ new Map(), ue = G; ue <= se; ue++)
        if (W[ue] & 1) {
          var Te = De(Fe[ue]);
          Te !== null && ve.set(ue, Te);
        }
      return ve;
    }
    function Ie(Fe, W, G, se) {
      var _e = Fe.length;
      G = Math.max(0, G == null ? 0 : +G), se = Math.min(_e - 1, se == null ? _e - 1 : +se);
      var ve = [];
      return W.paragraphs.forEach(function(ue) {
        var Te = Math.max(G, ue.start), Ge = Math.min(se, ue.end);
        if (Te < Ge) {
          for (var Pe = W.levels.slice(Te, Ge + 1), he = Ge; he >= Te && h(Fe[he]) & c; he--)
            Pe[he] = ue.level;
          for (var Se = ue.level, Ve = 1 / 0, Ye = 0; Ye < Pe.length; Ye++) {
            var $e = Pe[Ye];
            $e > Se && (Se = $e), $e < Ve && (Ve = $e | 1);
          }
          for (var Ne = Se; Ne >= Ve; Ne--)
            for (var He = 0; He < Pe.length; He++)
              if (Pe[He] >= Ne) {
                for (var Qe = He; He + 1 < Pe.length && Pe[He + 1] >= Ne; )
                  He++;
                He > Qe && ve.push([Qe + Te, He + Te]);
              }
        }
      }), ve;
    }
    function Ce(Fe, W, G, se) {
      var _e = ze(Fe, W, G, se), ve = [].concat(Fe);
      return _e.forEach(function(ue, Te) {
        ve[Te] = (W.levels[ue] & 1 ? De(Fe[ue]) : null) || Fe[ue];
      }), ve.join("");
    }
    function ze(Fe, W, G, se) {
      for (var _e = Ie(Fe, W, G, se), ve = [], ue = 0; ue < Fe.length; ue++)
        ve[ue] = ue;
      return _e.forEach(function(Te) {
        for (var Ge = Te[0], Pe = Te[1], he = ve.slice(Ge, Pe + 1), Se = he.length; Se--; )
          ve[Pe - Se] = he[Se];
      }), ve;
    }
    return e.closingToOpeningBracket = E, e.getBidiCharType = h, e.getBidiCharTypeName = d, e.getCanonicalBracket = I, e.getEmbeddingLevels = me, e.getMirroredCharacter = De, e.getMirroredCharactersMap = Ee, e.getReorderSegments = Ie, e.getReorderedIndices = ze, e.getReorderedString = Ce, e.openingToClosingBracket = w, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const BE = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Hg(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(n, i) {
    let r = gt[i];
    return r ? Hg(r) : n;
  }
  return s.replace(e, t);
}
const _i = [];
for (let s = 0; s < 256; s++)
  _i[s] = (s < 16 ? "0" : "") + s.toString(16);
function P4() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (_i[s & 255] + _i[s >> 8 & 255] + _i[s >> 16 & 255] + _i[s >> 24 & 255] + "-" + _i[e & 255] + _i[e >> 8 & 255] + "-" + _i[e >> 16 & 15 | 64] + _i[e >> 24 & 255] + "-" + _i[t & 63 | 128] + _i[t >> 8 & 255] + "-" + _i[t >> 16 & 255] + _i[t >> 24 & 255] + _i[n & 255] + _i[n >> 8 & 255] + _i[n >> 16 & 255] + _i[n >> 24 & 255]).toUpperCase();
}
const Ko = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let n = arguments[e];
    if (n)
      for (let i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (s[i] = n[i]);
  }
  return s;
}, R4 = Date.now(), cy = /* @__PURE__ */ new WeakMap(), uy = /* @__PURE__ */ new Map();
let D4 = 1e10;
function jg(s, e) {
  const t = F4(e);
  let n = cy.get(s);
  if (n || cy.set(s, n = /* @__PURE__ */ Object.create(null)), n[t])
    return new n[t]();
  const i = `_onBeforeCompile${t}`, r = function(c, u) {
    s.onBeforeCompile.call(this, c, u);
    const f = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let h = uy[f];
    if (!h) {
      const d = L4(this, c, e, t);
      h = uy[f] = d;
    }
    c.vertexShader = h.vertexShader, c.fragmentShader = h.fragmentShader, Ko(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - R4;
      }
    }), this[i] && this[i](c);
  }, a = function() {
    return o(e.chained ? s : s.clone());
  }, o = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: D4++ }), u.uuid = P4(), u.uniforms = Ko({}, c.uniforms, e.uniforms), u.defines = Ko({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = Ko({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[i] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return s.copy.call(this, c), !s.isShaderMaterial && !s.isDerivedMaterial && (Ko(this.extensions, c.extensions), Ko(this.defines, c.defines), Ko(this.uniforms, ql.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new s.constructor();
        return o(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = jg(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Ea({ depthPacking: jl }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = jg(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Kl(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return n[t] = a, new a();
}
function L4(s, { vertexShader: e, fragmentShader: t }, n, i) {
  let {
    vertexDefs: r,
    vertexMainIntro: a,
    vertexMainOutro: o,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: f,
    fragmentColorTransform: h,
    customRewriter: d,
    timeUniform: m
  } = n;
  if (r = r || "", a = a || "", o = o || "", c = c || "", u = u || "", f = f || "", (l || d) && (e = Hg(e)), (h || d) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = Hg(t)), d) {
    let _ = d({ vertexShader: e, fragmentShader: t });
    e = _.vertexShader, t = _.fragmentShader;
  }
  if (h) {
    let _ = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (_.push(g), "")
    ), f = `${h}
${_.join(`
`)}
${f}`;
  }
  if (m) {
    const _ = `
uniform float ${m};
`;
    r = _ + r, c = _ + c;
  }
  return l && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, r = `${r}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, a = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (_, g, A, v) => /\battribute\s+vec[23]\s+$/.test(v.substr(0, A)) ? g : `troika_${g}_${i}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = fy(e, i, r, a, o), t = fy(t, i, c, u, f), {
    vertexShader: e,
    fragmentShader: t
  };
}
function fy(s, e, t, n, i) {
  return (n || i || t) && (s = s.replace(
    BE,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`), s;
}
function k4(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let U4 = 0;
const hy = /* @__PURE__ */ new Map();
function F4(s) {
  const e = JSON.stringify(s, k4);
  let t = hy.get(e);
  return t == null && hy.set(e, t = ++U4), t;
}
function O4(s, e, t) {
  const {
    defaultFontURL: n
  } = t, i = /* @__PURE__ */ Object.create(null), r = 1 / 0, a = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, o = "[^\\S\\u00A0]", l = new RegExp(`${o}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function c(v, y) {
    function w() {
      const E = (I) => {
        console.error(`Failure loading font ${v}${v === n ? "" : "; trying fallback"}`, I), v !== n && (v = n, w());
      };
      try {
        const I = new XMLHttpRequest();
        I.open("get", v, !0), I.responseType = "arraybuffer", I.onload = function() {
          if (I.status >= 400)
            E(new Error(I.statusText));
          else if (I.status > 0)
            try {
              const C = s(I.response);
              y(C);
            } catch (C) {
              E(C);
            }
        }, I.onerror = E, I.send();
      } catch (I) {
        E(I);
      }
    }
    w();
  }
  function u(v, y) {
    v || (v = n);
    let w = i[v];
    w ? w.pending ? w.pending.push(y) : y(w) : (i[v] = { pending: [y] }, c(v, (E) => {
      let I = i[v].pending;
      i[v] = E, I.forEach((C) => C(E));
    }));
  }
  function f({
    text: v = "",
    font: y = n,
    sdfGlyphSize: w = 64,
    fontSize: E = 1,
    letterSpacing: I = 0,
    lineHeight: C = "normal",
    maxWidth: B = r,
    direction: T,
    textAlign: S = "left",
    textIndent: D = 0,
    whiteSpace: R = "normal",
    overflowWrap: P = "normal",
    anchorX: L = 0,
    anchorY: V = 0,
    includeCaretPositions: U = !1,
    chunkedBoundsSize: Q = 8192,
    colorRanges: q = null
  }, oe, le = !1) {
    const k = _(), X = { fontLoad: 0, typesetting: 0 };
    v.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), v = v.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), E = +E, I = +I, B = +B, C = C || "normal", D = +D, u(y, (fe) => {
      const te = isFinite(B);
      let j = null, Ae = null, Y = null, pe = null, me = null, re = null, ye = null, ae = 0, De = 0, Ee = R !== "nowrap";
      const { ascender: Ie, descender: Ce, unitsPerEm: ze, lineGap: Fe, capHeight: W, xHeight: G } = fe;
      X.fontLoad = _() - k;
      const se = _(), _e = E / ze;
      C === "normal" && (C = (Ie - Ce + Fe) / ze), C = C * E;
      const ve = (C - (Ie - Ce) * _e) / 2, ue = -(Ie * _e + ve), Te = Math.min(C, (Ie - Ce) * _e), Ge = (Ie + Ce) / 2 * _e - Te / 2;
      let Pe = D, he = new g();
      const Se = [he];
      fe.forEachGlyph(v, E, I, ($e, Ne, He) => {
        const Qe = v.charAt(He), Ze = $e.advanceWidth * _e, Ke = he.count;
        let $;
        if ("isEmpty" in $e || ($e.isWhitespace = !!Qe && new RegExp(o).test(Qe), $e.canBreakAfter = !!Qe && l.test(Qe), $e.isEmpty = $e.xMin === $e.xMax || $e.yMin === $e.yMax || a.test(Qe)), !$e.isWhitespace && !$e.isEmpty && De++, Ee && te && !$e.isWhitespace && Ne + Ze + Pe > B && Ke) {
          if (he.glyphAt(Ke - 1).glyphObj.canBreakAfter)
            $ = new g(), Pe = -Ne;
          else
            for (let be = Ke; be--; )
              if (be === 0 && P === "break-word") {
                $ = new g(), Pe = -Ne;
                break;
              } else if (he.glyphAt(be).glyphObj.canBreakAfter) {
                $ = he.splitAt(be + 1);
                const Ue = $.glyphAt(0).x;
                Pe -= Ue;
                for (let je = $.count; je--; )
                  $.glyphAt(je).x -= Ue;
                break;
              }
          $ && (he.isSoftWrapped = !0, he = $, Se.push(he), ae = B);
        }
        let ge = he.glyphAt(he.count);
        ge.glyphObj = $e, ge.x = Ne + Pe, ge.width = Ze, ge.charIndex = He, Qe === `
` && (he = new g(), Se.push(he), Pe = -(Ne + Ze + I * E) + D);
      }), Se.forEach(($e) => {
        for (let Ne = $e.count; Ne--; ) {
          let { glyphObj: He, x: Qe, width: Ze } = $e.glyphAt(Ne);
          if (!He.isWhitespace) {
            $e.width = Qe + Ze, $e.width > ae && (ae = $e.width);
            return;
          }
        }
      });
      let Ve = 0, Ye = 0;
      if (L && (typeof L == "number" ? Ve = -L : typeof L == "string" && (Ve = -ae * (L === "left" ? 0 : L === "center" ? 0.5 : L === "right" ? 1 : d(L)))), V) {
        if (typeof V == "number")
          Ye = -V;
        else if (typeof V == "string") {
          let $e = Se.length * C;
          Ye = V === "top" ? 0 : V === "top-baseline" ? -ue : V === "top-cap" ? -ue - W * _e : V === "top-ex" ? -ue - G * _e : V === "middle" ? $e / 2 : V === "bottom" ? $e : V === "bottom-baseline" ? $e - ve + Ce * _e : d(V) * $e;
        }
      }
      if (!le) {
        const $e = e.getEmbeddingLevels(v, T);
        j = new Uint16Array(De), Ae = new Float32Array(De * 2), Y = {}, re = [r, r, -r, -r], ye = [];
        let Ne = ue;
        U && (me = new Float32Array(v.length * 3)), q && (pe = new Uint8Array(De * 3));
        let He = 0, Qe = -1, Ze = -1, Ke, $;
        if (Se.forEach((ge, be) => {
          let { count: Ue, width: je } = ge;
          if (Ue > 0) {
            let it = 0;
            for (let at = Ue; at-- && ge.glyphAt(at).glyphObj.isWhitespace; )
              it++;
            let nt = 0, mt = 0;
            if (S === "center")
              nt = (ae - je) / 2;
            else if (S === "right")
              nt = ae - je;
            else if (S === "justify" && ge.isSoftWrapped) {
              let at = 0;
              for (let At = Ue - it; At--; )
                ge.glyphAt(At).glyphObj.isWhitespace && at++;
              mt = (ae - je) / at;
            }
            if (mt || nt) {
              let at = 0;
              for (let At = 0; At < Ue; At++) {
                let It = ge.glyphAt(At);
                const Qt = It.glyphObj;
                It.x += nt + at, mt !== 0 && Qt.isWhitespace && At < Ue - it && (at += mt, It.width += mt);
              }
            }
            const bt = e.getReorderSegments(
              v,
              $e,
              ge.glyphAt(0).charIndex,
              ge.glyphAt(ge.count - 1).charIndex
            );
            for (let at = 0; at < bt.length; at++) {
              const [At, It] = bt[at];
              let Qt = 1 / 0, Tt = -1 / 0;
              for (let $t = 0; $t < Ue; $t++)
                if (ge.glyphAt($t).charIndex >= At) {
                  let Jt = $t, on = $t;
                  for (; on < Ue; on++) {
                    let Wt = ge.glyphAt(on);
                    if (Wt.charIndex > It)
                      break;
                    on < Ue - it && (Qt = Math.min(Qt, Wt.x), Tt = Math.max(Tt, Wt.x + Wt.width));
                  }
                  for (let Wt = Jt; Wt < on; Wt++) {
                    const an = ge.glyphAt(Wt);
                    an.x = Tt - (an.x + an.width - Qt);
                  }
                  break;
                }
            }
            let Xe;
            const dt = (at) => Xe = at;
            for (let at = 0; at < Ue; at++) {
              let At = ge.glyphAt(at);
              Xe = At.glyphObj;
              const It = Xe.index, Qt = $e.levels[At.charIndex] & 1;
              if (Qt) {
                const Tt = e.getMirroredCharacter(v[At.charIndex]);
                Tt && fe.forEachGlyph(Tt, 0, 0, dt);
              }
              if (U) {
                const { charIndex: Tt } = At, $t = At.x + Ve, Jt = At.x + At.width + Ve;
                me[Tt * 3] = Qt ? Jt : $t, me[Tt * 3 + 1] = Qt ? $t : Jt, me[Tt * 3 + 2] = Ne + Ge + Ye;
                const on = Tt - Qe;
                on > 1 && m(me, Qe, on), Qe = Tt;
              }
              if (q) {
                const { charIndex: Tt } = At;
                for (; Tt > Ze; )
                  Ze++, q.hasOwnProperty(Ze) && ($ = q[Ze]);
              }
              if (!Xe.isWhitespace && !Xe.isEmpty) {
                const Tt = He++;
                Y[It] || (Y[It] = {
                  path: Xe.path,
                  pathBounds: [Xe.xMin, Xe.yMin, Xe.xMax, Xe.yMax]
                });
                const $t = At.x + Ve, Jt = Ne + Ye;
                Ae[Tt * 2] = $t, Ae[Tt * 2 + 1] = Jt;
                const on = $t + Xe.xMin * _e, Wt = Jt + Xe.yMin * _e, an = $t + Xe.xMax * _e, Mn = Jt + Xe.yMax * _e;
                on < re[0] && (re[0] = on), Wt < re[1] && (re[1] = Wt), an > re[2] && (re[2] = an), Mn > re[3] && (re[3] = Mn), Tt % Q === 0 && (Ke = { start: Tt, end: Tt, rect: [r, r, -r, -r] }, ye.push(Ke)), Ke.end++;
                const Zn = Ke.rect;
                if (on < Zn[0] && (Zn[0] = on), Wt < Zn[1] && (Zn[1] = Wt), an > Zn[2] && (Zn[2] = an), Mn > Zn[3] && (Zn[3] = Mn), j[Tt] = It, q) {
                  const ie = Tt * 3;
                  pe[ie] = $ >> 16 & 255, pe[ie + 1] = $ >> 8 & 255, pe[ie + 2] = $ & 255;
                }
              }
            }
          }
          Ne -= C;
        }), me) {
          const ge = v.length - Qe;
          ge > 1 && m(me, Qe, ge);
        }
      }
      X.typesetting = _() - se, oe({
        glyphIds: j,
        //font indices for each glyph
        glyphPositions: Ae,
        //x,y of each glyph's origin in layout
        glyphData: Y,
        //dict holding data about each glyph appearing in the text
        caretPositions: me,
        //startX,endX,bottomY caret positions for each char
        caretHeight: Te,
        //height of cursor from bottom to top
        glyphColors: pe,
        //color for each glyph, if color ranges supplied
        chunkedBounds: ye,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: E,
        //calculated em height
        unitsPerEm: ze,
        //font units per em
        ascender: Ie * _e,
        //font ascender
        descender: Ce * _e,
        //font descender
        capHeight: W * _e,
        //font cap-height
        xHeight: G * _e,
        //font x-height
        lineHeight: C,
        //computed line height
        topBaseline: ue,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          Ve,
          Ye - Se.length * C,
          Ve + ae,
          Ye
        ],
        visibleBounds: re,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: X
      });
    });
  }
  function h(v, y) {
    f(v, (w) => {
      const [E, I, C, B] = w.blockBounds;
      y({
        width: C - E,
        height: B - I
      });
    }, { metricsOnly: !0 });
  }
  function d(v) {
    let y = v.match(/^([\d.]+)%$/), w = y ? parseFloat(y[1]) : NaN;
    return isNaN(w) ? 0 : w / 100;
  }
  function m(v, y, w) {
    const E = v[y * 3], I = v[y * 3 + 1], C = v[y * 3 + 2], B = (I - E) / w;
    for (let T = 0; T < w; T++) {
      const S = (y + T) * 3;
      v[S] = E + B * T, v[S + 1] = E + B * (T + 1), v[S + 2] = C;
    }
  }
  function _() {
    return (self.performance || Date).now();
  }
  function g() {
    this.data = [];
  }
  const A = ["glyphObj", "x", "width", "charIndex"];
  return g.prototype = {
    width: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / A.length);
    },
    glyphAt(v) {
      let y = g.flyweight;
      return y.data = this.data, y.index = v, y;
    },
    splitAt(v) {
      let y = new g();
      return y.data = this.data.splice(v * A.length), y;
    }
  }, g.flyweight = A.reduce((v, y, w, E) => (Object.defineProperty(v, y, {
    get() {
      return this.data[this.index * A.length + w];
    },
    set(I) {
      this.data[this.index * A.length + w] = I;
    }
  }), v), { data: null, index: 0 }), {
    typeset: f,
    measure: h,
    loadFont: u
  };
}
const pa = () => (self.performance || Date).now(), zd = /* @__PURE__ */ Qd();
let dy;
function N4(s, e, t, n, i, r, a, o, l, c, u = !0) {
  return u ? Q4(s, e, t, n, i, r, a, o, l, c).then(
    null,
    (f) => (dy || (console.warn("WebGL SDF generation failed, falling back to JS", f), dy = !0), my(s, e, t, n, i, r, a, o, l, c))
  ) : my(s, e, t, n, i, r, a, o, l, c);
}
const Lh = [], G4 = 5;
let Wg = 0;
function PE() {
  const s = pa();
  for (; Lh.length && pa() - s < G4; )
    Lh.shift()();
  Wg = Lh.length ? setTimeout(PE, 0) : 0;
}
const Q4 = (...s) => new Promise((e, t) => {
  Lh.push(() => {
    const n = pa();
    try {
      zd.webgl.generateIntoCanvas(...s), e({ timing: pa() - n });
    } catch (i) {
      t(i);
    }
  }), Wg || (Wg = setTimeout(PE, 0));
}), z4 = 4, $4 = 2e3, py = {};
let V4 = 0;
function my(s, e, t, n, i, r, a, o, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + V4++ % z4;
  let f = py[u];
  return f || (f = py[u] = {
    workerModule: Hu({
      name: u,
      workerId: u,
      dependencies: [
        Qd,
        pa
      ],
      init(h, d) {
        const m = h().javascript.generate;
        return function(..._) {
          const g = d();
          return {
            textureData: m(..._),
            timing: d() - g
          };
        };
      },
      getTransferables(h) {
        return [h.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), f.requests++, clearTimeout(f.idleTimer), f.workerModule(s, e, t, n, i, r).then(({ textureData: h, timing: d }) => {
    const m = pa(), _ = new Uint8Array(h.length * 4);
    for (let g = 0; g < h.length; g++)
      _[g * 4 + c] = h[g];
    return zd.webglUtils.renderImageData(a, _, o, l, s, e, 1 << 3 - c), d += pa() - m, --f.requests === 0 && (f.idleTimer = setTimeout(() => {
      T4(u);
    }, $4)), { timing: d };
  });
}
function H4(s) {
  s._warm || (zd.webgl.isSupported(s), s._warm = !0);
}
const j4 = zd.webglUtils.resizeWebGLCanvasWithoutClearing;
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function W4() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(i) {
      var r = e._bin, a = new Uint8Array(i);
      if (r.readASCII(a, 0, 4) == "ttcf") {
        var o = 4;
        r.readUshort(a, o), o += 2, r.readUshort(a, o), o += 2;
        var l = r.readUint(a, o);
        o += 4;
        for (var c = [], u = 0; u < l; u++) {
          var f = r.readUint(a, o);
          o += 4, c.push(e._readFont(a, f));
        }
        return c;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(i, r) {
      var a = e._bin, o = r;
      a.readFixed(i, r), r += 4;
      var l = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2;
      for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: i, _offset: o }, f = {}, h = 0; h < l; h++) {
        var d = a.readASCII(i, r, 4);
        r += 4, a.readUint(i, r), r += 4;
        var m = a.readUint(i, r);
        r += 4;
        var _ = a.readUint(i, r);
        r += 4, f[d] = { offset: m, length: _ };
      }
      for (h = 0; h < c.length; h++) {
        var g = c[h];
        f[g] && (u[g.trim()] = e[g.trim()].parse(i, f[g].offset, f[g].length, u));
      }
      return u;
    }, _tabOffset: function(i, r, a) {
      for (var o = e._bin, l = o.readUshort(i, a + 4), c = a + 12, u = 0; u < l; u++) {
        var f = o.readASCII(i, c, 4);
        c += 4, o.readUint(i, c), c += 4;
        var h = o.readUint(i, c);
        if (c += 4, o.readUint(i, c), c += 4, f == r)
          return h;
      }
      return 0;
    } };
    e._bin = { readFixed: function(i, r) {
      return (i[r] << 8 | i[r + 1]) + (i[r + 2] << 8 | i[r + 3]) / 65540;
    }, readF2dot14: function(i, r) {
      return e._bin.readShort(i, r) / 16384;
    }, readInt: function(i, r) {
      return e._bin._view(i).getInt32(r);
    }, readInt8: function(i, r) {
      return e._bin._view(i).getInt8(r);
    }, readShort: function(i, r) {
      return e._bin._view(i).getInt16(r);
    }, readUshort: function(i, r) {
      return e._bin._view(i).getUint16(r);
    }, readUshorts: function(i, r, a) {
      for (var o = [], l = 0; l < a; l++)
        o.push(e._bin.readUshort(i, r + 2 * l));
      return o;
    }, readUint: function(i, r) {
      return e._bin._view(i).getUint32(r);
    }, readUint64: function(i, r) {
      return 4294967296 * e._bin.readUint(i, r) + e._bin.readUint(i, r + 4);
    }, readASCII: function(i, r, a) {
      for (var o = "", l = 0; l < a; l++)
        o += String.fromCharCode(i[r + l]);
      return o;
    }, readUnicode: function(i, r, a) {
      for (var o = "", l = 0; l < a; l++) {
        var c = i[r++] << 8 | i[r++];
        o += String.fromCharCode(c);
      }
      return o;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(i, r, a) {
      var o = e._bin._tdec;
      return o && r == 0 && a == i.length ? o.decode(i) : e._bin.readASCII(i, r, a);
    }, readBytes: function(i, r, a) {
      for (var o = [], l = 0; l < a; l++)
        o.push(i[r + l]);
      return o;
    }, readASCIIArray: function(i, r, a) {
      for (var o = [], l = 0; l < a; l++)
        o.push(String.fromCharCode(i[r + l]));
      return o;
    }, _view: function(i) {
      return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(i, r, a, o, l) {
      var c = e._bin, u = {}, f = r;
      c.readFixed(i, r), r += 4;
      var h = c.readUshort(i, r);
      r += 2;
      var d = c.readUshort(i, r);
      r += 2;
      var m = c.readUshort(i, r);
      return r += 2, u.scriptList = e._lctf.readScriptList(i, f + h), u.featureList = e._lctf.readFeatureList(i, f + d), u.lookupList = e._lctf.readLookupList(i, f + m, l), u;
    }, e._lctf.readLookupList = function(i, r, a) {
      var o = e._bin, l = r, c = [], u = o.readUshort(i, r);
      r += 2;
      for (var f = 0; f < u; f++) {
        var h = o.readUshort(i, r);
        r += 2;
        var d = e._lctf.readLookupTable(i, l + h, a);
        c.push(d);
      }
      return c;
    }, e._lctf.readLookupTable = function(i, r, a) {
      var o = e._bin, l = r, c = { tabs: [] };
      c.ltype = o.readUshort(i, r), r += 2, c.flag = o.readUshort(i, r), r += 2;
      var u = o.readUshort(i, r);
      r += 2;
      for (var f = c.ltype, h = 0; h < u; h++) {
        var d = o.readUshort(i, r);
        r += 2;
        var m = a(i, f, l + d, c);
        c.tabs.push(m);
      }
      return c;
    }, e._lctf.numOfOnes = function(i) {
      for (var r = 0, a = 0; a < 32; a++)
        i >>> a & 1 && r++;
      return r;
    }, e._lctf.readClassDef = function(i, r) {
      var a = e._bin, o = [], l = a.readUshort(i, r);
      if (r += 2, l == 1) {
        var c = a.readUshort(i, r);
        r += 2;
        var u = a.readUshort(i, r);
        r += 2;
        for (var f = 0; f < u; f++)
          o.push(c + f), o.push(c + f), o.push(a.readUshort(i, r)), r += 2;
      }
      if (l == 2) {
        var h = a.readUshort(i, r);
        for (r += 2, f = 0; f < h; f++)
          o.push(a.readUshort(i, r)), r += 2, o.push(a.readUshort(i, r)), r += 2, o.push(a.readUshort(i, r)), r += 2;
      }
      return o;
    }, e._lctf.getInterval = function(i, r) {
      for (var a = 0; a < i.length; a += 3) {
        var o = i[a], l = i[a + 1];
        if (i[a + 2], o <= r && r <= l)
          return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(i, r) {
      var a = e._bin, o = {};
      o.fmt = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      return r += 2, o.fmt == 1 && (o.tab = a.readUshorts(i, r, l)), o.fmt == 2 && (o.tab = a.readUshorts(i, r, 3 * l)), o;
    }, e._lctf.coverageIndex = function(i, r) {
      var a = i.tab;
      if (i.fmt == 1)
        return a.indexOf(r);
      if (i.fmt == 2) {
        var o = e._lctf.getInterval(a, r);
        if (o != -1)
          return a[o + 2] + (r - a[o]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(i, r) {
      var a = e._bin, o = r, l = [], c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readASCII(i, r, 4);
        r += 4;
        var h = a.readUshort(i, r);
        r += 2;
        var d = e._lctf.readFeatureTable(i, o + h);
        d.tag = f.trim(), l.push(d);
      }
      return l;
    }, e._lctf.readFeatureTable = function(i, r) {
      var a = e._bin, o = r, l = {}, c = a.readUshort(i, r);
      r += 2, c > 0 && (l.featureParams = o + c);
      var u = a.readUshort(i, r);
      r += 2, l.tab = [];
      for (var f = 0; f < u; f++)
        l.tab.push(a.readUshort(i, r + 2 * f));
      return l;
    }, e._lctf.readScriptList = function(i, r) {
      var a = e._bin, o = r, l = {}, c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readASCII(i, r, 4);
        r += 4;
        var h = a.readUshort(i, r);
        r += 2, l[f.trim()] = e._lctf.readScriptTable(i, o + h);
      }
      return l;
    }, e._lctf.readScriptTable = function(i, r) {
      var a = e._bin, o = r, l = {}, c = a.readUshort(i, r);
      r += 2, l.default = e._lctf.readLangSysTable(i, o + c);
      var u = a.readUshort(i, r);
      r += 2;
      for (var f = 0; f < u; f++) {
        var h = a.readASCII(i, r, 4);
        r += 4;
        var d = a.readUshort(i, r);
        r += 2, l[h.trim()] = e._lctf.readLangSysTable(i, o + d);
      }
      return l;
    }, e._lctf.readLangSysTable = function(i, r) {
      var a = e._bin, o = {};
      a.readUshort(i, r), r += 2, o.reqFeature = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      return r += 2, o.features = a.readUshorts(i, r, l), o;
    }, e.CFF = {}, e.CFF.parse = function(i, r, a) {
      var o = e._bin;
      (i = new Uint8Array(i.buffer, r, a))[r = 0], i[++r], i[++r], i[++r], r++;
      var l = [];
      r = e.CFF.readIndex(i, r, l);
      for (var c = [], u = 0; u < l.length - 1; u++)
        c.push(o.readASCII(i, r + l[u], l[u + 1] - l[u]));
      r += l[l.length - 1];
      var f = [];
      r = e.CFF.readIndex(i, r, f);
      var h = [];
      for (u = 0; u < f.length - 1; u++)
        h.push(e.CFF.readDict(i, r + f[u], r + f[u + 1]));
      r += f[f.length - 1];
      var d = h[0], m = [];
      r = e.CFF.readIndex(i, r, m);
      var _ = [];
      for (u = 0; u < m.length - 1; u++)
        _.push(o.readASCII(i, r + m[u], m[u + 1] - m[u]));
      if (r += m[m.length - 1], e.CFF.readSubrs(i, r, d), d.CharStrings) {
        r = d.CharStrings, m = [], r = e.CFF.readIndex(i, r, m);
        var g = [];
        for (u = 0; u < m.length - 1; u++)
          g.push(o.readBytes(i, r + m[u], m[u + 1] - m[u]));
        d.CharStrings = g;
      }
      if (d.ROS) {
        r = d.FDArray;
        var A = [];
        for (r = e.CFF.readIndex(i, r, A), d.FDArray = [], u = 0; u < A.length - 1; u++) {
          var v = e.CFF.readDict(i, r + A[u], r + A[u + 1]);
          e.CFF._readFDict(i, v, _), d.FDArray.push(v);
        }
        r += A[A.length - 1], r = d.FDSelect, d.FDSelect = [];
        var y = i[r];
        if (r++, y != 3)
          throw y;
        var w = o.readUshort(i, r);
        for (r += 2, u = 0; u < w + 1; u++)
          d.FDSelect.push(o.readUshort(i, r), i[r + 2]), r += 3;
      }
      return d.Encoding && (d.Encoding = e.CFF.readEncoding(i, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(i, d.charset, d.CharStrings.length)), e.CFF._readFDict(i, d, _), d;
    }, e.CFF._readFDict = function(i, r, a) {
      var o;
      for (var l in r.Private && (o = r.Private[1], r.Private = e.CFF.readDict(i, o, o + r.Private[0]), r.Private.Subrs && e.CFF.readSubrs(i, o + r.Private.Subrs, r.Private)), r)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (r[l] = a[r[l] - 426 + 35]);
    }, e.CFF.readSubrs = function(i, r, a) {
      var o = e._bin, l = [];
      r = e.CFF.readIndex(i, r, l);
      var c, u = l.length;
      c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, a.Bias = c, a.Subrs = [];
      for (var f = 0; f < l.length - 1; f++)
        a.Subrs.push(o.readBytes(i, r + l[f], l[f + 1] - l[f]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, r) {
      for (var a = 0; a < i.charset.length; a++)
        if (i.charset[a] == r)
          return a;
      return -1;
    }, e.CFF.glyphBySE = function(i, r) {
      return r < 0 || r > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[r]);
    }, e.CFF.readEncoding = function(i, r, a) {
      e._bin;
      var o = [".notdef"], l = i[r];
      if (r++, l != 0)
        throw "error: unknown encoding format: " + l;
      var c = i[r];
      r++;
      for (var u = 0; u < c; u++)
        o.push(i[r + u]);
      return o;
    }, e.CFF.readCharset = function(i, r, a) {
      var o = e._bin, l = [".notdef"], c = i[r];
      if (r++, c == 0)
        for (var u = 0; u < a; u++) {
          var f = o.readUshort(i, r);
          r += 2, l.push(f);
        }
      else {
        if (c != 1 && c != 2)
          throw "error: format: " + c;
        for (; l.length < a; ) {
          f = o.readUshort(i, r), r += 2;
          var h = 0;
          for (c == 1 ? (h = i[r], r++) : (h = o.readUshort(i, r), r += 2), u = 0; u <= h; u++)
            l.push(f), f++;
        }
      }
      return l;
    }, e.CFF.readIndex = function(i, r, a) {
      var o = e._bin, l = o.readUshort(i, r) + 1, c = i[r += 2];
      if (r++, c == 1)
        for (var u = 0; u < l; u++)
          a.push(i[r + u]);
      else if (c == 2)
        for (u = 0; u < l; u++)
          a.push(o.readUshort(i, r + 2 * u));
      else if (c == 3)
        for (u = 0; u < l; u++)
          a.push(16777215 & o.readUint(i, r + 3 * u - 1));
      else if (l != 1)
        throw "unsupported offset size: " + c + ", count: " + l;
      return (r += l * c) - 1;
    }, e.CFF.getCharString = function(i, r, a) {
      var o = e._bin, l = i[r], c = i[r + 1];
      i[r + 2], i[r + 3], i[r + 4];
      var u = 1, f = null, h = null;
      l <= 20 && (f = l, u = 1), l == 12 && (f = 100 * l + c, u = 2), 21 <= l && l <= 27 && (f = l, u = 1), l == 28 && (h = o.readShort(i, r + 1), u = 3), 29 <= l && l <= 31 && (f = l, u = 1), 32 <= l && l <= 246 && (h = l - 139, u = 1), 247 <= l && l <= 250 && (h = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (h = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (h = o.readInt(i, r + 1) / 65535, u = 5), a.val = h ?? "o" + f, a.size = u;
    }, e.CFF.readCharString = function(i, r, a) {
      for (var o = r + a, l = e._bin, c = []; r < o; ) {
        var u = i[r], f = i[r + 1];
        i[r + 2], i[r + 3], i[r + 4];
        var h = 1, d = null, m = null;
        u <= 20 && (d = u, h = 1), u == 12 && (d = 100 * u + f, h = 2), u != 19 && u != 20 || (d = u, h = 2), 21 <= u && u <= 27 && (d = u, h = 1), u == 28 && (m = l.readShort(i, r + 1), h = 3), 29 <= u && u <= 31 && (d = u, h = 1), 32 <= u && u <= 246 && (m = u - 139, h = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + f + 108, h = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - f - 108, h = 2), u == 255 && (m = l.readInt(i, r + 1) / 65535, h = 5), c.push(m ?? "o" + d), r += h;
      }
      return c;
    }, e.CFF.readDict = function(i, r, a) {
      for (var o = e._bin, l = {}, c = []; r < a; ) {
        var u = i[r], f = i[r + 1];
        i[r + 2], i[r + 3], i[r + 4];
        var h = 1, d = null, m = null;
        if (u == 28 && (m = o.readShort(i, r + 1), h = 3), u == 29 && (m = o.readInt(i, r + 1), h = 5), 32 <= u && u <= 246 && (m = u - 139, h = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + f + 108, h = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - f - 108, h = 2), u == 255)
          throw m = o.readInt(i, r + 1) / 65535, h = 5, "unknown number";
        if (u == 30) {
          var _ = [];
          for (h = 1; ; ) {
            var g = i[r + h];
            h++;
            var A = g >> 4, v = 15 & g;
            if (A != 15 && _.push(A), v != 15 && _.push(v), v == 15)
              break;
          }
          for (var y = "", w = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], E = 0; E < _.length; E++)
            y += w[_[E]];
          m = parseFloat(y);
        }
        u <= 21 && (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], h = 1, u == 12 && (d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][f], h = 2)), d != null ? (l[d] = c.length == 1 ? c[0] : c, c = []) : c.push(m), r += h;
      }
      return l;
    }, e.cmap = {}, e.cmap.parse = function(i, r, a) {
      i = new Uint8Array(i.buffer, r, a), r = 0;
      var o = e._bin, l = {};
      o.readUshort(i, r), r += 2;
      var c = o.readUshort(i, r);
      r += 2;
      var u = [];
      l.tables = [];
      for (var f = 0; f < c; f++) {
        var h = o.readUshort(i, r);
        r += 2;
        var d = o.readUshort(i, r);
        r += 2;
        var m = o.readUint(i, r);
        r += 4;
        var _ = "p" + h + "e" + d, g = u.indexOf(m);
        if (g == -1) {
          var A;
          g = l.tables.length, u.push(m);
          var v = o.readUshort(i, m);
          v == 0 ? A = e.cmap.parse0(i, m) : v == 4 ? A = e.cmap.parse4(i, m) : v == 6 ? A = e.cmap.parse6(i, m) : v == 12 ? A = e.cmap.parse12(i, m) : console.debug("unknown format: " + v, h, d, m), l.tables.push(A);
        }
        if (l[_] != null)
          throw "multiple tables for one platform+encoding";
        l[_] = g;
      }
      return l;
    }, e.cmap.parse0 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2, o.map = [];
      for (var c = 0; c < l - 6; c++)
        o.map.push(i[r + c]);
      return o;
    }, e.cmap.parse4 = function(i, r) {
      var a = e._bin, o = r, l = {};
      l.format = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2;
      var u = a.readUshort(i, r);
      r += 2;
      var f = u / 2;
      l.searchRange = a.readUshort(i, r), r += 2, l.entrySelector = a.readUshort(i, r), r += 2, l.rangeShift = a.readUshort(i, r), r += 2, l.endCount = a.readUshorts(i, r, f), r += 2 * f, r += 2, l.startCount = a.readUshorts(i, r, f), r += 2 * f, l.idDelta = [];
      for (var h = 0; h < f; h++)
        l.idDelta.push(a.readShort(i, r)), r += 2;
      for (l.idRangeOffset = a.readUshorts(i, r, f), r += 2 * f, l.glyphIdArray = []; r < o + c; )
        l.glyphIdArray.push(a.readUshort(i, r)), r += 2;
      return l;
    }, e.cmap.parse6 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, o.firstCode = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2, o.glyphIdArray = [];
      for (var c = 0; c < l; c++)
        o.glyphIdArray.push(a.readUshort(i, r)), r += 2;
      return o;
    }, e.cmap.parse12 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2, r += 2, a.readUint(i, r), r += 4, a.readUint(i, r), r += 4;
      var l = a.readUint(i, r);
      r += 4, o.groups = [];
      for (var c = 0; c < l; c++) {
        var u = r + 12 * c, f = a.readUint(i, u + 0), h = a.readUint(i, u + 4), d = a.readUint(i, u + 8);
        o.groups.push([f, h, d]);
      }
      return o;
    }, e.glyf = {}, e.glyf.parse = function(i, r, a, o) {
      for (var l = [], c = 0; c < o.maxp.numGlyphs; c++)
        l.push(null);
      return l;
    }, e.glyf._parseGlyf = function(i, r) {
      var a = e._bin, o = i._data, l = e._tabOffset(o, "glyf", i._offset) + i.loca[r];
      if (i.loca[r] == i.loca[r + 1])
        return null;
      var c = {};
      if (c.noc = a.readShort(o, l), l += 2, c.xMin = a.readShort(o, l), l += 2, c.yMin = a.readShort(o, l), l += 2, c.xMax = a.readShort(o, l), l += 2, c.yMax = a.readShort(o, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax)
        return null;
      if (c.noc > 0) {
        c.endPts = [];
        for (var u = 0; u < c.noc; u++)
          c.endPts.push(a.readUshort(o, l)), l += 2;
        var f = a.readUshort(o, l);
        if (l += 2, o.length - l < f)
          return null;
        c.instructions = a.readBytes(o, l, f), l += f;
        var h = c.endPts[c.noc - 1] + 1;
        for (c.flags = [], u = 0; u < h; u++) {
          var d = o[l];
          if (l++, c.flags.push(d), (8 & d) != 0) {
            var m = o[l];
            l++;
            for (var _ = 0; _ < m; _++)
              c.flags.push(d), u++;
          }
        }
        for (c.xs = [], u = 0; u < h; u++) {
          var g = (2 & c.flags[u]) != 0, A = (16 & c.flags[u]) != 0;
          g ? (c.xs.push(A ? o[l] : -o[l]), l++) : A ? c.xs.push(0) : (c.xs.push(a.readShort(o, l)), l += 2);
        }
        for (c.ys = [], u = 0; u < h; u++)
          g = (4 & c.flags[u]) != 0, A = (32 & c.flags[u]) != 0, g ? (c.ys.push(A ? o[l] : -o[l]), l++) : A ? c.ys.push(0) : (c.ys.push(a.readShort(o, l)), l += 2);
        var v = 0, y = 0;
        for (u = 0; u < h; u++)
          v += c.xs[u], y += c.ys[u], c.xs[u] = v, c.ys[u] = y;
      } else {
        var w;
        c.parts = [];
        do {
          w = a.readUshort(o, l), l += 2;
          var E = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (c.parts.push(E), E.glyphIndex = a.readUshort(o, l), l += 2, 1 & w) {
            var I = a.readShort(o, l);
            l += 2;
            var C = a.readShort(o, l);
            l += 2;
          } else
            I = a.readInt8(o, l), l++, C = a.readInt8(o, l), l++;
          2 & w ? (E.m.tx = I, E.m.ty = C) : (E.p1 = I, E.p2 = C), 8 & w ? (E.m.a = E.m.d = a.readF2dot14(o, l), l += 2) : 64 & w ? (E.m.a = a.readF2dot14(o, l), l += 2, E.m.d = a.readF2dot14(o, l), l += 2) : 128 & w && (E.m.a = a.readF2dot14(o, l), l += 2, E.m.b = a.readF2dot14(o, l), l += 2, E.m.c = a.readF2dot14(o, l), l += 2, E.m.d = a.readF2dot14(o, l), l += 2);
        } while (32 & w);
        if (256 & w) {
          var B = a.readUshort(o, l);
          for (l += 2, c.instr = [], u = 0; u < B; u++)
            c.instr.push(o[l]), l++;
        }
      }
      return c;
    }, e.GPOS = {}, e.GPOS.parse = function(i, r, a, o) {
      return e._lctf.parse(i, r, a, o, e.GPOS.subt);
    }, e.GPOS.subt = function(i, r, a, o) {
      var l = e._bin, c = a, u = {};
      if (u.fmt = l.readUshort(i, a), a += 2, r == 1 || r == 2 || r == 3 || r == 7 || r == 8 && u.fmt <= 2) {
        var f = l.readUshort(i, a);
        a += 2, u.coverage = e._lctf.readCoverage(i, f + c);
      }
      if (r == 1 && u.fmt == 1) {
        var h = l.readUshort(i, a);
        a += 2;
        var d = e._lctf.numOfOnes(h);
        h != 0 && (u.pos = e.GPOS.readValueRecord(i, a, h));
      } else if (r == 2 && u.fmt >= 1 && u.fmt <= 2) {
        h = l.readUshort(i, a), a += 2;
        var m = l.readUshort(i, a);
        a += 2, d = e._lctf.numOfOnes(h);
        var _ = e._lctf.numOfOnes(m);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = l.readUshort(i, a);
          a += 2;
          for (var A = 0; A < g; A++) {
            var v = c + l.readUshort(i, a);
            a += 2;
            var y = l.readUshort(i, v);
            v += 2;
            for (var w = [], E = 0; E < y; E++) {
              var I = l.readUshort(i, v);
              v += 2, h != 0 && (R = e.GPOS.readValueRecord(i, v, h), v += 2 * d), m != 0 && (P = e.GPOS.readValueRecord(i, v, m), v += 2 * _), w.push({ gid2: I, val1: R, val2: P });
            }
            u.pairsets.push(w);
          }
        }
        if (u.fmt == 2) {
          var C = l.readUshort(i, a);
          a += 2;
          var B = l.readUshort(i, a);
          a += 2;
          var T = l.readUshort(i, a);
          a += 2;
          var S = l.readUshort(i, a);
          for (a += 2, u.classDef1 = e._lctf.readClassDef(i, c + C), u.classDef2 = e._lctf.readClassDef(i, c + B), u.matrix = [], A = 0; A < T; A++) {
            var D = [];
            for (E = 0; E < S; E++) {
              var R = null, P = null;
              h != 0 && (R = e.GPOS.readValueRecord(i, a, h), a += 2 * d), m != 0 && (P = e.GPOS.readValueRecord(i, a, m), a += 2 * _), D.push({ val1: R, val2: P });
            }
            u.matrix.push(D);
          }
        }
      } else {
        if (r == 9 && u.fmt == 1) {
          var L = l.readUshort(i, a);
          a += 2;
          var V = l.readUint(i, a);
          if (a += 4, o.ltype == 9)
            o.ltype = L;
          else if (o.ltype != L)
            throw "invalid extension substitution";
          return e.GPOS.subt(i, o.ltype, c + V);
        }
        console.debug("unsupported GPOS table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(i, r, a) {
      var o = e._bin, l = [];
      return l.push(1 & a ? o.readShort(i, r) : 0), r += 1 & a ? 2 : 0, l.push(2 & a ? o.readShort(i, r) : 0), r += 2 & a ? 2 : 0, l.push(4 & a ? o.readShort(i, r) : 0), r += 4 & a ? 2 : 0, l.push(8 & a ? o.readShort(i, r) : 0), r += 8 & a ? 2 : 0, l;
    }, e.GSUB = {}, e.GSUB.parse = function(i, r, a, o) {
      return e._lctf.parse(i, r, a, o, e.GSUB.subt);
    }, e.GSUB.subt = function(i, r, a, o) {
      var l = e._bin, c = a, u = {};
      if (u.fmt = l.readUshort(i, a), a += 2, r != 1 && r != 4 && r != 5 && r != 6)
        return null;
      if (r == 1 || r == 4 || r == 5 && u.fmt <= 2 || r == 6 && u.fmt <= 2) {
        var f = l.readUshort(i, a);
        a += 2, u.coverage = e._lctf.readCoverage(i, c + f);
      }
      if (r == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = l.readShort(i, a), a += 2;
        else if (u.fmt == 2) {
          var h = l.readUshort(i, a);
          a += 2, u.newg = l.readUshorts(i, a, h), a += 2 * u.newg.length;
        }
      } else if (r == 4) {
        u.vals = [], h = l.readUshort(i, a), a += 2;
        for (var d = 0; d < h; d++) {
          var m = l.readUshort(i, a);
          a += 2, u.vals.push(e.GSUB.readLigatureSet(i, c + m));
        }
      } else if (r == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var _ = l.readUshort(i, a);
          a += 2, u.cDef = e._lctf.readClassDef(i, c + _), u.scset = [];
          var g = l.readUshort(i, a);
          for (a += 2, d = 0; d < g; d++) {
            var A = l.readUshort(i, a);
            a += 2, u.scset.push(A == 0 ? null : e.GSUB.readSubClassSet(i, c + A));
          }
        }
      } else if (r == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (d = 0; d < 3; d++) {
            h = l.readUshort(i, a), a += 2;
            for (var v = [], y = 0; y < h; y++)
              v.push(e._lctf.readCoverage(i, c + l.readUshort(i, a + 2 * y)));
            a += 2 * h, d == 0 && (u.backCvg = v), d == 1 && (u.inptCvg = v), d == 2 && (u.ahedCvg = v);
          }
          h = l.readUshort(i, a), a += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(i, a, h);
        }
      } else {
        if (r == 7 && u.fmt == 1) {
          var w = l.readUshort(i, a);
          a += 2;
          var E = l.readUint(i, a);
          if (a += 4, o.ltype == 9)
            o.ltype = w;
          else if (o.ltype != w)
            throw "invalid extension substitution";
          return e.GSUB.subt(i, o.ltype, c + E);
        }
        console.debug("unsupported GSUB table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(i, r) {
      var a = e._bin.readUshort, o = r, l = [], c = a(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a(i, r);
        r += 2, l.push(e.GSUB.readSubClassRule(i, o + f));
      }
      return l;
    }, e.GSUB.readSubClassRule = function(i, r) {
      var a = e._bin.readUshort, o = {}, l = a(i, r), c = a(i, r += 2);
      r += 2, o.input = [];
      for (var u = 0; u < l - 1; u++)
        o.input.push(a(i, r)), r += 2;
      return o.substLookupRecords = e.GSUB.readSubstLookupRecords(i, r, c), o;
    }, e.GSUB.readSubstLookupRecords = function(i, r, a) {
      for (var o = e._bin.readUshort, l = [], c = 0; c < a; c++)
        l.push(o(i, r), o(i, r + 2)), r += 4;
      return l;
    }, e.GSUB.readChainSubClassSet = function(i, r) {
      var a = e._bin, o = r, l = [], c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readUshort(i, r);
        r += 2, l.push(e.GSUB.readChainSubClassRule(i, o + f));
      }
      return l;
    }, e.GSUB.readChainSubClassRule = function(i, r) {
      for (var a = e._bin, o = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) {
        var u = a.readUshort(i, r);
        r += 2, c == 1 && u--, o[l[c]] = a.readUshorts(i, r, u), r += 2 * o[l[c]].length;
      }
      return u = a.readUshort(i, r), r += 2, o.subst = a.readUshorts(i, r, 2 * u), r += 2 * o.subst.length, o;
    }, e.GSUB.readLigatureSet = function(i, r) {
      var a = e._bin, o = r, l = [], c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readUshort(i, r);
        r += 2, l.push(e.GSUB.readLigature(i, o + f));
      }
      return l;
    }, e.GSUB.readLigature = function(i, r) {
      var a = e._bin, o = { chain: [] };
      o.nglyph = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2;
      for (var c = 0; c < l - 1; c++)
        o.chain.push(a.readUshort(i, r)), r += 2;
      return o;
    }, e.head = {}, e.head.parse = function(i, r, a) {
      var o = e._bin, l = {};
      return o.readFixed(i, r), r += 4, l.fontRevision = o.readFixed(i, r), r += 4, o.readUint(i, r), r += 4, o.readUint(i, r), r += 4, l.flags = o.readUshort(i, r), r += 2, l.unitsPerEm = o.readUshort(i, r), r += 2, l.created = o.readUint64(i, r), r += 8, l.modified = o.readUint64(i, r), r += 8, l.xMin = o.readShort(i, r), r += 2, l.yMin = o.readShort(i, r), r += 2, l.xMax = o.readShort(i, r), r += 2, l.yMax = o.readShort(i, r), r += 2, l.macStyle = o.readUshort(i, r), r += 2, l.lowestRecPPEM = o.readUshort(i, r), r += 2, l.fontDirectionHint = o.readShort(i, r), r += 2, l.indexToLocFormat = o.readShort(i, r), r += 2, l.glyphDataFormat = o.readShort(i, r), r += 2, l;
    }, e.hhea = {}, e.hhea.parse = function(i, r, a) {
      var o = e._bin, l = {};
      return o.readFixed(i, r), r += 4, l.ascender = o.readShort(i, r), r += 2, l.descender = o.readShort(i, r), r += 2, l.lineGap = o.readShort(i, r), r += 2, l.advanceWidthMax = o.readUshort(i, r), r += 2, l.minLeftSideBearing = o.readShort(i, r), r += 2, l.minRightSideBearing = o.readShort(i, r), r += 2, l.xMaxExtent = o.readShort(i, r), r += 2, l.caretSlopeRise = o.readShort(i, r), r += 2, l.caretSlopeRun = o.readShort(i, r), r += 2, l.caretOffset = o.readShort(i, r), r += 2, r += 8, l.metricDataFormat = o.readShort(i, r), r += 2, l.numberOfHMetrics = o.readUshort(i, r), r += 2, l;
    }, e.hmtx = {}, e.hmtx.parse = function(i, r, a, o) {
      for (var l = e._bin, c = { aWidth: [], lsBearing: [] }, u = 0, f = 0, h = 0; h < o.maxp.numGlyphs; h++)
        h < o.hhea.numberOfHMetrics && (u = l.readUshort(i, r), r += 2, f = l.readShort(i, r), r += 2), c.aWidth.push(u), c.lsBearing.push(f);
      return c;
    }, e.kern = {}, e.kern.parse = function(i, r, a, o) {
      var l = e._bin, c = l.readUshort(i, r);
      if (r += 2, c == 1)
        return e.kern.parseV1(i, r - 2, a, o);
      var u = l.readUshort(i, r);
      r += 2;
      for (var f = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
        r += 2, a = l.readUshort(i, r), r += 2;
        var d = l.readUshort(i, r);
        r += 2;
        var m = d >>> 8;
        if ((m &= 15) != 0)
          throw "unknown kern table format: " + m;
        r = e.kern.readFormat0(i, r, f);
      }
      return f;
    }, e.kern.parseV1 = function(i, r, a, o) {
      var l = e._bin;
      l.readFixed(i, r), r += 4;
      var c = l.readUint(i, r);
      r += 4;
      for (var u = { glyph1: [], rval: [] }, f = 0; f < c; f++) {
        l.readUint(i, r), r += 4;
        var h = l.readUshort(i, r);
        r += 2, l.readUshort(i, r), r += 2;
        var d = h >>> 8;
        if ((d &= 15) != 0)
          throw "unknown kern table format: " + d;
        r = e.kern.readFormat0(i, r, u);
      }
      return u;
    }, e.kern.readFormat0 = function(i, r, a) {
      var o = e._bin, l = -1, c = o.readUshort(i, r);
      r += 2, o.readUshort(i, r), r += 2, o.readUshort(i, r), r += 2, o.readUshort(i, r), r += 2;
      for (var u = 0; u < c; u++) {
        var f = o.readUshort(i, r);
        r += 2;
        var h = o.readUshort(i, r);
        r += 2;
        var d = o.readShort(i, r);
        r += 2, f != l && (a.glyph1.push(f), a.rval.push({ glyph2: [], vals: [] }));
        var m = a.rval[a.rval.length - 1];
        m.glyph2.push(h), m.vals.push(d), l = f;
      }
      return r;
    }, e.loca = {}, e.loca.parse = function(i, r, a, o) {
      var l = e._bin, c = [], u = o.head.indexToLocFormat, f = o.maxp.numGlyphs + 1;
      if (u == 0)
        for (var h = 0; h < f; h++)
          c.push(l.readUshort(i, r + (h << 1)) << 1);
      if (u == 1)
        for (h = 0; h < f; h++)
          c.push(l.readUint(i, r + (h << 2)));
      return c;
    }, e.maxp = {}, e.maxp.parse = function(i, r, a) {
      var o = e._bin, l = {}, c = o.readUint(i, r);
      return r += 4, l.numGlyphs = o.readUshort(i, r), r += 2, c == 65536 && (l.maxPoints = o.readUshort(i, r), r += 2, l.maxContours = o.readUshort(i, r), r += 2, l.maxCompositePoints = o.readUshort(i, r), r += 2, l.maxCompositeContours = o.readUshort(i, r), r += 2, l.maxZones = o.readUshort(i, r), r += 2, l.maxTwilightPoints = o.readUshort(i, r), r += 2, l.maxStorage = o.readUshort(i, r), r += 2, l.maxFunctionDefs = o.readUshort(i, r), r += 2, l.maxInstructionDefs = o.readUshort(i, r), r += 2, l.maxStackElements = o.readUshort(i, r), r += 2, l.maxSizeOfInstructions = o.readUshort(i, r), r += 2, l.maxComponentElements = o.readUshort(i, r), r += 2, l.maxComponentDepth = o.readUshort(i, r), r += 2), l;
    }, e.name = {}, e.name.parse = function(i, r, a) {
      var o = e._bin, l = {};
      o.readUshort(i, r), r += 2;
      var c = o.readUshort(i, r);
      r += 2, o.readUshort(i, r);
      for (var u, f = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], h = r += 2, d = 0; d < c; d++) {
        var m = o.readUshort(i, r);
        r += 2;
        var _ = o.readUshort(i, r);
        r += 2;
        var g = o.readUshort(i, r);
        r += 2;
        var A = o.readUshort(i, r);
        r += 2;
        var v = o.readUshort(i, r);
        r += 2;
        var y = o.readUshort(i, r);
        r += 2;
        var w, E = f[A], I = h + 12 * c + y;
        if (m == 0)
          w = o.readUnicode(i, I, v / 2);
        else if (m == 3 && _ == 0)
          w = o.readUnicode(i, I, v / 2);
        else if (_ == 0)
          w = o.readASCII(i, I, v);
        else if (_ == 1)
          w = o.readUnicode(i, I, v / 2);
        else if (_ == 3)
          w = o.readUnicode(i, I, v / 2);
        else {
          if (m != 1)
            throw "unknown encoding " + _ + ", platformID: " + m;
          w = o.readASCII(i, I, v), console.debug("reading unknown MAC encoding " + _ + " as ASCII");
        }
        var C = "p" + m + "," + g.toString(16);
        l[C] == null && (l[C] = {}), l[C][E !== void 0 ? E : A] = w, l[C]._lang = g;
      }
      for (var B in l)
        if (l[B].postScriptName != null && l[B]._lang == 1033)
          return l[B];
      for (var B in l)
        if (l[B].postScriptName != null && l[B]._lang == 0)
          return l[B];
      for (var B in l)
        if (l[B].postScriptName != null && l[B]._lang == 3084)
          return l[B];
      for (var B in l)
        if (l[B].postScriptName != null)
          return l[B];
      for (var B in l) {
        u = B;
        break;
      }
      return console.debug("returning name table with languageID " + l[u]._lang), l[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(i, r, a) {
      var o = e._bin.readUshort(i, r);
      r += 2;
      var l = {};
      if (o == 0)
        e["OS/2"].version0(i, r, l);
      else if (o == 1)
        e["OS/2"].version1(i, r, l);
      else if (o == 2 || o == 3 || o == 4)
        e["OS/2"].version2(i, r, l);
      else {
        if (o != 5)
          throw "unknown OS/2 table version: " + o;
        e["OS/2"].version5(i, r, l);
      }
      return l;
    }, e["OS/2"].version0 = function(i, r, a) {
      var o = e._bin;
      return a.xAvgCharWidth = o.readShort(i, r), r += 2, a.usWeightClass = o.readUshort(i, r), r += 2, a.usWidthClass = o.readUshort(i, r), r += 2, a.fsType = o.readUshort(i, r), r += 2, a.ySubscriptXSize = o.readShort(i, r), r += 2, a.ySubscriptYSize = o.readShort(i, r), r += 2, a.ySubscriptXOffset = o.readShort(i, r), r += 2, a.ySubscriptYOffset = o.readShort(i, r), r += 2, a.ySuperscriptXSize = o.readShort(i, r), r += 2, a.ySuperscriptYSize = o.readShort(i, r), r += 2, a.ySuperscriptXOffset = o.readShort(i, r), r += 2, a.ySuperscriptYOffset = o.readShort(i, r), r += 2, a.yStrikeoutSize = o.readShort(i, r), r += 2, a.yStrikeoutPosition = o.readShort(i, r), r += 2, a.sFamilyClass = o.readShort(i, r), r += 2, a.panose = o.readBytes(i, r, 10), r += 10, a.ulUnicodeRange1 = o.readUint(i, r), r += 4, a.ulUnicodeRange2 = o.readUint(i, r), r += 4, a.ulUnicodeRange3 = o.readUint(i, r), r += 4, a.ulUnicodeRange4 = o.readUint(i, r), r += 4, a.achVendID = [o.readInt8(i, r), o.readInt8(i, r + 1), o.readInt8(i, r + 2), o.readInt8(i, r + 3)], r += 4, a.fsSelection = o.readUshort(i, r), r += 2, a.usFirstCharIndex = o.readUshort(i, r), r += 2, a.usLastCharIndex = o.readUshort(i, r), r += 2, a.sTypoAscender = o.readShort(i, r), r += 2, a.sTypoDescender = o.readShort(i, r), r += 2, a.sTypoLineGap = o.readShort(i, r), r += 2, a.usWinAscent = o.readUshort(i, r), r += 2, a.usWinDescent = o.readUshort(i, r), r += 2;
    }, e["OS/2"].version1 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version0(i, r, a), a.ulCodePageRange1 = o.readUint(i, r), r += 4, a.ulCodePageRange2 = o.readUint(i, r), r += 4;
    }, e["OS/2"].version2 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version1(i, r, a), a.sxHeight = o.readShort(i, r), r += 2, a.sCapHeight = o.readShort(i, r), r += 2, a.usDefault = o.readUshort(i, r), r += 2, a.usBreak = o.readUshort(i, r), r += 2, a.usMaxContext = o.readUshort(i, r), r += 2;
    }, e["OS/2"].version5 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version2(i, r, a), a.usLowerOpticalPointSize = o.readUshort(i, r), r += 2, a.usUpperOpticalPointSize = o.readUshort(i, r), r += 2;
    }, e.post = {}, e.post.parse = function(i, r, a) {
      var o = e._bin, l = {};
      return l.version = o.readFixed(i, r), r += 4, l.italicAngle = o.readFixed(i, r), r += 4, l.underlinePosition = o.readShort(i, r), r += 2, l.underlineThickness = o.readShort(i, r), r += 2, l;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, r) {
      var a = i.cmap, o = -1;
      if (a.p0e4 != null ? o = a.p0e4 : a.p3e1 != null ? o = a.p3e1 : a.p1e0 != null ? o = a.p1e0 : a.p0e3 != null && (o = a.p0e3), o == -1)
        throw "no familiar platform and encoding!";
      var l = a.tables[o];
      if (l.format == 0)
        return r >= l.map.length ? 0 : l.map[r];
      if (l.format == 4) {
        for (var c = -1, u = 0; u < l.endCount.length; u++)
          if (r <= l.endCount[u]) {
            c = u;
            break;
          }
        return c == -1 || l.startCount[c] > r ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[r - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : r + l.idDelta[c]);
      }
      if (l.format == 12) {
        if (r > l.groups[l.groups.length - 1][1])
          return 0;
        for (u = 0; u < l.groups.length; u++) {
          var f = l.groups[u];
          if (f[0] <= r && r <= f[1])
            return f[2] + (r - f[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + l.format;
    }, e.U.glyphToPath = function(i, r) {
      var a = { cmds: [], crds: [] };
      if (i.SVG && i.SVG.entries[r]) {
        var o = i.SVG.entries[r];
        return o == null ? a : (typeof o == "string" && (o = e.SVG.toPath(o), i.SVG.entries[r] = o), o);
      }
      if (i.CFF) {
        var l = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, c = i.CFF, u = i.CFF.Private;
        if (c.ROS) {
          for (var f = 0; c.FDSelect[f + 2] <= r; )
            f += 2;
          u = c.FDArray[c.FDSelect[f + 1]].Private;
        }
        e.U._drawCFF(i.CFF.CharStrings[r], l, c, u, a);
      } else
        i.glyf && e.U._drawGlyf(r, i, a);
      return a;
    }, e.U._drawGlyf = function(i, r, a) {
      var o = r.glyf[i];
      o == null && (o = r.glyf[i] = e.glyf._parseGlyf(r, i)), o != null && (o.noc > -1 ? e.U._simpleGlyph(o, a) : e.U._compoGlyph(o, r, a));
    }, e.U._simpleGlyph = function(i, r) {
      for (var a = 0; a < i.noc; a++) {
        for (var o = a == 0 ? 0 : i.endPts[a - 1] + 1, l = i.endPts[a], c = o; c <= l; c++) {
          var u = c == o ? l : c - 1, f = c == l ? o : c + 1, h = 1 & i.flags[c], d = 1 & i.flags[u], m = 1 & i.flags[f], _ = i.xs[c], g = i.ys[c];
          if (c == o)
            if (h) {
              if (!d) {
                e.U.P.moveTo(r, _, g);
                continue;
              }
              e.U.P.moveTo(r, i.xs[u], i.ys[u]);
            } else
              d ? e.U.P.moveTo(r, i.xs[u], i.ys[u]) : e.U.P.moveTo(r, (i.xs[u] + _) / 2, (i.ys[u] + g) / 2);
          h ? d && e.U.P.lineTo(r, _, g) : m ? e.U.P.qcurveTo(r, _, g, i.xs[f], i.ys[f]) : e.U.P.qcurveTo(r, _, g, (_ + i.xs[f]) / 2, (g + i.ys[f]) / 2);
        }
        e.U.P.closePath(r);
      }
    }, e.U._compoGlyph = function(i, r, a) {
      for (var o = 0; o < i.parts.length; o++) {
        var l = { cmds: [], crds: [] }, c = i.parts[o];
        e.U._drawGlyf(c.glyphIndex, r, l);
        for (var u = c.m, f = 0; f < l.crds.length; f += 2) {
          var h = l.crds[f], d = l.crds[f + 1];
          a.crds.push(h * u.a + d * u.b + u.tx), a.crds.push(h * u.c + d * u.d + u.ty);
        }
        for (f = 0; f < l.cmds.length; f++)
          a.cmds.push(l.cmds[f]);
      }
    }, e.U._getGlyphClass = function(i, r) {
      var a = e._lctf.getInterval(r, i);
      return a == -1 ? 0 : r[a + 2];
    }, e.U.getPairAdjustment = function(i, r, a) {
      var o = !1;
      if (i.GPOS)
        for (var l = i.GPOS, c = l.lookupList, u = l.featureList, f = [], h = 0; h < u.length; h++) {
          var d = u[h];
          if (d.tag == "kern") {
            o = !0;
            for (var m = 0; m < d.tab.length; m++)
              if (!f[d.tab[m]]) {
                f[d.tab[m]] = !0;
                for (var _ = c[d.tab[m]], g = 0; g < _.tabs.length; g++)
                  if (_.tabs[g] != null) {
                    var A, v = _.tabs[g];
                    if ((!v.coverage || (A = e._lctf.coverageIndex(v.coverage, r)) != -1) && _.ltype != 1) {
                      if (_.ltype == 2) {
                        var y = null;
                        if (v.fmt == 1) {
                          var w = v.pairsets[A];
                          for (h = 0; h < w.length; h++)
                            w[h].gid2 == a && (y = w[h]);
                        } else if (v.fmt == 2) {
                          var E = e.U._getGlyphClass(r, v.classDef1), I = e.U._getGlyphClass(a, v.classDef2);
                          y = v.matrix[E][I];
                        }
                        if (y) {
                          var C = 0;
                          return y.val1 && y.val1[2] && (C += y.val1[2]), y.val2 && y.val2[0] && (C += y.val2[0]), C;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (i.kern && !o) {
        var B = i.kern.glyph1.indexOf(r);
        if (B != -1) {
          var T = i.kern.rval[B].glyph2.indexOf(a);
          if (T != -1)
            return i.kern.rval[B].vals[T];
        }
      }
      return 0;
    }, e.U._applySubs = function(i, r, a, o) {
      for (var l = i.length - r - 1, c = 0; c < a.tabs.length; c++)
        if (a.tabs[c] != null) {
          var u, f = a.tabs[c];
          if (!f.coverage || (u = e._lctf.coverageIndex(f.coverage, i[r])) != -1) {
            if (a.ltype == 1)
              i[r], f.fmt == 1 ? i[r] = i[r] + f.delta : i[r] = f.newg[u];
            else if (a.ltype == 4)
              for (var h = f.vals[u], d = 0; d < h.length; d++) {
                var m = h[d], _ = m.chain.length;
                if (!(_ > l)) {
                  for (var g = !0, A = 0, v = 0; v < _; v++) {
                    for (; i[r + A + (1 + v)] == -1; )
                      A++;
                    m.chain[v] != i[r + A + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (i[r] = m.nglyph, v = 0; v < _ + A; v++)
                      i[r + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (a.ltype == 5 && f.fmt == 2)
              for (var y = e._lctf.getInterval(f.cDef, i[r]), w = f.cDef[y + 2], E = f.scset[w], I = 0; I < E.length; I++) {
                var C = E[I], B = C.input;
                if (!(B.length > l)) {
                  for (g = !0, v = 0; v < B.length; v++) {
                    var T = e._lctf.getInterval(f.cDef, i[r + 1 + v]);
                    if (y == -1 && f.cDef[T + 2] != B[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var S = C.substLookupRecords;
                    for (d = 0; d < S.length; d += 2)
                      S[d], S[d + 1];
                  }
                }
              }
            else if (a.ltype == 6 && f.fmt == 3) {
              if (!e.U._glsCovered(i, f.backCvg, r - f.backCvg.length) || !e.U._glsCovered(i, f.inptCvg, r) || !e.U._glsCovered(i, f.ahedCvg, r + f.inptCvg.length))
                continue;
              var D = f.lookupRec;
              for (I = 0; I < D.length; I += 2) {
                y = D[I];
                var R = o[D[I + 1]];
                e.U._applySubs(i, r + y, R, o);
              }
            }
          }
        }
    }, e.U._glsCovered = function(i, r, a) {
      for (var o = 0; o < r.length; o++)
        if (e._lctf.coverageIndex(r[o], i[a + o]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(i, r, a) {
      for (var o = { cmds: [], crds: [] }, l = 0, c = 0; c < r.length; c++) {
        var u = r[c];
        if (u != -1) {
          for (var f = c < r.length - 1 && r[c + 1] != -1 ? r[c + 1] : 0, h = e.U.glyphToPath(i, u), d = 0; d < h.crds.length; d += 2)
            o.crds.push(h.crds[d] + l), o.crds.push(h.crds[d + 1]);
          for (a && o.cmds.push(a), d = 0; d < h.cmds.length; d++)
            o.cmds.push(h.cmds[d]);
          a && o.cmds.push("X"), l += i.hmtx.aWidth[u], c < r.length - 1 && (l += e.U.getPairAdjustment(i, u, f));
        }
      }
      return o;
    }, e.U.P = {}, e.U.P.moveTo = function(i, r, a) {
      i.cmds.push("M"), i.crds.push(r, a);
    }, e.U.P.lineTo = function(i, r, a) {
      i.cmds.push("L"), i.crds.push(r, a);
    }, e.U.P.curveTo = function(i, r, a, o, l, c, u) {
      i.cmds.push("C"), i.crds.push(r, a, o, l, c, u);
    }, e.U.P.qcurveTo = function(i, r, a, o, l) {
      i.cmds.push("Q"), i.crds.push(r, a, o, l);
    }, e.U.P.closePath = function(i) {
      i.cmds.push("Z");
    }, e.U._drawCFF = function(i, r, a, o, l) {
      for (var c = r.stack, u = r.nStems, f = r.haveWidth, h = r.width, d = r.open, m = 0, _ = r.x, g = r.y, A = 0, v = 0, y = 0, w = 0, E = 0, I = 0, C = 0, B = 0, T = 0, S = 0, D = { val: 0, size: 0 }; m < i.length; ) {
        e.CFF.getCharString(i, m, D);
        var R = D.val;
        if (m += D.size, R == "o1" || R == "o18")
          c.length % 2 != 0 && !f && (h = c.shift() + o.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0;
        else if (R == "o3" || R == "o23")
          c.length % 2 != 0 && !f && (h = c.shift() + o.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0;
        else if (R == "o4")
          c.length > 1 && !f && (h = c.shift() + o.nominalWidthX, f = !0), d && e.U.P.closePath(l), g += c.pop(), e.U.P.moveTo(l, _, g), d = !0;
        else if (R == "o5")
          for (; c.length > 0; )
            _ += c.shift(), g += c.shift(), e.U.P.lineTo(l, _, g);
        else if (R == "o6" || R == "o7")
          for (var P = c.length, L = R == "o6", V = 0; V < P; V++) {
            var U = c.shift();
            L ? _ += U : g += U, L = !L, e.U.P.lineTo(l, _, g);
          }
        else if (R == "o8" || R == "o24") {
          P = c.length;
          for (var Q = 0; Q + 6 <= P; )
            A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), _ = y + c.shift(), g = w + c.shift(), e.U.P.curveTo(l, A, v, y, w, _, g), Q += 6;
          R == "o24" && (_ += c.shift(), g += c.shift(), e.U.P.lineTo(l, _, g));
        } else {
          if (R == "o11")
            break;
          if (R == "o1234" || R == "o1235" || R == "o1236" || R == "o1237")
            R == "o1234" && (v = g, y = (A = _ + c.shift()) + c.shift(), S = w = v + c.shift(), I = w, B = g, _ = (C = (E = (T = y + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g)), R == "o1235" && (A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), T = y + c.shift(), S = w + c.shift(), E = T + c.shift(), I = S + c.shift(), C = E + c.shift(), B = I + c.shift(), _ = C + c.shift(), g = B + c.shift(), c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g)), R == "o1236" && (A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), S = w = v + c.shift(), I = w, C = (E = (T = y + c.shift()) + c.shift()) + c.shift(), B = I + c.shift(), _ = C + c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g)), R == "o1237" && (A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), T = y + c.shift(), S = w + c.shift(), E = T + c.shift(), I = S + c.shift(), C = E + c.shift(), B = I + c.shift(), Math.abs(C - _) > Math.abs(B - g) ? _ = C + c.shift() : g = B + c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g));
          else if (R == "o14") {
            if (c.length > 0 && !f && (h = c.shift() + a.nominalWidthX, f = !0), c.length == 4) {
              var q = c.shift(), oe = c.shift(), le = c.shift(), k = c.shift(), X = e.CFF.glyphBySE(a, le), fe = e.CFF.glyphBySE(a, k);
              e.U._drawCFF(a.CharStrings[X], r, a, o, l), r.x = q, r.y = oe, e.U._drawCFF(a.CharStrings[fe], r, a, o, l);
            }
            d && (e.U.P.closePath(l), d = !1);
          } else if (R == "o19" || R == "o20")
            c.length % 2 != 0 && !f && (h = c.shift() + o.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0, m += u + 7 >> 3;
          else if (R == "o21")
            c.length > 2 && !f && (h = c.shift() + o.nominalWidthX, f = !0), g += c.pop(), _ += c.pop(), d && e.U.P.closePath(l), e.U.P.moveTo(l, _, g), d = !0;
          else if (R == "o22")
            c.length > 1 && !f && (h = c.shift() + o.nominalWidthX, f = !0), _ += c.pop(), d && e.U.P.closePath(l), e.U.P.moveTo(l, _, g), d = !0;
          else if (R == "o25") {
            for (; c.length > 6; )
              _ += c.shift(), g += c.shift(), e.U.P.lineTo(l, _, g);
            A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), _ = y + c.shift(), g = w + c.shift(), e.U.P.curveTo(l, A, v, y, w, _, g);
          } else if (R == "o26")
            for (c.length % 2 && (_ += c.shift()); c.length > 0; )
              A = _, v = g + c.shift(), _ = y = A + c.shift(), g = (w = v + c.shift()) + c.shift(), e.U.P.curveTo(l, A, v, y, w, _, g);
          else if (R == "o27")
            for (c.length % 2 && (g += c.shift()); c.length > 0; )
              v = g, y = (A = _ + c.shift()) + c.shift(), w = v + c.shift(), _ = y + c.shift(), g = w, e.U.P.curveTo(l, A, v, y, w, _, g);
          else if (R == "o10" || R == "o29") {
            var te = R == "o10" ? o : a;
            if (c.length == 0)
              console.debug("error: empty stack");
            else {
              var j = c.pop(), Ae = te.Subrs[j + te.Bias];
              r.x = _, r.y = g, r.nStems = u, r.haveWidth = f, r.width = h, r.open = d, e.U._drawCFF(Ae, r, a, o, l), _ = r.x, g = r.y, u = r.nStems, f = r.haveWidth, h = r.width, d = r.open;
            }
          } else if (R == "o30" || R == "o31") {
            var Y = c.length, pe = (Q = 0, R == "o31");
            for (Q += Y - (P = -3 & Y); Q < P; )
              pe ? (v = g, y = (A = _ + c.shift()) + c.shift(), g = (w = v + c.shift()) + c.shift(), P - Q == 5 ? (_ = y + c.shift(), Q++) : _ = y, pe = !1) : (A = _, v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), _ = y + c.shift(), P - Q == 5 ? (g = w + c.shift(), Q++) : g = w, pe = !0), e.U.P.curveTo(l, A, v, y, w, _, g), Q += 4;
          } else {
            if ((R + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + R, i), R;
            c.push(R);
          }
        }
      }
      r.x = _, r.y = g, r.nStems = u, r.haveWidth = f, r.width = h, r.open = d;
    };
    var t = e, n = { Typr: t };
    return s.Typr = t, s.default = n, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function q4() {
  return function(s) {
    var e = Uint8Array, t = Uint16Array, n = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), r = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o = function(R, P) {
      for (var L = new t(31), V = 0; V < 31; ++V)
        L[V] = P += 1 << R[V - 1];
      var U = new n(L[30]);
      for (V = 1; V < 30; ++V)
        for (var Q = L[V]; Q < L[V + 1]; ++Q)
          U[Q] = Q - L[V] << 5 | V;
      return [L, U];
    }, l = o(i, 2), c = l[0], u = l[1];
    c[28] = 258, u[258] = 28;
    for (var f = o(r, 0)[0], h = new t(32768), d = 0; d < 32768; ++d) {
      var m = (43690 & d) >>> 1 | (21845 & d) << 1;
      m = (61680 & (m = (52428 & m) >>> 2 | (13107 & m) << 2)) >>> 4 | (3855 & m) << 4, h[d] = ((65280 & m) >>> 8 | (255 & m) << 8) >>> 1;
    }
    var _ = function(R, P, L) {
      for (var V = R.length, U = 0, Q = new t(P); U < V; ++U)
        ++Q[R[U] - 1];
      var q, oe = new t(P);
      for (U = 0; U < P; ++U)
        oe[U] = oe[U - 1] + Q[U - 1] << 1;
      if (L) {
        q = new t(1 << P);
        var le = 15 - P;
        for (U = 0; U < V; ++U)
          if (R[U])
            for (var k = U << 4 | R[U], X = P - R[U], fe = oe[R[U] - 1]++ << X, te = fe | (1 << X) - 1; fe <= te; ++fe)
              q[h[fe] >>> le] = k;
      } else
        for (q = new t(V), U = 0; U < V; ++U)
          R[U] && (q[U] = h[oe[R[U] - 1]++] >>> 15 - R[U]);
      return q;
    }, g = new e(288);
    for (d = 0; d < 144; ++d)
      g[d] = 8;
    for (d = 144; d < 256; ++d)
      g[d] = 9;
    for (d = 256; d < 280; ++d)
      g[d] = 7;
    for (d = 280; d < 288; ++d)
      g[d] = 8;
    var A = new e(32);
    for (d = 0; d < 32; ++d)
      A[d] = 5;
    var v = _(g, 9, 1), y = _(A, 5, 1), w = function(R) {
      for (var P = R[0], L = 1; L < R.length; ++L)
        R[L] > P && (P = R[L]);
      return P;
    }, E = function(R, P, L) {
      var V = P / 8 | 0;
      return (R[V] | R[V + 1] << 8) >> (7 & P) & L;
    }, I = function(R, P) {
      var L = P / 8 | 0;
      return (R[L] | R[L + 1] << 8 | R[L + 2] << 16) >> (7 & P);
    }, C = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], B = function(R, P, L) {
      var V = new Error(P || C[R]);
      if (V.code = R, Error.captureStackTrace && Error.captureStackTrace(V, B), !L)
        throw V;
      return V;
    }, T = function(R, P, L) {
      var V = R.length;
      if (!V || L && !L.l && V < 5)
        return P || new e(0);
      var U = !P || L, Q = !L || L.i;
      L || (L = {}), P || (P = new e(3 * V));
      var q, oe = function(Qe) {
        var Ze = P.length;
        if (Qe > Ze) {
          var Ke = new e(Math.max(2 * Ze, Qe));
          Ke.set(P), P = Ke;
        }
      }, le = L.f || 0, k = L.p || 0, X = L.b || 0, fe = L.l, te = L.d, j = L.m, Ae = L.n, Y = 8 * V;
      do {
        if (!fe) {
          L.f = le = E(R, k, 1);
          var pe = E(R, k + 1, 3);
          if (k += 3, !pe) {
            var me = R[(G = ((q = k) / 8 | 0) + (7 & q && 1) + 4) - 4] | R[G - 3] << 8, re = G + me;
            if (re > V) {
              Q && B(0);
              break;
            }
            U && oe(X + me), P.set(R.subarray(G, re), X), L.b = X += me, L.p = k = 8 * re;
            continue;
          }
          if (pe == 1)
            fe = v, te = y, j = 9, Ae = 5;
          else if (pe == 2) {
            var ye = E(R, k, 31) + 257, ae = E(R, k + 10, 15) + 4, De = ye + E(R, k + 5, 31) + 1;
            k += 14;
            for (var Ee = new e(De), Ie = new e(19), Ce = 0; Ce < ae; ++Ce)
              Ie[a[Ce]] = E(R, k + 3 * Ce, 7);
            k += 3 * ae;
            var ze = w(Ie), Fe = (1 << ze) - 1, W = _(Ie, ze, 1);
            for (Ce = 0; Ce < De; ) {
              var G, se = W[E(R, k, Fe)];
              if (k += 15 & se, (G = se >>> 4) < 16)
                Ee[Ce++] = G;
              else {
                var _e = 0, ve = 0;
                for (G == 16 ? (ve = 3 + E(R, k, 3), k += 2, _e = Ee[Ce - 1]) : G == 17 ? (ve = 3 + E(R, k, 7), k += 3) : G == 18 && (ve = 11 + E(R, k, 127), k += 7); ve--; )
                  Ee[Ce++] = _e;
              }
            }
            var ue = Ee.subarray(0, ye), Te = Ee.subarray(ye);
            j = w(ue), Ae = w(Te), fe = _(ue, j, 1), te = _(Te, Ae, 1);
          } else
            B(1);
          if (k > Y) {
            Q && B(0);
            break;
          }
        }
        U && oe(X + 131072);
        for (var Ge = (1 << j) - 1, Pe = (1 << Ae) - 1, he = k; ; he = k) {
          var Se = (_e = fe[I(R, k) & Ge]) >>> 4;
          if ((k += 15 & _e) > Y) {
            Q && B(0);
            break;
          }
          if (_e || B(2), Se < 256)
            P[X++] = Se;
          else {
            if (Se == 256) {
              he = k, fe = null;
              break;
            }
            var Ve = Se - 254;
            if (Se > 264) {
              var Ye = i[Ce = Se - 257];
              Ve = E(R, k, (1 << Ye) - 1) + c[Ce], k += Ye;
            }
            var $e = te[I(R, k) & Pe], Ne = $e >>> 4;
            if ($e || B(3), k += 15 & $e, Te = f[Ne], Ne > 3 && (Ye = r[Ne], Te += I(R, k) & (1 << Ye) - 1, k += Ye), k > Y) {
              Q && B(0);
              break;
            }
            U && oe(X + 131072);
            for (var He = X + Ve; X < He; X += 4)
              P[X] = P[X - Te], P[X + 1] = P[X + 1 - Te], P[X + 2] = P[X + 2 - Te], P[X + 3] = P[X + 3 - Te];
            X = He;
          }
        }
        L.l = fe, L.p = he, L.b = X, fe && (le = 1, L.m = j, L.d = te, L.n = Ae);
      } while (!le);
      return X == P.length ? P : function(Qe, Ze, Ke) {
        (Ze == null || Ze < 0) && (Ze = 0), (Ke == null || Ke > Qe.length) && (Ke = Qe.length);
        var $ = new (Qe instanceof t ? t : Qe instanceof n ? n : e)(Ke - Ze);
        return $.set(Qe.subarray(Ze, Ke)), $;
      }(P, 0, X);
    }, S = new e(0), D = typeof TextDecoder < "u" && new TextDecoder();
    try {
      D.decode(S, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(R) {
      var P = new DataView(R), L = 0;
      function V() {
        var ye = P.getUint16(L);
        return L += 2, ye;
      }
      function U() {
        var ye = P.getUint32(L);
        return L += 4, ye;
      }
      function Q(ye) {
        me.setUint16(re, ye), re += 2;
      }
      function q(ye) {
        me.setUint32(re, ye), re += 4;
      }
      for (var oe = { signature: U(), flavor: U(), length: U(), numTables: V(), reserved: V(), totalSfntSize: U(), majorVersion: V(), minorVersion: V(), metaOffset: U(), metaLength: U(), metaOrigLength: U(), privOffset: U(), privLength: U() }, le = 0; Math.pow(2, le) <= oe.numTables; )
        le++;
      le--;
      for (var k = 16 * Math.pow(2, le), X = 16 * oe.numTables - k, fe = 12, te = [], j = 0; j < oe.numTables; j++)
        te.push({ tag: U(), offset: U(), compLength: U(), origLength: U(), origChecksum: U() }), fe += 16;
      var Ae, Y = new Uint8Array(12 + 16 * te.length + te.reduce(function(ye, ae) {
        return ye + ae.origLength + 4;
      }, 0)), pe = Y.buffer, me = new DataView(pe), re = 0;
      return q(oe.flavor), Q(oe.numTables), Q(k), Q(le), Q(X), te.forEach(function(ye) {
        q(ye.tag), q(ye.origChecksum), q(fe), q(ye.origLength), ye.outOffset = fe, (fe += ye.origLength) % 4 != 0 && (fe += 4 - fe % 4);
      }), te.forEach(function(ye) {
        var ae, De = R.slice(ye.offset, ye.offset + ye.compLength);
        if (ye.compLength != ye.origLength) {
          var Ee = new Uint8Array(ye.origLength);
          ae = new Uint8Array(De, 2), T(ae, Ee);
        } else
          Ee = new Uint8Array(De);
        Y.set(Ee, ye.outOffset);
        var Ie = 0;
        (fe = ye.outOffset + ye.origLength) % 4 != 0 && (Ie = 4 - fe % 4), Y.set(new Uint8Array(Ie).buffer, ye.outOffset + ye.origLength), Ae = fe + Ie;
      }), pe.slice(0, Ae);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function X4(s, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, n = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, r = 2, a = 4, o = 8, l = 16, c = 32;
  let u;
  function f(E) {
    if (!u) {
      const I = {
        R: r,
        L: i,
        D: a,
        C: l,
        U: c,
        T: o
      };
      u = /* @__PURE__ */ new Map();
      for (let C in n) {
        let B = 0;
        n[C].split(",").forEach((T) => {
          let [S, D] = T.split("+");
          S = parseInt(S, 36), D = D ? parseInt(D, 36) : 0, u.set(B += S, I[C]);
          for (let R = D; R--; )
            u.set(++B, I[C]);
        });
      }
    }
    return u.get(E) || c;
  }
  const h = 1, d = 2, m = 3, _ = 4, g = [null, "isol", "init", "fina", "medi"];
  function A(E) {
    const I = new Uint8Array(E.length);
    let C = c, B = h, T = -1;
    for (let S = 0; S < E.length; S++) {
      const D = E.codePointAt(S);
      let R = f(D) | 0, P = h;
      R & o || (C & (i | a | l) ? R & (r | a | l) ? (P = m, (B === h || B === m) && I[T]++) : R & (i | c) && (B === d || B === _) && I[T]-- : C & (r | c) && (B === d || B === _) && I[T]--, B = I[S] = P, C = R, T = S, D > 65535 && S++);
    }
    return I;
  }
  function v(E, I) {
    const C = [];
    for (let T = 0; T < I.length; T++) {
      const S = I.codePointAt(T);
      S > 65535 && T++, C.push(s.U.codeToGlyph(E, S));
    }
    const B = E.GSUB;
    if (B) {
      const { lookupList: T, featureList: S } = B;
      let D;
      const R = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, P = [];
      S.forEach((L) => {
        if (R.test(L.tag))
          for (let V = 0; V < L.tab.length; V++) {
            if (P[L.tab[V]])
              continue;
            P[L.tab[V]] = !0;
            const U = T[L.tab[V]], Q = /^(isol|init|fina|medi)$/.test(L.tag);
            Q && !D && (D = A(I));
            for (let q = 0; q < C.length; q++)
              (!D || !Q || g[D[q]] === L.tag) && s.U._applySubs(C, q, U, T);
          }
      });
    }
    return C;
  }
  function y(...E) {
    for (let I = 0; I < E.length; I++)
      if (typeof E[I] == "number")
        return E[I];
  }
  function w(E) {
    const I = /* @__PURE__ */ Object.create(null), C = E["OS/2"], B = E.hhea, T = E.head.unitsPerEm, S = y(C && C.sTypoAscender, B && B.ascender, T), D = {
      unitsPerEm: T,
      ascender: S,
      descender: y(C && C.sTypoDescender, B && B.descender, 0),
      capHeight: y(C && C.sCapHeight, S),
      xHeight: y(C && C.sxHeight, S),
      lineGap: y(C && C.sTypoLineGap, B && B.lineGap),
      forEachGlyph(R, P, L, V) {
        let U = 0;
        const Q = 1 / D.unitsPerEm * P, q = v(E, R);
        let oe = 0, le = -1;
        return q.forEach((k, X) => {
          if (k !== -1) {
            let fe = I[k];
            if (!fe) {
              const { cmds: te, crds: j } = s.U.glyphToPath(E, k);
              let Ae = "", Y = 0;
              for (let ae = 0, De = te.length; ae < De; ae++) {
                const Ee = t[te[ae]];
                Ae += te[ae];
                for (let Ie = 1; Ie <= Ee; Ie++)
                  Ae += (Ie > 1 ? "," : "") + j[Y++];
              }
              let pe, me, re, ye;
              if (j.length) {
                pe = me = 1 / 0, re = ye = -1 / 0;
                for (let ae = 0, De = j.length; ae < De; ae += 2) {
                  let Ee = j[ae], Ie = j[ae + 1];
                  Ee < pe && (pe = Ee), Ie < me && (me = Ie), Ee > re && (re = Ee), Ie > ye && (ye = Ie);
                }
              } else
                pe = re = me = ye = 0;
              fe = I[k] = {
                index: k,
                advanceWidth: E.hmtx.aWidth[k],
                xMin: pe,
                yMin: me,
                xMax: re,
                yMax: ye,
                path: Ae,
                pathCommandCount: te.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            le !== -1 && (U += s.U.getPairAdjustment(E, le, k) * Q), V.call(null, fe, U, oe), fe.advanceWidth && (U += fe.advanceWidth * Q), L && (U += L * P), le = k;
          }
          oe += R.codePointAt(oe) > 65535 ? 2 : 1;
        }), U;
      }
    };
    return D;
  }
  return function(I) {
    const C = new Uint8Array(I, 0, 4), B = s._bin.readASCII(C, 0, 4);
    if (B === "wOFF")
      I = e(I);
    else if (B === "wOF2")
      throw new Error("woff2 fonts not supported");
    return w(s.parse(I)[0]);
  };
}
const Y4 = /* @__PURE__ */ Hu({
  name: "Typr Font Parser",
  dependencies: [W4, q4, X4],
  init(s, e, t) {
    const n = s(), i = e();
    return t(n, i);
  }
}), Cl = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, K4 = /* @__PURE__ */ new Je();
function Al() {
  return (self.performance || Date).now();
}
const gy = /* @__PURE__ */ Object.create(null);
function J4(s, e) {
  s = eG({}, s);
  const t = Al();
  if (s.font = tG(s.font || Cl.defaultFontURL), s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || Cl.sdfGlyphSize, s.colorRanges != null) {
    let f = {};
    for (let h in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(h)) {
        let d = s.colorRanges[h];
        typeof d != "number" && (d = K4.set(d).getHex()), f[h] = d;
      }
    s.colorRanges = f;
  }
  Object.freeze(s);
  const { textureWidth: n, sdfExponent: i } = Cl, { sdfGlyphSize: r } = s, a = n / r * 4;
  let o = gy[r];
  if (!o) {
    const f = document.createElement("canvas");
    f.width = n, f.height = r * 256 / a, o = gy[r] = {
      glyphCount: 0,
      sdfGlyphSize: r,
      sdfCanvas: f,
      sdfTexture: new wn(
        f,
        void 0,
        void 0,
        void 0,
        Yt,
        Yt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, o.sdfTexture.generateMipmaps = !1, Z4(o);
  }
  const { sdfTexture: l, sdfCanvas: c } = o;
  let u = o.glyphsByFont.get(s.font);
  u || o.glyphsByFont.set(s.font, u = /* @__PURE__ */ new Map()), iG(s).then((f) => {
    const { glyphIds: h, glyphPositions: d, fontSize: m, unitsPerEm: _, timings: g } = f, A = [], v = new Float32Array(h.length * 4), y = m / _;
    let w = 0, E = 0;
    const I = Al();
    h.forEach((D, R) => {
      let P = u.get(D);
      if (!P) {
        const { path: Q, pathBounds: q } = f.glyphData[D], oe = Math.max(q[2] - q[0], q[3] - q[1]) / r * (Cl.sdfMargin * r + 0.5), le = o.glyphCount++, k = [
          q[0] - oe,
          q[1] - oe,
          q[2] + oe,
          q[3] + oe
        ];
        u.set(D, P = { path: Q, atlasIndex: le, sdfViewBox: k }), A.push(P);
      }
      const { sdfViewBox: L } = P, V = d[E++], U = d[E++];
      v[w++] = V + L[0] * y, v[w++] = U + L[1] * y, v[w++] = V + L[2] * y, v[w++] = U + L[3] * y, h[R] = P.atlasIndex;
    }), g.quads = (g.quads || 0) + (Al() - I);
    const C = Al();
    g.sdf = {};
    const B = c.height, T = Math.ceil(o.glyphCount / a), S = Math.pow(2, Math.ceil(Math.log2(T * r)));
    S > B && (console.info(`Increasing SDF texture size ${B}->${S}`), j4(c, n, S), l.dispose()), Promise.all(A.map(
      (D) => RE(D, o, s.gpuAccelerateSDF).then(({ timing: R }) => {
        g.sdf[D.atlasIndex] = R;
      })
    )).then(() => {
      A.length && !o.contextLost && (DE(o), l.needsUpdate = !0), g.sdfTotal = Al() - C, g.total = Al() - t, e(Object.freeze({
        parameters: s,
        sdfTexture: l,
        sdfGlyphSize: r,
        sdfExponent: i,
        glyphBounds: v,
        glyphAtlasIndices: h,
        glyphColors: f.glyphColors,
        caretPositions: f.caretPositions,
        caretHeight: f.caretHeight,
        chunkedBounds: f.chunkedBounds,
        ascender: f.ascender,
        descender: f.descender,
        lineHeight: f.lineHeight,
        capHeight: f.capHeight,
        xHeight: f.xHeight,
        topBaseline: f.topBaseline,
        blockBounds: f.blockBounds,
        visibleBounds: f.visibleBounds,
        timings: f.timings
      }));
    });
  }), Promise.resolve().then(() => {
    o.contextLost || H4(c);
  });
}
function RE({ path: s, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: n, sdfCanvas: i, contextLost: r }, a) {
  if (r)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: o, sdfExponent: l } = Cl, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), f = u % (o / n) * n, h = Math.floor(u / (o / n)) * n, d = e % 4;
  return N4(n, n, s, t, c, l, i, f, h, d, a);
}
function Z4(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), s.contextLost = !1;
    const n = [];
    s.glyphsByFont.forEach((i) => {
      i.forEach((r) => {
        n.push(RE(r, s, !0));
      });
    }), Promise.all(n).then(() => {
      DE(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function eG(s, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (s[t] = e[t]);
  return s;
}
let _h;
function tG(s) {
  return _h || (_h = typeof document > "u" ? {} : document.createElement("a")), _h.href = s, _h.href;
}
function DE(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = s, { width: n, height: i } = e, r = s.sdfCanvas.getContext("webgl");
    let a = t.image.data;
    (!a || a.length !== n * i * 4) && (a = new Uint8Array(n * i * 4), t.image = { width: n, height: i, data: a }, t.flipY = !1, t.isDataTexture = !0), r.readPixels(0, 0, n, i, r.RGBA, r.UNSIGNED_BYTE, a);
  }
}
const nG = /* @__PURE__ */ Hu({
  name: "Typesetter",
  dependencies: [
    Cl,
    Y4,
    O4,
    TE
  ],
  init(s, e, t, n) {
    const { defaultFontURL: i } = s;
    return t(e, n(), { defaultFontURL: i });
  }
}), iG = /* @__PURE__ */ Hu({
  name: "Typesetter",
  dependencies: [
    nG
  ],
  init(s) {
    return function(e) {
      return new Promise((t) => {
        s.typeset(e, t);
      });
    };
  },
  getTransferables(s) {
    const e = [
      s.glyphPositions.buffer,
      s.glyphIds.buffer
    ];
    return s.caretPositions && e.push(s.caretPositions.buffer), s.glyphColors && e.push(s.glyphColors.buffer), e;
  }
}), Ay = {};
function rG(s) {
  let e = Ay[s];
  if (!e) {
    const t = new Fi(1, 1, s, s), n = t.clone(), i = t.attributes, r = n.attributes, a = new Dt(), o = i.uv.count;
    for (let l = 0; l < o; l++)
      r.position.array[l * 3] *= -1, r.normal.array[l * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((l) => {
      a.setAttribute(
        l,
        new ht(
          [...i[l].array, ...r[l].array],
          i[l].itemSize
        )
      );
    }), a.setIndex([...t.index.array, ...n.index.array.map((l) => l + o)]), a.translate(0.5, 0.5, 0), e = Ay[s] = a;
  }
  return e;
}
const sG = "aTroikaGlyphBounds", _y = "aTroikaGlyphIndex", oG = "aTroikaGlyphColor";
let aG = class extends Ld {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Vn(), this.boundingBox = new dn();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Kn ? t / 2 : 0, e === zn ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = rG(e);
      ["position", "normal", "uv"].forEach((n) => {
        this.attributes[n] = t.attributes[n].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, n, i, r) {
    Gm(this, sG, e, 4), Gm(this, _y, t, 1), Gm(this, oG, r, 3), this._blockBounds = n, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: n } = this;
      if (t) {
        const { PI: i, floor: r, min: a, max: o, sin: l, cos: c } = Math, u = i / 2, f = i * 2, h = Math.abs(t), d = e[0] / h, m = e[2] / h, _ = r((d + u) / f) !== r((m + u) / f) ? -h : a(l(d) * h, l(m) * h), g = r((d - u) / f) !== r((m - u) / f) ? h : o(l(d) * h, l(m) * h), A = r((d + i) / f) !== r((m + i) / f) ? h * 2 : o(h - c(d) * h, h - c(m) * h);
        n.min.set(_, e[1], t < 0 ? -A : 0), n.max.set(g, e[3], t < 0 ? 0 : A);
      } else
        n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
      n.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(_y).count, n = this._chunkedBounds;
    if (n)
      for (let i = n.length; i--; ) {
        t = n[i].end;
        let r = n[i].rect;
        if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
};
function Gm(s, e, t, n) {
  const i = s.getAttribute(e);
  t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (s.setAttribute(e, new cs(t, n)), delete s._maxInstanceCount, s.dispose()) : i && s.deleteAttribute(e);
}
const lG = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, cG = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, uG = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, fG = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function hG(s) {
  const e = jg(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new ke() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Xt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Xt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new ke() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Je() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Ot() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: lG,
    vertexTransform: cG,
    fragmentDefs: uG,
    fragmentColorTransform: fG,
    customRewriter({ vertexShader: t, fragmentShader: n }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return i.test(n) && (n = n.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(
        BE,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: n };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const i0 = /* @__PURE__ */ new $n({
  color: 16777215,
  side: zn,
  transparent: !0
}), by = 8421504, vy = /* @__PURE__ */ new st(), bh = /* @__PURE__ */ new H(), Qm = /* @__PURE__ */ new H(), $c = [], dG = /* @__PURE__ */ new H(), zm = "+x+y";
function yy(s) {
  return Array.isArray(s) ? s[0] : s;
}
let LE = () => {
  const s = new tt(
    new Fi(1, 1),
    i0
  );
  return LE = () => s, s;
}, kE = () => {
  const s = new tt(
    new Fi(1, 1, 32, 1),
    i0
  );
  return kE = () => s, s;
};
const pG = { type: "syncstart" }, mG = { type: "synccomplete" }, UE = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], gG = UE.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
let En = class extends tt {
  constructor() {
    const e = new aG();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = 0.1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = by, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = zm, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(pG), J4({
      text: this.text,
      font: this.font,
      fontSize: this.fontSize || 0.1,
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const n = this._queuedSyncs;
      n && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        n.forEach((i) => i && i());
      })), this.dispatchEvent(mG), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, n, i, r, a) {
    this.sync(), r.isTroikaTextMaterial && this._prepareForRender(r), r._hadOwnSide = r.hasOwnProperty("side"), this.geometry.setSide(r._actualSide = r.side), r.side = Hi;
  }
  onAfterRender(e, t, n, i, r, a) {
    r._hadOwnSide ? r.side = r._actualSide : delete r.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = i0.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = hG(t), t.addEventListener("dispose", function n() {
      t.removeEventListener("dispose", n), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let n = e._outlineMtl;
      return n || (n = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), n.isTextOutlineMaterial = !0, n.depthWrite = !1, n.map = null, e.addEventListener("dispose", function i() {
        e.removeEventListener("dispose", i), n.dispose();
      })), [
        n,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return yy(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return yy(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, n = e.uniforms, i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: o, blockBounds: l } = i;
      n.uTroikaSDFTexture.value = o, n.uTroikaSDFTextureSize.value.set(o.image.width, o.image.height), n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, n.uTroikaSDFExponent.value = i.sdfExponent, n.uTroikaTotalBounds.value.fromArray(l), n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
      let c = 0, u = 0, f = 0, h, d, m, _ = 0, g = 0;
      if (t) {
        let { outlineWidth: v, outlineOffsetX: y, outlineOffsetY: w, outlineBlur: E, outlineOpacity: I } = this;
        c = this._parsePercent(v) || 0, u = Math.max(0, this._parsePercent(E) || 0), h = I, _ = this._parsePercent(y) || 0, g = this._parsePercent(w) || 0;
      } else
        f = Math.max(0, this._parsePercent(this.strokeWidth) || 0), f && (m = this.strokeColor, n.uTroikaStrokeColor.value.set(m ?? by), d = this.strokeOpacity, d == null && (d = 1)), h = this.fillOpacity;
      n.uTroikaDistanceOffset.value = c, n.uTroikaPositionOffset.value.set(_, g), n.uTroikaBlurRadius.value = u, n.uTroikaStrokeWidth.value = f, n.uTroikaStrokeOpacity.value = d, n.uTroikaFillOpacity.value = h ?? 1, n.uTroikaCurveRadius.value = this.curveRadius || 0;
      let A = this.clipRect;
      if (A && Array.isArray(A) && A.length === 4)
        n.uTroikaClipRect.value.fromArray(A);
      else {
        const v = (this.fontSize || 0.1) * 100;
        n.uTroikaClipRect.value.set(
          l[0] - v,
          l[1] - v,
          l[2] + v,
          l[3] + v
        );
      }
      this.geometry.applyClipRect(n.uTroikaClipRect.value);
    }
    n.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const r = t ? this.outlineColor || 0 : this.color;
    if (r == null)
      delete e.color;
    else {
      const o = e.hasOwnProperty("color") ? e.color : e.color = new Je();
      (r !== o._input || typeof r == "object") && o.set(o._input = r);
    }
    let a = this.orientation || zm;
    if (a !== e._orientation) {
      let o = n.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let l = a !== zm && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, f, h] = l;
        bh.set(0, 0, 0)[u] = c === "-" ? 1 : -1, Qm.set(0, 0, 0)[h] = f === "-" ? -1 : 1, vy.lookAt(dG, bh.cross(Qm), Qm), o.setFromMatrix4(vy);
      } else
        o.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), n = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(n) ? 0 : n / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new ke()) {
    t.copy(e);
    const n = this.curveRadius;
    return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new ke()) {
    return bh.copy(e), this.localPositionToTextCoords(this.worldToLocal(bh), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: n, curveRadius: i } = this;
    if (n) {
      const r = n.blockBounds, a = i ? kE() : LE(), o = a.geometry, { position: l, uv: c } = o.attributes;
      for (let u = 0; u < c.count; u++) {
        let f = r[0] + c.getX(u) * (r[2] - r[0]);
        const h = r[1] + c.getY(u) * (r[3] - r[1]);
        let d = 0;
        i && (d = i - Math.cos(f / i) * i, f = Math.sin(f / i) * i), l.setXYZ(u, f, h, d);
      }
      o.boundingSphere = this.geometry.boundingSphere, o.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, $c.length = 0, a.raycast(e, $c);
      for (let u = 0; u < $c.length; u++)
        $c[u].object = this, t.push($c[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, gG.forEach((n) => {
      this[n] = e[n];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
UE.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(En.prototype, s, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
class AG {
  //
  constructor(e) {
    var t;
    this._charts = /* @__PURE__ */ new Map(), this._width = 400, this._height = 110, this._backgroundOpacity = 0.7, this._perf = e.perf, this._backgroundOpacity = (t = e.backgroundOpacity) != null ? t : this._backgroundOpacity, this.wrapper = document.createElement("div"), this.wrapper.id = "three-perf-ui", this.wrapper.style.position = "fixed", this.wrapper.style.bottom = "0", this.wrapper.style.left = "0", this.wrapper.style.width = this._width + "px", this.wrapper.style.height = this._height + "px", e.domElement.appendChild(this.wrapper), this.canvas = document.createElement("canvas"), this.canvas.width = this._width, this.canvas.height = this._height, this.canvas.style.position = "absolute", this.wrapper.appendChild(this.canvas), this.initCanvas();
  }
  setScale(e) {
    this.wrapper.style.width = e * this.width + "px", this.wrapper.style.height = e * this.height + "px", this._renderer.setSize(this._width * e, this._height * e, !0);
  }
  initCanvas() {
    this._renderer = new xA({ canvas: this.canvas, antialias: !0, alpha: !0 }), this._renderer.setClearColor(0, this._backgroundOpacity), this._renderer.setPixelRatio(window.devicePixelRatio), this._scene = new Jl(), this._camera = new yo(0, this._width, 0, -this._height, 0.1, 100), this._camera.position.set(0, 0, 10), this._camera.lookAt(0, 0, 0), this._camera.updateProjectionMatrix(), this._scene.add(this._camera), this._scene.userData.useStats = !1;
    const e = new En();
    e.anchorX = "right", e.position.set(45, -8, 0), e.text = "0.000", e.fontSize = 15, e.color = "rgb(253, 151, 31)", e.sync(), this._scene.add(e);
    const t = new En();
    t.anchorX = "right", t.position.set(65, -7, 0), t.text = "ms", t.fontSize = 9, t.color = "rgb(255, 255, 255)", t.sync(), this._scene.add(t);
    const n = new En();
    n.anchorX = "right", n.position.set(65, -22, 0), n.text = "GPU", n.fontSize = 9, n.color = "rgb(253, 151, 31)", n.sync(), this._scene.add(n);
    const i = new En();
    i.anchorX = "right", i.position.set(115, -8, 0), i.text = "0.000", i.fontSize = 15, i.color = "rgb(66, 226, 46)", i.sync(), this._scene.add(i);
    const r = new En();
    r.anchorX = "right", r.position.set(135, -7, 0), r.text = "ms", r.fontSize = 9, r.color = "rgb(255, 255, 255)", r.sync(), this._scene.add(r);
    const a = new En();
    a.anchorX = "right", a.position.set(135, -22, 0), a.text = "CPU", a.fontSize = 9, a.color = "rgb(66, 226, 46)", a.sync(), this._scene.add(a);
    const o = new En();
    o.anchorX = "center", o.position.set(165, -8, 0), o.text = "0", o.fontSize = 15, o.color = "rgb(238, 38, 110)", o.sync(), this._scene.add(o);
    const l = new En();
    l.anchorX = "center", l.position.set(175, -22, 0), l.text = "FPS", l.fontSize = 9, l.color = "rgb(238, 38, 110)", l.sync(), this._scene.add(l);
    const c = new En();
    c.anchorX = "right", c.position.set(235, -8, 0), c.text = "0", c.fontSize = 15, c.color = "#ffffff", c.sync(), this._scene.add(c);
    const u = new En();
    u.anchorX = "right", u.position.set(235, -22, 0), u.text = "calls", u.fontSize = 9, u.color = "rgb(101, 197, 188)", u.sync(), this._scene.add(u);
    const f = new En();
    f.anchorX = "right", f.position.set(315, -8, 0), f.text = "0", f.fontSize = 15, f.color = "#ffffff", f.sync(), this._scene.add(f);
    const h = new En();
    h.anchorX = "right", h.position.set(315, -22, 0), h.text = "triangles", h.fontSize = 9, h.color = "rgb(101, 197, 188)", h.sync(), this._scene.add(h);
    const d = new En();
    d.anchorX = "right", d.position.set(365, -8, 0), d.text = "0", d.fontSize = 15, d.color = "#ffffff", d.sync(), this._scene.add(d);
    const m = new En();
    m.anchorX = "right", m.position.set(365, -22, 0), m.text = "passes", m.fontSize = 9, m.color = "rgb(101, 197, 188)", m.sync(), this._scene.add(m), this._basicInfoElements = {
      gpuValue: e,
      cpuValue: i,
      fpsValue: o,
      callsValue: c,
      trianglesValue: f,
      renderpassesValue: d
    };
    const _ = new En();
    _.anchorX = "right", _.position.set(65, -39, 0), _.text = "0", _.fontSize = 15, _.color = "#ffffff", _.sync(), this._scene.add(_);
    const g = new En();
    g.anchorX = "right", g.position.set(65, -53, 0), g.text = "geometries", g.fontSize = 9, g.color = "rgb(101, 197, 188)", g.sync(), this._scene.add(g);
    const A = new En();
    A.anchorX = "right", A.position.set(135, -39, 0), A.text = "0", A.fontSize = 15, A.color = "#ffffff", A.sync(), this._scene.add(A);
    const v = new En();
    v.anchorX = "right", v.position.set(135, -53, 0), v.text = "textures", v.fontSize = 9, v.color = "rgb(101, 197, 188)", v.sync(), this._scene.add(v);
    const y = new En();
    y.anchorX = "right", y.position.set(205, -39, 0), y.text = "0", y.fontSize = 15, y.color = "#ffffff", y.sync(), this._scene.add(y);
    const w = new En();
    w.anchorX = "right", w.position.set(205, -53, 0), w.text = "shaders", w.fontSize = 9, w.color = "rgb(101, 197, 188)", w.sync(), this._scene.add(w);
    const E = new En();
    E.anchorX = "right", E.position.set(275, -39, 0), E.text = "0", E.fontSize = 15, E.color = "#ffffff", E.sync(), this._scene.add(E);
    const I = new En();
    I.anchorX = "right", I.position.set(275, -53, 0), I.text = "lines", I.fontSize = 9, I.color = "rgb(101, 197, 188)", I.sync(), this._scene.add(I);
    const C = new En();
    C.anchorX = "right", C.position.set(345, -39, 0), C.text = "0", C.fontSize = 15, C.color = "#ffffff", C.sync(), this._scene.add(C);
    const B = new En();
    B.anchorX = "right", B.position.set(345, -53, 0), B.text = "points", B.fontSize = 9, B.color = "rgb(101, 197, 188)", B.sync(), this._scene.add(B), this._memInfoElements = {
      geometriesValue: _,
      geometriesLabel: g,
      texturesValue: A,
      texturesLabel: v,
      shadersValue: y,
      shadersLabel: w,
      linesValue: E,
      linesLabel: I,
      pointsValue: C,
      pointsLabel: B
    };
    const T = new Dt();
    let S = new Float32Array(60 * 3);
    for (let Q = 0; Q < 60; Q++)
      S[3 * Q + 0] = this._width / 59 * Q, S[3 * Q + 1] = -110, S[3 * Q + 2] = 0;
    let D = new Rt(S, 3);
    D.usage = Pl, T.setAttribute("position", D);
    const R = new qn(T, new Jn({ color: "rgb(253, 151, 31)" }));
    this._scene.add(R), this._charts.set("gpu", R);
    const P = new Dt();
    S = new Float32Array(60 * 3);
    for (let Q = 0; Q < 60; Q++)
      S[3 * Q + 0] = this._width / 59 * Q, S[3 * Q + 1] = -110, S[3 * Q + 2] = 0;
    D = new Rt(S, 3), D.usage = Pl, P.setAttribute("position", D);
    const L = new qn(P, new Jn({ color: "rgb(66, 226, 46)" }));
    this._scene.add(L), this._charts.set("cpu", L);
    const V = new Dt();
    S = new Float32Array(60 * 3);
    for (let Q = 0; Q < 60; Q++)
      S[3 * Q + 0] = this._width / 59 * Q, S[3 * Q + 1] = -110, S[3 * Q + 2] = 0;
    D = new Rt(S, 3), D.usage = Pl, V.setAttribute("position", D);
    const U = new qn(V, new Jn({ color: "rgb(238, 38, 110)" }));
    this._scene.add(U), this._charts.set("fps", U);
  }
  update() {
    var e, t;
    if (this._perf.chart && this._perf.showGraph)
      for (const n in this._perf.chart.data) {
        const i = this._perf.chart.data[n];
        if (!this._charts.get(n) || !i)
          continue;
        const a = this._charts.get(n).geometry.attributes.position;
        let o = 0;
        for (let l = 0; l < i.length; l++)
          i[l] > o && (o = i[l]);
        o = Math.max(o, 20);
        for (let l = 0; l < i.length; l++) {
          let c = (this._perf.chart.circularId + l + 1) % 60;
          a.setY(l, (i[c] / o * 90 - 110) * this.height / 110);
        }
        a.needsUpdate = !0;
      }
    this._basicInfoElements.gpuValue.text = this._perf.log.gpu.toFixed(3), this._basicInfoElements.cpuValue.text = this._perf.log.cpu.toFixed(3), this._basicInfoElements.fpsValue.text = this._perf.log.fps.toFixed(0), this._basicInfoElements.callsValue.text = this._perf.threeRenderer.info.render.calls.toString(), this._basicInfoElements.trianglesValue.text = this._perf.threeRenderer.info.render.triangles.toString(), this._basicInfoElements.renderpassesValue.text = this._perf.renderPassesNumber.toString(), this._memInfoElements.geometriesValue.text = this._perf.threeRenderer.info.memory.geometries.toString(), this._memInfoElements.texturesValue.text = this._perf.threeRenderer.info.memory.textures.toString(), this._memInfoElements.shadersValue.text = (t = (e = this._perf.threeRenderer.info.programs) == null ? void 0 : e.length.toString()) != null ? t : "", this._memInfoElements.linesValue.text = this._perf.threeRenderer.info.render.lines.toString(), this._memInfoElements.pointsValue.text = this._perf.threeRenderer.info.render.points.toString(), this.render();
  }
  render() {
    this._renderer.render(this._scene, this._camera);
  }
  dispose() {
    this.wrapper.remove();
  }
  //
  toggleVisibility(e) {
    this.wrapper.style.display = e ? "block" : "none";
  }
  toggleCharts(e) {
    this._charts.forEach((t) => {
      t.visible = e;
    }), this._perf.showGraph ? this.height = this._perf.memory ? 110 : 70 : this.height = this._perf.memory ? 70 : 40, this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  toggleMemoryInfo(e) {
    for (const t in this._memInfoElements)
      this._memInfoElements[t].visible = e;
    this.width = 380, this._perf.showGraph ? this.height = this._perf.memory ? 110 : 70 : this.height = this._perf.memory ? 70 : 40, this.wrapper.style.width = this._perf.scale * this.width + "px", this.wrapper.style.height = this._perf.scale * this.height + "px";
  }
  setBackgroundOpacity(e) {
    this._backgroundOpacity = e, this._renderer.setClearColor(0, this._backgroundOpacity), this.render();
  }
  //
  get width() {
    return this._width;
  }
  set width(e) {
    this._width = e, this._camera.right = e, this._camera.updateProjectionMatrix(), this._renderer.setSize(this._perf.scale * this._width, this._perf.scale * this._height), this.render();
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e, this._camera.bottom = -e, this._camera.updateProjectionMatrix(), this._renderer.setSize(this._perf.scale * this._width, this._perf.scale * this._height), this.render();
  }
}
const Zr = {
  value: 0,
  fpsLimit: 60,
  isOverLimit: 0
}, Vc = (s) => (s == null ? void 0 : s.reduce((e, t) => e + t, 0)) / s.length;
class _G {
  //
  constructor(e) {
    this.names = [""], this.finished = [], this.paused = !1, this.overClock = !1, this.queryHasResult = !1, this.queryCreated = !1, this.isWebGL2 = !0, this.memAccums = [], this.gpuAccums = [], this.activeAccums = [], this.logsAccums = {
      mem: [],
      gpu: [],
      cpu: [],
      fps: [],
      fpsFixed: []
    }, this.fpsChart = [], this.gpuChart = [], this.cpuChart = [], this.memChart = [], this.paramLogger = () => {
    }, this.glFinish = () => {
    }, this.chartLogger = () => {
    }, this.chartLen = 60, this.logsPerSecond = 10, this.maxMemory = 1500, this.chartHz = 10, this.startCpuProfiling = !1, this.lastCalculateFixed = 0, this.chartFrame = 0, this.gpuTimeProcess = 0, this.chartTime = 0, this.activeQueries = 0, this.circularId = 0, this.detected = 0, this.frameId = 0, this.rafId = 0, this.idleCbId = 0, this.checkQueryId = 0, this.uuid = void 0, this.currentCpu = 0, this.currentMem = 0, this.paramFrame = 0, this.paramTime = 0, this.now = () => {
    }, this.t0 = 0, this.nextFps = (t) => {
      const n = 16.666666666666668, i = n - t.timeRemaining(), r = n * Zr.fpsLimit / 10 / i;
      r < 0 || (Zr.value = r, Zr.isOverLimit < 25 ? Zr.isOverLimit++ : this.perf.overclockingFps = !0);
    }, this.nextFrame = (t) => {
      this.frameId++;
      const n = t || this.now();
      let i = n - this.paramTime, r = 0;
      if (this.frameId <= 1)
        this.paramFrame = this.frameId, this.paramTime = n;
      else if (n >= this.paramTime) {
        this.maxMemory = window.performance.memory ? window.performance.memory.jsHeapSizeLimit / 1048576 : 0;
        const a = this.frameId - this.paramFrame, o = a * 1e3 / i, l = this.perf.overclockingFps ? Zr.value : o;
        if (r = this.isWebGL2 ? this.gpuAccums[0] : this.gpuAccums[0] / i, this.isWebGL2 ? this.gpuAccums[0] = 0 : Promise.all(this.finished).then(() => {
          this.gpuAccums[0] = 0, this.finished = [];
        }), this.currentMem = Math.round(window.performance && window.performance.memory ? window.performance.memory.usedJSHeapSize / 1048576 : 0), window.performance && this.startCpuProfiling) {
          window.performance.mark("cpu-finished");
          const c = performance.measure("cpu-duration", "cpu-started", "cpu-finished");
          this.currentCpu = c.duration, this.logsAccums.cpu.push(this.currentCpu), this.startCpuProfiling = !1;
        }
        this.logsAccums.mem.push(this.currentMem), this.logsAccums.fpsFixed.push(o), this.logsAccums.fps.push(l), this.logsAccums.gpu.push(r), this.overClock && typeof window.requestIdleCallback < "u" && (Zr.isOverLimit > 0 && l > o ? Zr.isOverLimit-- : this.perf.overclockingFps && (this.perf.overclockingFps = !1)), n >= this.paramTime + 1e3 / this.logsPerSecond && (this.paramLogger({
          cpu: Vc(this.logsAccums.cpu),
          gpu: Vc(this.logsAccums.gpu),
          mem: Vc(this.logsAccums.mem),
          fps: Vc(this.logsAccums.fps),
          duration: Math.round(i),
          maxMemory: this.maxMemory,
          frameCount: a
        }), this.logsAccums.mem = [], this.logsAccums.fps = [], this.logsAccums.gpu = [], this.logsAccums.cpu = [], this.paramFrame = this.frameId, this.paramTime = n), this.overClock && n - this.lastCalculateFixed >= 2 * 1e3 && (this.lastCalculateFixed = t, Zr.fpsLimit = Math.round(Vc(this.logsAccums.fpsFixed) / 10) * 100, this.perf.fpsLimit = Zr.fpsLimit / 10, this.logsAccums.fpsFixed = [], this.paramFrame = this.frameId, this.paramTime = n);
      }
      if (!this.detected || !this.chartFrame)
        this.chartFrame = this.frameId, this.chartTime = n, this.circularId = 0;
      else {
        const a = n - this.chartTime;
        let o = this.chartHz * a / 1e3;
        for (; --o > 0 && this.detected; ) {
          const c = (this.frameId - this.chartFrame) / a * 1e3, u = this.perf.overclockingFps ? Zr.value : c;
          this.fpsChart[this.circularId % this.chartLen] = u;
          const f = 1e3 / this.currentMem, h = this.currentCpu, d = (this.isWebGL2 ? this.gpuAccums[1] * 2 : Math.round(this.gpuAccums[1] / i * 100)) + 4;
          d > 0 && (this.gpuChart[this.circularId % this.chartLen] = d), h > 0 && (this.cpuChart[this.circularId % this.chartLen] = h), f > 0 && (this.memChart[this.circularId % this.chartLen] = f);
          for (let m = 0; m < this.names.length; m++)
            this.chartLogger({
              i: m,
              data: {
                fps: this.fpsChart,
                gpu: this.gpuChart,
                cpu: this.cpuChart,
                mem: this.memChart
              },
              circularId: this.circularId
            });
          this.circularId++, this.chartFrame = this.frameId, this.chartTime = n;
        }
      }
    }, this.perf = e.perf, this.trackGPU = e.trackGPU, this.overClock = e.overClock, this.logsPerSecond = e.logsPerSecond, this.gl = e.gl, this.paramLogger = e.paramLogger, this.chartLogger = e.chartLogger, window.GLPerf = window.GLPerf || {}, this.fpsChart = new Array(this.chartLen).fill(0), this.gpuChart = new Array(this.chartLen).fill(0), this.cpuChart = new Array(this.chartLen).fill(0), this.memChart = new Array(this.chartLen).fill(0), this.now = () => window.performance && window.performance.now ? window.performance.now() : Date.now(), this.initGpu(), this.is120hz();
  }
  initGpu() {
    this.uuid = ls.generateUUID(), this.gl && (this.isWebGL2 = !0, this.extension || (this.extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")), this.extension === null && (this.isWebGL2 = !1));
  }
  /**
   * 120hz device detection
   */
  is120hz() {
    let e = 0;
    const t = (n) => {
      ++e < 20 ? this.rafId = window.requestAnimationFrame(t) : (this.detected = Math.ceil(1e3 * e / (n - this.t0) / 70), window.cancelAnimationFrame(this.rafId)), this.t0 || (this.t0 = n);
    };
    this.rafId = window.requestAnimationFrame(t);
  }
  /**
   * Explicit UI add
   * @param { string | undefined } name
   */
  addUI(e) {
    this.names.indexOf(e) === -1 && (this.names.push(e), this.gpuAccums.push(0), this.activeAccums.push(!1));
  }
  startGpu() {
    const e = this.gl, t = this.extension;
    if (!(!e || !t) && this.isWebGL2) {
      let n = !1, i, r;
      if (this.query) {
        this.queryHasResult = !1;
        let a = this.query;
        if (n = e.getQueryParameter(a, e.QUERY_RESULT_AVAILABLE), i = e.getParameter(t.GPU_DISJOINT_EXT), n && !i) {
          r = e.getQueryParameter(this.query, e.QUERY_RESULT);
          const o = r * 1e-6;
          (n || i) && (e.deleteQuery(this.query), a = null), n && o > 0 && (i || this.activeAccums.forEach((l, c) => {
            this.gpuAccums[c] = o;
          }));
        }
      }
      (n || !this.query) && (this.queryCreated = !0, this.query = e.createQuery(), e.beginQuery(t.TIME_ELAPSED_EXT, this.query));
    }
  }
  endGpu() {
    const e = this.extension, t = this.gl;
    this.isWebGL2 && this.queryCreated && t.getQuery(e.TIME_ELAPSED_EXT, t.CURRENT_QUERY) && t.endQuery(e.TIME_ELAPSED_EXT);
  }
  /**
   * Begin named measurement
   * @param { string | undefined } name
   */
  begin(e) {
    this.startGpu(), this.updateAccums(e);
  }
  /**
   * End named measure
   * @param { string | undefined } name
   */
  end(e) {
    this.endGpu(), this.updateAccums(e);
  }
  updateAccums(e) {
    let t = this.names.indexOf(e);
    t === -1 && (t = this.names.length, this.addUI(e));
    const n = this.now();
    this.activeAccums[t] = !this.activeAccums[t], this.t0 = n;
  }
}
Gt.prototype.updateMatrixWorld;
Gt.prototype.updateWorldMatrix;
Gt.prototype.updateMatrix;
const xy = ["calls", "triangles", "points", "lines"], wy = ["gpu", "cpu", "mem", "fps"];
class bG {
  //
  constructor(e) {
    var t, n, i, r, a, o, l, c, u, f, h, d;
    this.gui = new E4.Pane(), this.accumulated = {
      totalFrames: 0,
      log: {
        i: 0,
        maxMemory: 0,
        gpu: 0,
        mem: 0,
        cpu: 0,
        fps: 0,
        duration: 0,
        frameCount: 0
      },
      gl: {
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
        counts: 0
      },
      max: {
        log: {
          i: 0,
          maxMemory: 0,
          gpu: 0,
          mem: 0,
          cpu: 0,
          fps: 0,
          duration: 0,
          frameCount: 0
        },
        gl: {
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0,
          counts: 0
        }
      }
    }, this.renderPassesNumber = 0, this._keypressed = "", this._guiVisible = !0, this.actionToCallUI = "dev", this.keypressHandler = (E) => {
      if (!this.actionToCallUI)
        return;
      this._keypressed += E.key;
      const I = this._keypressed.split("");
      for (; I.length > this.actionToCallUI.length; )
        I.shift();
      I.join("") === this.actionToCallUI && (this._keypressed = "", this.guiVisible = !this.guiVisible);
    }, this.afterRender = () => {
      this._enabled && (this.perfEngine.paused || (this.perfEngine.nextFrame(window.performance.now()), this.perfEngine.overClock && typeof window.requestIdleCallback < "u" && (this.perfEngine.idleCbId = requestIdleCallback(this.perfEngine.nextFps))), this.perfEngine && this.perfEngine.end("profiler"), window.performance && (window.performance.mark("cpu-started"), this.perfEngine.startCpuProfiling = !0), this.deepAnalyze);
    }, this.deepAnalyze = (t = e.deepAnalyze) != null ? t : !1, this.threeRenderer = e.renderer, this.ui = new AG({ perf: this, domElement: e.domElement, backgroundOpacity: e.backgroundOpacity }), this._visible = (n = e.visible) != null ? n : !0, this._enabled = (i = e.enabled) != null ? i : !0, this.scale = (r = e.scale) != null ? r : 1, this.anchorX = (a = e.anchorX) != null ? a : "left", this.anchorY = (o = e.anchorY) != null ? o : "top", this.showGraph = (l = e.showGraph) != null ? l : !0, this.memory = (c = e.memory) != null ? c : !0, this.actionToCallUI = (u = e.actionToCallUI) != null ? u : "", this.guiVisible = (f = e.guiVisible) != null ? f : !1, this.gui.element.parentElement.style.width = "300px", window.addEventListener("keypress", this.keypressHandler);
    const m = (h = e.overClock) != null ? h : !0;
    this.perfEngine = new _G({
      perf: this,
      trackGPU: !0,
      overClock: m,
      chartLen: 120,
      // chart ? chart.length : 120,
      chartHz: 60,
      // chart ? chart.hz : 60,
      logsPerSecond: (d = e.logsPerSecond) != null ? d : 10,
      gl: e.renderer.getContext(),
      chartLogger: (E) => {
        this.chart = E;
      },
      paramLogger: (E) => {
        if (!this._enabled)
          return;
        const I = {
          maxMemory: E.maxMemory,
          gpu: E.gpu,
          cpu: E.cpu,
          mem: E.mem,
          fps: E.fps,
          totalTime: E.duration,
          frameCount: E.frameCount
        };
        this.log = I;
        const C = this.accumulated, B = this.threeRenderer.info.render;
        C.totalFrames++, C.gl.calls += B.calls, C.gl.triangles += B.triangles, C.gl.points += B.points, C.gl.lines += B.lines, C.log.gpu += E.gpu, C.log.cpu += E.cpu, C.log.mem += E.mem, C.log.fps += E.fps;
        for (let T = 0; T < xy.length; T++) {
          const S = xy[T], D = B[S];
          D > C.max.gl[S] && (C.max.gl[S] = D);
        }
        for (let T = 0; T < wy.length; T++) {
          const S = wy[T], D = E[S];
          D > C.max.log[S] && (C.max.log[S] = D);
        }
        this.accumulated = C, this.ui.update();
      }
    });
    const _ = e.renderer.getContext();
    let g = null, A = null;
    const v = _.getExtension("WEBGL_debug_renderer_info"), y = _.getParameter(_.VERSION);
    v != null && (g = _.getParameter(v.UNMASKED_RENDERER_WEBGL), A = _.getParameter(v.UNMASKED_VENDOR_WEBGL)), A || (A = "Unknown vendor"), g || (g = _.getParameter(_.RENDERER)), this.startTime = performance.now(), this.infos = {
      version: y,
      renderer: g,
      vendor: A
    }, this.rendererRender = this.threeRenderer.render, this.threeRenderer.info.autoReset = !1, this.threeRenderer.render = (E, I) => {
      this.renderPassesNumber++, this.rendererRender.call(this.threeRenderer, E, I);
    }, this.guiFolder = this.gui.addFolder({ title: "Settings" });
    const w = this.guiFolder.addFolder({ title: "ThreePerf" });
    w.addInput(this, "visible", { label: "Visible" }), w.addInput(this, "enabled", { label: "Enabled" }), w.addInput(this, "anchorX", { label: "xAnchor", options: { left: "left", right: "right" } }), w.addInput(this, "anchorY", { label: "yAnchor", options: { top: "top", bottom: "bottom" } }), w.addInput(this, "backgroundOpacity", { label: "Background opacity", min: 0, max: 1, step: 0.1 }), w.addInput(this, "memory", { label: "Memory" }), w.addInput(this, "showGraph", { label: "Charts" }), w.addInput(this, "scale", { label: "Scale", min: 0.1, max: 2, step: 0.1 }), w.addInput(this, "logsPerSecond", { label: "LogsPerSecond", min: 1, max: 60, step: 1 }), console.log("ThreePerf inited.");
  }
  begin() {
    this.perfEngine.begin("profiler");
  }
  end() {
    this.afterRender(), this.renderPassesNumber = 0, this.threeRenderer.info.reset();
  }
  dispose() {
    var e;
    this.ui.dispose(), (e = this.gui.element.parentElement) == null || e.remove(), window.removeEventListener("keypress", this.keypressHandler);
  }
  //
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e;
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    this._visible = e, this.ui.toggleVisibility(e);
  }
  get guiVisible() {
    return this._guiVisible;
  }
  set guiVisible(e) {
    this._guiVisible = e, this.gui.element.parentElement.style.display = e ? "block" : "none";
  }
  get anchorX() {
    return this._anchorX;
  }
  set anchorX(e) {
    this._anchorX = e, this._anchorX === "left" ? (this.ui.wrapper.style.left = "0", this.ui.wrapper.style.right = "") : (this.ui.wrapper.style.left = "", this.ui.wrapper.style.right = "0");
  }
  get anchorY() {
    return this._anchorY;
  }
  set anchorY(e) {
    this._anchorY = e, this._anchorY === "top" ? (this.ui.wrapper.style.top = "0", this.ui.wrapper.style.bottom = "") : (this.ui.wrapper.style.top = "", this.ui.wrapper.style.bottom = "0");
  }
  get showGraph() {
    return this._showGraph;
  }
  set showGraph(e) {
    this._showGraph = e, this.ui.toggleCharts(e);
  }
  get memory() {
    return this._memory;
  }
  set memory(e) {
    this._memory = e, this.ui.toggleMemoryInfo(e);
  }
  get scale() {
    return this._scale;
  }
  set scale(e) {
    this._scale = e, this.ui.setScale(e);
  }
  get logsPerSecond() {
    return this.perfEngine.logsPerSecond;
  }
  set logsPerSecond(e) {
    this.perfEngine.logsPerSecond = e;
  }
  get backgroundOpacity() {
    return this.ui._backgroundOpacity;
  }
  set backgroundOpacity(e) {
    this.ui.setBackgroundOpacity(e);
  }
}
function vG(s, e, t) {
  let { domElement: n = document.body } = e, { logsPerSecond: i = 10 } = e, { showGraph: r = !0 } = e, { memory: a = !0 } = e, { enabled: o = !0 } = e, { visible: l = !0 } = e, { actionToCallUI: c = "" } = e, { guiVisible: u = !1 } = e, { backgroundOpacity: f = 0.7 } = e, { scale: h = 1 } = e, { anchorX: d = "left" } = e, { anchorY: m = "top" } = e;
  const { renderer: _, renderStage: g, mainStage: A } = un();
  let v;
  const y = Ft(n);
  return tn([y], ([w]) => {
    v && v.dispose(), v = new bG({
      domElement: w || document.body,
      renderer: _
    });
  }), On(
    () => {
      v.begin();
    },
    {
      stage: jb("monitor-begin", { before: A })
    }
  ), On(
    () => {
      v.end();
    },
    {
      stage: jb("monitor-end", { after: g })
    }
  ), Sn(() => {
    v && v.dispose();
  }), s.$$set = (w) => {
    "domElement" in w && t(0, n = w.domElement), "logsPerSecond" in w && t(1, i = w.logsPerSecond), "showGraph" in w && t(2, r = w.showGraph), "memory" in w && t(3, a = w.memory), "enabled" in w && t(4, o = w.enabled), "visible" in w && t(5, l = w.visible), "actionToCallUI" in w && t(6, c = w.actionToCallUI), "guiVisible" in w && t(7, u = w.guiVisible), "backgroundOpacity" in w && t(8, f = w.backgroundOpacity), "scale" in w && t(9, h = w.scale), "anchorX" in w && t(10, d = w.anchorX), "anchorY" in w && t(11, m = w.anchorY);
  }, s.$$.update = () => {
    s.$$.dirty & /*domElement*/
    1 && y.set(n), s.$$.dirty & /*logsPerSecond*/
    2 && (v.logsPerSecond = i), s.$$.dirty & /*showGraph*/
    4 && (v.showGraph = r), s.$$.dirty & /*memory*/
    8 && (v.memory = a), s.$$.dirty & /*enabled*/
    16 && (v.enabled = o), s.$$.dirty & /*visible*/
    32 && (v.visible = l), s.$$.dirty & /*actionToCallUI*/
    64 && (v.actionToCallUI = c), s.$$.dirty & /*guiVisible*/
    128 && (v.guiVisible = u), s.$$.dirty & /*backgroundOpacity*/
    256 && (v.backgroundOpacity = f), s.$$.dirty & /*scale*/
    512 && (v.scale = h), s.$$.dirty & /*anchorX*/
    1024 && (v.anchorX = d), s.$$.dirty & /*anchorY*/
    2048 && (v.anchorY = m);
  }, [
    n,
    i,
    r,
    a,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    m
  ];
}
class yG extends Mt {
  constructor(e) {
    super(), Ct(this, e, vG, null, _t, {
      domElement: 0,
      logsPerSecond: 1,
      showGraph: 2,
      memory: 3,
      enabled: 4,
      visible: 5,
      actionToCallUI: 6,
      guiVisible: 7,
      backgroundOpacity: 8,
      scale: 9,
      anchorX: 10,
      anchorY: 11
    });
  }
  get domElement() {
    return this.$$.ctx[0];
  }
  set domElement(e) {
    this.$$set({ domElement: e }), ne();
  }
  get logsPerSecond() {
    return this.$$.ctx[1];
  }
  set logsPerSecond(e) {
    this.$$set({ logsPerSecond: e }), ne();
  }
  get showGraph() {
    return this.$$.ctx[2];
  }
  set showGraph(e) {
    this.$$set({ showGraph: e }), ne();
  }
  get memory() {
    return this.$$.ctx[3];
  }
  set memory(e) {
    this.$$set({ memory: e }), ne();
  }
  get enabled() {
    return this.$$.ctx[4];
  }
  set enabled(e) {
    this.$$set({ enabled: e }), ne();
  }
  get visible() {
    return this.$$.ctx[5];
  }
  set visible(e) {
    this.$$set({ visible: e }), ne();
  }
  get actionToCallUI() {
    return this.$$.ctx[6];
  }
  set actionToCallUI(e) {
    this.$$set({ actionToCallUI: e }), ne();
  }
  get guiVisible() {
    return this.$$.ctx[7];
  }
  set guiVisible(e) {
    this.$$set({ guiVisible: e }), ne();
  }
  get backgroundOpacity() {
    return this.$$.ctx[8];
  }
  set backgroundOpacity(e) {
    this.$$set({ backgroundOpacity: e }), ne();
  }
  get scale() {
    return this.$$.ctx[9];
  }
  set scale(e) {
    this.$$set({ scale: e }), ne();
  }
  get anchorX() {
    return this.$$.ctx[10];
  }
  set anchorX(e) {
    this.$$set({ anchorX: e }), ne();
  }
  get anchorY() {
    return this.$$.ctx[11];
  }
  set anchorY(e) {
    this.$$set({ anchorY: e }), ne();
  }
}
St(yG, { domElement: {}, logsPerSecond: {}, showGraph: { type: "Boolean" }, memory: { type: "Boolean" }, enabled: { type: "Boolean" }, visible: { type: "Boolean" }, actionToCallUI: {}, guiVisible: { type: "Boolean" }, backgroundOpacity: {}, scale: {}, anchorX: {}, anchorY: {} }, [], [], !0);
const xG = `
#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

uniform float thickness;
uniform bool screenspace;
uniform vec2 size;

void main() {
  #if defined (USE_SKINNING)
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif
  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  vec4 tNormal = vec4(normal, 0.0);
  vec4 tPosition = vec4(transformed, 1.0);
  #ifdef USE_INSTANCING
    tNormal = instanceMatrix * tNormal;
    tPosition = instanceMatrix * tPosition;
  #endif
  if (!screenspace) {
    vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  } else {
    vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
    vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
    vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
    clipPosition.xy += offset;
    gl_Position = clipPosition;
  }
}`, wG = `
uniform vec3 color;
uniform float opacity;
void main(){
  gl_FragColor = vec4(color, opacity);
  #include <tonemapping_fragment>
  #include <${va >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
}
`, EG = (s) => ({ ref: s & /*ref*/
1 }), Ey = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function CG(s) {
  let e, t, n;
  e = new ee({ props: { is: (
    /*mesh*/
    s[1]
  ) } });
  const i = (
    /*#slots*/
    s[20].default
  ), r = yt(
    i,
    s,
    /*$$scope*/
    s[22],
    Ey
  );
  return {
    c() {
      Z(e.$$.fragment), t = Me(), r && r.c();
    },
    m(a, o) {
      K(e, a, o), we(a, t, o), r && r.m(a, o), n = !0;
    },
    p(a, o) {
      const l = {};
      o & /*mesh*/
      2 && (l.is = /*mesh*/
      a[1]), e.$set(l), r && r.p && (!n || o & /*$$scope, ref*/
      4194305) && wt(
        r,
        i,
        a,
        /*$$scope*/
        a[22],
        n ? xt(
          i,
          /*$$scope*/
          a[22],
          o,
          EG
        ) : Et(
          /*$$scope*/
          a[22]
        ),
        Ey
      );
    },
    i(a) {
      n || (O(e.$$.fragment, a), O(r, a), n = !0);
    },
    o(a) {
      N(e.$$.fragment, a), N(r, a), n = !1;
    },
    d(a) {
      a && xe(t), J(e, a), r && r.d(a);
    }
  };
}
function SG(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[5]
  ];
  let i = {
    $$slots: { default: [CG] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[21](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      33 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        32 && Kt(
          /*$$restProps*/
          r[5]
        )
      ]) : {};
      a & /*$$scope, ref, mesh*/
      4194307 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[21](null), J(e, r);
    }
  };
}
function MG(s, e, t) {
  const n = [
    "color",
    "screenspace",
    "opacity",
    "transparent",
    "thickness",
    "toneMapped",
    "angle",
    "polygonOffset",
    "polygonOffsetFactor",
    "renderOrder",
    "ref"
  ];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e, { color: c = "black" } = e, { screenspace: u = !1 } = e, { opacity: f = 1 } = e, { transparent: h = !1 } = e, { thickness: d = 0.05 } = e, { toneMapped: m = !0 } = e, { angle: _ = Math.PI } = e, { polygonOffset: g = !1 } = e, { polygonOffsetFactor: A = 0 } = e, { renderOrder: v = 0 } = e;
  const { renderer: y } = un(), w = {
    screenspace: { value: u },
    color: { value: new Je(c) },
    opacity: { value: f },
    thickness: { value: d },
    size: { value: new ke() }
  };
  let { ref: E = new Xn() } = e;
  const I = new Hn({
    side: Kn,
    uniforms: w,
    vertexShader: xG,
    fragmentShader: wG
  });
  let C = 0, B, T;
  const S = Er();
  lt(s, S, (P) => t(19, r = P));
  const D = An();
  lt(s, D, (P) => t(2, a = P));
  function R(P) {
    Ut[P ? "unshift" : "push"](() => {
      a = P, D.set(a);
    });
  }
  return s.$$set = (P) => {
    e = We(We({}, e), rn(P)), t(5, i = ft(e, n)), "color" in P && t(6, c = P.color), "screenspace" in P && t(7, u = P.screenspace), "opacity" in P && t(8, f = P.opacity), "transparent" in P && t(9, h = P.transparent), "thickness" in P && t(10, d = P.thickness), "toneMapped" in P && t(11, m = P.toneMapped), "angle" in P && t(12, _ = P.angle), "polygonOffset" in P && t(13, g = P.polygonOffset), "polygonOffsetFactor" in P && t(14, A = P.polygonOffsetFactor), "renderOrder" in P && t(15, v = P.renderOrder), "ref" in P && t(0, E = P.ref), "$$scope" in P && t(22, l = P.$$scope);
  }, s.$$.update = () => {
    if (s.$$.dirty & /*transparent*/
    512 && t(16, I.transparent = h, I), s.$$.dirty & /*toneMapped*/
    2048 && t(16, I.toneMapped = m, I), s.$$.dirty & /*polygonOffset*/
    8192 && t(16, I.polygonOffset = g, I), s.$$.dirty & /*polygonOffsetFactor*/
    16384 && t(16, I.polygonOffsetFactor = A, I), s.$$.dirty & /*screenspace*/
    128 && t(16, I.uniforms.screenspace.value = u, I), s.$$.dirty & /*opacity*/
    256 && t(16, I.uniforms.opacity.value = f, I), s.$$.dirty & /*thickness*/
    1024 && t(16, I.uniforms.thickness.value = d, I), s.$$.dirty & /*$parent, oldAngle, angle, oldGeometry, mesh, ref, material, renderOrder*/
    1019907) {
      const P = r;
      if ((P == null ? void 0 : P.geometry) !== void 0 && (C !== _ || B !== P.geometry)) {
        t(17, C = _), t(18, B = P.geometry), T && (_ && T.geometry.dispose(), E.remove(T));
        const L = _ ? XA(P.geometry, _) : P.geometry;
        if ("skeleton" in P) {
          const V = new _d(L, I);
          V.bind(P.skeleton, P.bindMatrix), t(1, T = V);
        } else if ("isInstancedMesh" in P) {
          const V = new Zl(L, I, P.count);
          V.instanceMatrix = P.instanceMatrix, t(1, T = V);
        } else
          t(1, T = new tt(L, I));
        t(1, T.renderOrder = v, T);
      }
    }
    s.$$.dirty & /*mesh, renderOrder*/
    32770 && T && t(1, T.renderOrder = v, T), s.$$.dirty & /*material, color*/
    65600 && I.uniforms.color.value.set(c), s.$$.dirty & /*material*/
    65536 && y.getDrawingBufferSize(I.uniforms.size.value);
  }, [
    E,
    T,
    a,
    S,
    D,
    i,
    c,
    u,
    f,
    h,
    d,
    m,
    _,
    g,
    A,
    v,
    I,
    C,
    B,
    r,
    o,
    R,
    l
  ];
}
class IG extends Mt {
  constructor(e) {
    super(), Ct(this, e, MG, SG, _t, {
      color: 6,
      screenspace: 7,
      opacity: 8,
      transparent: 9,
      thickness: 10,
      toneMapped: 11,
      angle: 12,
      polygonOffset: 13,
      polygonOffsetFactor: 14,
      renderOrder: 15,
      ref: 0
    });
  }
  get color() {
    return this.$$.ctx[6];
  }
  set color(e) {
    this.$$set({ color: e }), ne();
  }
  get screenspace() {
    return this.$$.ctx[7];
  }
  set screenspace(e) {
    this.$$set({ screenspace: e }), ne();
  }
  get opacity() {
    return this.$$.ctx[8];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), ne();
  }
  get transparent() {
    return this.$$.ctx[9];
  }
  set transparent(e) {
    this.$$set({ transparent: e }), ne();
  }
  get thickness() {
    return this.$$.ctx[10];
  }
  set thickness(e) {
    this.$$set({ thickness: e }), ne();
  }
  get toneMapped() {
    return this.$$.ctx[11];
  }
  set toneMapped(e) {
    this.$$set({ toneMapped: e }), ne();
  }
  get angle() {
    return this.$$.ctx[12];
  }
  set angle(e) {
    this.$$set({ angle: e }), ne();
  }
  get polygonOffset() {
    return this.$$.ctx[13];
  }
  set polygonOffset(e) {
    this.$$set({ polygonOffset: e }), ne();
  }
  get polygonOffsetFactor() {
    return this.$$.ctx[14];
  }
  set polygonOffsetFactor(e) {
    this.$$set({ polygonOffsetFactor: e }), ne();
  }
  get renderOrder() {
    return this.$$.ctx[15];
  }
  set renderOrder(e) {
    this.$$set({ renderOrder: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
}
St(IG, { color: {}, screenspace: { type: "Boolean" }, opacity: {}, transparent: { type: "Boolean" }, thickness: {}, toneMapped: { type: "Boolean" }, angle: {}, polygonOffset: { type: "Boolean" }, polygonOffsetFactor: {}, renderOrder: {}, ref: {} }, ["default"], [], !0);
const TG = (s) => ({ ref: s & /*ref*/
1 }), Cy = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function BG(s) {
  let e;
  const t = (
    /*#slots*/
    s[5].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    Cy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      129) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          TG
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        Cy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function PG(s) {
  let e, t, n;
  const i = [
    /*$$restProps*/
    s[2],
    { renderOrder: -/*id*/
    s[1] }
  ];
  function r(o) {
    s[6](o);
  }
  let a = {
    $$slots: { default: [BG] },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < i.length; o += 1)
    a = We(a, i[o]);
  return (
    /*ref*/
    s[0] !== void 0 && (a.ref = /*ref*/
    s[0]), e = new ee.Mesh({ props: a }), Ut.push(() => ar(e, "ref", r)), {
      c() {
        Z(e.$$.fragment);
      },
      m(o, l) {
        K(e, o, l), n = !0;
      },
      p(o, [l]) {
        const c = l & /*$$restProps, id*/
        6 ? jt(i, [
          l & /*$$restProps*/
          4 && Kt(
            /*$$restProps*/
            o[2]
          ),
          l & /*id*/
          2 && { renderOrder: -/*id*/
          o[1] }
        ]) : {};
        l & /*$$scope, ref*/
        129 && (c.$$scope = { dirty: l, ctx: o }), !t && l & /*ref*/
        1 && (t = !0, c.ref = /*ref*/
        o[0], or(() => t = !1)), e.$set(c);
      },
      i(o) {
        n || (O(e.$$.fragment, o), n = !0);
      },
      o(o) {
        N(e.$$.fragment, o), n = !1;
      },
      d(o) {
        J(e, o);
      }
    }
  );
}
function RG(s, e, t) {
  const n = ["id", "colorWrite", "depthWrite", "ref"];
  let i = ft(e, n), { $$slots: r = {}, $$scope: a } = e, { id: o = 1 } = e, { colorWrite: l = !1 } = e, { depthWrite: c = !1 } = e, { ref: u = new tt() } = e;
  const f = (d) => {
    if (!d)
      return;
    const m = d.material;
    Array.isArray(m) || (m.colorWrite = l, m.depthWrite = c, m.stencilWrite = !0, m.stencilRef = o, m.stencilFunc = Yh, m.stencilFail = Th, m.stencilZFail = Th, m.stencilZPass = Th);
  };
  function h(d) {
    u = d, t(0, u);
  }
  return s.$$set = (d) => {
    e = We(We({}, e), rn(d)), t(2, i = ft(e, n)), "id" in d && t(1, o = d.id), "colorWrite" in d && t(3, l = d.colorWrite), "depthWrite" in d && t(4, c = d.depthWrite), "ref" in d && t(0, u = d.ref), "$$scope" in d && t(7, a = d.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*ref*/
    1 && f(u), s.$$.dirty & /*ref, id*/
    3 && f(u);
  }, [
    u,
    o,
    i,
    l,
    c,
    r,
    h,
    a
  ];
}
class DG extends Mt {
  constructor(e) {
    super(), Ct(this, e, RG, PG, _t, {
      id: 1,
      colorWrite: 3,
      depthWrite: 4,
      ref: 0
    });
  }
  get id() {
    return this.$$.ctx[1];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get colorWrite() {
    return this.$$.ctx[3];
  }
  set colorWrite(e) {
    this.$$set({ colorWrite: e }), ne();
  }
  get depthWrite() {
    return this.$$.ctx[4];
  }
  set depthWrite(e) {
    this.$$set({ depthWrite: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
}
St(DG, { id: {}, colorWrite: { type: "Boolean" }, depthWrite: { type: "Boolean" }, ref: {} }, ["default"], [], !0);
const LG = (s) => ({}), Sy = (s) => ({}), kG = (s) => ({ errors: s & /*$errors*/
1 }), My = (s) => ({ errors: (
  /*$errors*/
  s[0]
) }), UG = (s) => ({
  suspended: s & /*$suspended*/
  2,
  errors: s & /*$errors*/
  1
}), Iy = (s) => ({
  suspended: (
    /*$suspended*/
    s[1]
  ),
  errors: (
    /*$errors*/
    s[0]
  )
});
function FG(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    Iy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, $suspended, $errors*/
      131) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          UG
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        Iy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function OG(s) {
  let e, t;
  return e = new ee({
    props: {
      is: (
        /*group*/
        s[4]
      ),
      $$slots: { default: [FG] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, $suspended, $errors*/
      131 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function NG(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].fallback
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    Sy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      128) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          LG
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        Sy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function GG(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].error
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    My
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, $errors*/
      129) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          kG
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        My
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function QG(s) {
  let e, t, n, i, r, a;
  e = new ic({
    props: {
      $$slots: { default: [OG] },
      $$scope: { ctx: s }
    }
  });
  const o = [GG, NG], l = [];
  function c(u, f) {
    return (
      /*$errors*/
      u[0].length ? 0 : (
        /*$suspended*/
        u[1] ? 1 : -1
      )
    );
  }
  return ~(n = c(s)) && (i = l[n] = o[n](s)), {
    c() {
      Z(e.$$.fragment), t = Me(), i && i.c(), r = ji();
    },
    m(u, f) {
      K(e, u, f), we(u, t, f), ~n && l[n].m(u, f), we(u, r, f), a = !0;
    },
    p(u, [f]) {
      const h = {};
      f & /*$$scope, $suspended, $errors*/
      131 && (h.$$scope = { dirty: f, ctx: u }), e.$set(h);
      let d = n;
      n = c(u), n === d ? ~n && l[n].p(u, f) : (i && (Li(), N(l[d], 1, 1, () => {
        l[d] = null;
      }), ki()), ~n ? (i = l[n], i ? i.p(u, f) : (i = l[n] = o[n](u), i.c()), O(i, 1), i.m(r.parentNode, r)) : i = null);
    },
    i(u) {
      a || (O(e.$$.fragment, u), O(i), a = !0);
    },
    o(u) {
      N(e.$$.fragment, u), N(i), a = !1;
    },
    d(u) {
      u && (xe(t), xe(r)), J(e, u), ~n && l[n].d(u);
    }
  };
}
function zG(s, e, t) {
  let n, i, { $$slots: r = {}, $$scope: a } = e, { final: o = !1 } = e;
  const l = us(), { suspended: c, errors: u, setFinal: f } = hk({ final: o });
  lt(s, c, (m) => t(1, i = m)), lt(s, u, (m) => t(0, n = m));
  const h = new Xn(), d = Er();
  return tn([d, c, u], ([m, _, g]) => {
    if (m) {
      if (_ || g.length) {
        m.remove(h);
        return;
      }
      return m.add(h), () => {
        m.remove(h);
      };
    }
  }), s.$$set = (m) => {
    "final" in m && t(5, o = m.final), "$$scope" in m && t(7, a = m.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*final*/
    32 && f(o), s.$$.dirty & /*$suspended*/
    2 && (i || l("load")), s.$$.dirty & /*$suspended*/
    2 && i && l("suspend"), s.$$.dirty & /*$errors*/
    1 && n.length && l("error", n);
  }, [n, i, c, u, h, o, r, a];
}
class $G extends Mt {
  constructor(e) {
    super(), Ct(this, e, zG, QG, _t, { final: 5 });
  }
  get final() {
    return this.$$.ctx[5];
  }
  set final(e) {
    this.$$set({ final: e }), ne();
  }
}
St($G, { final: { type: "Boolean" } }, ["default", "error", "fallback"], [], !0);
const VG = () => {
  const s = {
    portals: xn(/* @__PURE__ */ new Map()),
    addPortal(e, t) {
      s.portals.update((n) => (n.has(t) ? console.warn(`Portal with id ${t} already exists. Skipping portal creation.`) : n.set(t, e), n));
    },
    removePortal(e) {
      s.portals.update((t) => (t.has(e) ? t.delete(e) : console.warn(`Portal with id ${e} does not exist. Skipping portal removal.`), t));
    },
    getPortal(e) {
      return hi(s.portals, (t) => t.get(e));
    },
    hasPortal(e) {
      return s.portals.current.has(e);
    }
  };
  return s;
}, FE = () => qA("threlte-portals", VG());
function Ty(s) {
  let e, t;
  return e = new ic({
    props: {
      onChildMount: (
        /*func*/
        s[8]
      ),
      onChildDestroy: (
        /*func_1*/
        s[9]
      ),
      $$slots: { default: [HG] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      1024 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function HG(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[10],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      1024) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[10],
        e ? xt(
          t,
          /*$$scope*/
          i[10],
          r,
          null
        ) : Et(
          /*$$scope*/
          i[10]
        ),
        null
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function jG(s) {
  let e, t, n = (
    /*$target*/
    s[1] && Ty(s)
  );
  return {
    c() {
      n && n.c(), e = ji();
    },
    m(i, r) {
      n && n.m(i, r), we(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*$target*/
      i[1] ? n ? (n.p(i, r), r & /*$target*/
      2 && O(n, 1)) : (n = Ty(i), n.c(), O(n, 1), n.m(e.parentNode, e)) : n && (Li(), N(n, 1, 1, () => {
        n = null;
      }), ki());
    },
    i(i) {
      t || (O(n), t = !0);
    },
    o(i) {
      N(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function WG(s, e, t) {
  let n, i, r = rt, a = () => (r(), r = Bu(n, (A) => t(6, i = A)), n), o;
  s.$$.on_destroy.push(() => r());
  let { $$slots: l = {}, $$scope: c } = e, { id: u = "default" } = e, { object: f = void 0 } = e;
  const { getPortal: h } = FE(), d = Ft([]), m = Ft();
  lt(s, m, (A) => t(1, o = A)), tn([d, m], ([A, v]) => {
    if (v !== void 0) {
      for (const y of A)
        v.children.includes(y) || v.add(y);
      return () => {
        for (const y of A)
          v.children.includes(y) && v.remove(y);
      };
    }
  });
  const _ = (A) => d.update((v) => (v.push(A), v)), g = (A) => d.update((v) => (v.splice(v.indexOf(A), 1), v));
  return s.$$set = (A) => {
    "id" in A && t(4, u = A.id), "object" in A && t(5, f = A.object), "$$scope" in A && t(10, c = A.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*id*/
    16 && a(t(0, n = h(u))), s.$$.dirty & /*object, $portal*/
    96 && m.set(f ?? i);
  }, [
    n,
    o,
    d,
    m,
    u,
    f,
    i,
    l,
    _,
    g,
    c
  ];
}
class qG extends Mt {
  constructor(e) {
    super(), Ct(this, e, WG, jG, _t, { id: 4, object: 5 });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get object() {
    return this.$$.ctx[5];
  }
  set object(e) {
    this.$$set({ object: e }), ne();
  }
}
St(qG, { id: {}, object: {} }, ["default"], [], !0);
function XG(s, e, t) {
  let n;
  const i = Er();
  if (lt(s, i, (l) => t(2, n = l)), !n)
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  let { id: r = "default" } = e;
  const { addPortal: a, removePortal: o } = FE();
  return tn(i, (l) => {
    if (l)
      return a(l, r), () => {
        o(r);
      };
  }), s.$$set = (l) => {
    "id" in l && t(1, r = l.id);
  }, [i, r];
}
class YG extends Mt {
  constructor(e) {
    super(), Ct(this, e, XG, null, _t, { id: 1 });
  }
  get id() {
    return this.$$.ctx[1];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
}
St(YG, { id: {} }, [], [], !0);
function KG() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(i, r) {
    var a = i.id, o = i.name, l = i.dependencies;
    l === void 0 && (l = []);
    var c = i.init;
    c === void 0 && (c = function() {
    });
    var u = i.getTransferables;
    if (u === void 0 && (u = null), !s[a])
      try {
        l = l.map(function(h) {
          return h && h.isWorkerModule && (e(h, function(d) {
            if (d instanceof Error)
              throw d;
          }), h = s[h.id].value), h;
        }), c = n("<" + o + ">.init", c), u && (u = n("<" + o + ">.getTransferables", u));
        var f = null;
        typeof c == "function" ? f = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), s[a] = {
          id: a,
          value: f,
          getTransferables: u
        }, r(f);
      } catch (h) {
        h && h.noLog || console.error(h), r(h);
      }
  }
  function t(i, r) {
    var a, o = i.id, l = i.args;
    (!s[o] || typeof s[o].value != "function") && r(new Error("Worker module " + o + ": not found or its 'init' did not return a function"));
    try {
      var c = (a = s[o]).value.apply(a, l);
      c && typeof c.then == "function" ? c.then(u, function(f) {
        return r(f instanceof Error ? f : new Error("" + f));
      }) : u(c);
    } catch (f) {
      r(f);
    }
    function u(f) {
      try {
        var h = s[o].getTransferables && s[o].getTransferables(f);
        (!h || !Array.isArray(h) || !h.length) && (h = void 0), r(f, h);
      } catch (d) {
        console.error(d), r(d);
      }
    }
  }
  function n(i, r) {
    var a = void 0;
    self.troikaDefine = function(l) {
      return a = l;
    };
    var o = URL.createObjectURL(
      new Blob(
        ["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + r + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(o);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(o), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(i) {
    var r = i.data, a = r.messageId, o = r.action, l = r.data;
    try {
      o === "registerModule" && e(l, function(c) {
        c instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof c == "function" }
        });
      }), o === "callModule" && t(l, function(c, u) {
        c instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: c.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: c
        }, u || void 0);
      });
    } catch (c) {
      postMessage({
        messageId: a,
        success: !1,
        error: c.stack
      });
    }
  });
}
function JG(s) {
  var e = function() {
    for (var t = [], n = arguments.length; n--; )
      t[n] = arguments[n];
    return e._getInitResult().then(function(i) {
      if (typeof i == "function")
        return i.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = s.dependencies, n = s.init;
    t = Array.isArray(t) ? t.map(
      function(r) {
        return r && r._getInitResult ? r._getInitResult() : r;
      }
    ) : [];
    var i = Promise.all(t).then(function(r) {
      return n.apply(null, r);
    });
    return e._getInitResult = function() {
      return i;
    }, i;
  }, e;
}
var OE = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return OE = function() {
    return s;
  }, s;
}, ZG = 0, e5 = 0, $m = !1, au = /* @__PURE__ */ Object.create(null), lu = /* @__PURE__ */ Object.create(null), qg = /* @__PURE__ */ Object.create(null);
function oc(s) {
  if ((!s || typeof s.init != "function") && !$m)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, t = s.init, n = s.getTransferables, i = s.workerId;
  if (!OE())
    return JG(s);
  i == null && (i = "#default");
  var r = "workerModule" + ++ZG, a = s.name || r, o = null;
  e = e && e.map(function(c) {
    return typeof c == "function" && !c.workerModuleData && ($m = !0, c = oc({
      workerId: i,
      name: "<" + a + "> function dependency: " + c.name,
      init: `function(){return (
` + kh(c) + `
)}`
    }), $m = !1), c && c.workerModuleData && (c = c.workerModuleData), c;
  });
  function l() {
    for (var c = [], u = arguments.length; u--; )
      c[u] = arguments[u];
    if (!o) {
      o = By(i, "registerModule", l.workerModuleData);
      var f = function() {
        o = null, lu[i].delete(f);
      };
      (lu[i] || (lu[i] = /* @__PURE__ */ new Set())).add(f);
    }
    return o.then(function(h) {
      var d = h.isCallable;
      if (d)
        return By(i, "callModule", { id: r, args: c });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return l.workerModuleData = {
    isWorkerModule: !0,
    id: r,
    name: a,
    dependencies: e,
    init: kh(t),
    getTransferables: n && kh(n)
  }, l;
}
function t5(s) {
  lu[s] && lu[s].forEach(function(e) {
    e();
  }), au[s] && (au[s].terminate(), delete au[s]);
}
function kh(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function n5(s) {
  var e = au[s];
  if (!e) {
    var t = kh(KG);
    e = au[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(n) {
      var i = n.data, r = i.messageId, a = qg[r];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete qg[r], a(i);
    };
  }
  return e;
}
function By(s, e, t) {
  return new Promise(function(n, i) {
    var r = ++e5;
    qg[r] = function(a) {
      a.success ? n(a.result) : i(new Error("Error in worker " + e + " call: " + a.error));
    }, n5(s).postMessage({
      messageId: r,
      action: e,
      data: t
    });
  });
}
const NE = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Xg(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(n, i) {
    let r = gt[i];
    return r ? Xg(r) : n;
  }
  return s.replace(e, t);
}
const bi = [];
for (let s = 0; s < 256; s++)
  bi[s] = (s < 16 ? "0" : "") + s.toString(16);
function i5() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (bi[s & 255] + bi[s >> 8 & 255] + bi[s >> 16 & 255] + bi[s >> 24 & 255] + "-" + bi[e & 255] + bi[e >> 8 & 255] + "-" + bi[e >> 16 & 15 | 64] + bi[e >> 24 & 255] + "-" + bi[t & 63 | 128] + bi[t >> 8 & 255] + "-" + bi[t >> 16 & 255] + bi[t >> 24 & 255] + bi[n & 255] + bi[n >> 8 & 255] + bi[n >> 16 & 255] + bi[n >> 24 & 255]).toUpperCase();
}
const Jo = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let n = arguments[e];
    if (n)
      for (let i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (s[i] = n[i]);
  }
  return s;
}, r5 = Date.now(), Py = /* @__PURE__ */ new WeakMap(), Ry = /* @__PURE__ */ new Map();
let s5 = 1e10;
function Yg(s, e) {
  const t = c5(e);
  let n = Py.get(s);
  if (n || Py.set(s, n = /* @__PURE__ */ Object.create(null)), n[t])
    return new n[t]();
  const i = `_onBeforeCompile${t}`, r = function(c, u) {
    s.onBeforeCompile.call(this, c, u);
    const f = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let h = Ry[f];
    if (!h) {
      const d = o5(this, c, e, t);
      h = Ry[f] = d;
    }
    c.vertexShader = h.vertexShader, c.fragmentShader = h.fragmentShader, Jo(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - r5;
      }
    }), this[i] && this[i](c);
  }, a = function() {
    return o(e.chained ? s : s.clone());
  }, o = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: s5++ }), u.uuid = i5(), u.uniforms = Jo({}, c.uniforms, e.uniforms), u.defines = Jo({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = Jo({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[i] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return s.copy.call(this, c), !s.isShaderMaterial && !s.isDerivedMaterial && (Jo(this.extensions, c.extensions), Jo(this.defines, c.defines), Jo(this.uniforms, ql.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new s.constructor();
        return o(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = Yg(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Ea({ depthPacking: jl }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = Yg(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Kl(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return n[t] = a, new a();
}
function o5(s, { vertexShader: e, fragmentShader: t }, n, i) {
  let {
    vertexDefs: r,
    vertexMainIntro: a,
    vertexMainOutro: o,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: f,
    fragmentColorTransform: h,
    customRewriter: d,
    timeUniform: m
  } = n;
  if (r = r || "", a = a || "", o = o || "", c = c || "", u = u || "", f = f || "", (l || d) && (e = Xg(e)), (h || d) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = Xg(t)), d) {
    let _ = d({ vertexShader: e, fragmentShader: t });
    e = _.vertexShader, t = _.fragmentShader;
  }
  if (h) {
    let _ = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (_.push(g), "")
    ), f = `${h}
${_.join(`
`)}
${f}`;
  }
  if (m) {
    const _ = `
uniform float ${m};
`;
    r = _ + r, c = _ + c;
  }
  return l && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, r = `${r}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, a = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (_, g, A, v) => /\battribute\s+vec[23]\s+$/.test(v.substr(0, A)) ? g : `troika_${g}_${i}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = Dy(e, i, r, a, o), t = Dy(t, i, c, u, f), {
    vertexShader: e,
    fragmentShader: t
  };
}
function Dy(s, e, t, n, i) {
  return (n || i || t) && (s = s.replace(
    NE,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`), s;
}
function a5(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let l5 = 0;
const Ly = /* @__PURE__ */ new Map();
function c5(s) {
  const e = JSON.stringify(s, a5);
  let t = Ly.get(e);
  return t == null && Ly.set(e, t = ++l5), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function u5() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(i) {
      var r = e._bin, a = new Uint8Array(i);
      if (r.readASCII(a, 0, 4) == "ttcf") {
        var o = 4;
        r.readUshort(a, o), o += 2, r.readUshort(a, o), o += 2;
        var l = r.readUint(a, o);
        o += 4;
        for (var c = [], u = 0; u < l; u++) {
          var f = r.readUint(a, o);
          o += 4, c.push(e._readFont(a, f));
        }
        return c;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(i, r) {
      var a = e._bin, o = r;
      a.readFixed(i, r), r += 4;
      var l = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2;
      for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], u = { _data: i, _offset: o }, f = {}, h = 0; h < l; h++) {
        var d = a.readASCII(i, r, 4);
        r += 4, a.readUint(i, r), r += 4;
        var m = a.readUint(i, r);
        r += 4;
        var _ = a.readUint(i, r);
        r += 4, f[d] = { offset: m, length: _ };
      }
      for (h = 0; h < c.length; h++) {
        var g = c[h];
        f[g] && (u[g.trim()] = e[g.trim()].parse(i, f[g].offset, f[g].length, u));
      }
      return u;
    }, _tabOffset: function(i, r, a) {
      for (var o = e._bin, l = o.readUshort(i, a + 4), c = a + 12, u = 0; u < l; u++) {
        var f = o.readASCII(i, c, 4);
        c += 4, o.readUint(i, c), c += 4;
        var h = o.readUint(i, c);
        if (c += 4, o.readUint(i, c), c += 4, f == r)
          return h;
      }
      return 0;
    } };
    e._bin = { readFixed: function(i, r) {
      return (i[r] << 8 | i[r + 1]) + (i[r + 2] << 8 | i[r + 3]) / 65540;
    }, readF2dot14: function(i, r) {
      return e._bin.readShort(i, r) / 16384;
    }, readInt: function(i, r) {
      return e._bin._view(i).getInt32(r);
    }, readInt8: function(i, r) {
      return e._bin._view(i).getInt8(r);
    }, readShort: function(i, r) {
      return e._bin._view(i).getInt16(r);
    }, readUshort: function(i, r) {
      return e._bin._view(i).getUint16(r);
    }, readUshorts: function(i, r, a) {
      for (var o = [], l = 0; l < a; l++)
        o.push(e._bin.readUshort(i, r + 2 * l));
      return o;
    }, readUint: function(i, r) {
      return e._bin._view(i).getUint32(r);
    }, readUint64: function(i, r) {
      return 4294967296 * e._bin.readUint(i, r) + e._bin.readUint(i, r + 4);
    }, readASCII: function(i, r, a) {
      for (var o = "", l = 0; l < a; l++)
        o += String.fromCharCode(i[r + l]);
      return o;
    }, readUnicode: function(i, r, a) {
      for (var o = "", l = 0; l < a; l++) {
        var c = i[r++] << 8 | i[r++];
        o += String.fromCharCode(c);
      }
      return o;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(i, r, a) {
      var o = e._bin._tdec;
      return o && r == 0 && a == i.length ? o.decode(i) : e._bin.readASCII(i, r, a);
    }, readBytes: function(i, r, a) {
      for (var o = [], l = 0; l < a; l++)
        o.push(i[r + l]);
      return o;
    }, readASCIIArray: function(i, r, a) {
      for (var o = [], l = 0; l < a; l++)
        o.push(String.fromCharCode(i[r + l]));
      return o;
    }, _view: function(i) {
      return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(i, r, a, o, l) {
      var c = e._bin, u = {}, f = r;
      c.readFixed(i, r), r += 4;
      var h = c.readUshort(i, r);
      r += 2;
      var d = c.readUshort(i, r);
      r += 2;
      var m = c.readUshort(i, r);
      return r += 2, u.scriptList = e._lctf.readScriptList(i, f + h), u.featureList = e._lctf.readFeatureList(i, f + d), u.lookupList = e._lctf.readLookupList(i, f + m, l), u;
    }, e._lctf.readLookupList = function(i, r, a) {
      var o = e._bin, l = r, c = [], u = o.readUshort(i, r);
      r += 2;
      for (var f = 0; f < u; f++) {
        var h = o.readUshort(i, r);
        r += 2;
        var d = e._lctf.readLookupTable(i, l + h, a);
        c.push(d);
      }
      return c;
    }, e._lctf.readLookupTable = function(i, r, a) {
      var o = e._bin, l = r, c = { tabs: [] };
      c.ltype = o.readUshort(i, r), r += 2, c.flag = o.readUshort(i, r), r += 2;
      var u = o.readUshort(i, r);
      r += 2;
      for (var f = c.ltype, h = 0; h < u; h++) {
        var d = o.readUshort(i, r);
        r += 2;
        var m = a(i, f, l + d, c);
        c.tabs.push(m);
      }
      return c;
    }, e._lctf.numOfOnes = function(i) {
      for (var r = 0, a = 0; a < 32; a++)
        i >>> a & 1 && r++;
      return r;
    }, e._lctf.readClassDef = function(i, r) {
      var a = e._bin, o = [], l = a.readUshort(i, r);
      if (r += 2, l == 1) {
        var c = a.readUshort(i, r);
        r += 2;
        var u = a.readUshort(i, r);
        r += 2;
        for (var f = 0; f < u; f++)
          o.push(c + f), o.push(c + f), o.push(a.readUshort(i, r)), r += 2;
      }
      if (l == 2) {
        var h = a.readUshort(i, r);
        for (r += 2, f = 0; f < h; f++)
          o.push(a.readUshort(i, r)), r += 2, o.push(a.readUshort(i, r)), r += 2, o.push(a.readUshort(i, r)), r += 2;
      }
      return o;
    }, e._lctf.getInterval = function(i, r) {
      for (var a = 0; a < i.length; a += 3) {
        var o = i[a], l = i[a + 1];
        if (i[a + 2], o <= r && r <= l)
          return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(i, r) {
      var a = e._bin, o = {};
      o.fmt = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      return r += 2, o.fmt == 1 && (o.tab = a.readUshorts(i, r, l)), o.fmt == 2 && (o.tab = a.readUshorts(i, r, 3 * l)), o;
    }, e._lctf.coverageIndex = function(i, r) {
      var a = i.tab;
      if (i.fmt == 1)
        return a.indexOf(r);
      if (i.fmt == 2) {
        var o = e._lctf.getInterval(a, r);
        if (o != -1)
          return a[o + 2] + (r - a[o]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(i, r) {
      var a = e._bin, o = r, l = [], c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readASCII(i, r, 4);
        r += 4;
        var h = a.readUshort(i, r);
        r += 2;
        var d = e._lctf.readFeatureTable(i, o + h);
        d.tag = f.trim(), l.push(d);
      }
      return l;
    }, e._lctf.readFeatureTable = function(i, r) {
      var a = e._bin, o = r, l = {}, c = a.readUshort(i, r);
      r += 2, c > 0 && (l.featureParams = o + c);
      var u = a.readUshort(i, r);
      r += 2, l.tab = [];
      for (var f = 0; f < u; f++)
        l.tab.push(a.readUshort(i, r + 2 * f));
      return l;
    }, e._lctf.readScriptList = function(i, r) {
      var a = e._bin, o = r, l = {}, c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readASCII(i, r, 4);
        r += 4;
        var h = a.readUshort(i, r);
        r += 2, l[f.trim()] = e._lctf.readScriptTable(i, o + h);
      }
      return l;
    }, e._lctf.readScriptTable = function(i, r) {
      var a = e._bin, o = r, l = {}, c = a.readUshort(i, r);
      r += 2, c > 0 && (l.default = e._lctf.readLangSysTable(i, o + c));
      var u = a.readUshort(i, r);
      r += 2;
      for (var f = 0; f < u; f++) {
        var h = a.readASCII(i, r, 4);
        r += 4;
        var d = a.readUshort(i, r);
        r += 2, l[h.trim()] = e._lctf.readLangSysTable(i, o + d);
      }
      return l;
    }, e._lctf.readLangSysTable = function(i, r) {
      var a = e._bin, o = {};
      a.readUshort(i, r), r += 2, o.reqFeature = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      return r += 2, o.features = a.readUshorts(i, r, l), o;
    }, e.CFF = {}, e.CFF.parse = function(i, r, a) {
      var o = e._bin;
      (i = new Uint8Array(i.buffer, r, a))[r = 0], i[++r], i[++r], i[++r], r++;
      var l = [];
      r = e.CFF.readIndex(i, r, l);
      for (var c = [], u = 0; u < l.length - 1; u++)
        c.push(o.readASCII(i, r + l[u], l[u + 1] - l[u]));
      r += l[l.length - 1];
      var f = [];
      r = e.CFF.readIndex(i, r, f);
      var h = [];
      for (u = 0; u < f.length - 1; u++)
        h.push(e.CFF.readDict(i, r + f[u], r + f[u + 1]));
      r += f[f.length - 1];
      var d = h[0], m = [];
      r = e.CFF.readIndex(i, r, m);
      var _ = [];
      for (u = 0; u < m.length - 1; u++)
        _.push(o.readASCII(i, r + m[u], m[u + 1] - m[u]));
      if (r += m[m.length - 1], e.CFF.readSubrs(i, r, d), d.CharStrings) {
        r = d.CharStrings, m = [], r = e.CFF.readIndex(i, r, m);
        var g = [];
        for (u = 0; u < m.length - 1; u++)
          g.push(o.readBytes(i, r + m[u], m[u + 1] - m[u]));
        d.CharStrings = g;
      }
      if (d.ROS) {
        r = d.FDArray;
        var A = [];
        for (r = e.CFF.readIndex(i, r, A), d.FDArray = [], u = 0; u < A.length - 1; u++) {
          var v = e.CFF.readDict(i, r + A[u], r + A[u + 1]);
          e.CFF._readFDict(i, v, _), d.FDArray.push(v);
        }
        r += A[A.length - 1], r = d.FDSelect, d.FDSelect = [];
        var y = i[r];
        if (r++, y != 3)
          throw y;
        var w = o.readUshort(i, r);
        for (r += 2, u = 0; u < w + 1; u++)
          d.FDSelect.push(o.readUshort(i, r), i[r + 2]), r += 3;
      }
      return d.Encoding && (d.Encoding = e.CFF.readEncoding(i, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(i, d.charset, d.CharStrings.length)), e.CFF._readFDict(i, d, _), d;
    }, e.CFF._readFDict = function(i, r, a) {
      var o;
      for (var l in r.Private && (o = r.Private[1], r.Private = e.CFF.readDict(i, o, o + r.Private[0]), r.Private.Subrs && e.CFF.readSubrs(i, o + r.Private.Subrs, r.Private)), r)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (r[l] = a[r[l] - 426 + 35]);
    }, e.CFF.readSubrs = function(i, r, a) {
      var o = e._bin, l = [];
      r = e.CFF.readIndex(i, r, l);
      var c, u = l.length;
      c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, a.Bias = c, a.Subrs = [];
      for (var f = 0; f < l.length - 1; f++)
        a.Subrs.push(o.readBytes(i, r + l[f], l[f + 1] - l[f]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, r) {
      for (var a = 0; a < i.charset.length; a++)
        if (i.charset[a] == r)
          return a;
      return -1;
    }, e.CFF.glyphBySE = function(i, r) {
      return r < 0 || r > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[r]);
    }, e.CFF.readEncoding = function(i, r, a) {
      e._bin;
      var o = [".notdef"], l = i[r];
      if (r++, l != 0)
        throw "error: unknown encoding format: " + l;
      var c = i[r];
      r++;
      for (var u = 0; u < c; u++)
        o.push(i[r + u]);
      return o;
    }, e.CFF.readCharset = function(i, r, a) {
      var o = e._bin, l = [".notdef"], c = i[r];
      if (r++, c == 0)
        for (var u = 0; u < a; u++) {
          var f = o.readUshort(i, r);
          r += 2, l.push(f);
        }
      else {
        if (c != 1 && c != 2)
          throw "error: format: " + c;
        for (; l.length < a; ) {
          f = o.readUshort(i, r), r += 2;
          var h = 0;
          for (c == 1 ? (h = i[r], r++) : (h = o.readUshort(i, r), r += 2), u = 0; u <= h; u++)
            l.push(f), f++;
        }
      }
      return l;
    }, e.CFF.readIndex = function(i, r, a) {
      var o = e._bin, l = o.readUshort(i, r) + 1, c = i[r += 2];
      if (r++, c == 1)
        for (var u = 0; u < l; u++)
          a.push(i[r + u]);
      else if (c == 2)
        for (u = 0; u < l; u++)
          a.push(o.readUshort(i, r + 2 * u));
      else if (c == 3)
        for (u = 0; u < l; u++)
          a.push(16777215 & o.readUint(i, r + 3 * u - 1));
      else if (l != 1)
        throw "unsupported offset size: " + c + ", count: " + l;
      return (r += l * c) - 1;
    }, e.CFF.getCharString = function(i, r, a) {
      var o = e._bin, l = i[r], c = i[r + 1];
      i[r + 2], i[r + 3], i[r + 4];
      var u = 1, f = null, h = null;
      l <= 20 && (f = l, u = 1), l == 12 && (f = 100 * l + c, u = 2), 21 <= l && l <= 27 && (f = l, u = 1), l == 28 && (h = o.readShort(i, r + 1), u = 3), 29 <= l && l <= 31 && (f = l, u = 1), 32 <= l && l <= 246 && (h = l - 139, u = 1), 247 <= l && l <= 250 && (h = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (h = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (h = o.readInt(i, r + 1) / 65535, u = 5), a.val = h ?? "o" + f, a.size = u;
    }, e.CFF.readCharString = function(i, r, a) {
      for (var o = r + a, l = e._bin, c = []; r < o; ) {
        var u = i[r], f = i[r + 1];
        i[r + 2], i[r + 3], i[r + 4];
        var h = 1, d = null, m = null;
        u <= 20 && (d = u, h = 1), u == 12 && (d = 100 * u + f, h = 2), u != 19 && u != 20 || (d = u, h = 2), 21 <= u && u <= 27 && (d = u, h = 1), u == 28 && (m = l.readShort(i, r + 1), h = 3), 29 <= u && u <= 31 && (d = u, h = 1), 32 <= u && u <= 246 && (m = u - 139, h = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + f + 108, h = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - f - 108, h = 2), u == 255 && (m = l.readInt(i, r + 1) / 65535, h = 5), c.push(m ?? "o" + d), r += h;
      }
      return c;
    }, e.CFF.readDict = function(i, r, a) {
      for (var o = e._bin, l = {}, c = []; r < a; ) {
        var u = i[r], f = i[r + 1];
        i[r + 2], i[r + 3], i[r + 4];
        var h = 1, d = null, m = null;
        if (u == 28 && (m = o.readShort(i, r + 1), h = 3), u == 29 && (m = o.readInt(i, r + 1), h = 5), 32 <= u && u <= 246 && (m = u - 139, h = 1), 247 <= u && u <= 250 && (m = 256 * (u - 247) + f + 108, h = 2), 251 <= u && u <= 254 && (m = 256 * -(u - 251) - f - 108, h = 2), u == 255)
          throw m = o.readInt(i, r + 1) / 65535, h = 5, "unknown number";
        if (u == 30) {
          var _ = [];
          for (h = 1; ; ) {
            var g = i[r + h];
            h++;
            var A = g >> 4, v = 15 & g;
            if (A != 15 && _.push(A), v != 15 && _.push(v), v == 15)
              break;
          }
          for (var y = "", w = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], E = 0; E < _.length; E++)
            y += w[_[E]];
          m = parseFloat(y);
        }
        u <= 21 && (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], h = 1, u == 12 && (d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][f], h = 2)), d != null ? (l[d] = c.length == 1 ? c[0] : c, c = []) : c.push(m), r += h;
      }
      return l;
    }, e.cmap = {}, e.cmap.parse = function(i, r, a) {
      i = new Uint8Array(i.buffer, r, a), r = 0;
      var o = e._bin, l = {};
      o.readUshort(i, r), r += 2;
      var c = o.readUshort(i, r);
      r += 2;
      var u = [];
      l.tables = [];
      for (var f = 0; f < c; f++) {
        var h = o.readUshort(i, r);
        r += 2;
        var d = o.readUshort(i, r);
        r += 2;
        var m = o.readUint(i, r);
        r += 4;
        var _ = "p" + h + "e" + d, g = u.indexOf(m);
        if (g == -1) {
          var A;
          g = l.tables.length, u.push(m);
          var v = o.readUshort(i, m);
          v == 0 ? A = e.cmap.parse0(i, m) : v == 4 ? A = e.cmap.parse4(i, m) : v == 6 ? A = e.cmap.parse6(i, m) : v == 12 ? A = e.cmap.parse12(i, m) : console.debug("unknown format: " + v, h, d, m), l.tables.push(A);
        }
        if (l[_] != null)
          throw "multiple tables for one platform+encoding";
        l[_] = g;
      }
      return l;
    }, e.cmap.parse0 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2, o.map = [];
      for (var c = 0; c < l - 6; c++)
        o.map.push(i[r + c]);
      return o;
    }, e.cmap.parse4 = function(i, r) {
      var a = e._bin, o = r, l = {};
      l.format = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2;
      var u = a.readUshort(i, r);
      r += 2;
      var f = u / 2;
      l.searchRange = a.readUshort(i, r), r += 2, l.entrySelector = a.readUshort(i, r), r += 2, l.rangeShift = a.readUshort(i, r), r += 2, l.endCount = a.readUshorts(i, r, f), r += 2 * f, r += 2, l.startCount = a.readUshorts(i, r, f), r += 2 * f, l.idDelta = [];
      for (var h = 0; h < f; h++)
        l.idDelta.push(a.readShort(i, r)), r += 2;
      for (l.idRangeOffset = a.readUshorts(i, r, f), r += 2 * f, l.glyphIdArray = []; r < o + c; )
        l.glyphIdArray.push(a.readUshort(i, r)), r += 2;
      return l;
    }, e.cmap.parse6 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, o.firstCode = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2, o.glyphIdArray = [];
      for (var c = 0; c < l; c++)
        o.glyphIdArray.push(a.readUshort(i, r)), r += 2;
      return o;
    }, e.cmap.parse12 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2, r += 2, a.readUint(i, r), r += 4, a.readUint(i, r), r += 4;
      var l = a.readUint(i, r);
      r += 4, o.groups = [];
      for (var c = 0; c < l; c++) {
        var u = r + 12 * c, f = a.readUint(i, u + 0), h = a.readUint(i, u + 4), d = a.readUint(i, u + 8);
        o.groups.push([f, h, d]);
      }
      return o;
    }, e.glyf = {}, e.glyf.parse = function(i, r, a, o) {
      for (var l = [], c = 0; c < o.maxp.numGlyphs; c++)
        l.push(null);
      return l;
    }, e.glyf._parseGlyf = function(i, r) {
      var a = e._bin, o = i._data, l = e._tabOffset(o, "glyf", i._offset) + i.loca[r];
      if (i.loca[r] == i.loca[r + 1])
        return null;
      var c = {};
      if (c.noc = a.readShort(o, l), l += 2, c.xMin = a.readShort(o, l), l += 2, c.yMin = a.readShort(o, l), l += 2, c.xMax = a.readShort(o, l), l += 2, c.yMax = a.readShort(o, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax)
        return null;
      if (c.noc > 0) {
        c.endPts = [];
        for (var u = 0; u < c.noc; u++)
          c.endPts.push(a.readUshort(o, l)), l += 2;
        var f = a.readUshort(o, l);
        if (l += 2, o.length - l < f)
          return null;
        c.instructions = a.readBytes(o, l, f), l += f;
        var h = c.endPts[c.noc - 1] + 1;
        for (c.flags = [], u = 0; u < h; u++) {
          var d = o[l];
          if (l++, c.flags.push(d), (8 & d) != 0) {
            var m = o[l];
            l++;
            for (var _ = 0; _ < m; _++)
              c.flags.push(d), u++;
          }
        }
        for (c.xs = [], u = 0; u < h; u++) {
          var g = (2 & c.flags[u]) != 0, A = (16 & c.flags[u]) != 0;
          g ? (c.xs.push(A ? o[l] : -o[l]), l++) : A ? c.xs.push(0) : (c.xs.push(a.readShort(o, l)), l += 2);
        }
        for (c.ys = [], u = 0; u < h; u++)
          g = (4 & c.flags[u]) != 0, A = (32 & c.flags[u]) != 0, g ? (c.ys.push(A ? o[l] : -o[l]), l++) : A ? c.ys.push(0) : (c.ys.push(a.readShort(o, l)), l += 2);
        var v = 0, y = 0;
        for (u = 0; u < h; u++)
          v += c.xs[u], y += c.ys[u], c.xs[u] = v, c.ys[u] = y;
      } else {
        var w;
        c.parts = [];
        do {
          w = a.readUshort(o, l), l += 2;
          var E = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (c.parts.push(E), E.glyphIndex = a.readUshort(o, l), l += 2, 1 & w) {
            var I = a.readShort(o, l);
            l += 2;
            var C = a.readShort(o, l);
            l += 2;
          } else
            I = a.readInt8(o, l), l++, C = a.readInt8(o, l), l++;
          2 & w ? (E.m.tx = I, E.m.ty = C) : (E.p1 = I, E.p2 = C), 8 & w ? (E.m.a = E.m.d = a.readF2dot14(o, l), l += 2) : 64 & w ? (E.m.a = a.readF2dot14(o, l), l += 2, E.m.d = a.readF2dot14(o, l), l += 2) : 128 & w && (E.m.a = a.readF2dot14(o, l), l += 2, E.m.b = a.readF2dot14(o, l), l += 2, E.m.c = a.readF2dot14(o, l), l += 2, E.m.d = a.readF2dot14(o, l), l += 2);
        } while (32 & w);
        if (256 & w) {
          var B = a.readUshort(o, l);
          for (l += 2, c.instr = [], u = 0; u < B; u++)
            c.instr.push(o[l]), l++;
        }
      }
      return c;
    }, e.GDEF = {}, e.GDEF.parse = function(i, r, a, o) {
      var l = r;
      r += 4;
      var c = e._bin.readUshort(i, r);
      return { glyphClassDef: c === 0 ? null : e._lctf.readClassDef(i, l + c) };
    }, e.GPOS = {}, e.GPOS.parse = function(i, r, a, o) {
      return e._lctf.parse(i, r, a, o, e.GPOS.subt);
    }, e.GPOS.subt = function(i, r, a, o) {
      var l = e._bin, c = a, u = {};
      if (u.fmt = l.readUshort(i, a), a += 2, r == 1 || r == 2 || r == 3 || r == 7 || r == 8 && u.fmt <= 2) {
        var f = l.readUshort(i, a);
        a += 2, u.coverage = e._lctf.readCoverage(i, f + c);
      }
      if (r == 1 && u.fmt == 1) {
        var h = l.readUshort(i, a);
        a += 2, h != 0 && (u.pos = e.GPOS.readValueRecord(i, a, h));
      } else if (r == 2 && u.fmt >= 1 && u.fmt <= 2) {
        h = l.readUshort(i, a), a += 2;
        var d = l.readUshort(i, a);
        a += 2;
        var m = e._lctf.numOfOnes(h), _ = e._lctf.numOfOnes(d);
        if (u.fmt == 1) {
          u.pairsets = [];
          var g = l.readUshort(i, a);
          a += 2;
          for (var A = 0; A < g; A++) {
            var v = c + l.readUshort(i, a);
            a += 2;
            var y = l.readUshort(i, v);
            v += 2;
            for (var w = [], E = 0; E < y; E++) {
              var I = l.readUshort(i, v);
              v += 2, h != 0 && (R = e.GPOS.readValueRecord(i, v, h), v += 2 * m), d != 0 && (P = e.GPOS.readValueRecord(i, v, d), v += 2 * _), w.push({ gid2: I, val1: R, val2: P });
            }
            u.pairsets.push(w);
          }
        }
        if (u.fmt == 2) {
          var C = l.readUshort(i, a);
          a += 2;
          var B = l.readUshort(i, a);
          a += 2;
          var T = l.readUshort(i, a);
          a += 2;
          var S = l.readUshort(i, a);
          for (a += 2, u.classDef1 = e._lctf.readClassDef(i, c + C), u.classDef2 = e._lctf.readClassDef(i, c + B), u.matrix = [], A = 0; A < T; A++) {
            var D = [];
            for (E = 0; E < S; E++) {
              var R = null, P = null;
              h != 0 && (R = e.GPOS.readValueRecord(i, a, h), a += 2 * m), d != 0 && (P = e.GPOS.readValueRecord(i, a, d), a += 2 * _), D.push({ val1: R, val2: P });
            }
            u.matrix.push(D);
          }
        }
      } else if (r == 4 && u.fmt == 1)
        u.markCoverage = e._lctf.readCoverage(i, l.readUshort(i, a) + c), u.baseCoverage = e._lctf.readCoverage(i, l.readUshort(i, a + 2) + c), u.markClassCount = l.readUshort(i, a + 4), u.markArray = e.GPOS.readMarkArray(i, l.readUshort(i, a + 6) + c), u.baseArray = e.GPOS.readBaseArray(i, l.readUshort(i, a + 8) + c, u.markClassCount);
      else if (r == 6 && u.fmt == 1)
        u.mark1Coverage = e._lctf.readCoverage(i, l.readUshort(i, a) + c), u.mark2Coverage = e._lctf.readCoverage(i, l.readUshort(i, a + 2) + c), u.markClassCount = l.readUshort(i, a + 4), u.mark1Array = e.GPOS.readMarkArray(i, l.readUshort(i, a + 6) + c), u.mark2Array = e.GPOS.readBaseArray(i, l.readUshort(i, a + 8) + c, u.markClassCount);
      else {
        if (r == 9 && u.fmt == 1) {
          var L = l.readUshort(i, a);
          a += 2;
          var V = l.readUint(i, a);
          if (a += 4, o.ltype == 9)
            o.ltype = L;
          else if (o.ltype != L)
            throw "invalid extension substitution";
          return e.GPOS.subt(i, o.ltype, c + V);
        }
        console.debug("unsupported GPOS table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(i, r, a) {
      var o = e._bin, l = [];
      return l.push(1 & a ? o.readShort(i, r) : 0), r += 1 & a ? 2 : 0, l.push(2 & a ? o.readShort(i, r) : 0), r += 2 & a ? 2 : 0, l.push(4 & a ? o.readShort(i, r) : 0), r += 4 & a ? 2 : 0, l.push(8 & a ? o.readShort(i, r) : 0), r += 8 & a ? 2 : 0, l;
    }, e.GPOS.readBaseArray = function(i, r, a) {
      var o = e._bin, l = [], c = r, u = o.readUshort(i, r);
      r += 2;
      for (var f = 0; f < u; f++) {
        for (var h = [], d = 0; d < a; d++)
          h.push(e.GPOS.readAnchorRecord(i, c + o.readUshort(i, r))), r += 2;
        l.push(h);
      }
      return l;
    }, e.GPOS.readMarkArray = function(i, r) {
      var a = e._bin, o = [], l = r, c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = e.GPOS.readAnchorRecord(i, a.readUshort(i, r + 2) + l);
        f.markClass = a.readUshort(i, r), o.push(f), r += 4;
      }
      return o;
    }, e.GPOS.readAnchorRecord = function(i, r) {
      var a = e._bin, o = {};
      return o.fmt = a.readUshort(i, r), o.x = a.readShort(i, r + 2), o.y = a.readShort(i, r + 4), o;
    }, e.GSUB = {}, e.GSUB.parse = function(i, r, a, o) {
      return e._lctf.parse(i, r, a, o, e.GSUB.subt);
    }, e.GSUB.subt = function(i, r, a, o) {
      var l = e._bin, c = a, u = {};
      if (u.fmt = l.readUshort(i, a), a += 2, r != 1 && r != 2 && r != 4 && r != 5 && r != 6)
        return null;
      if (r == 1 || r == 2 || r == 4 || r == 5 && u.fmt <= 2 || r == 6 && u.fmt <= 2) {
        var f = l.readUshort(i, a);
        a += 2, u.coverage = e._lctf.readCoverage(i, c + f);
      }
      if (r == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = l.readShort(i, a), a += 2;
        else if (u.fmt == 2) {
          var h = l.readUshort(i, a);
          a += 2, u.newg = l.readUshorts(i, a, h), a += 2 * u.newg.length;
        }
      } else if (r == 2 && u.fmt == 1) {
        h = l.readUshort(i, a), a += 2, u.seqs = [];
        for (var d = 0; d < h; d++) {
          var m = l.readUshort(i, a) + c;
          a += 2;
          var _ = l.readUshort(i, m);
          u.seqs.push(l.readUshorts(i, m + 2, _));
        }
      } else if (r == 4)
        for (u.vals = [], h = l.readUshort(i, a), a += 2, d = 0; d < h; d++) {
          var g = l.readUshort(i, a);
          a += 2, u.vals.push(e.GSUB.readLigatureSet(i, c + g));
        }
      else if (r == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var A = l.readUshort(i, a);
          a += 2, u.cDef = e._lctf.readClassDef(i, c + A), u.scset = [];
          var v = l.readUshort(i, a);
          for (a += 2, d = 0; d < v; d++) {
            var y = l.readUshort(i, a);
            a += 2, u.scset.push(y == 0 ? null : e.GSUB.readSubClassSet(i, c + y));
          }
        }
      } else if (r == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (d = 0; d < 3; d++) {
            h = l.readUshort(i, a), a += 2;
            for (var w = [], E = 0; E < h; E++)
              w.push(e._lctf.readCoverage(i, c + l.readUshort(i, a + 2 * E)));
            a += 2 * h, d == 0 && (u.backCvg = w), d == 1 && (u.inptCvg = w), d == 2 && (u.ahedCvg = w);
          }
          h = l.readUshort(i, a), a += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(i, a, h);
        }
      } else {
        if (r == 7 && u.fmt == 1) {
          var I = l.readUshort(i, a);
          a += 2;
          var C = l.readUint(i, a);
          if (a += 4, o.ltype == 9)
            o.ltype = I;
          else if (o.ltype != I)
            throw "invalid extension substitution";
          return e.GSUB.subt(i, o.ltype, c + C);
        }
        console.debug("unsupported GSUB table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(i, r) {
      var a = e._bin.readUshort, o = r, l = [], c = a(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a(i, r);
        r += 2, l.push(e.GSUB.readSubClassRule(i, o + f));
      }
      return l;
    }, e.GSUB.readSubClassRule = function(i, r) {
      var a = e._bin.readUshort, o = {}, l = a(i, r), c = a(i, r += 2);
      r += 2, o.input = [];
      for (var u = 0; u < l - 1; u++)
        o.input.push(a(i, r)), r += 2;
      return o.substLookupRecords = e.GSUB.readSubstLookupRecords(i, r, c), o;
    }, e.GSUB.readSubstLookupRecords = function(i, r, a) {
      for (var o = e._bin.readUshort, l = [], c = 0; c < a; c++)
        l.push(o(i, r), o(i, r + 2)), r += 4;
      return l;
    }, e.GSUB.readChainSubClassSet = function(i, r) {
      var a = e._bin, o = r, l = [], c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readUshort(i, r);
        r += 2, l.push(e.GSUB.readChainSubClassRule(i, o + f));
      }
      return l;
    }, e.GSUB.readChainSubClassRule = function(i, r) {
      for (var a = e._bin, o = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) {
        var u = a.readUshort(i, r);
        r += 2, c == 1 && u--, o[l[c]] = a.readUshorts(i, r, u), r += 2 * o[l[c]].length;
      }
      return u = a.readUshort(i, r), r += 2, o.subst = a.readUshorts(i, r, 2 * u), r += 2 * o.subst.length, o;
    }, e.GSUB.readLigatureSet = function(i, r) {
      var a = e._bin, o = r, l = [], c = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < c; u++) {
        var f = a.readUshort(i, r);
        r += 2, l.push(e.GSUB.readLigature(i, o + f));
      }
      return l;
    }, e.GSUB.readLigature = function(i, r) {
      var a = e._bin, o = { chain: [] };
      o.nglyph = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2;
      for (var c = 0; c < l - 1; c++)
        o.chain.push(a.readUshort(i, r)), r += 2;
      return o;
    }, e.head = {}, e.head.parse = function(i, r, a) {
      var o = e._bin, l = {};
      return o.readFixed(i, r), r += 4, l.fontRevision = o.readFixed(i, r), r += 4, o.readUint(i, r), r += 4, o.readUint(i, r), r += 4, l.flags = o.readUshort(i, r), r += 2, l.unitsPerEm = o.readUshort(i, r), r += 2, l.created = o.readUint64(i, r), r += 8, l.modified = o.readUint64(i, r), r += 8, l.xMin = o.readShort(i, r), r += 2, l.yMin = o.readShort(i, r), r += 2, l.xMax = o.readShort(i, r), r += 2, l.yMax = o.readShort(i, r), r += 2, l.macStyle = o.readUshort(i, r), r += 2, l.lowestRecPPEM = o.readUshort(i, r), r += 2, l.fontDirectionHint = o.readShort(i, r), r += 2, l.indexToLocFormat = o.readShort(i, r), r += 2, l.glyphDataFormat = o.readShort(i, r), r += 2, l;
    }, e.hhea = {}, e.hhea.parse = function(i, r, a) {
      var o = e._bin, l = {};
      return o.readFixed(i, r), r += 4, l.ascender = o.readShort(i, r), r += 2, l.descender = o.readShort(i, r), r += 2, l.lineGap = o.readShort(i, r), r += 2, l.advanceWidthMax = o.readUshort(i, r), r += 2, l.minLeftSideBearing = o.readShort(i, r), r += 2, l.minRightSideBearing = o.readShort(i, r), r += 2, l.xMaxExtent = o.readShort(i, r), r += 2, l.caretSlopeRise = o.readShort(i, r), r += 2, l.caretSlopeRun = o.readShort(i, r), r += 2, l.caretOffset = o.readShort(i, r), r += 2, r += 8, l.metricDataFormat = o.readShort(i, r), r += 2, l.numberOfHMetrics = o.readUshort(i, r), r += 2, l;
    }, e.hmtx = {}, e.hmtx.parse = function(i, r, a, o) {
      for (var l = e._bin, c = { aWidth: [], lsBearing: [] }, u = 0, f = 0, h = 0; h < o.maxp.numGlyphs; h++)
        h < o.hhea.numberOfHMetrics && (u = l.readUshort(i, r), r += 2, f = l.readShort(i, r), r += 2), c.aWidth.push(u), c.lsBearing.push(f);
      return c;
    }, e.kern = {}, e.kern.parse = function(i, r, a, o) {
      var l = e._bin, c = l.readUshort(i, r);
      if (r += 2, c == 1)
        return e.kern.parseV1(i, r - 2, a, o);
      var u = l.readUshort(i, r);
      r += 2;
      for (var f = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
        r += 2, a = l.readUshort(i, r), r += 2;
        var d = l.readUshort(i, r);
        r += 2;
        var m = d >>> 8;
        if ((m &= 15) != 0)
          throw "unknown kern table format: " + m;
        r = e.kern.readFormat0(i, r, f);
      }
      return f;
    }, e.kern.parseV1 = function(i, r, a, o) {
      var l = e._bin;
      l.readFixed(i, r), r += 4;
      var c = l.readUint(i, r);
      r += 4;
      for (var u = { glyph1: [], rval: [] }, f = 0; f < c; f++) {
        l.readUint(i, r), r += 4;
        var h = l.readUshort(i, r);
        r += 2, l.readUshort(i, r), r += 2;
        var d = h >>> 8;
        if ((d &= 15) != 0)
          throw "unknown kern table format: " + d;
        r = e.kern.readFormat0(i, r, u);
      }
      return u;
    }, e.kern.readFormat0 = function(i, r, a) {
      var o = e._bin, l = -1, c = o.readUshort(i, r);
      r += 2, o.readUshort(i, r), r += 2, o.readUshort(i, r), r += 2, o.readUshort(i, r), r += 2;
      for (var u = 0; u < c; u++) {
        var f = o.readUshort(i, r);
        r += 2;
        var h = o.readUshort(i, r);
        r += 2;
        var d = o.readShort(i, r);
        r += 2, f != l && (a.glyph1.push(f), a.rval.push({ glyph2: [], vals: [] }));
        var m = a.rval[a.rval.length - 1];
        m.glyph2.push(h), m.vals.push(d), l = f;
      }
      return r;
    }, e.loca = {}, e.loca.parse = function(i, r, a, o) {
      var l = e._bin, c = [], u = o.head.indexToLocFormat, f = o.maxp.numGlyphs + 1;
      if (u == 0)
        for (var h = 0; h < f; h++)
          c.push(l.readUshort(i, r + (h << 1)) << 1);
      if (u == 1)
        for (h = 0; h < f; h++)
          c.push(l.readUint(i, r + (h << 2)));
      return c;
    }, e.maxp = {}, e.maxp.parse = function(i, r, a) {
      var o = e._bin, l = {}, c = o.readUint(i, r);
      return r += 4, l.numGlyphs = o.readUshort(i, r), r += 2, c == 65536 && (l.maxPoints = o.readUshort(i, r), r += 2, l.maxContours = o.readUshort(i, r), r += 2, l.maxCompositePoints = o.readUshort(i, r), r += 2, l.maxCompositeContours = o.readUshort(i, r), r += 2, l.maxZones = o.readUshort(i, r), r += 2, l.maxTwilightPoints = o.readUshort(i, r), r += 2, l.maxStorage = o.readUshort(i, r), r += 2, l.maxFunctionDefs = o.readUshort(i, r), r += 2, l.maxInstructionDefs = o.readUshort(i, r), r += 2, l.maxStackElements = o.readUshort(i, r), r += 2, l.maxSizeOfInstructions = o.readUshort(i, r), r += 2, l.maxComponentElements = o.readUshort(i, r), r += 2, l.maxComponentDepth = o.readUshort(i, r), r += 2), l;
    }, e.name = {}, e.name.parse = function(i, r, a) {
      var o = e._bin, l = {};
      o.readUshort(i, r), r += 2;
      var c = o.readUshort(i, r);
      r += 2, o.readUshort(i, r);
      for (var u, f = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], h = r += 2, d = 0; d < c; d++) {
        var m = o.readUshort(i, r);
        r += 2;
        var _ = o.readUshort(i, r);
        r += 2;
        var g = o.readUshort(i, r);
        r += 2;
        var A = o.readUshort(i, r);
        r += 2;
        var v = o.readUshort(i, r);
        r += 2;
        var y = o.readUshort(i, r);
        r += 2;
        var w, E = f[A], I = h + 12 * c + y;
        if (m == 0)
          w = o.readUnicode(i, I, v / 2);
        else if (m == 3 && _ == 0)
          w = o.readUnicode(i, I, v / 2);
        else if (_ == 0)
          w = o.readASCII(i, I, v);
        else if (_ == 1)
          w = o.readUnicode(i, I, v / 2);
        else if (_ == 3)
          w = o.readUnicode(i, I, v / 2);
        else {
          if (m != 1)
            throw "unknown encoding " + _ + ", platformID: " + m;
          w = o.readASCII(i, I, v), console.debug("reading unknown MAC encoding " + _ + " as ASCII");
        }
        var C = "p" + m + "," + g.toString(16);
        l[C] == null && (l[C] = {}), l[C][E !== void 0 ? E : A] = w, l[C]._lang = g;
      }
      for (var B in l)
        if (l[B].postScriptName != null && l[B]._lang == 1033)
          return l[B];
      for (var B in l)
        if (l[B].postScriptName != null && l[B]._lang == 0)
          return l[B];
      for (var B in l)
        if (l[B].postScriptName != null && l[B]._lang == 3084)
          return l[B];
      for (var B in l)
        if (l[B].postScriptName != null)
          return l[B];
      for (var B in l) {
        u = B;
        break;
      }
      return console.debug("returning name table with languageID " + l[u]._lang), l[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(i, r, a) {
      var o = e._bin.readUshort(i, r);
      r += 2;
      var l = {};
      if (o == 0)
        e["OS/2"].version0(i, r, l);
      else if (o == 1)
        e["OS/2"].version1(i, r, l);
      else if (o == 2 || o == 3 || o == 4)
        e["OS/2"].version2(i, r, l);
      else {
        if (o != 5)
          throw "unknown OS/2 table version: " + o;
        e["OS/2"].version5(i, r, l);
      }
      return l;
    }, e["OS/2"].version0 = function(i, r, a) {
      var o = e._bin;
      return a.xAvgCharWidth = o.readShort(i, r), r += 2, a.usWeightClass = o.readUshort(i, r), r += 2, a.usWidthClass = o.readUshort(i, r), r += 2, a.fsType = o.readUshort(i, r), r += 2, a.ySubscriptXSize = o.readShort(i, r), r += 2, a.ySubscriptYSize = o.readShort(i, r), r += 2, a.ySubscriptXOffset = o.readShort(i, r), r += 2, a.ySubscriptYOffset = o.readShort(i, r), r += 2, a.ySuperscriptXSize = o.readShort(i, r), r += 2, a.ySuperscriptYSize = o.readShort(i, r), r += 2, a.ySuperscriptXOffset = o.readShort(i, r), r += 2, a.ySuperscriptYOffset = o.readShort(i, r), r += 2, a.yStrikeoutSize = o.readShort(i, r), r += 2, a.yStrikeoutPosition = o.readShort(i, r), r += 2, a.sFamilyClass = o.readShort(i, r), r += 2, a.panose = o.readBytes(i, r, 10), r += 10, a.ulUnicodeRange1 = o.readUint(i, r), r += 4, a.ulUnicodeRange2 = o.readUint(i, r), r += 4, a.ulUnicodeRange3 = o.readUint(i, r), r += 4, a.ulUnicodeRange4 = o.readUint(i, r), r += 4, a.achVendID = [o.readInt8(i, r), o.readInt8(i, r + 1), o.readInt8(i, r + 2), o.readInt8(i, r + 3)], r += 4, a.fsSelection = o.readUshort(i, r), r += 2, a.usFirstCharIndex = o.readUshort(i, r), r += 2, a.usLastCharIndex = o.readUshort(i, r), r += 2, a.sTypoAscender = o.readShort(i, r), r += 2, a.sTypoDescender = o.readShort(i, r), r += 2, a.sTypoLineGap = o.readShort(i, r), r += 2, a.usWinAscent = o.readUshort(i, r), r += 2, a.usWinDescent = o.readUshort(i, r), r += 2;
    }, e["OS/2"].version1 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version0(i, r, a), a.ulCodePageRange1 = o.readUint(i, r), r += 4, a.ulCodePageRange2 = o.readUint(i, r), r += 4;
    }, e["OS/2"].version2 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version1(i, r, a), a.sxHeight = o.readShort(i, r), r += 2, a.sCapHeight = o.readShort(i, r), r += 2, a.usDefault = o.readUshort(i, r), r += 2, a.usBreak = o.readUshort(i, r), r += 2, a.usMaxContext = o.readUshort(i, r), r += 2;
    }, e["OS/2"].version5 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version2(i, r, a), a.usLowerOpticalPointSize = o.readUshort(i, r), r += 2, a.usUpperOpticalPointSize = o.readUshort(i, r), r += 2;
    }, e.post = {}, e.post.parse = function(i, r, a) {
      var o = e._bin, l = {};
      return l.version = o.readFixed(i, r), r += 4, l.italicAngle = o.readFixed(i, r), r += 4, l.underlinePosition = o.readShort(i, r), r += 2, l.underlineThickness = o.readShort(i, r), r += 2, l;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, r) {
      var a = i.cmap, o = -1;
      if (a.p0e4 != null ? o = a.p0e4 : a.p3e1 != null ? o = a.p3e1 : a.p1e0 != null ? o = a.p1e0 : a.p0e3 != null && (o = a.p0e3), o == -1)
        throw "no familiar platform and encoding!";
      var l = a.tables[o];
      if (l.format == 0)
        return r >= l.map.length ? 0 : l.map[r];
      if (l.format == 4) {
        for (var c = -1, u = 0; u < l.endCount.length; u++)
          if (r <= l.endCount[u]) {
            c = u;
            break;
          }
        return c == -1 || l.startCount[c] > r ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[r - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : r + l.idDelta[c]);
      }
      if (l.format == 12) {
        if (r > l.groups[l.groups.length - 1][1])
          return 0;
        for (u = 0; u < l.groups.length; u++) {
          var f = l.groups[u];
          if (f[0] <= r && r <= f[1])
            return f[2] + (r - f[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + l.format;
    }, e.U.glyphToPath = function(i, r) {
      var a = { cmds: [], crds: [] };
      if (i.SVG && i.SVG.entries[r]) {
        var o = i.SVG.entries[r];
        return o == null ? a : (typeof o == "string" && (o = e.SVG.toPath(o), i.SVG.entries[r] = o), o);
      }
      if (i.CFF) {
        var l = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, c = i.CFF, u = i.CFF.Private;
        if (c.ROS) {
          for (var f = 0; c.FDSelect[f + 2] <= r; )
            f += 2;
          u = c.FDArray[c.FDSelect[f + 1]].Private;
        }
        e.U._drawCFF(i.CFF.CharStrings[r], l, c, u, a);
      } else
        i.glyf && e.U._drawGlyf(r, i, a);
      return a;
    }, e.U._drawGlyf = function(i, r, a) {
      var o = r.glyf[i];
      o == null && (o = r.glyf[i] = e.glyf._parseGlyf(r, i)), o != null && (o.noc > -1 ? e.U._simpleGlyph(o, a) : e.U._compoGlyph(o, r, a));
    }, e.U._simpleGlyph = function(i, r) {
      for (var a = 0; a < i.noc; a++) {
        for (var o = a == 0 ? 0 : i.endPts[a - 1] + 1, l = i.endPts[a], c = o; c <= l; c++) {
          var u = c == o ? l : c - 1, f = c == l ? o : c + 1, h = 1 & i.flags[c], d = 1 & i.flags[u], m = 1 & i.flags[f], _ = i.xs[c], g = i.ys[c];
          if (c == o)
            if (h) {
              if (!d) {
                e.U.P.moveTo(r, _, g);
                continue;
              }
              e.U.P.moveTo(r, i.xs[u], i.ys[u]);
            } else
              d ? e.U.P.moveTo(r, i.xs[u], i.ys[u]) : e.U.P.moveTo(r, (i.xs[u] + _) / 2, (i.ys[u] + g) / 2);
          h ? d && e.U.P.lineTo(r, _, g) : m ? e.U.P.qcurveTo(r, _, g, i.xs[f], i.ys[f]) : e.U.P.qcurveTo(r, _, g, (_ + i.xs[f]) / 2, (g + i.ys[f]) / 2);
        }
        e.U.P.closePath(r);
      }
    }, e.U._compoGlyph = function(i, r, a) {
      for (var o = 0; o < i.parts.length; o++) {
        var l = { cmds: [], crds: [] }, c = i.parts[o];
        e.U._drawGlyf(c.glyphIndex, r, l);
        for (var u = c.m, f = 0; f < l.crds.length; f += 2) {
          var h = l.crds[f], d = l.crds[f + 1];
          a.crds.push(h * u.a + d * u.b + u.tx), a.crds.push(h * u.c + d * u.d + u.ty);
        }
        for (f = 0; f < l.cmds.length; f++)
          a.cmds.push(l.cmds[f]);
      }
    }, e.U._getGlyphClass = function(i, r) {
      var a = e._lctf.getInterval(r, i);
      return a == -1 ? 0 : r[a + 2];
    }, e.U._applySubs = function(i, r, a, o) {
      for (var l = i.length - r - 1, c = 0; c < a.tabs.length; c++)
        if (a.tabs[c] != null) {
          var u, f = a.tabs[c];
          if (!f.coverage || (u = e._lctf.coverageIndex(f.coverage, i[r])) != -1) {
            if (a.ltype == 1)
              i[r], f.fmt == 1 ? i[r] = i[r] + f.delta : i[r] = f.newg[u];
            else if (a.ltype == 4)
              for (var h = f.vals[u], d = 0; d < h.length; d++) {
                var m = h[d], _ = m.chain.length;
                if (!(_ > l)) {
                  for (var g = !0, A = 0, v = 0; v < _; v++) {
                    for (; i[r + A + (1 + v)] == -1; )
                      A++;
                    m.chain[v] != i[r + A + (1 + v)] && (g = !1);
                  }
                  if (g) {
                    for (i[r] = m.nglyph, v = 0; v < _ + A; v++)
                      i[r + v + 1] = -1;
                    break;
                  }
                }
              }
            else if (a.ltype == 5 && f.fmt == 2)
              for (var y = e._lctf.getInterval(f.cDef, i[r]), w = f.cDef[y + 2], E = f.scset[w], I = 0; I < E.length; I++) {
                var C = E[I], B = C.input;
                if (!(B.length > l)) {
                  for (g = !0, v = 0; v < B.length; v++) {
                    var T = e._lctf.getInterval(f.cDef, i[r + 1 + v]);
                    if (y == -1 && f.cDef[T + 2] != B[v]) {
                      g = !1;
                      break;
                    }
                  }
                  if (g) {
                    var S = C.substLookupRecords;
                    for (d = 0; d < S.length; d += 2)
                      S[d], S[d + 1];
                  }
                }
              }
            else if (a.ltype == 6 && f.fmt == 3) {
              if (!e.U._glsCovered(i, f.backCvg, r - f.backCvg.length) || !e.U._glsCovered(i, f.inptCvg, r) || !e.U._glsCovered(i, f.ahedCvg, r + f.inptCvg.length))
                continue;
              var D = f.lookupRec;
              for (I = 0; I < D.length; I += 2) {
                y = D[I];
                var R = o[D[I + 1]];
                e.U._applySubs(i, r + y, R, o);
              }
            }
          }
        }
    }, e.U._glsCovered = function(i, r, a) {
      for (var o = 0; o < r.length; o++)
        if (e._lctf.coverageIndex(r[o], i[a + o]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(i, r, a) {
      for (var o = { cmds: [], crds: [] }, l = 0, c = 0; c < r.length; c++) {
        var u = r[c];
        if (u != -1) {
          for (var f = c < r.length - 1 && r[c + 1] != -1 ? r[c + 1] : 0, h = e.U.glyphToPath(i, u), d = 0; d < h.crds.length; d += 2)
            o.crds.push(h.crds[d] + l), o.crds.push(h.crds[d + 1]);
          for (a && o.cmds.push(a), d = 0; d < h.cmds.length; d++)
            o.cmds.push(h.cmds[d]);
          a && o.cmds.push("X"), l += i.hmtx.aWidth[u], c < r.length - 1 && (l += e.U.getPairAdjustment(i, u, f));
        }
      }
      return o;
    }, e.U.P = {}, e.U.P.moveTo = function(i, r, a) {
      i.cmds.push("M"), i.crds.push(r, a);
    }, e.U.P.lineTo = function(i, r, a) {
      i.cmds.push("L"), i.crds.push(r, a);
    }, e.U.P.curveTo = function(i, r, a, o, l, c, u) {
      i.cmds.push("C"), i.crds.push(r, a, o, l, c, u);
    }, e.U.P.qcurveTo = function(i, r, a, o, l) {
      i.cmds.push("Q"), i.crds.push(r, a, o, l);
    }, e.U.P.closePath = function(i) {
      i.cmds.push("Z");
    }, e.U._drawCFF = function(i, r, a, o, l) {
      for (var c = r.stack, u = r.nStems, f = r.haveWidth, h = r.width, d = r.open, m = 0, _ = r.x, g = r.y, A = 0, v = 0, y = 0, w = 0, E = 0, I = 0, C = 0, B = 0, T = 0, S = 0, D = { val: 0, size: 0 }; m < i.length; ) {
        e.CFF.getCharString(i, m, D);
        var R = D.val;
        if (m += D.size, R == "o1" || R == "o18")
          c.length % 2 != 0 && !f && (h = c.shift() + o.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0;
        else if (R == "o3" || R == "o23")
          c.length % 2 != 0 && !f && (h = c.shift() + o.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0;
        else if (R == "o4")
          c.length > 1 && !f && (h = c.shift() + o.nominalWidthX, f = !0), d && e.U.P.closePath(l), g += c.pop(), e.U.P.moveTo(l, _, g), d = !0;
        else if (R == "o5")
          for (; c.length > 0; )
            _ += c.shift(), g += c.shift(), e.U.P.lineTo(l, _, g);
        else if (R == "o6" || R == "o7")
          for (var P = c.length, L = R == "o6", V = 0; V < P; V++) {
            var U = c.shift();
            L ? _ += U : g += U, L = !L, e.U.P.lineTo(l, _, g);
          }
        else if (R == "o8" || R == "o24") {
          P = c.length;
          for (var Q = 0; Q + 6 <= P; )
            A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), _ = y + c.shift(), g = w + c.shift(), e.U.P.curveTo(l, A, v, y, w, _, g), Q += 6;
          R == "o24" && (_ += c.shift(), g += c.shift(), e.U.P.lineTo(l, _, g));
        } else {
          if (R == "o11")
            break;
          if (R == "o1234" || R == "o1235" || R == "o1236" || R == "o1237")
            R == "o1234" && (v = g, y = (A = _ + c.shift()) + c.shift(), S = w = v + c.shift(), I = w, B = g, _ = (C = (E = (T = y + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g)), R == "o1235" && (A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), T = y + c.shift(), S = w + c.shift(), E = T + c.shift(), I = S + c.shift(), C = E + c.shift(), B = I + c.shift(), _ = C + c.shift(), g = B + c.shift(), c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g)), R == "o1236" && (A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), S = w = v + c.shift(), I = w, C = (E = (T = y + c.shift()) + c.shift()) + c.shift(), B = I + c.shift(), _ = C + c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g)), R == "o1237" && (A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), T = y + c.shift(), S = w + c.shift(), E = T + c.shift(), I = S + c.shift(), C = E + c.shift(), B = I + c.shift(), Math.abs(C - _) > Math.abs(B - g) ? _ = C + c.shift() : g = B + c.shift(), e.U.P.curveTo(l, A, v, y, w, T, S), e.U.P.curveTo(l, E, I, C, B, _, g));
          else if (R == "o14") {
            if (c.length > 0 && !f && (h = c.shift() + a.nominalWidthX, f = !0), c.length == 4) {
              var q = c.shift(), oe = c.shift(), le = c.shift(), k = c.shift(), X = e.CFF.glyphBySE(a, le), fe = e.CFF.glyphBySE(a, k);
              e.U._drawCFF(a.CharStrings[X], r, a, o, l), r.x = q, r.y = oe, e.U._drawCFF(a.CharStrings[fe], r, a, o, l);
            }
            d && (e.U.P.closePath(l), d = !1);
          } else if (R == "o19" || R == "o20")
            c.length % 2 != 0 && !f && (h = c.shift() + o.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0, m += u + 7 >> 3;
          else if (R == "o21")
            c.length > 2 && !f && (h = c.shift() + o.nominalWidthX, f = !0), g += c.pop(), _ += c.pop(), d && e.U.P.closePath(l), e.U.P.moveTo(l, _, g), d = !0;
          else if (R == "o22")
            c.length > 1 && !f && (h = c.shift() + o.nominalWidthX, f = !0), _ += c.pop(), d && e.U.P.closePath(l), e.U.P.moveTo(l, _, g), d = !0;
          else if (R == "o25") {
            for (; c.length > 6; )
              _ += c.shift(), g += c.shift(), e.U.P.lineTo(l, _, g);
            A = _ + c.shift(), v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), _ = y + c.shift(), g = w + c.shift(), e.U.P.curveTo(l, A, v, y, w, _, g);
          } else if (R == "o26")
            for (c.length % 2 && (_ += c.shift()); c.length > 0; )
              A = _, v = g + c.shift(), _ = y = A + c.shift(), g = (w = v + c.shift()) + c.shift(), e.U.P.curveTo(l, A, v, y, w, _, g);
          else if (R == "o27")
            for (c.length % 2 && (g += c.shift()); c.length > 0; )
              v = g, y = (A = _ + c.shift()) + c.shift(), w = v + c.shift(), _ = y + c.shift(), g = w, e.U.P.curveTo(l, A, v, y, w, _, g);
          else if (R == "o10" || R == "o29") {
            var te = R == "o10" ? o : a;
            if (c.length == 0)
              console.debug("error: empty stack");
            else {
              var j = c.pop(), Ae = te.Subrs[j + te.Bias];
              r.x = _, r.y = g, r.nStems = u, r.haveWidth = f, r.width = h, r.open = d, e.U._drawCFF(Ae, r, a, o, l), _ = r.x, g = r.y, u = r.nStems, f = r.haveWidth, h = r.width, d = r.open;
            }
          } else if (R == "o30" || R == "o31") {
            var Y = c.length, pe = (Q = 0, R == "o31");
            for (Q += Y - (P = -3 & Y); Q < P; )
              pe ? (v = g, y = (A = _ + c.shift()) + c.shift(), g = (w = v + c.shift()) + c.shift(), P - Q == 5 ? (_ = y + c.shift(), Q++) : _ = y, pe = !1) : (A = _, v = g + c.shift(), y = A + c.shift(), w = v + c.shift(), _ = y + c.shift(), P - Q == 5 ? (g = w + c.shift(), Q++) : g = w, pe = !0), e.U.P.curveTo(l, A, v, y, w, _, g), Q += 4;
          } else {
            if ((R + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + R, i), R;
            c.push(R);
          }
        }
      }
      r.x = _, r.y = g, r.nStems = u, r.haveWidth = f, r.width = h, r.open = d;
    };
    var t = e, n = { Typr: t };
    return s.Typr = t, s.default = n, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function f5() {
  return function(s) {
    var e = Uint8Array, t = Uint16Array, n = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), r = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o = function(R, P) {
      for (var L = new t(31), V = 0; V < 31; ++V)
        L[V] = P += 1 << R[V - 1];
      var U = new n(L[30]);
      for (V = 1; V < 30; ++V)
        for (var Q = L[V]; Q < L[V + 1]; ++Q)
          U[Q] = Q - L[V] << 5 | V;
      return [L, U];
    }, l = o(i, 2), c = l[0], u = l[1];
    c[28] = 258, u[258] = 28;
    for (var f = o(r, 0)[0], h = new t(32768), d = 0; d < 32768; ++d) {
      var m = (43690 & d) >>> 1 | (21845 & d) << 1;
      m = (61680 & (m = (52428 & m) >>> 2 | (13107 & m) << 2)) >>> 4 | (3855 & m) << 4, h[d] = ((65280 & m) >>> 8 | (255 & m) << 8) >>> 1;
    }
    var _ = function(R, P, L) {
      for (var V = R.length, U = 0, Q = new t(P); U < V; ++U)
        ++Q[R[U] - 1];
      var q, oe = new t(P);
      for (U = 0; U < P; ++U)
        oe[U] = oe[U - 1] + Q[U - 1] << 1;
      if (L) {
        q = new t(1 << P);
        var le = 15 - P;
        for (U = 0; U < V; ++U)
          if (R[U])
            for (var k = U << 4 | R[U], X = P - R[U], fe = oe[R[U] - 1]++ << X, te = fe | (1 << X) - 1; fe <= te; ++fe)
              q[h[fe] >>> le] = k;
      } else
        for (q = new t(V), U = 0; U < V; ++U)
          R[U] && (q[U] = h[oe[R[U] - 1]++] >>> 15 - R[U]);
      return q;
    }, g = new e(288);
    for (d = 0; d < 144; ++d)
      g[d] = 8;
    for (d = 144; d < 256; ++d)
      g[d] = 9;
    for (d = 256; d < 280; ++d)
      g[d] = 7;
    for (d = 280; d < 288; ++d)
      g[d] = 8;
    var A = new e(32);
    for (d = 0; d < 32; ++d)
      A[d] = 5;
    var v = _(g, 9, 1), y = _(A, 5, 1), w = function(R) {
      for (var P = R[0], L = 1; L < R.length; ++L)
        R[L] > P && (P = R[L]);
      return P;
    }, E = function(R, P, L) {
      var V = P / 8 | 0;
      return (R[V] | R[V + 1] << 8) >> (7 & P) & L;
    }, I = function(R, P) {
      var L = P / 8 | 0;
      return (R[L] | R[L + 1] << 8 | R[L + 2] << 16) >> (7 & P);
    }, C = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], B = function(R, P, L) {
      var V = new Error(P || C[R]);
      if (V.code = R, Error.captureStackTrace && Error.captureStackTrace(V, B), !L)
        throw V;
      return V;
    }, T = function(R, P, L) {
      var V = R.length;
      if (!V || L && !L.l && V < 5)
        return P || new e(0);
      var U = !P || L, Q = !L || L.i;
      L || (L = {}), P || (P = new e(3 * V));
      var q, oe = function(Qe) {
        var Ze = P.length;
        if (Qe > Ze) {
          var Ke = new e(Math.max(2 * Ze, Qe));
          Ke.set(P), P = Ke;
        }
      }, le = L.f || 0, k = L.p || 0, X = L.b || 0, fe = L.l, te = L.d, j = L.m, Ae = L.n, Y = 8 * V;
      do {
        if (!fe) {
          L.f = le = E(R, k, 1);
          var pe = E(R, k + 1, 3);
          if (k += 3, !pe) {
            var me = R[(G = ((q = k) / 8 | 0) + (7 & q && 1) + 4) - 4] | R[G - 3] << 8, re = G + me;
            if (re > V) {
              Q && B(0);
              break;
            }
            U && oe(X + me), P.set(R.subarray(G, re), X), L.b = X += me, L.p = k = 8 * re;
            continue;
          }
          if (pe == 1)
            fe = v, te = y, j = 9, Ae = 5;
          else if (pe == 2) {
            var ye = E(R, k, 31) + 257, ae = E(R, k + 10, 15) + 4, De = ye + E(R, k + 5, 31) + 1;
            k += 14;
            for (var Ee = new e(De), Ie = new e(19), Ce = 0; Ce < ae; ++Ce)
              Ie[a[Ce]] = E(R, k + 3 * Ce, 7);
            k += 3 * ae;
            var ze = w(Ie), Fe = (1 << ze) - 1, W = _(Ie, ze, 1);
            for (Ce = 0; Ce < De; ) {
              var G, se = W[E(R, k, Fe)];
              if (k += 15 & se, (G = se >>> 4) < 16)
                Ee[Ce++] = G;
              else {
                var _e = 0, ve = 0;
                for (G == 16 ? (ve = 3 + E(R, k, 3), k += 2, _e = Ee[Ce - 1]) : G == 17 ? (ve = 3 + E(R, k, 7), k += 3) : G == 18 && (ve = 11 + E(R, k, 127), k += 7); ve--; )
                  Ee[Ce++] = _e;
              }
            }
            var ue = Ee.subarray(0, ye), Te = Ee.subarray(ye);
            j = w(ue), Ae = w(Te), fe = _(ue, j, 1), te = _(Te, Ae, 1);
          } else
            B(1);
          if (k > Y) {
            Q && B(0);
            break;
          }
        }
        U && oe(X + 131072);
        for (var Ge = (1 << j) - 1, Pe = (1 << Ae) - 1, he = k; ; he = k) {
          var Se = (_e = fe[I(R, k) & Ge]) >>> 4;
          if ((k += 15 & _e) > Y) {
            Q && B(0);
            break;
          }
          if (_e || B(2), Se < 256)
            P[X++] = Se;
          else {
            if (Se == 256) {
              he = k, fe = null;
              break;
            }
            var Ve = Se - 254;
            if (Se > 264) {
              var Ye = i[Ce = Se - 257];
              Ve = E(R, k, (1 << Ye) - 1) + c[Ce], k += Ye;
            }
            var $e = te[I(R, k) & Pe], Ne = $e >>> 4;
            if ($e || B(3), k += 15 & $e, Te = f[Ne], Ne > 3 && (Ye = r[Ne], Te += I(R, k) & (1 << Ye) - 1, k += Ye), k > Y) {
              Q && B(0);
              break;
            }
            U && oe(X + 131072);
            for (var He = X + Ve; X < He; X += 4)
              P[X] = P[X - Te], P[X + 1] = P[X + 1 - Te], P[X + 2] = P[X + 2 - Te], P[X + 3] = P[X + 3 - Te];
            X = He;
          }
        }
        L.l = fe, L.p = he, L.b = X, fe && (le = 1, L.m = j, L.d = te, L.n = Ae);
      } while (!le);
      return X == P.length ? P : function(Qe, Ze, Ke) {
        (Ze == null || Ze < 0) && (Ze = 0), (Ke == null || Ke > Qe.length) && (Ke = Qe.length);
        var $ = new (Qe instanceof t ? t : Qe instanceof n ? n : e)(Ke - Ze);
        return $.set(Qe.subarray(Ze, Ke)), $;
      }(P, 0, X);
    }, S = new e(0), D = typeof TextDecoder < "u" && new TextDecoder();
    try {
      D.decode(S, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(R) {
      var P = new DataView(R), L = 0;
      function V() {
        var ye = P.getUint16(L);
        return L += 2, ye;
      }
      function U() {
        var ye = P.getUint32(L);
        return L += 4, ye;
      }
      function Q(ye) {
        me.setUint16(re, ye), re += 2;
      }
      function q(ye) {
        me.setUint32(re, ye), re += 4;
      }
      for (var oe = { signature: U(), flavor: U(), length: U(), numTables: V(), reserved: V(), totalSfntSize: U(), majorVersion: V(), minorVersion: V(), metaOffset: U(), metaLength: U(), metaOrigLength: U(), privOffset: U(), privLength: U() }, le = 0; Math.pow(2, le) <= oe.numTables; )
        le++;
      le--;
      for (var k = 16 * Math.pow(2, le), X = 16 * oe.numTables - k, fe = 12, te = [], j = 0; j < oe.numTables; j++)
        te.push({ tag: U(), offset: U(), compLength: U(), origLength: U(), origChecksum: U() }), fe += 16;
      var Ae, Y = new Uint8Array(12 + 16 * te.length + te.reduce(function(ye, ae) {
        return ye + ae.origLength + 4;
      }, 0)), pe = Y.buffer, me = new DataView(pe), re = 0;
      return q(oe.flavor), Q(oe.numTables), Q(k), Q(le), Q(X), te.forEach(function(ye) {
        q(ye.tag), q(ye.origChecksum), q(fe), q(ye.origLength), ye.outOffset = fe, (fe += ye.origLength) % 4 != 0 && (fe += 4 - fe % 4);
      }), te.forEach(function(ye) {
        var ae, De = R.slice(ye.offset, ye.offset + ye.compLength);
        if (ye.compLength != ye.origLength) {
          var Ee = new Uint8Array(ye.origLength);
          ae = new Uint8Array(De, 2), T(ae, Ee);
        } else
          Ee = new Uint8Array(De);
        Y.set(Ee, ye.outOffset);
        var Ie = 0;
        (fe = ye.outOffset + ye.origLength) % 4 != 0 && (Ie = 4 - fe % 4), Y.set(new Uint8Array(Ie).buffer, ye.outOffset + ye.origLength), Ae = fe + Ie;
      }), pe.slice(0, Ae);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function h5(s, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, n = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, r = 2, a = 4, o = 8, l = 16, c = 32;
  let u;
  function f(C) {
    if (!u) {
      const B = {
        R: r,
        L: i,
        D: a,
        C: l,
        U: c,
        T: o
      };
      u = /* @__PURE__ */ new Map();
      for (let T in n) {
        let S = 0;
        n[T].split(",").forEach((D) => {
          let [R, P] = D.split("+");
          R = parseInt(R, 36), P = P ? parseInt(P, 36) : 0, u.set(S += R, B[T]);
          for (let L = P; L--; )
            u.set(++S, B[T]);
        });
      }
    }
    return u.get(C) || c;
  }
  const h = 1, d = 2, m = 3, _ = 4, g = [null, "isol", "init", "fina", "medi"];
  function A(C) {
    const B = new Uint8Array(C.length);
    let T = c, S = h, D = -1;
    for (let R = 0; R < C.length; R++) {
      const P = C.codePointAt(R);
      let L = f(P) | 0, V = h;
      L & o || (T & (i | a | l) ? L & (r | a | l) ? (V = m, (S === h || S === m) && B[D]++) : L & (i | c) && (S === d || S === _) && B[D]-- : T & (r | c) && (S === d || S === _) && B[D]--, S = B[R] = V, T = L, D = R, P > 65535 && R++);
    }
    return B;
  }
  function v(C, B) {
    const T = [];
    for (let D = 0; D < B.length; D++) {
      const R = B.codePointAt(D);
      R > 65535 && D++, T.push(s.U.codeToGlyph(C, R));
    }
    const S = C.GSUB;
    if (S) {
      const { lookupList: D, featureList: R } = S;
      let P;
      const L = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, V = [];
      R.forEach((U) => {
        if (L.test(U.tag))
          for (let Q = 0; Q < U.tab.length; Q++) {
            if (V[U.tab[Q]])
              continue;
            V[U.tab[Q]] = !0;
            const q = D[U.tab[Q]], oe = /^(isol|init|fina|medi)$/.test(U.tag);
            oe && !P && (P = A(B));
            for (let le = 0; le < T.length; le++)
              (!P || !oe || g[P[le]] === U.tag) && s.U._applySubs(T, le, q, D);
          }
      });
    }
    return T;
  }
  function y(C, B) {
    const T = new Int16Array(B.length * 3);
    let S = 0;
    for (; S < B.length; S++) {
      const L = B[S];
      if (L === -1)
        continue;
      T[S * 3 + 2] = C.hmtx.aWidth[L];
      const V = C.GPOS;
      if (V) {
        const U = V.lookupList;
        for (let Q = 0; Q < U.length; Q++) {
          const q = U[Q];
          for (let oe = 0; oe < q.tabs.length; oe++) {
            const le = q.tabs[oe];
            if (q.ltype === 1) {
              if (s._lctf.coverageIndex(le.coverage, L) !== -1 && le.pos) {
                P(le.pos, S);
                break;
              }
            } else if (q.ltype === 2) {
              let k = null, X = D();
              if (X !== -1) {
                const fe = s._lctf.coverageIndex(le.coverage, B[X]);
                if (fe !== -1) {
                  if (le.fmt === 1) {
                    const te = le.pairsets[fe];
                    for (let j = 0; j < te.length; j++)
                      te[j].gid2 === L && (k = te[j]);
                  } else if (le.fmt === 2) {
                    const te = s.U._getGlyphClass(B[X], le.classDef1), j = s.U._getGlyphClass(L, le.classDef2);
                    k = le.matrix[te][j];
                  }
                  if (k) {
                    k.val1 && P(k.val1, X), k.val2 && P(k.val2, S);
                    break;
                  }
                }
              }
            } else if (q.ltype === 4) {
              const k = s._lctf.coverageIndex(le.markCoverage, L);
              if (k !== -1) {
                const X = D(R), fe = X === -1 ? -1 : s._lctf.coverageIndex(le.baseCoverage, B[X]);
                if (fe !== -1) {
                  const te = le.markArray[k], j = le.baseArray[fe][te.markClass];
                  T[S * 3] = j.x - te.x + T[X * 3] - T[X * 3 + 2], T[S * 3 + 1] = j.y - te.y + T[X * 3 + 1];
                  break;
                }
              }
            } else if (q.ltype === 6) {
              const k = s._lctf.coverageIndex(le.mark1Coverage, L);
              if (k !== -1) {
                const X = D();
                if (X !== -1) {
                  const fe = B[X];
                  if (w(C, fe) === 3) {
                    const te = s._lctf.coverageIndex(le.mark2Coverage, fe);
                    if (te !== -1) {
                      const j = le.mark1Array[k], Ae = le.mark2Array[te][j.markClass];
                      T[S * 3] = Ae.x - j.x + T[X * 3] - T[X * 3 + 2], T[S * 3 + 1] = Ae.y - j.y + T[X * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (C.kern && !C.cff) {
        const U = D();
        if (U !== -1) {
          const Q = C.kern.glyph1.indexOf(B[U]);
          if (Q !== -1) {
            const q = C.kern.rval[Q].glyph2.indexOf(L);
            q !== -1 && (T[U * 3 + 2] += C.kern.rval[Q].vals[q]);
          }
        }
      }
    }
    return T;
    function D(L) {
      for (let V = S - 1; V >= 0; V--)
        if (B[V] !== -1 && (!L || L(B[V])))
          return V;
      return -1;
    }
    function R(L) {
      return w(C, L) === 1;
    }
    function P(L, V) {
      for (let U = 0; U < 3; U++)
        T[V * 3 + U] += L[U] || 0;
    }
  }
  function w(C, B) {
    const T = C.GDEF && C.GDEF.glyphClassDef;
    return T ? s.U._getGlyphClass(B, T) : 0;
  }
  function E(...C) {
    for (let B = 0; B < C.length; B++)
      if (typeof C[B] == "number")
        return C[B];
  }
  function I(C) {
    const B = /* @__PURE__ */ Object.create(null), T = C["OS/2"], S = C.hhea, D = C.head.unitsPerEm, R = E(T && T.sTypoAscender, S && S.ascender, D), P = {
      unitsPerEm: D,
      ascender: R,
      descender: E(T && T.sTypoDescender, S && S.descender, 0),
      capHeight: E(T && T.sCapHeight, R),
      xHeight: E(T && T.sxHeight, R),
      lineGap: E(T && T.sTypoLineGap, S && S.lineGap),
      supportsCodePoint(L) {
        return s.U.codeToGlyph(C, L) > 0;
      },
      forEachGlyph(L, V, U, Q) {
        let q = 0;
        const oe = 1 / P.unitsPerEm * V, le = v(C, L);
        let k = 0;
        const X = y(C, le);
        return le.forEach((fe, te) => {
          if (fe !== -1) {
            let j = B[fe];
            if (!j) {
              const { cmds: Ae, crds: Y } = s.U.glyphToPath(C, fe);
              let pe = "", me = 0;
              for (let Ee = 0, Ie = Ae.length; Ee < Ie; Ee++) {
                const Ce = t[Ae[Ee]];
                pe += Ae[Ee];
                for (let ze = 1; ze <= Ce; ze++)
                  pe += (ze > 1 ? "," : "") + Y[me++];
              }
              let re, ye, ae, De;
              if (Y.length) {
                re = ye = 1 / 0, ae = De = -1 / 0;
                for (let Ee = 0, Ie = Y.length; Ee < Ie; Ee += 2) {
                  let Ce = Y[Ee], ze = Y[Ee + 1];
                  Ce < re && (re = Ce), ze < ye && (ye = ze), Ce > ae && (ae = Ce), ze > De && (De = ze);
                }
              } else
                re = ae = ye = De = 0;
              j = B[fe] = {
                index: fe,
                advanceWidth: C.hmtx.aWidth[fe],
                xMin: re,
                yMin: ye,
                xMax: ae,
                yMax: De,
                path: pe
              };
            }
            Q.call(
              null,
              j,
              q + X[te * 3] * oe,
              X[te * 3 + 1] * oe,
              k
            ), q += X[te * 3 + 2] * oe, U && (q += U * V);
          }
          k += L.codePointAt(k) > 65535 ? 2 : 1;
        }), q;
      }
    };
    return P;
  }
  return function(B) {
    const T = new Uint8Array(B, 0, 4), S = s._bin.readASCII(T, 0, 4);
    if (S === "wOFF")
      B = e(B);
    else if (S === "wOF2")
      throw new Error("woff2 fonts not supported");
    return I(s.parse(B)[0]);
  };
}
const d5 = /* @__PURE__ */ oc({
  name: "Typr Font Parser",
  dependencies: [u5, f5, h5],
  init(s, e, t) {
    const n = s(), i = e();
    return t(n, i);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function p5() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(y) {
      var w = y >> 5;
      this.buckets.set(w, (this.buckets.get(w) || 0) | 1 << (31 & y));
    }, e.prototype.has = function(y) {
      var w = this.buckets.get(y >> 5);
      return w !== void 0 && (w & 1 << (31 & y)) != 0;
    }, e.prototype.serialize = function() {
      var y = [];
      return this.buckets.forEach(function(w, E) {
        y.push((+E).toString(36) + ":" + w.toString(36));
      }), y.join(",");
    }, e.prototype.deserialize = function(y) {
      var w = this;
      this.buckets.clear(), y.split(",").forEach(function(E) {
        var I = E.split(":");
        w.buckets.set(parseInt(I[0], 36), parseInt(I[1], 36));
      });
    };
    var t = Math.pow(2, 8), n = t - 1, i = ~n;
    function r(y) {
      var w = function(I) {
        return I & i;
      }(y).toString(16), E = function(I) {
        return (I & i) + t - 1;
      }(y).toString(16);
      return "codepoint-index/plane" + (y >> 16) + "/" + w + "-" + E + ".json";
    }
    function a(y, w) {
      var E = y & n, I = w.codePointAt(E / 6 | 0);
      return ((I = (I || 48) - 48) & 1 << E % 6) != 0;
    }
    function o(y, w) {
      var E;
      (E = y, E.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(I) {
        return I.split("-").map(function(C) {
          return parseInt(C.trim(), 16);
        });
      })).forEach(function(I) {
        var C = I[0], B = I[1];
        B === void 0 && (B = C), w(C, B);
      });
    }
    function l(y, w) {
      o(y, function(E, I) {
        for (var C = E; C <= I; C++)
          w(C);
      });
    }
    var c = {}, u = {}, f = /* @__PURE__ */ new WeakMap(), h = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(y) {
      var w = f.get(y);
      return w || (w = new e(), l(y.ranges, function(E) {
        return w.add(E);
      }), f.set(y, w)), w;
    }
    var m, _ = /* @__PURE__ */ new Map();
    function g(y, w, E) {
      return y[w] ? w : y[E] ? E : function(I) {
        for (var C in I)
          return C;
      }(y);
    }
    function A(y, w) {
      var E = w;
      if (!y.includes(E)) {
        E = 1 / 0;
        for (var I = 0; I < y.length; I++)
          Math.abs(y[I] - w) < Math.abs(E - w) && (E = y[I]);
      }
      return E;
    }
    function v(y) {
      return m || (m = /* @__PURE__ */ new Set(), l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(w) {
        m.add(w);
      })), m.has(y);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      c = {}, u = {};
    }, s.getFontsForString = function(y, w) {
      w === void 0 && (w = {});
      var E, I = w.lang;
      I === void 0 && (I = /\p{Script=Hangul}/u.test(E = y) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(E) ? "ja" : "en");
      var C = w.category;
      C === void 0 && (C = "sans-serif");
      var B = w.style;
      B === void 0 && (B = "normal");
      var T = w.weight;
      T === void 0 && (T = 400);
      var S = (w.dataUrl || h).replace(/\/$/g, ""), D = /* @__PURE__ */ new Map(), R = new Uint8Array(y.length), P = {}, L = {}, V = new Array(y.length), U = /* @__PURE__ */ new Map(), Q = !1;
      function q(k) {
        var X = _.get(k);
        return X || (X = fetch(S + "/" + k).then(function(fe) {
          if (!fe.ok)
            throw new Error(fe.statusText);
          return fe.json().then(function(te) {
            if (!Array.isArray(te) || te[0] !== 1)
              throw new Error("Incorrect schema version; need 1, got " + te[0]);
            return te[1];
          });
        }).catch(function(fe) {
          if (S !== h)
            return Q || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + S + '", trying default CDN. ' + fe.message), Q = !0), S = h, _.delete(k), q(k);
          throw fe;
        }), _.set(k, X)), X;
      }
      for (var oe = function(k) {
        var X = y.codePointAt(k), fe = r(X);
        V[k] = fe, c[fe] || U.has(fe) || U.set(fe, q(fe).then(function(te) {
          c[fe] = te;
        })), X > 65535 && (k++, le = k);
      }, le = 0; le < y.length; le++)
        oe(le);
      return Promise.all(U.values()).then(function() {
        U.clear();
        for (var k = function(fe) {
          var te = y.codePointAt(fe), j = null, Ae = c[V[fe]], Y = void 0;
          for (var pe in Ae) {
            var me = L[pe];
            if (me === void 0 && (me = L[pe] = new RegExp(pe).test(I || "en")), me) {
              for (var re in Y = pe, Ae[pe])
                if (a(te, Ae[pe][re])) {
                  j = re;
                  break;
                }
              break;
            }
          }
          if (!j) {
            e:
              for (var ye in Ae)
                if (ye !== Y) {
                  for (var ae in Ae[ye])
                    if (a(te, Ae[ye][ae])) {
                      j = ae;
                      break e;
                    }
                }
          }
          j || (console.debug("No font coverage for U+" + te.toString(16)), j = "latin"), V[fe] = j, u[j] || U.has(j) || U.set(j, q("font-meta/" + j + ".json").then(function(De) {
            u[j] = De;
          })), te > 65535 && (fe++, X = fe);
        }, X = 0; X < y.length; X++)
          k(X);
        return Promise.all(U.values());
      }).then(function() {
        for (var k, X = null, fe = 0; fe < y.length; fe++) {
          var te = y.codePointAt(fe);
          if (X && (v(te) || d(X).has(te)))
            R[fe] = R[fe - 1];
          else {
            X = u[V[fe]];
            var j = P[X.id];
            if (!j) {
              var Ae = X.typeforms, Y = g(Ae, C, "sans-serif"), pe = g(Ae[Y], B, "normal"), me = A((k = Ae[Y]) === null || k === void 0 ? void 0 : k[pe], T);
              j = P[X.id] = S + "/font-files/" + X.id + "/" + Y + "." + pe + "." + me + ".woff";
            }
            var re = D.get(j);
            re == null && (re = D.size, D.set(j, re)), R[fe] = re;
          }
          te > 65535 && (fe++, R[fe] = R[fe - 1]);
        }
        return { fontUrls: Array.from(D.keys()), chars: R };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function m5(s, e) {
  const t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function i(a, o) {
    const l = (c) => {
      console.error(`Failure loading font ${a}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", a, !0), c.responseType = "arraybuffer", c.onload = function() {
        if (c.status >= 400)
          l(new Error(c.statusText));
        else if (c.status > 0)
          try {
            const u = s(c.response);
            u.src = a, o(u);
          } catch (u) {
            l(u);
          }
      }, c.onerror = l, c.send();
    } catch (c) {
      l(c);
    }
  }
  function r(a, o) {
    let l = t[a];
    l ? o(l) : n[a] ? n[a].push(o) : (n[a] = [o], i(a, (c) => {
      c.src = a, t[a] = c, n[a].forEach((u) => u(c)), delete n[a];
    }));
  }
  return function(a, o, {
    lang: l,
    fonts: c = [],
    style: u = "normal",
    weight: f = "normal",
    unicodeFontsURL: h
  } = {}) {
    const d = new Uint8Array(a.length), m = [];
    a.length || v();
    const _ = /* @__PURE__ */ new Map(), g = [];
    if (u !== "italic" && (u = "normal"), typeof f != "number" && (f = f === "bold" ? 700 : 400), c && !Array.isArray(c) && (c = [c]), c = c.slice().filter((w) => !w.lang || w.lang.test(l)).reverse(), c.length) {
      let C = 0;
      (function B(T = 0) {
        for (let S = T, D = a.length; S < D; S++) {
          const R = a.codePointAt(S);
          if (C === 1 && m[d[S - 1]].supportsCodePoint(R) || /\s/.test(a[S]))
            d[S] = d[S - 1], C === 2 && (g[g.length - 1][1] = S);
          else
            for (let P = d[S], L = c.length; P <= L; P++)
              if (P === L) {
                const V = C === 2 ? g[g.length - 1] : g[g.length] = [S, S];
                V[1] = S, C = 2;
              } else {
                d[S] = P;
                const { src: V, unicodeRange: U } = c[P];
                if (!U || y(R, U)) {
                  const Q = t[V];
                  if (!Q) {
                    r(V, () => {
                      B(S);
                    });
                    return;
                  }
                  if (Q.supportsCodePoint(R)) {
                    let q = _.get(Q);
                    typeof q != "number" && (q = m.length, m.push(Q), _.set(Q, q)), d[S] = q, C = 1;
                    break;
                  }
                }
              }
          R > 65535 && S + 1 < D && (d[S + 1] = d[S], S++, C === 2 && (g[g.length - 1][1] = S));
        }
        A();
      })();
    } else
      g.push([0, a.length - 1]), A();
    function A() {
      if (g.length) {
        const w = g.map((E) => a.substring(E[0], E[1] + 1)).join(`
`);
        e.getFontsForString(w, {
          lang: l || void 0,
          style: u,
          weight: f,
          dataUrl: h
        }).then(({ fontUrls: E, chars: I }) => {
          const C = m.length;
          let B = 0;
          g.forEach((S) => {
            for (let D = 0, R = S[1] - S[0]; D <= R; D++)
              d[S[0] + D] = I[B++] + C;
            B++;
          });
          let T = 0;
          E.forEach((S, D) => {
            r(S, (R) => {
              m[D + C] = R, ++T === E.length && v();
            });
          });
        });
      } else
        v();
    }
    function v() {
      o({
        chars: d,
        fonts: m
      });
    }
    function y(w, E) {
      for (let I = 0; I < E.length; I++) {
        const [C, B = C] = E[I];
        if (C <= w && w <= B)
          return !0;
      }
      return !1;
    }
  };
}
const g5 = /* @__PURE__ */ oc({
  name: "FontResolver",
  dependencies: [
    m5,
    d5,
    p5
  ],
  init(s, e, t) {
    return s(e, t());
  }
});
function A5(s, e) {
  const n = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, i = "[^\\S\\u00A0]", r = new RegExp(`${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function a({ text: m, lang: _, fonts: g, style: A, weight: v, preResolvedFonts: y, unicodeFontsURL: w }, E) {
    const I = ({ chars: C, fonts: B }) => {
      let T, S;
      const D = [];
      for (let R = 0; R < C.length; R++)
        C[R] !== S ? (S = C[R], D.push(T = { start: R, end: R, fontObj: B[C[R]] })) : T.end = R;
      E(D);
    };
    y ? I(y) : s(
      m,
      I,
      { lang: _, fonts: g, style: A, weight: v, unicodeFontsURL: w }
    );
  }
  function o({
    text: m = "",
    font: _,
    lang: g,
    sdfGlyphSize: A = 64,
    fontSize: v = 400,
    fontWeight: y = 1,
    fontStyle: w = "normal",
    letterSpacing: E = 0,
    lineHeight: I = "normal",
    maxWidth: C = 1 / 0,
    direction: B,
    textAlign: T = "left",
    textIndent: S = 0,
    whiteSpace: D = "normal",
    overflowWrap: R = "normal",
    anchorX: P = 0,
    anchorY: L = 0,
    metricsOnly: V = !1,
    unicodeFontsURL: U,
    preResolvedFonts: Q = null,
    includeCaretPositions: q = !1,
    chunkedBoundsSize: oe = 8192,
    colorRanges: le = null
  }, k) {
    const X = f(), fe = { fontLoad: 0, typesetting: 0 };
    m.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), m = m.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, E = +E, C = +C, I = I || "normal", S = +S, a({
      text: m,
      lang: g,
      style: w,
      weight: y,
      fonts: typeof _ == "string" ? [{ src: _ }] : _,
      unicodeFontsURL: U,
      preResolvedFonts: Q
    }, (te) => {
      fe.fontLoad = f() - X;
      const j = isFinite(C);
      let Ae = null, Y = null, pe = null, me = null, re = null, ye = null, ae = null, De = null, Ee = 0, Ie = 0, Ce = D !== "nowrap";
      const ze = /* @__PURE__ */ new Map(), Fe = f();
      let W = S, G = 0, se = new h();
      const _e = [se];
      te.forEach((Pe) => {
        const { fontObj: he } = Pe, { ascender: Se, descender: Ve, unitsPerEm: Ye, lineGap: $e, capHeight: Ne, xHeight: He } = he;
        let Qe = ze.get(he);
        if (!Qe) {
          const be = v / Ye, Ue = I === "normal" ? (Se - Ve + $e) * be : I * v, je = (Ue - (Se - Ve) * be) / 2, it = Math.min(Ue, (Se - Ve) * be), nt = (Se + Ve) / 2 * be + it / 2;
          Qe = {
            index: ze.size,
            src: he.src,
            fontObj: he,
            fontSizeMult: be,
            unitsPerEm: Ye,
            ascender: Se * be,
            descender: Ve * be,
            capHeight: Ne * be,
            xHeight: He * be,
            lineHeight: Ue,
            baseline: -je - Se * be,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: nt,
            caretBottom: nt - it
          }, ze.set(he, Qe);
        }
        const { fontSizeMult: Ze } = Qe, Ke = m.slice(Pe.start, Pe.end + 1);
        let $, ge;
        he.forEachGlyph(Ke, v, E, (be, Ue, je, it) => {
          Ue += G, it += Pe.start, $ = Ue, ge = be;
          const nt = m.charAt(it), mt = be.advanceWidth * Ze, bt = se.count;
          let Xe;
          if ("isEmpty" in be || (be.isWhitespace = !!nt && new RegExp(i).test(nt), be.canBreakAfter = !!nt && r.test(nt), be.isEmpty = be.xMin === be.xMax || be.yMin === be.yMax || n.test(nt)), !be.isWhitespace && !be.isEmpty && Ie++, Ce && j && !be.isWhitespace && Ue + mt + W > C && bt) {
            if (se.glyphAt(bt - 1).glyphObj.canBreakAfter)
              Xe = new h(), W = -Ue;
            else
              for (let at = bt; at--; )
                if (at === 0 && R === "break-word") {
                  Xe = new h(), W = -Ue;
                  break;
                } else if (se.glyphAt(at).glyphObj.canBreakAfter) {
                  Xe = se.splitAt(at + 1);
                  const At = Xe.glyphAt(0).x;
                  W -= At;
                  for (let It = Xe.count; It--; )
                    Xe.glyphAt(It).x -= At;
                  break;
                }
            Xe && (se.isSoftWrapped = !0, se = Xe, _e.push(se), Ee = C);
          }
          let dt = se.glyphAt(se.count);
          dt.glyphObj = be, dt.x = Ue + W, dt.y = je, dt.width = mt, dt.charIndex = it, dt.fontData = Qe, nt === `
` && (se = new h(), _e.push(se), W = -(Ue + mt + E * v) + S);
        }), G = $ + ge.advanceWidth * Ze + E * v;
      });
      let ve = 0;
      _e.forEach((Pe) => {
        let he = !0;
        for (let Se = Pe.count; Se--; ) {
          const Ve = Pe.glyphAt(Se);
          he && !Ve.glyphObj.isWhitespace && (Pe.width = Ve.x + Ve.width, Pe.width > Ee && (Ee = Pe.width), he = !1);
          let { lineHeight: Ye, capHeight: $e, xHeight: Ne, baseline: He } = Ve.fontData;
          Ye > Pe.lineHeight && (Pe.lineHeight = Ye);
          const Qe = He - Pe.baseline;
          Qe < 0 && (Pe.baseline += Qe, Pe.cap += Qe, Pe.ex += Qe), Pe.cap = Math.max(Pe.cap, Pe.baseline + $e), Pe.ex = Math.max(Pe.ex, Pe.baseline + Ne);
        }
        Pe.baseline -= ve, Pe.cap -= ve, Pe.ex -= ve, ve += Pe.lineHeight;
      });
      let ue = 0, Te = 0;
      if (P && (typeof P == "number" ? ue = -P : typeof P == "string" && (ue = -Ee * (P === "left" ? 0 : P === "center" ? 0.5 : P === "right" ? 1 : c(P)))), L && (typeof L == "number" ? Te = -L : typeof L == "string" && (Te = L === "top" ? 0 : L === "top-baseline" ? -_e[0].baseline : L === "top-cap" ? -_e[0].cap : L === "top-ex" ? -_e[0].ex : L === "middle" ? ve / 2 : L === "bottom" ? ve : L === "bottom-baseline" ? -_e[_e.length - 1].baseline : c(L) * ve)), !V) {
        const Pe = e.getEmbeddingLevels(m, B);
        Ae = new Uint16Array(Ie), Y = new Uint8Array(Ie), pe = new Float32Array(Ie * 2), me = {}, ae = [1 / 0, 1 / 0, -1 / 0, -1 / 0], De = [], q && (ye = new Float32Array(m.length * 4)), le && (re = new Uint8Array(Ie * 3));
        let he = 0, Se = -1, Ve = -1, Ye, $e;
        if (_e.forEach((Ne, He) => {
          let { count: Qe, width: Ze } = Ne;
          if (Qe > 0) {
            let Ke = 0;
            for (let it = Qe; it-- && Ne.glyphAt(it).glyphObj.isWhitespace; )
              Ke++;
            let $ = 0, ge = 0;
            if (T === "center")
              $ = (Ee - Ze) / 2;
            else if (T === "right")
              $ = Ee - Ze;
            else if (T === "justify" && Ne.isSoftWrapped) {
              let it = 0;
              for (let nt = Qe - Ke; nt--; )
                Ne.glyphAt(nt).glyphObj.isWhitespace && it++;
              ge = (Ee - Ze) / it;
            }
            if (ge || $) {
              let it = 0;
              for (let nt = 0; nt < Qe; nt++) {
                let mt = Ne.glyphAt(nt);
                const bt = mt.glyphObj;
                mt.x += $ + it, ge !== 0 && bt.isWhitespace && nt < Qe - Ke && (it += ge, mt.width += ge);
              }
            }
            const be = e.getReorderSegments(
              m,
              Pe,
              Ne.glyphAt(0).charIndex,
              Ne.glyphAt(Ne.count - 1).charIndex
            );
            for (let it = 0; it < be.length; it++) {
              const [nt, mt] = be[it];
              let bt = 1 / 0, Xe = -1 / 0;
              for (let dt = 0; dt < Qe; dt++)
                if (Ne.glyphAt(dt).charIndex >= nt) {
                  let at = dt, At = dt;
                  for (; At < Qe; At++) {
                    let It = Ne.glyphAt(At);
                    if (It.charIndex > mt)
                      break;
                    At < Qe - Ke && (bt = Math.min(bt, It.x), Xe = Math.max(Xe, It.x + It.width));
                  }
                  for (let It = at; It < At; It++) {
                    const Qt = Ne.glyphAt(It);
                    Qt.x = Xe - (Qt.x + Qt.width - bt);
                  }
                  break;
                }
            }
            let Ue;
            const je = (it) => Ue = it;
            for (let it = 0; it < Qe; it++) {
              const nt = Ne.glyphAt(it);
              Ue = nt.glyphObj;
              const mt = Ue.index, bt = Pe.levels[nt.charIndex] & 1;
              if (bt) {
                const Xe = e.getMirroredCharacter(m[nt.charIndex]);
                Xe && nt.fontData.fontObj.forEachGlyph(Xe, 0, 0, je);
              }
              if (q) {
                const { charIndex: Xe, fontData: dt } = nt, at = nt.x + ue, At = nt.x + nt.width + ue;
                ye[Xe * 4] = bt ? At : at, ye[Xe * 4 + 1] = bt ? at : At, ye[Xe * 4 + 2] = Ne.baseline + dt.caretBottom + Te, ye[Xe * 4 + 3] = Ne.baseline + dt.caretTop + Te;
                const It = Xe - Se;
                It > 1 && u(ye, Se, It), Se = Xe;
              }
              if (le) {
                const { charIndex: Xe } = nt;
                for (; Xe > Ve; )
                  Ve++, le.hasOwnProperty(Ve) && ($e = le[Ve]);
              }
              if (!Ue.isWhitespace && !Ue.isEmpty) {
                const Xe = he++, { fontSizeMult: dt, src: at, index: At } = nt.fontData, It = me[at] || (me[at] = {});
                It[mt] || (It[mt] = {
                  path: Ue.path,
                  pathBounds: [Ue.xMin, Ue.yMin, Ue.xMax, Ue.yMax]
                });
                const Qt = nt.x + ue, Tt = nt.y + Ne.baseline + Te;
                pe[Xe * 2] = Qt, pe[Xe * 2 + 1] = Tt;
                const $t = Qt + Ue.xMin * dt, Jt = Tt + Ue.yMin * dt, on = Qt + Ue.xMax * dt, Wt = Tt + Ue.yMax * dt;
                $t < ae[0] && (ae[0] = $t), Jt < ae[1] && (ae[1] = Jt), on > ae[2] && (ae[2] = on), Wt > ae[3] && (ae[3] = Wt), Xe % oe === 0 && (Ye = { start: Xe, end: Xe, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, De.push(Ye)), Ye.end++;
                const an = Ye.rect;
                if ($t < an[0] && (an[0] = $t), Jt < an[1] && (an[1] = Jt), on > an[2] && (an[2] = on), Wt > an[3] && (an[3] = Wt), Ae[Xe] = mt, Y[Xe] = At, le) {
                  const Mn = Xe * 3;
                  re[Mn] = $e >> 16 & 255, re[Mn + 1] = $e >> 8 & 255, re[Mn + 2] = $e & 255;
                }
              }
            }
          }
        }), ye) {
          const Ne = m.length - Se;
          Ne > 1 && u(ye, Se, Ne);
        }
      }
      const Ge = [];
      ze.forEach(({ index: Pe, src: he, unitsPerEm: Se, ascender: Ve, descender: Ye, lineHeight: $e, capHeight: Ne, xHeight: He }) => {
        Ge[Pe] = { src: he, unitsPerEm: Se, ascender: Ve, descender: Ye, lineHeight: $e, capHeight: Ne, xHeight: He };
      }), fe.typesetting = f() - Fe, k({
        glyphIds: Ae,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: Y,
        //index into fontData for each glyph
        glyphPositions: pe,
        //x,y of each glyph's origin in layout
        glyphData: me,
        //dict holding data about each glyph appearing in the text
        fontData: Ge,
        //data about each font used in the text
        caretPositions: ye,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: re,
        //color for each glyph, if color ranges supplied
        chunkedBounds: De,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        topBaseline: Te + _e[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          ue,
          Te - ve,
          ue + Ee,
          Te
        ],
        visibleBounds: ae,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: fe
      });
    });
  }
  function l(m, _) {
    o({ ...m, metricsOnly: !0 }, (g) => {
      const [A, v, y, w] = g.blockBounds;
      _({
        width: y - A,
        height: w - v
      });
    });
  }
  function c(m) {
    let _ = m.match(/^([\d.]+)%$/), g = _ ? parseFloat(_[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function u(m, _, g) {
    const A = m[_ * 4], v = m[_ * 4 + 1], y = m[_ * 4 + 2], w = m[_ * 4 + 3], E = (v - A) / g;
    for (let I = 0; I < g; I++) {
      const C = (_ + I) * 4;
      m[C] = A + E * I, m[C + 1] = A + E * (I + 1), m[C + 2] = y, m[C + 3] = w;
    }
  }
  function f() {
    return (self.performance || Date).now();
  }
  function h() {
    this.data = [];
  }
  const d = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return h.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / d.length);
    },
    glyphAt(m) {
      let _ = h.flyweight;
      return _.data = this.data, _.index = m, _;
    },
    splitAt(m) {
      let _ = new h();
      return _.data = this.data.splice(m * d.length), _;
    }
  }, h.flyweight = d.reduce((m, _, g, A) => (Object.defineProperty(m, _, {
    get() {
      return this.data[this.index * d.length + g];
    },
    set(v) {
      this.data[this.index * d.length + g] = v;
    }
  }), m), { data: null, index: 0 }), {
    typeset: o,
    measure: l
  };
}
const ma = () => (self.performance || Date).now(), $d = /* @__PURE__ */ Qd();
let ky;
function _5(s, e, t, n, i, r, a, o, l, c, u = !0) {
  return u ? v5(s, e, t, n, i, r, a, o, l, c).then(
    null,
    (f) => (ky || (console.warn("WebGL SDF generation failed, falling back to JS", f), ky = !0), Fy(s, e, t, n, i, r, a, o, l, c))
  ) : Fy(s, e, t, n, i, r, a, o, l, c);
}
const Uh = [], b5 = 5;
let Kg = 0;
function GE() {
  const s = ma();
  for (; Uh.length && ma() - s < b5; )
    Uh.shift()();
  Kg = Uh.length ? setTimeout(GE, 0) : 0;
}
const v5 = (...s) => new Promise((e, t) => {
  Uh.push(() => {
    const n = ma();
    try {
      $d.webgl.generateIntoCanvas(...s), e({ timing: ma() - n });
    } catch (i) {
      t(i);
    }
  }), Kg || (Kg = setTimeout(GE, 0));
}), y5 = 4, x5 = 2e3, Uy = {};
let w5 = 0;
function Fy(s, e, t, n, i, r, a, o, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + w5++ % y5;
  let f = Uy[u];
  return f || (f = Uy[u] = {
    workerModule: oc({
      name: u,
      workerId: u,
      dependencies: [
        Qd,
        ma
      ],
      init(h, d) {
        const m = h().javascript.generate;
        return function(..._) {
          const g = d();
          return {
            textureData: m(..._),
            timing: d() - g
          };
        };
      },
      getTransferables(h) {
        return [h.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), f.requests++, clearTimeout(f.idleTimer), f.workerModule(s, e, t, n, i, r).then(({ textureData: h, timing: d }) => {
    const m = ma(), _ = new Uint8Array(h.length * 4);
    for (let g = 0; g < h.length; g++)
      _[g * 4 + c] = h[g];
    return $d.webglUtils.renderImageData(a, _, o, l, s, e, 1 << 3 - c), d += ma() - m, --f.requests === 0 && (f.idleTimer = setTimeout(() => {
      t5(u);
    }, x5)), { timing: d };
  });
}
function E5(s) {
  s._warm || ($d.webgl.isSupported(s), s._warm = !0);
}
const C5 = $d.webglUtils.resizeWebGLCanvasWithoutClearing, vl = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, S5 = /* @__PURE__ */ new Je();
function _l() {
  return (self.performance || Date).now();
}
const Oy = /* @__PURE__ */ Object.create(null);
function QE(s, e) {
  s = T5({}, s);
  const t = _l(), { defaultFontURL: n } = vl, i = [];
  if (n && i.push({ label: "default", src: Ny(n) }), s.font && i.push({ label: "user", src: Ny(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || vl.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || vl.unicodeFontsURL, s.colorRanges != null) {
    let h = {};
    for (let d in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(d)) {
        let m = s.colorRanges[d];
        typeof m != "number" && (m = S5.set(m).getHex()), h[d] = m;
      }
    s.colorRanges = h;
  }
  Object.freeze(s);
  const { textureWidth: r, sdfExponent: a } = vl, { sdfGlyphSize: o } = s, l = r / o * 4;
  let c = Oy[o];
  if (!c) {
    const h = document.createElement("canvas");
    h.width = r, h.height = o * 256 / l, c = Oy[o] = {
      glyphCount: 0,
      sdfGlyphSize: o,
      sdfCanvas: h,
      sdfTexture: new wn(
        h,
        void 0,
        void 0,
        void 0,
        Yt,
        Yt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, M5(c);
  }
  const { sdfTexture: u, sdfCanvas: f } = c;
  P5(s).then((h) => {
    const { glyphIds: d, glyphFontIndices: m, fontData: _, glyphPositions: g, fontSize: A, timings: v } = h, y = [], w = new Float32Array(d.length * 4);
    let E = 0, I = 0;
    const C = _l(), B = _.map((P) => {
      let L = c.glyphsByFont.get(P.src);
      return L || c.glyphsByFont.set(P.src, L = /* @__PURE__ */ new Map()), L;
    });
    d.forEach((P, L) => {
      const V = m[L], { src: U, unitsPerEm: Q } = _[V];
      let q = B[V].get(P);
      if (!q) {
        const { path: fe, pathBounds: te } = h.glyphData[U][P], j = Math.max(te[2] - te[0], te[3] - te[1]) / o * (vl.sdfMargin * o + 0.5), Ae = c.glyphCount++, Y = [
          te[0] - j,
          te[1] - j,
          te[2] + j,
          te[3] + j
        ];
        B[V].set(P, q = { path: fe, atlasIndex: Ae, sdfViewBox: Y }), y.push(q);
      }
      const { sdfViewBox: oe } = q, le = g[I++], k = g[I++], X = A / Q;
      w[E++] = le + oe[0] * X, w[E++] = k + oe[1] * X, w[E++] = le + oe[2] * X, w[E++] = k + oe[3] * X, d[L] = q.atlasIndex;
    }), v.quads = (v.quads || 0) + (_l() - C);
    const T = _l();
    v.sdf = {};
    const S = f.height, D = Math.ceil(c.glyphCount / l), R = Math.pow(2, Math.ceil(Math.log2(D * o)));
    R > S && (console.info(`Increasing SDF texture size ${S}->${R}`), C5(f, r, R), u.dispose()), Promise.all(y.map(
      (P) => zE(P, c, s.gpuAccelerateSDF).then(({ timing: L }) => {
        v.sdf[P.atlasIndex] = L;
      })
    )).then(() => {
      y.length && !c.contextLost && ($E(c), u.needsUpdate = !0), v.sdfTotal = _l() - T, v.total = _l() - t, e(Object.freeze({
        parameters: s,
        sdfTexture: u,
        sdfGlyphSize: o,
        sdfExponent: a,
        glyphBounds: w,
        glyphAtlasIndices: d,
        glyphColors: h.glyphColors,
        caretPositions: h.caretPositions,
        chunkedBounds: h.chunkedBounds,
        ascender: h.ascender,
        descender: h.descender,
        lineHeight: h.lineHeight,
        capHeight: h.capHeight,
        xHeight: h.xHeight,
        topBaseline: h.topBaseline,
        blockBounds: h.blockBounds,
        visibleBounds: h.visibleBounds,
        timings: h.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || E5(f);
  });
}
function zE({ path: s, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: n, sdfCanvas: i, contextLost: r }, a) {
  if (r)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: o, sdfExponent: l } = vl, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), f = u % (o / n) * n, h = Math.floor(u / (o / n)) * n, d = e % 4;
  return _5(n, n, s, t, c, l, i, f, h, d, a);
}
function M5(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), s.contextLost = !1;
    const n = [];
    s.glyphsByFont.forEach((i) => {
      i.forEach((r) => {
        n.push(zE(r, s, !0));
      });
    }), Promise.all(n).then(() => {
      $E(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function I5({ font: s, characters: e, sdfGlyphSize: t }, n) {
  let i = Array.isArray(e) ? e.join(`
`) : "" + e;
  QE({ font: s, sdfGlyphSize: t, text: i }, n);
}
function T5(s, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (s[t] = e[t]);
  return s;
}
let vh;
function Ny(s) {
  return vh || (vh = typeof document > "u" ? {} : document.createElement("a")), vh.href = s, vh.href;
}
function $E(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = s, { width: n, height: i } = e, r = s.sdfCanvas.getContext("webgl");
    let a = t.image.data;
    (!a || a.length !== n * i * 4) && (a = new Uint8Array(n * i * 4), t.image = { width: n, height: i, data: a }, t.flipY = !1, t.isDataTexture = !0), r.readPixels(0, 0, n, i, r.RGBA, r.UNSIGNED_BYTE, a);
  }
}
const B5 = /* @__PURE__ */ oc({
  name: "Typesetter",
  dependencies: [
    A5,
    g5,
    TE
  ],
  init(s, e, t) {
    return s(e, t());
  }
}), P5 = /* @__PURE__ */ oc({
  name: "Typesetter",
  dependencies: [
    B5
  ],
  init(s) {
    return function(e) {
      return new Promise((t) => {
        s.typeset(e, t);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let t in s)
      s[t] && s[t].buffer && e.push(s[t].buffer);
    return e;
  }
}), Gy = {};
function R5(s) {
  let e = Gy[s];
  if (!e) {
    const t = new Fi(1, 1, s, s), n = t.clone(), i = t.attributes, r = n.attributes, a = new Dt(), o = i.uv.count;
    for (let l = 0; l < o; l++)
      r.position.array[l * 3] *= -1, r.normal.array[l * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((l) => {
      a.setAttribute(
        l,
        new ht(
          [...i[l].array, ...r[l].array],
          i[l].itemSize
        )
      );
    }), a.setIndex([...t.index.array, ...n.index.array.map((l) => l + o)]), a.translate(0.5, 0.5, 0), e = Gy[s] = a;
  }
  return e;
}
const D5 = "aTroikaGlyphBounds", Qy = "aTroikaGlyphIndex", L5 = "aTroikaGlyphColor";
class k5 extends Ld {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Vn(), this.boundingBox = new dn();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Kn ? t / 2 : 0, e === zn ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = R5(e);
      ["position", "normal", "uv"].forEach((n) => {
        this.attributes[n] = t.attributes[n].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, n, i, r) {
    Vm(this, D5, e, 4), Vm(this, Qy, t, 1), Vm(this, L5, r, 3), this._blockBounds = n, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: n } = this;
      if (t) {
        const { PI: i, floor: r, min: a, max: o, sin: l, cos: c } = Math, u = i / 2, f = i * 2, h = Math.abs(t), d = e[0] / h, m = e[2] / h, _ = r((d + u) / f) !== r((m + u) / f) ? -h : a(l(d) * h, l(m) * h), g = r((d - u) / f) !== r((m - u) / f) ? h : o(l(d) * h, l(m) * h), A = r((d + i) / f) !== r((m + i) / f) ? h * 2 : o(h - c(d) * h, h - c(m) * h);
        n.min.set(_, e[1], t < 0 ? -A : 0), n.max.set(g, e[3], t < 0 ? 0 : A);
      } else
        n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
      n.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(Qy).count, n = this._chunkedBounds;
    if (n)
      for (let i = n.length; i--; ) {
        t = n[i].end;
        let r = n[i].rect;
        if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function Vm(s, e, t, n) {
  const i = s.getAttribute(e);
  t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (s.setAttribute(e, new cs(t, n)), delete s._maxInstanceCount, s.dispose()) : i && s.deleteAttribute(e);
}
const U5 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, F5 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, O5 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, N5 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function G5(s) {
  const e = Yg(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new ke() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Xt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Xt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new ke() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Je() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Ot() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: U5,
    vertexTransform: F5,
    fragmentDefs: O5,
    fragmentColorTransform: N5,
    customRewriter({ vertexShader: t, fragmentShader: n }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return i.test(n) && (n = n.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(
        NE,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: n };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const r0 = /* @__PURE__ */ new $n({
  color: 16777215,
  side: zn,
  transparent: !0
}), zy = 8421504, $y = /* @__PURE__ */ new st(), yh = /* @__PURE__ */ new H(), Hm = /* @__PURE__ */ new H(), Hc = [], Q5 = /* @__PURE__ */ new H(), jm = "+x+y";
function Vy(s) {
  return Array.isArray(s) ? s[0] : s;
}
let VE = () => {
  const s = new tt(
    new Fi(1, 1),
    r0
  );
  return VE = () => s, s;
}, HE = () => {
  const s = new tt(
    new Fi(1, 1, 32, 1),
    r0
  );
  return HE = () => s, s;
};
const z5 = { type: "syncstart" }, $5 = { type: "synccomplete" }, jE = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], V5 = jE.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class WE extends tt {
  constructor() {
    const e = new k5();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = zy, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = jm, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(z5), QE({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const n = this._queuedSyncs;
      n && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        n.forEach((i) => i && i());
      })), this.dispatchEvent($5), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, n, i, r, a) {
    this.sync(), r.isTroikaTextMaterial && this._prepareForRender(r), r._hadOwnSide = r.hasOwnProperty("side"), this.geometry.setSide(r._actualSide = r.side), r.side = Hi;
  }
  onAfterRender(e, t, n, i, r, a) {
    r._hadOwnSide ? r.side = r._actualSide : delete r.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = r0.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = G5(t), t.addEventListener("dispose", function n() {
      t.removeEventListener("dispose", n), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let n = e._outlineMtl;
      return n || (n = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), n.isTextOutlineMaterial = !0, n.depthWrite = !1, n.map = null, e.addEventListener("dispose", function i() {
        e.removeEventListener("dispose", i), n.dispose();
      })), [
        n,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Vy(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return Vy(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, n = e.uniforms, i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: o, blockBounds: l } = i;
      n.uTroikaSDFTexture.value = o, n.uTroikaSDFTextureSize.value.set(o.image.width, o.image.height), n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, n.uTroikaSDFExponent.value = i.sdfExponent, n.uTroikaTotalBounds.value.fromArray(l), n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
      let c = 0, u = 0, f = 0, h, d, m, _ = 0, g = 0;
      if (t) {
        let { outlineWidth: v, outlineOffsetX: y, outlineOffsetY: w, outlineBlur: E, outlineOpacity: I } = this;
        c = this._parsePercent(v) || 0, u = Math.max(0, this._parsePercent(E) || 0), h = I, _ = this._parsePercent(y) || 0, g = this._parsePercent(w) || 0;
      } else
        f = Math.max(0, this._parsePercent(this.strokeWidth) || 0), f && (m = this.strokeColor, n.uTroikaStrokeColor.value.set(m ?? zy), d = this.strokeOpacity, d == null && (d = 1)), h = this.fillOpacity;
      n.uTroikaDistanceOffset.value = c, n.uTroikaPositionOffset.value.set(_, g), n.uTroikaBlurRadius.value = u, n.uTroikaStrokeWidth.value = f, n.uTroikaStrokeOpacity.value = d, n.uTroikaFillOpacity.value = h ?? 1, n.uTroikaCurveRadius.value = this.curveRadius || 0;
      let A = this.clipRect;
      if (A && Array.isArray(A) && A.length === 4)
        n.uTroikaClipRect.value.fromArray(A);
      else {
        const v = (this.fontSize || 0.1) * 100;
        n.uTroikaClipRect.value.set(
          l[0] - v,
          l[1] - v,
          l[2] + v,
          l[3] + v
        );
      }
      this.geometry.applyClipRect(n.uTroikaClipRect.value);
    }
    n.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const r = t ? this.outlineColor || 0 : this.color;
    if (r == null)
      delete e.color;
    else {
      const o = e.hasOwnProperty("color") ? e.color : e.color = new Je();
      (r !== o._input || typeof r == "object") && o.set(o._input = r);
    }
    let a = this.orientation || jm;
    if (a !== e._orientation) {
      let o = n.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let l = a !== jm && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, f, h] = l;
        yh.set(0, 0, 0)[u] = c === "-" ? 1 : -1, Hm.set(0, 0, 0)[h] = f === "-" ? -1 : 1, $y.lookAt(Q5, yh.cross(Hm), Hm), o.setFromMatrix4($y);
      } else
        o.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), n = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(n) ? 0 : n / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new ke()) {
    t.copy(e);
    const n = this.curveRadius;
    return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new ke()) {
    return yh.copy(e), this.localPositionToTextCoords(this.worldToLocal(yh), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: n, curveRadius: i } = this;
    if (n) {
      const r = n.blockBounds, a = i ? HE() : VE(), o = a.geometry, { position: l, uv: c } = o.attributes;
      for (let u = 0; u < c.count; u++) {
        let f = r[0] + c.getX(u) * (r[2] - r[0]);
        const h = r[1] + c.getY(u) * (r[3] - r[1]);
        let d = 0;
        i && (d = i - Math.cos(f / i) * i, f = Math.sin(f / i) * i), l.setXYZ(u, f, h, d);
      }
      o.boundingSphere = this.geometry.boundingSphere, o.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, Hc.length = 0, a.raycast(e, Hc);
      for (let u = 0; u < Hc.length; u++)
        Hc[u].object = this, t.push(Hc[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, V5.forEach((n) => {
      this[n] = e[n];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
jE.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(WE.prototype, s, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const H5 = (s) => ({ ref: s & /*ref*/
8 }), Hy = (s) => ({ ref: (
  /*ref*/
  s[3]
) });
function j5(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[9],
    Hy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      520) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? xt(
          t,
          /*$$scope*/
          i[9],
          r,
          H5
        ) : Et(
          /*$$scope*/
          i[9]
        ),
        Hy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function W5(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[3]
    ) },
    /*$$restProps*/
    s[6],
    { font: (
      /*font*/
      s[0]
    ) },
    { characters: (
      /*characters*/
      s[1]
    ) },
    { sdfGlyphSize: (
      /*sdfGlyphSize*/
      s[2]
    ) }
  ];
  let i = {
    $$slots: {
      default: [j5, ({ ref: r }) => ({ 3: r }), ({ ref: r }) => r ? 8 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[8](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps, font, characters, sdfGlyphSize*/
      79 ? jt(n, [
        a & /*ref*/
        8 && { is: (
          /*ref*/
          r[3]
        ) },
        a & /*$$restProps*/
        64 && Kt(
          /*$$restProps*/
          r[6]
        ),
        a & /*font*/
        1 && { font: (
          /*font*/
          r[0]
        ) },
        a & /*characters*/
        2 && { characters: (
          /*characters*/
          r[1]
        ) },
        a & /*sdfGlyphSize*/
        4 && { sdfGlyphSize: (
          /*sdfGlyphSize*/
          r[2]
        ) }
      ]) : {};
      a & /*$$scope, ref*/
      520 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), J(e, r);
    }
  };
}
function q5(s, e, t) {
  const n = ["font", "characters", "sdfGlyphSize", "ref"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { font: l = void 0 } = e, { characters: c = void 0 } = e, { sdfGlyphSize: u = void 0 } = e;
  const f = new WE(), { invalidate: h } = un(), d = kM(), m = An();
  lt(s, m, (v) => t(4, r = v));
  const _ = async () => {
    await rd(), f.sync(() => {
      h(), d("sync");
    });
  }, g = rc();
  function A(v) {
    Ut[v ? "unshift" : "push"](() => {
      r = v, m.set(r);
    });
  }
  return s.$$set = (v) => {
    e = We(We({}, e), rn(v)), t(6, i = ft(e, n)), "font" in v && t(0, l = v.font), "characters" in v && t(1, c = v.characters), "sdfGlyphSize" in v && t(2, u = v.sdfGlyphSize), "$$scope" in v && t(9, o = v.$$scope);
  }, s.$$.update = () => {
    i && _(), s.$$.dirty & /*font, characters, sdfGlyphSize*/
    7 && g(new Promise((v) => I5({ font: l, characters: c, sdfGlyphSize: u }, v)));
  }, [
    l,
    c,
    u,
    f,
    r,
    m,
    i,
    a,
    A,
    o
  ];
}
class X5 extends Mt {
  constructor(e) {
    super(), Ct(this, e, q5, W5, _t, {
      font: 0,
      characters: 1,
      sdfGlyphSize: 2,
      ref: 3
    });
  }
  get font() {
    return this.$$.ctx[0];
  }
  set font(e) {
    this.$$set({ font: e }), ne();
  }
  get characters() {
    return this.$$.ctx[1];
  }
  set characters(e) {
    this.$$set({ characters: e }), ne();
  }
  get sdfGlyphSize() {
    return this.$$.ctx[2];
  }
  set sdfGlyphSize(e) {
    this.$$set({ sdfGlyphSize: e }), ne();
  }
  get ref() {
    return this.$$.ctx[3];
  }
}
St(X5, { font: {}, characters: {}, sdfGlyphSize: {} }, ["default"], ["ref"], !0);
function s0() {
  const s = {
    audioListeners: /* @__PURE__ */ new Map(),
    addAudioListener: (e, t) => {
      if (t = t ?? "default", s.audioListeners.has(t)) {
        console.warn(`An AudioListener with the id "${t}" has already been added, aborting.`);
        return;
      }
      s.audioListeners.set(t, e);
    },
    removeAudioListener: (e) => {
      if (e = e ?? "default", !s.audioListeners.has(e)) {
        console.warn(`No AudioListener with the id "${e}" found, aborting.`);
        return;
      }
      s.audioListeners.delete(e);
    },
    getAudioListener: (e) => {
      if (e = e ?? "default", !s.audioListeners.has(e)) {
        console.warn(`No AudioListener with the id "${e}" found, aborting.`);
        return;
      }
      return s.audioListeners.get(e);
    }
  };
  return qA("threlte-audio", s);
}
const Y5 = (s) => ({ ref: s & /*ref*/
1 }), jy = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function K5(s) {
  let e;
  const t = (
    /*#slots*/
    s[8].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[10],
    jy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      1025) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[10],
        e ? xt(
          t,
          /*$$scope*/
          i[10],
          r,
          Y5
        ) : Et(
          /*$$scope*/
          i[10]
        ),
        jy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function J5(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [K5, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[9](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      1025 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[9](null), J(e, r);
    }
  };
}
function Z5(s, e, t) {
  const n = ["id", "masterVolume", "ref", "audioContext", "resumeContext"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { id: l = void 0 } = e, { masterVolume: c = void 0 } = e;
  const u = new Tw(), f = u.context, h = async () => await u.context.resume(), { addAudioListener: d, removeAudioListener: m } = s0();
  d(u, l), Sn(() => {
    m(l);
  });
  const _ = An();
  lt(s, _, (A) => t(1, r = A));
  function g(A) {
    Ut[A ? "unshift" : "push"](() => {
      r = A, _.set(r);
    });
  }
  return s.$$set = (A) => {
    e = We(We({}, e), rn(A)), t(3, i = ft(e, n)), "id" in A && t(4, l = A.id), "masterVolume" in A && t(5, c = A.masterVolume), "$$scope" in A && t(10, o = A.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*masterVolume*/
    32 && c !== void 0 && u.setMasterVolume(c);
  }, [
    u,
    r,
    _,
    i,
    l,
    c,
    f,
    h,
    a,
    g,
    o
  ];
}
class eQ extends Mt {
  constructor(e) {
    super(), Ct(this, e, Z5, J5, _t, {
      id: 4,
      masterVolume: 5,
      ref: 0,
      audioContext: 6,
      resumeContext: 7
    });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get masterVolume() {
    return this.$$.ctx[5];
  }
  set masterVolume(e) {
    this.$$set({ masterVolume: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get audioContext() {
    return this.$$.ctx[6];
  }
  get resumeContext() {
    return this.$$.ctx[7];
  }
}
St(eQ, { id: {}, masterVolume: {} }, ["default"], ["ref", "audioContext", "resumeContext"], !0);
const qE = (s) => {
  const e = xn(!1), t = xn(!1), n = xn(!1);
  let i = !1;
  const r = $u(Mw), a = us(), o = async (g) => {
    var A;
    e.set(!1);
    try {
      if (typeof g == "string") {
        const v = await r.load(g, {
          onProgress(y) {
            a("progress", y);
          }
        });
        s.setBuffer(v);
      } else
        g instanceof AudioBuffer ? s.setBuffer(g) : g instanceof HTMLMediaElement ? s.setMediaElementSource(g) : g instanceof AudioBufferSourceNode ? s.setNodeSource(g) : g instanceof MediaStream && s.setMediaStreamSource(g);
      e.set(!0), (A = s.source) != null && A.buffer ? a("load", s.source.buffer) : a("load");
    } catch (v) {
      a("error", v);
    }
  }, l = (g) => {
    s.setVolume(g ?? 1);
  }, c = (g) => {
    s.setPlaybackRate(g ?? 1);
  }, u = async (g) => {
    if (!e.current) {
      n.set(!0);
      return;
    }
    if (!(s.context.state !== "running" && (await s.context.resume(), i)))
      return s.play(g);
  }, f = () => s.pause(), h = () => s.source ? s.stop() : s, d = (g) => {
    t.set(g ?? !1);
  }, m = (g) => {
    s.source && s.source.detune && s.setDetune(g ?? 0);
  }, _ = (g) => {
    s.setLoop(g ?? !1);
  };
  return tn([e, t, n], ([g, A, v]) => {
    if (!g) {
      s.isPlaying && h();
      return;
    }
    (A || v) && u();
  }), Sn(() => {
    try {
      i = !0, h();
    } catch (g) {
      console.warn("Error while destroying audio", g);
    }
  }), {
    setVolume: l,
    setSrc: o,
    setPlaybackRate: c,
    setAutoPlay: d,
    setDetune: m,
    setLoop: _,
    play: u,
    pause: f,
    stop: h
  };
}, tQ = (s) => ({ ref: s & /*ref*/
1 }), Wy = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function nQ(s) {
  let e;
  const t = (
    /*#slots*/
    s[14].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[16],
    Wy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      65537) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[16],
        e ? xt(
          t,
          /*$$scope*/
          i[16],
          r,
          tQ
        ) : Et(
          /*$$scope*/
          i[16]
        ),
        Wy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function iQ(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [nQ, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[15](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      65537 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[15](null), J(e, r);
    }
  };
}
function rQ(s, e, t) {
  const n = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { src: l } = e, { id: c = void 0 } = e, { volume: u = void 0 } = e, { playbackRate: f = void 0 } = e, { autoplay: h = void 0 } = e, { detune: d = void 0 } = e, { loop: m = void 0 } = e;
  const { getAudioListener: _ } = s0(), g = _(c);
  if (!g)
    throw new Error(`No Audiolistener with id ${c} found.`);
  const A = new NA(g), { pause: v, play: y, stop: w, setAutoPlay: E, setDetune: I, setLoop: C, setPlaybackRate: B, setSrc: T, setVolume: S } = qE(A), D = An();
  lt(s, D, (P) => t(1, r = P));
  function R(P) {
    Ut[P ? "unshift" : "push"](() => {
      r = P, D.set(r);
    });
  }
  return s.$$set = (P) => {
    e = We(We({}, e), rn(P)), t(3, i = ft(e, n)), "src" in P && t(4, l = P.src), "id" in P && t(5, c = P.id), "volume" in P && t(6, u = P.volume), "playbackRate" in P && t(7, f = P.playbackRate), "autoplay" in P && t(8, h = P.autoplay), "detune" in P && t(9, d = P.detune), "loop" in P && t(10, m = P.loop), "$$scope" in P && t(16, o = P.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*autoplay*/
    256 && E(h), s.$$.dirty & /*src*/
    16 && T(l), s.$$.dirty & /*volume*/
    64 && S(u), s.$$.dirty & /*playbackRate*/
    128 && B(f), s.$$.dirty & /*loop*/
    1024 && C(m), s.$$.dirty & /*detune*/
    512 && I(d);
  }, [
    A,
    r,
    D,
    i,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    v,
    y,
    w,
    a,
    R,
    o
  ];
}
class sQ extends Mt {
  constructor(e) {
    super(), Ct(this, e, rQ, iQ, _t, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      ref: 0,
      pause: 11,
      play: 12,
      stop: 13
    });
  }
  get src() {
    return this.$$.ctx[4];
  }
  set src(e) {
    this.$$set({ src: e }), ne();
  }
  get id() {
    return this.$$.ctx[5];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get volume() {
    return this.$$.ctx[6];
  }
  set volume(e) {
    this.$$set({ volume: e }), ne();
  }
  get playbackRate() {
    return this.$$.ctx[7];
  }
  set playbackRate(e) {
    this.$$set({ playbackRate: e }), ne();
  }
  get autoplay() {
    return this.$$.ctx[8];
  }
  set autoplay(e) {
    this.$$set({ autoplay: e }), ne();
  }
  get detune() {
    return this.$$.ctx[9];
  }
  set detune(e) {
    this.$$set({ detune: e }), ne();
  }
  get loop() {
    return this.$$.ctx[10];
  }
  set loop(e) {
    this.$$set({ loop: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get pause() {
    return this.$$.ctx[11];
  }
  get play() {
    return this.$$.ctx[12];
  }
  get stop() {
    return this.$$.ctx[13];
  }
}
St(sQ, { src: {}, id: {}, volume: {}, playbackRate: {}, autoplay: {}, detune: {}, loop: {} }, ["default"], ["ref", "pause", "play", "stop"], !0);
const oQ = (s) => ({ ref: s & /*ref*/
1 }), qy = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function aQ(s) {
  let e;
  const t = (
    /*#slots*/
    s[19].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[21],
    qy
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      2097153) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[21],
        e ? xt(
          t,
          /*$$scope*/
          i[21],
          r,
          oQ
        ) : Et(
          /*$$scope*/
          i[21]
        ),
        qy
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function lQ(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [aQ, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[20](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      2097153 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[20](null), J(e, r);
    }
  };
}
function cQ(s, e, t) {
  const n = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e, { src: l } = e, { id: c = void 0 } = e, { volume: u = void 0 } = e, { playbackRate: f = void 0 } = e, { autoplay: h = void 0 } = e, { detune: d = void 0 } = e, { loop: m = void 0 } = e, { directionalCone: _ = void 0 } = e, { refDistance: g = void 0 } = e, { rolloffFactor: A = void 0 } = e, { distanceModel: v = void 0 } = e, { maxDistance: y = void 0 } = e;
  const { getAudioListener: w } = s0(), E = w(c);
  if (!E)
    throw new Error(`No Audiolistener with id ${c} found.`);
  const I = new Bw(E), { pause: C, play: B, stop: T, setAutoPlay: S, setDetune: D, setLoop: R, setPlaybackRate: P, setSrc: L, setVolume: V } = qE(I), U = An();
  lt(s, U, (q) => t(1, r = q));
  function Q(q) {
    Ut[q ? "unshift" : "push"](() => {
      r = q, U.set(r);
    });
  }
  return s.$$set = (q) => {
    e = We(We({}, e), rn(q)), t(3, i = ft(e, n)), "src" in q && t(4, l = q.src), "id" in q && t(5, c = q.id), "volume" in q && t(6, u = q.volume), "playbackRate" in q && t(7, f = q.playbackRate), "autoplay" in q && t(8, h = q.autoplay), "detune" in q && t(9, d = q.detune), "loop" in q && t(10, m = q.loop), "directionalCone" in q && t(11, _ = q.directionalCone), "refDistance" in q && t(12, g = q.refDistance), "rolloffFactor" in q && t(13, A = q.rolloffFactor), "distanceModel" in q && t(14, v = q.distanceModel), "maxDistance" in q && t(15, y = q.maxDistance), "$$scope" in q && t(21, o = q.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*refDistance, rolloffFactor, distanceModel, maxDistance, directionalCone*/
    63488 && (g !== void 0 && I.setRefDistance(g), A !== void 0 && I.setRolloffFactor(A), v !== void 0 && I.setDistanceModel(v), y !== void 0 && I.setMaxDistance(y), _ !== void 0 && I.setDirectionalCone(_.coneInnerAngle, _.coneOuterAngle, _.coneOuterGain)), s.$$.dirty & /*autoplay*/
    256 && S(h), s.$$.dirty & /*src*/
    16 && L(l), s.$$.dirty & /*volume*/
    64 && V(u), s.$$.dirty & /*playbackRate*/
    128 && P(f), s.$$.dirty & /*loop*/
    1024 && R(m), s.$$.dirty & /*detune*/
    512 && D(d);
  }, [
    I,
    r,
    U,
    i,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    _,
    g,
    A,
    v,
    y,
    C,
    B,
    T,
    a,
    Q,
    o
  ];
}
class uQ extends Mt {
  constructor(e) {
    super(), Ct(this, e, cQ, lQ, _t, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      directionalCone: 11,
      refDistance: 12,
      rolloffFactor: 13,
      distanceModel: 14,
      maxDistance: 15,
      ref: 0,
      pause: 16,
      play: 17,
      stop: 18
    });
  }
  get src() {
    return this.$$.ctx[4];
  }
  set src(e) {
    this.$$set({ src: e }), ne();
  }
  get id() {
    return this.$$.ctx[5];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get volume() {
    return this.$$.ctx[6];
  }
  set volume(e) {
    this.$$set({ volume: e }), ne();
  }
  get playbackRate() {
    return this.$$.ctx[7];
  }
  set playbackRate(e) {
    this.$$set({ playbackRate: e }), ne();
  }
  get autoplay() {
    return this.$$.ctx[8];
  }
  set autoplay(e) {
    this.$$set({ autoplay: e }), ne();
  }
  get detune() {
    return this.$$.ctx[9];
  }
  set detune(e) {
    this.$$set({ detune: e }), ne();
  }
  get loop() {
    return this.$$.ctx[10];
  }
  set loop(e) {
    this.$$set({ loop: e }), ne();
  }
  get directionalCone() {
    return this.$$.ctx[11];
  }
  set directionalCone(e) {
    this.$$set({ directionalCone: e }), ne();
  }
  get refDistance() {
    return this.$$.ctx[12];
  }
  set refDistance(e) {
    this.$$set({ refDistance: e }), ne();
  }
  get rolloffFactor() {
    return this.$$.ctx[13];
  }
  set rolloffFactor(e) {
    this.$$set({ rolloffFactor: e }), ne();
  }
  get distanceModel() {
    return this.$$.ctx[14];
  }
  set distanceModel(e) {
    this.$$set({ distanceModel: e }), ne();
  }
  get maxDistance() {
    return this.$$.ctx[15];
  }
  set maxDistance(e) {
    this.$$set({ maxDistance: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get pause() {
    return this.$$.ctx[16];
  }
  get play() {
    return this.$$.ctx[17];
  }
  get stop() {
    return this.$$.ctx[18];
  }
}
St(uQ, { src: {}, id: {}, volume: {}, playbackRate: {}, autoplay: {}, detune: {}, loop: {}, directionalCone: {}, refDistance: {}, rolloffFactor: {}, distanceModel: {}, maxDistance: {} }, ["default"], ["ref", "pause", "play", "stop"], !0);
const fQ = (s) => {
  const { camera: e } = un();
  let t = s.current.clientWidth, n = s.current.clientHeight;
  const i = new ResizeObserver(([r]) => {
    t = r.contentRect.width, n = r.contentRect.height;
  });
  return tn(s, (r) => (r && i.observe(r), () => {
    r && i.unobserve(r);
  })), (r, a) => {
    a.pointer.update((o) => (o.set(r.offsetX / t * 2 - 1, -(r.offsetY / n) * 2 + 1), o)), a.raycaster.setFromCamera(a.pointer.current, e.current);
  };
}, XE = Symbol("interactivity-context"), hQ = () => wi(XE), dQ = (s) => {
  const e = xn((s == null ? void 0 : s.target) ?? un().renderer.domElement), t = {
    enabled: xn((s == null ? void 0 : s.enabled) ?? !0),
    pointer: xn(new ke()),
    pointerOverTarget: xn(!1),
    lastEvent: void 0,
    raycaster: new zu(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target: e,
    compute: (s == null ? void 0 : s.compute) ?? fQ(e),
    filter: s == null ? void 0 : s.filter
  };
  return xi(XE, t), t;
}, YE = Symbol("interactivity-handler-context"), KE = () => wi(YE), pQ = () => {
  xi(YE, {
    dispatchers: /* @__PURE__ */ new WeakMap()
  });
}, mQ = () => {
  const s = hQ(), { dispatchers: e } = KE();
  if (!s)
    throw new Error("No interactivity context found. Did you forget to implement interactivity()?");
  const t = us();
  return {
    ...s,
    addInteractiveObject: (r) => {
      s.interactiveObjects.indexOf(r) > -1 || (e.set(r, t), s.interactiveObjects.push(r));
    },
    removeInteractiveObject: (r) => {
      const a = s.interactiveObjects.indexOf(r);
      s.interactiveObjects.splice(a, 1), e.delete(r);
    }
  };
}, gQ = (s) => {
  const e = Gr(), t = Ft(!1);
  return Us(() => {
    t.set(Object.keys(e.$$.callbacks).some((n) => s.includes(n)));
  }), {
    hasEventHandlers: t
  };
}, AQ = [
  "click",
  "contextmenu",
  "dblclick",
  "wheel",
  "pointerup",
  "pointerdown",
  "pointerover",
  "pointerout",
  "pointerenter",
  "pointerleave",
  "pointermove",
  "pointermissed"
], _Q = () => {
  WA("interactivity", ({ ref: s }) => {
    if (!s.isObject3D)
      return;
    const { addInteractiveObject: e, removeInteractiveObject: t } = mQ(), n = Ft(s), { hasEventHandlers: i } = gQ(AQ);
    return tn([i, n], ([r, a]) => {
      if (r)
        return e(a), () => t(a);
    }), {
      onRefChange(r) {
        n.set(r);
      }
    };
  });
};
function Xy(s) {
  return `${(s.eventObject || s.object).uuid}/${s.index}${s.instanceId}`;
}
const Yy = [
  ["click", !1],
  ["contextmenu", !1],
  ["dblclick", !1],
  ["wheel", !1],
  ["pointerdown", !0],
  ["pointerup", !0],
  ["pointerleave", !0],
  ["pointerenter", !0],
  ["pointermove", !0],
  ["pointercancel", !0]
], bQ = (s) => {
  const { dispatchers: e } = KE(), t = (u) => {
    const f = u.offsetX - s.initialClick[0], h = u.offsetY - s.initialClick[1];
    return Math.round(Math.hypot(f, h));
  }, n = (u) => {
    for (const f of s.hovered.values())
      if (u.length === 0 || !u.some((h) => h.object === f.object && h.index === f.index && h.instanceId === f.instanceId)) {
        const { eventObject: h } = f;
        s.hovered.delete(Xy(f));
        const d = e.get(h);
        if (d) {
          const m = { ...f, intersections: u };
          d("pointerout", m), d("pointerleave", m);
        }
      }
  }, i = _3(s.enabled), r = () => {
    if (!i.current)
      return [];
    const u = [], f = s.raycaster.intersectObjects(s.interactiveObjects, !0), h = s.filter === void 0 ? f : s.filter(f, s);
    for (const d of h) {
      let m = d.object;
      for (; m; )
        e.has(m) && u.push({ ...d, eventObject: m }), m = m.parent;
    }
    return u;
  }, a = (u, f) => {
    var h;
    for (const d of f)
      (h = e.get(d)) == null || h("pointermissed", u);
  }, o = (u) => u === "pointerleave" || u === "pointercancel" ? () => {
    s.pointerOverTarget.set(!1), n([]);
  } : u === "pointerenter" ? () => {
    s.pointerOverTarget.set(!0);
  } : (f) => {
    const h = u === "pointermove", d = u === "click" || u === "contextmenu" || u === "dblclick";
    s.compute(f, s);
    const m = r(), _ = d ? t(f) : 0;
    u === "pointerdown" && (s.initialClick = [f.offsetX, f.offsetY], s.initialHits = m.map((A) => A.eventObject)), d && m.length === 0 && _ <= 2 && a(f, s.interactiveObjects), h && n(m);
    let g = !1;
    e:
      for (const A of m) {
        const v = {
          stopped: g,
          ...A,
          intersections: m,
          stopPropagation() {
            if (g = !0, v.stopped = !0, s.hovered.size > 0 && Array.from(s.hovered.values()).some((w) => w.eventObject === A.eventObject)) {
              const w = m.slice(0, m.indexOf(A));
              n([...w, A]);
            }
          },
          camera: s.raycaster.camera,
          delta: _,
          nativeEvent: f,
          pointer: s.pointer.current,
          ray: s.raycaster.ray
        }, y = e.get(A.eventObject);
        if (!y)
          return;
        if (h) {
          if (y.hasEventListener("pointerover") || y.hasEventListener("pointerenter") || y.hasEventListener("pointerout") || y.hasEventListener("pointerleave")) {
            const w = Xy(v), E = s.hovered.get(w);
            E ? E.stopped && v.stopPropagation() : (s.hovered.set(w, v), y("pointerover", v), y("pointerenter", v));
          }
          y("pointermove", v);
        } else
          y.hasEventListener(u) ? (!d || s.initialHits.includes(A.eventObject)) && (a(f, s.interactiveObjects.filter((E) => !s.initialHits.includes(E))), y(u, v)) : d && s.initialHits.includes(A.eventObject) && a(f, s.interactiveObjects.filter((E) => !s.initialHits.includes(E)));
        if (g)
          break e;
      }
  }, l = (u) => {
    Yy.forEach(([f]) => {
      u.removeEventListener(f, o(f));
    });
  }, c = (u) => {
    Yy.forEach(([f, h]) => {
      u.addEventListener(f, o(f), { passive: h });
    });
  };
  tn(s.target, (u) => (u && c(u), () => {
    u && l(u);
  }));
}, vQ = (s) => {
  pQ();
  const e = dQ(s);
  return _Q(), bQ(e), e;
};
var yQ = Object.defineProperty, xQ = (s, e, t) => e in s ? yQ(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, Pi = (s, e, t) => (xQ(s, typeof e != "symbol" ? e + "" : e, t), t);
const JE = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Jg(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(n, i) {
    let r = gt[i];
    return r ? Jg(r) : n;
  }
  return s.replace(e, t);
}
const vi = [];
for (let s = 0; s < 256; s++)
  vi[s] = (s < 16 ? "0" : "") + s.toString(16);
function wQ() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (vi[s & 255] + vi[s >> 8 & 255] + vi[s >> 16 & 255] + vi[s >> 24 & 255] + "-" + vi[e & 255] + vi[e >> 8 & 255] + "-" + vi[e >> 16 & 15 | 64] + vi[e >> 24 & 255] + "-" + vi[t & 63 | 128] + vi[t >> 8 & 255] + "-" + vi[t >> 16 & 255] + vi[t >> 24 & 255] + vi[n & 255] + vi[n >> 8 & 255] + vi[n >> 16 & 255] + vi[n >> 24 & 255]).toUpperCase();
}
const Zo = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let n = arguments[e];
    if (n)
      for (let i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (s[i] = n[i]);
  }
  return s;
}, EQ = Date.now(), Ky = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new Map();
let CQ = 1e10;
function nd(s, e) {
  const t = TQ(e);
  let n = Ky.get(s);
  if (n || Ky.set(s, n = /* @__PURE__ */ Object.create(null)), n[t])
    return new n[t]();
  const i = `_onBeforeCompile${t}`, r = function(c, u) {
    s.onBeforeCompile.call(this, c, u);
    const f = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
    let h = Jy[f];
    if (!h) {
      const d = SQ(this, c, e, t);
      h = Jy[f] = d;
    }
    c.vertexShader = h.vertexShader, c.fragmentShader = h.fragmentShader, Zo(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - EQ;
      }
    }), this[i] && this[i](c);
  }, a = function() {
    return o(e.chained ? s : s.clone());
  }, o = function(c) {
    const u = Object.create(c, l);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: CQ++ }), u.uuid = wQ(), u.uniforms = Zo({}, c.uniforms, e.uniforms), u.defines = Zo({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = Zo({}, c.extensions, e.extensions), u._listeners = void 0, u;
  }, l = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(c) {
        this[i] = c;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(c) {
        return s.copy.call(this, c), !s.isShaderMaterial && !s.isDerivedMaterial && (Zo(this.extensions, c.extensions), Zo(this.defines, c.defines), Zo(this.uniforms, ql.clone(c.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const c = new s.constructor();
        return o(c).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._depthMaterial;
        return c || (c = this._depthMaterial = nd(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Ea({ depthPacking: jl }),
          e
        ), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let c = this._distanceMaterial;
        return c || (c = this._distanceMaterial = nd(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Kl(),
          e
        ), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: c, _distanceMaterial: u } = this;
        c && c.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return n[t] = a, new a();
}
function SQ(s, { vertexShader: e, fragmentShader: t }, n, i) {
  let {
    vertexDefs: r,
    vertexMainIntro: a,
    vertexMainOutro: o,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: f,
    fragmentColorTransform: h,
    customRewriter: d,
    timeUniform: m
  } = n;
  if (r = r || "", a = a || "", o = o || "", c = c || "", u = u || "", f = f || "", (l || d) && (e = Jg(e)), (h || d) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = Jg(t)), d) {
    let _ = d({ vertexShader: e, fragmentShader: t });
    e = _.vertexShader, t = _.fragmentShader;
  }
  if (h) {
    let _ = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (_.push(g), "")
    ), f = `${h}
${_.join(`
`)}
${f}`;
  }
  if (m) {
    const _ = `
uniform float ${m};
`;
    r = _ + r, c = _ + c;
  }
  return l && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, r = `${r}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, a = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (_, g, A, v) => /\battribute\s+vec[23]\s+$/.test(v.substr(0, A)) ? g : `troika_${g}_${i}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = Zy(e, i, r, a, o), t = Zy(t, i, c, u, f), {
    vertexShader: e,
    fragmentShader: t
  };
}
function Zy(s, e, t, n, i) {
  return (n || i || t) && (s = s.replace(
    JE,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`), s;
}
function MQ(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let IQ = 0;
const e1 = /* @__PURE__ */ new Map();
function TQ(s) {
  const e = JSON.stringify(s, MQ);
  let t = e1.get(e);
  return t == null && e1.set(e, t = ++IQ), t;
}
const BQ = {
  MeshDepthMaterial: "depth",
  MeshDistanceMaterial: "distanceRGBA",
  MeshNormalMaterial: "normal",
  MeshBasicMaterial: "basic",
  MeshLambertMaterial: "lambert",
  MeshPhongMaterial: "phong",
  MeshToonMaterial: "toon",
  MeshStandardMaterial: "physical",
  MeshPhysicalMaterial: "physical",
  MeshMatcapMaterial: "matcap",
  LineBasicMaterial: "basic",
  LineDashedMaterial: "dashed",
  PointsMaterial: "points",
  ShadowMaterial: "shadow",
  SpriteMaterial: "sprite"
};
function PQ(s) {
  let e = BQ[s.type];
  return e ? br[e] : s;
}
function t1(s) {
  let e = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g, t = /* @__PURE__ */ Object.create(null), n;
  for (; (n = e.exec(s)) !== null; )
    t[n[2]] = n[1];
  return t;
}
function RQ(s) {
  let e = [], t = "";
  const n = nd(s, {
    chained: !0,
    customRewriter({ vertexShader: r, fragmentShader: a }) {
      let o = [], l = [], c = [], u = t1(r), f = t1(a);
      return e.forEach((h) => {
        let d = u[h], m = f[h];
        const _ = d || m;
        if (_) {
          const g = new RegExp(`\\buniform\\s+${_}\\s+${h}\\s*;`, "g"), A = new RegExp(`\\b${h}\\b`, "g"), v = `troika_attr_${h}`, y = `troika_vary_${h}`;
          if (o.push(`attribute ${_} ${v};`), d && (r = r.replace(g, ""), r = r.replace(A, v)), m) {
            a = a.replace(g, ""), a = a.replace(A, y);
            let w = `varying ${m} ${y};`;
            o.push(w), c.push(w), l.push(`${y} = ${v};`);
          }
        }
      }), r = `${o.join(`
`)}
${r.replace(JE, `
$&
${l.join(`
`)}`)}`, c.length && (a = `${c.join(`
`)}
${a}`), { vertexShader: r, fragmentShader: a };
    }
  });
  n.setUniformNames = function(r) {
    e = r || [];
    const a = e.sort().join("|");
    a !== t && (t = a, this.needsUpdate = !0);
  };
  const i = n.customProgramCacheKey();
  return n.customProgramCacheKey = function() {
    return i + "|" + t;
  }, n.isInstancedUniformsMaterial = !0, n;
}
class DQ extends Zl {
  constructor(e, t, n) {
    super(e, t, n), this._maxCount = n, this._instancedUniformNames = [];
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied geometry with one that will
   * carry our extra InstancedBufferAttribute(s). We do the wrapping lazily on _read_ rather
   * than write to avoid unnecessary wrapping on transient values.
   */
  get geometry() {
    let e = this._derivedGeometry;
    const t = this._baseGeometry;
    return (!e || e.baseGeometry !== t) && (e = this._derivedGeometry = Object.create(t), e.baseGeometry = t, e.attributes = Object.create(t.attributes), t.addEventListener("dispose", function() {
      e.dispose();
    })), e;
  }
  set geometry(e) {
    this._baseGeometry = e;
  }
  /*
   * Getter/setter for automatically wrapping the user-supplied material with our upgrades. We do the
   * wrapping lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
   */
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = new $n());
    return (!e || e.baseMaterial !== t) && (e = this._derivedMaterial = RQ(t), t.addEventListener("dispose", function n() {
      t.removeEventListener("dispose", n), e.dispose();
    })), e.setUniformNames(this._instancedUniformNames), e;
  }
  set material(e) {
    if (Array.isArray(e))
      throw new Error("InstancedUniformsMesh does not support multiple materials");
    for (; e && e.isInstancedUniformsMaterial; )
      e = e.baseMaterial;
    this._baseMaterial = e;
  }
  get customDepthMaterial() {
    return this.material.getDepthMaterial();
  }
  get customDistanceMaterial() {
    return this.material.getDistanceMaterial();
  }
  /**
   * Set the value of a shader uniform for a single instance.
   * @param {string} name - the name of the shader uniform
   * @param {number} index - the index of the instance to set the value for
   * @param {number|Vector2|Vector3|Vector4|Color|Array|Matrix3|Matrix4|Quaternion} value - the uniform value for this instance
   */
  setUniformAt(e, t, n) {
    const i = this.geometry.attributes, r = `troika_attr_${e}`;
    let a = i[r];
    if (!a) {
      const o = LQ(this._baseMaterial, e), l = kQ(o);
      if (a = i[r] = new cs(new Float32Array(l * this._maxCount), l), o !== null)
        for (let c = 0; c < this._maxCount; c++)
          n1(a, c, o);
      this._instancedUniformNames = [...this._instancedUniformNames, e];
    }
    n1(a, t, n), a.needsUpdate = !0;
  }
  /**
   * Unset all instance-specific values for a given uniform, reverting back to the original
   * uniform value for all.
   * @param {string} name
   */
  unsetUniform(e) {
    this.geometry.deleteAttribute(`troika_attr_${e}`), this._instancedUniformNames = this._instancedUniformNames.filter((t) => t !== e);
  }
}
function n1(s, e, t) {
  let n = s.itemSize;
  n === 1 ? s.setX(e, t) : n === 2 ? s.setXY(e, t.x, t.y) : n === 3 ? t.isColor ? s.setXYZ(e, t.r, t.g, t.b) : s.setXYZ(e, t.x, t.y, t.z) : n === 4 ? s.setXYZW(e, t.x, t.y, t.z, t.w) : t.toArray ? t.toArray(s.array, e * n) : s.set(t, e * n);
}
function LQ(s, e) {
  let t = s.uniforms;
  return t && t[e] || (t = PQ(s).uniforms, t && t[e]) ? t[e].value : null;
}
function kQ(s) {
  return s == null ? 0 : typeof s == "number" ? 1 : s.isVector2 ? 2 : s.isVector3 || s.isColor ? 3 : s.isVector4 || s.isQuaternion ? 4 : s.elements ? s.elements.length : Array.isArray(s) ? s.length : 0;
}
const UQ = (s, e) => {
  const t = s.split(`
`), n = /vMapUv|vAlphaMapUv|vNormalMapUv/g;
  return t.map((i) => !i.includes("varying") && !i.includes("uniform") ? i.replace(n, e) : i).join(`
`);
}, FQ = (s, e) => {
  const t = {
    USE_UV: ""
  };
  return e && (t.TRI_GEOMETRY = ""), nd(s, {
    defines: t,
    uniforms: {
      /** GPGPU animation driven data */
      animationData: { value: null },
      animationDataSize: { value: 0 },
      /* Repeat animation in a loop */
      billboarding: { value: 0 },
      /** flip uvs on x */
      flipX: { value: 0 },
      /** flip uvs on y */
      flipY: { value: 0 },
      /**
       * DataArrayTexture - data stored in columns. Rows are:
       * 0 - Frames declaration - RGBA[x,y,w,h]
       * 1 - Animation lengths RGBA[length,0,0,0]
       * 2 - Animation0 - RGBA [id,duration, 0,0]
       * 3 - Animation1 - RGBA [id,duration, 0,0]
       * ....etc
       */
      spritesheetData: { value: null },
      /**util for reading data texture in spritesheetData */
      dataSize: { value: new ke(0, 0) },
      /**
       * Tinting - Vector4 (enabled 0/1, H (0-3), S (0-1), V(0-1))
       */
      tint: { value: new Xt(0, 0, 0, 0) }
    },
    /**
     *
     * VERTEX
     * - billboarding
     *
     * */
    vertexDefs: (
      /*glsl*/
      `
    uniform float billboarding;
    flat varying int vId;
    `
    ),
    vertexMainOutro: (
      /*glsl*/
      `
    vId = gl_InstanceID;
    if(billboarding == 1.){
      vec3 instancePosition = vec3(instanceMatrix[3]);
      vec3 instanceScale = vec3(length(instanceMatrix[0]), length(instanceMatrix[1]), length(instanceMatrix[2]));

      vec3 cameraRight_worldspace = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
      vec3 cameraUp_worldspace = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

      vec3 vertexPosition_worldspace = instancePosition
        + cameraRight_worldspace * position.x * instanceScale.x
        + cameraUp_worldspace * position.y * instanceScale.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition_worldspace, 1.0);
    }
    `
    ),
    /**
     *
     * FRAGMENT REWRITER
     *
     * */
    customRewriter: ({ vertexShader: n, fragmentShader: i }) => {
      const r = (
        /*glsl*/
        `
			uniform sampler2D animationData;
      uniform int animationDataSize;
			uniform sampler2D spritesheetData;
      uniform float startTime;
			uniform float time;
			uniform float flipX;
			uniform float flipY;
			uniform vec2 dataSize;
      uniform vec4 tint;

      flat varying int vId;
			`
      ), a = (
        /*glsl*/
        `
			vec4 readData(float col, float row) {
				float wStep = 1.f / dataSize.x;
				float wHalfStep = wStep * 0.5f;
				float hStep = 1.f / dataSize.y;
				float hHalfStep = 1.f / dataSize.y * 0.5f;
				return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
			}

      vec2 zoomUV(vec2 uv, vec2 zoomCenter, float zoomFactor) {
        // Shift UVs so that the zoom center is the origin
        vec2 shiftedUV = uv - zoomCenter;

        // Scale (zoom) the UV coordinates
        shiftedUV *= zoomFactor;

        // Shift back
        shiftedUV += zoomCenter;

        return shiftedUV;
    }
			`
      ), o = (
        /*glsl*/
        `
      float y = float(vId / animationDataSize) / float(animationDataSize);
      float x = mod(float(vId),float(animationDataSize)) / float(animationDataSize);

      float spritesheetFrameId = texture2D(animationData, vec2(x,y)).r;

			// x,y,w,h
			vec4 frameMeta = readData(spritesheetFrameId, 0.f);

			vec2 fSize = frameMeta.zw;
			vec2 fOffset = vec2(frameMeta.xy);

      vec2 transformedPlaneUv = vUv + vec2(0.,0.);

      // todo  == 1. caused a flickering bug. look into Precision/interpolation?
      if(flipX > 0.){
        transformedPlaneUv.x = 1. - transformedPlaneUv.x;
      }
      if(flipY > 0.){
        transformedPlaneUv.y = 1. - transformedPlaneUv.y;
      }

			vec2 spriteUv = fSize * transformedPlaneUv + fOffset ;

      #ifdef TRI_GEOMETRY
        // Shift UVs if mesh uses triangle geometry
        // TODO optimize ugly math
        if(vUv.y>0.5 || vUv.x<0.25 || vUv.x>0.75){
          discard;
        }

        vec2 zoomCenter = vec2(fSize.x * 0.5,0.) + fOffset;
        float zoomFactor = 2.;
        vec2 shiftedUV = spriteUv - zoomCenter;
        shiftedUV *= zoomFactor;
        shiftedUV += zoomCenter;
        spriteUv = shiftedUV;
      #endif



			`
      );
      return i = i.replace(
        "void main() {",
        `void main() {${o}`
      ), i = `
			${r}
			${a}
			${i}
			`, i = i.replace(
        "vec4 sampledDiffuseColor = texture2D( map, vMapUv );",
        /*glsl*/
        `
        vec4 sampledDiffuseColor = texture2D( map, vMapUv );
        if(tint.w == 1.){
          vec3 hue_term = 1.0 - min(abs(vec3(tint.x) - vec3(0,2.0,1.0)), 1.0);
          hue_term.x = 1.0 - dot(hue_term.yz, vec2(1));
          vec3 res = vec3(dot(sampledDiffuseColor.xyz, hue_term.xyz), dot(sampledDiffuseColor.xyz, hue_term.zxy), dot(sampledDiffuseColor.xyz, hue_term.yzx));
          res = mix(vec3(dot(res, vec3(0.2, 0.5, 0.3))), res, tint.y);
          res = res * tint.z;

          sampledDiffuseColor = vec4(res, sampledDiffuseColor.a);
        }

        // sampledDiffuseColor = vec4(texture2D(animationData, vUv).rgb, 1.);
      `
      ), i = UQ(i, "spriteUv"), { vertexShader: n, fragmentShader: i };
    }
  });
}, OQ = (s) => {
  const { frames: e, animationLengths: t, animations: n } = s, i = Math.max(
    e.length,
    t.length,
    ...Object.values(n).map((d) => d.length)
  ), r = 2 + Object.values(n).length, a = e.flat().concat(new Array((i - e.length) * 4).fill(0)), o = t.map((d) => [d, 0, 0, 0]).flat().concat(new Array((i - t.length) * 4).fill(0)), l = [], c = /* @__PURE__ */ new Map();
  for (let d = 0; d < Object.keys(n).length; d++) {
    const m = Object.keys(n)[d];
    c.set(m, d);
    const _ = n[m].map((g) => [...g, 0, 0]).flat().concat(new Array((i - n[m].length) * 4).fill(0));
    l.push(..._);
  }
  const u = [
    ...a,
    ...o,
    ...l
  ], f = new Float32Array(u);
  f.set(u);
  const h = new Di(
    f,
    i,
    r,
    vn,
    hn
  );
  return h.type = hn, h.minFilter = nn, h.magFilter = nn, h.wrapS = yi, h.wrapT = Or, h.needsUpdate = !0, { dataTexture: h, dataWidth: i, dataHeight: r, animMap: c };
}, NQ = () => {
  const s = new Dt(), e = new Float32Array([
    // top
    0,
    1,
    0,
    // bot-left
    -1,
    -1,
    0,
    // bot-right
    1,
    -1,
    0
  ]);
  s.setAttribute("position", new Rt(e, 3));
  const t = new Float32Array([
    // top
    0.5,
    1,
    // bot-left
    0,
    0,
    // bot-right
    1,
    0
  ]);
  return s.setAttribute("uv", new Rt(t, 2)), s.computeVertexNormals(), s;
};
class GQ {
  constructor(e, t, n) {
    this.variables = [], this.currentTextureIndex = 0;
    let i = hn;
    const r = new Jl(), a = new Lu();
    a.position.z = 1;
    const o = {
      passThruTexture: { value: null }
    }, l = f(d(), o), c = new tt(new Fi(2, 2), l);
    r.add(c), this.setDataType = function(m) {
      return i = m, this;
    }, this.addVariable = function(m, _, g) {
      const A = this.createShaderMaterial(_), v = {
        name: m,
        initialValueTexture: g,
        material: A,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: nn,
        magFilter: nn
      };
      return this.variables.push(v), v;
    }, this.setVariableDependencies = function(m, _) {
      m.dependencies = _;
    }, this.init = function() {
      if (n.capabilities.isWebGL2 === !1 && n.extensions.has("OES_texture_float") === !1)
        return "No OES_texture_float support for float textures.";
      if (n.capabilities.maxVertexTextures === 0)
        return "No support for vertex shader textures.";
      for (let m = 0; m < this.variables.length; m++) {
        const _ = this.variables[m];
        _.renderTargets[0] = this.createRenderTarget(e, t, _.wrapS, _.wrapT, _.minFilter, _.magFilter), _.renderTargets[1] = this.createRenderTarget(e, t, _.wrapS, _.wrapT, _.minFilter, _.magFilter), this.renderTexture(_.initialValueTexture, _.renderTargets[0]), this.renderTexture(_.initialValueTexture, _.renderTargets[1]);
        const g = _.material, A = g.uniforms;
        if (_.dependencies !== null)
          for (let v = 0; v < _.dependencies.length; v++) {
            const y = _.dependencies[v];
            if (y.name !== _.name) {
              let w = !1;
              for (let E = 0; E < this.variables.length; E++)
                if (y.name === this.variables[E].name) {
                  w = !0;
                  break;
                }
              if (!w)
                return "Variable dependency not found. Variable=" + _.name + ", dependency=" + y.name;
            }
            A[y.name] = { value: null }, g.fragmentShader = `
uniform sampler2D ` + y.name + `;
` + g.fragmentShader;
          }
      }
      return this.currentTextureIndex = 0, null;
    }, this.compute = function() {
      const m = this.currentTextureIndex, _ = this.currentTextureIndex === 0 ? 1 : 0;
      for (let g = 0, A = this.variables.length; g < A; g++) {
        const v = this.variables[g];
        if (v.dependencies !== null) {
          const y = v.material.uniforms;
          for (let w = 0, E = v.dependencies.length; w < E; w++) {
            const I = v.dependencies[w];
            y[I.name].value = I.renderTargets[m].texture;
          }
        }
        this.doRenderTarget(v.material, v.renderTargets[_]);
      }
      this.currentTextureIndex = _;
    }, this.getCurrentRenderTarget = function(m) {
      return m.renderTargets[this.currentTextureIndex];
    }, this.getAlternateRenderTarget = function(m) {
      return m.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    }, this.dispose = function() {
      c.geometry.dispose(), c.material.dispose();
      const m = this.variables;
      for (let _ = 0; _ < m.length; _++) {
        const g = m[_];
        g.initialValueTexture && g.initialValueTexture.dispose();
        const A = g.renderTargets;
        for (let v = 0; v < A.length; v++)
          A[v].dispose();
      }
    };
    function u(m) {
      m.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = u;
    function f(m, _) {
      _ = _ || {};
      const g = new Hn({
        name: "GPUComputationShader",
        uniforms: _,
        vertexShader: h(),
        fragmentShader: m
      });
      return u(g), g;
    }
    this.createShaderMaterial = f, this.createRenderTarget = function(m, _, g, A, v, y) {
      return m = m || e, _ = _ || t, g = g || yi, A = A || yi, v = v || nn, y = y || nn, new Ji(m, _, {
        wrapS: g,
        wrapT: A,
        minFilter: v,
        magFilter: y,
        format: vn,
        type: i,
        depthBuffer: !1
      });
    }, this.createTexture = function() {
      const m = new Float32Array(e * t * 4), _ = new Di(m, e, t, vn, hn);
      return _.needsUpdate = !0, _;
    }, this.renderTexture = function(m, _) {
      o.passThruTexture.value = m, this.doRenderTarget(l, _), o.passThruTexture.value = null;
    }, this.doRenderTarget = function(m, _) {
      const g = n.getRenderTarget(), A = n.xr.enabled, v = n.shadowMap.autoUpdate;
      n.xr.enabled = !1, n.shadowMap.autoUpdate = !1, c.material = m, n.setRenderTarget(_), n.render(r, a), c.material = l, n.xr.enabled = A, n.shadowMap.autoUpdate = v, n.setRenderTarget(g);
    };
    function h() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function d() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
const QQ = (
  /*glsl*/
  `
  #include <common>
  uniform sampler2D instructionsTexture;

  uniform sampler2D spritesheetData;
  uniform vec2 dataSize;
  uniform float fps;
  uniform float deltaTime;

  // read spritesheet metadata
  vec4 readData(float col, float row, sampler2D tex) {
    float wStep = 1.f / dataSize.x;
    float wHalfStep = wStep * 0.5f;
    float hStep = 1.f / dataSize.y;
    float hHalfStep = 1.f / dataSize.y * 0.5f;
    return texture2D(spritesheetData, vec2(col * wStep + wHalfStep, row * hStep + hHalfStep));
  }



  void main()	{

    // OUTPUT FROM THIS SHADER
    // progressValue.r - picked animation frame
    // progressValue.g - previous progress state (for pause, reverse & pingpong consistency)
    // progressValue.b - not used yet
    // progressValue.a - previous animationID

    vec2 cellSize = 1.0 / resolution.xy;
    vec2 uv = gl_FragCoord.xy * cellSize;


    vec4 progressValue = texture2D( progress, uv );

    vec4 instructions = texture2D( instructionsTexture, uv);

    // FREEZE FRAME - return to save calculations?
    if(instructions.a >=10.){
      progressValue.r = instructions.a - 10.;
      progressValue.a = instructions.x;
      progressValue.g = progressValue.g;
      gl_FragColor = progressValue;
      return;
    }


    progressValue.b = 0.;

    // todo shouldn't be rounding here, pick
    float animationId = round(instructions.x);

    float offset = instructions.g;

    float animLength = readData(animationId, 1.f, spritesheetData).r;
    float totalTime = animLength / fps;

    // new delta is % of animation
    float newProgress = deltaTime / totalTime;
    // add new delta to saved progress
    float frameTimedId = mod(progressValue.g + newProgress, 1.);
    // frameTimedId = 0.;
    // float frameTimedId = progressValue.g;
    // save for use in next frame



    float playMode = mod(instructions.b, 10.);

    // forward
    if(playMode == 0.){
      frameTimedId = progressValue.g + newProgress;
    }
    // reverse
    if(playMode == 1.){
      frameTimedId = progressValue.g - newProgress;
    }
    // 2 - pause - do nothing
    if(playMode == 2.){
      frameTimedId = progressValue.g;
    }

    // //todo pingpong
    // if(playMode == 3.){
    // }

    // loop (play once over 10.)
    if(instructions.b < 10.){
      frameTimedId = mod(frameTimedId, 1.);
    }

    // todo This could be optional and user would reset manually,
    // todo allowing for consistent movement across multiple animations
    // todo for example - running steps being syncec
    // start anim from beginning if animationID changes
    if(progressValue.a != instructions.x){
      frameTimedId = 0.;
    }

    float frameId = floor(animLength * frameTimedId);
    float spritesheetFrameId = readData(frameId, 2.f + animationId, spritesheetData).r;



    // Picked sprite frame that goes to material
    progressValue.r = spritesheetFrameId;

    progressValue.a = instructions.x;
    progressValue.g = frameTimedId;

    gl_FragColor = progressValue;
  }
`
), zQ = (s = 512) => {
  const e = new Float32Array(s ** 2 * 4);
  for (let n = 0; n < s ** 2 * 4; n++)
    e[n] = 0;
  const t = new Di(
    e,
    s,
    s,
    vn,
    hn
  );
  return t.minFilter = nn, t.magFilter = nn, t.wrapS = yi, t.wrapT = Or, t.needsUpdate = !0, t;
}, $Q = (s) => {
  if (s <= 0)
    return 1;
  let e = 1;
  for (; e < s; )
    e <<= 1;
  return e;
}, VQ = (s, e) => {
  const t = $Q(Math.sqrt(e)), n = new GQ(
    t,
    t,
    s
  ), i = n.createTexture(), r = n.addVariable(
    "progress",
    QQ,
    i
  ), a = zQ(t);
  r.material.uniforms.instructionsTexture = {
    value: a
  }, r.material.uniforms.spritesheetData = { value: null }, r.material.uniforms.fps = { value: 0 }, r.material.uniforms.deltaTime = { value: 0 }, r.material.uniforms.dataSize = { value: new ke() }, n.setVariableDependencies(r, [r]);
  const o = n.init();
  o !== null && console.error(o);
  let l = !1;
  return {
    gpuCompute: n,
    animationRunner: r,
    progressDataTexture: a,
    utils: {
      updateAnimationAt: (c, u) => {
        const f = c * 4;
        a.image.data[f] = u, l = !0;
      },
      updateOffsetAt: (c, u) => {
        const f = c * 4;
        a.image.data[f + 1] = u, l = !0;
      },
      updatePlaymodeAt: (c, u) => {
        const f = c * 4;
        a.image.data[f + 2] = u, l = !0;
      },
      updateFrameAt: (c, u) => {
        const f = c * 4;
        a.image.data[f + 3] = u + 10, l = !0;
      }
    },
    update: () => {
      l && (a.needsUpdate = !0, l = !1), n.compute();
    }
  };
};
class HQ {
  constructor() {
    Pi(this, "_previousTime"), Pi(this, "_currentTime"), Pi(this, "_startTime"), Pi(this, "_delta"), Pi(this, "_elapsed"), Pi(this, "_timescale"), Pi(this, "_useFixedDelta"), Pi(this, "_fixedDelta"), Pi(this, "_usePageVisibilityAPI"), Pi(this, "_pageVisibilityHandler"), this._previousTime = 0, this._currentTime = 0, this._startTime = Wm(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = !1, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === !0 && (this._pageVisibilityHandler = jQ.bind(this), document.addEventListener(
      "visibilitychange",
      this._pageVisibilityHandler,
      !1
    ));
  }
  disableFixedDelta() {
    return this._useFixedDelta = !1, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === !0 && document.removeEventListener(
      "visibilitychange",
      this._pageVisibilityHandler
    ), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = !0, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = Wm() - this._startTime, this;
  }
  setFixedDelta(e) {
    return this._fixedDelta = e * 1e3, this;
  }
  setTimescale(e) {
    return this._timescale = e, this;
  }
  update() {
    return this._useFixedDelta === !0 ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = Wm() - this._startTime, this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
}
function Wm() {
  return (typeof performance > "u" ? Date : performance).now();
}
function jQ() {
  document.hidden === !1 && this.reset();
}
const qm = {
  FORWARD: 0,
  REVERSE: 1,
  PAUSE: 2,
  PINGPONG: 3
};
class WQ extends DQ {
  constructor(e, t, n, i = {
    geometry: "quad"
  }) {
    let r;
    i.geometry || (i.geometry = "quad"), i.geometry === "tri" && (r = NQ()), i.geometry === "quad" && (r = new Fi(1, 1)), i.geometry && typeof i.geometry != "string" && (r = i.geometry);
    const a = FQ(
      e,
      (i == null ? void 0 : i.geometry) === "tri"
    );
    super(r, a, t), Pi(this, "_spriteMaterial"), Pi(this, "_spritesheet"), Pi(this, "_animationMap"), Pi(this, "_fps", 15), Pi(this, "_timer"), Pi(this, "compute"), this.instanceMatrix.clearUpdateRanges(), this.instanceMatrix.addUpdateRange(0, t * 16), this.instanceColor && (this.instanceColor.clearUpdateRanges(), this.instanceColor.addUpdateRange(0, t * 3)), this.compute = VQ(n, t), this._spriteMaterial = a, i.spritesheet && this.updateSpritesheet(i.spritesheet), this._timer = new HQ(), this._animationMap = /* @__PURE__ */ new Map(), this._spriteMaterial.uniforms.animationData.value = this.compute.gpuCompute.getCurrentRenderTarget(
      this.compute.animationRunner
    ).texture, this._spriteMaterial.uniforms.animationDataSize.value = this.compute.progressDataTexture.image.width;
  }
  updateSpritesheet(e) {
    const { dataTexture: t, dataWidth: n, dataHeight: i, animMap: r } = OQ(e);
    this._spriteMaterial.uniforms.spritesheetData.value = t, this._spriteMaterial.uniforms.dataSize.value.x = n, this._spriteMaterial.uniforms.dataSize.value.y = i, this.compute.animationRunner.material.uniforms.dataSize.value = new ke(n, i), this.compute.animationRunner.material.uniforms.spritesheetData.value = t, this._animationMap = r;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(e) {
    this.updateSpritesheet(e), this._spritesheet = e;
  }
  get animationMap() {
    return this._animationMap;
  }
  get animation() {
    return {
      setAt: (e, t) => {
        this.compute.utils.updateAnimationAt(
          e,
          this._animationMap.get(t) || 0
        );
      }
    };
  }
  get frame() {
    return {
      setAt: (e, t, n) => {
        var i;
        let r = t;
        n && (r = (i = this.spritesheet) == null ? void 0 : i.animations[n][t][0]), this.compute.utils.updateFrameAt(e, r);
      },
      unsetAt: (e) => {
        this.compute.utils.updateFrameAt(e, -10);
      },
      unsetAll: () => {
        for (let e = 0; e < this.count; e++)
          this.compute.utils.updateFrameAt(e, -10);
      }
    };
  }
  get playmode() {
    return {
      setAt: (e, t) => {
        this.compute.utils.updatePlaymodeAt(e, qm[t]);
      },
      setAll: (e) => {
        for (let t = 0; t < this.count; t++) {
          const n = this.compute.progressDataTexture.image.data[t * 4 + 2] >= 10 ? 10 : 0;
          this.compute.utils.updatePlaymodeAt(t, n + qm[e]);
        }
      }
    };
  }
  get billboarding() {
    return {
      setAt: (e, t) => {
        this.setUniformAt("billboarding", e, t ? 1 : 0);
      },
      setAll: (e) => {
        this._spriteMaterial.uniforms.billboarding.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("billboarding");
      }
    };
  }
  get offset() {
    return {
      setAt: (e, t) => {
        this.compute.utils.updateOffsetAt(e, t);
      },
      randomizeAll: (e = 1) => {
        for (let t = 0; t < this.count; t++)
          this.compute.utils.updateOffsetAt(t, Math.random() * e);
      }
    };
  }
  get loop() {
    return {
      setAt: (e, t) => {
        const n = this.compute.progressDataTexture.image.data[e * 4 + 2] % 10;
        this.compute.utils.updatePlaymodeAt(
          e,
          n + (t ? 0 : 10)
        );
      },
      setAll: (e) => {
        for (let t = 0; t < this.count; t++) {
          const n = this.compute.progressDataTexture.image.data[t * 4 + 2] % 10;
          this.compute.utils.updatePlaymodeAt(t, n + (e ? 0 : 10));
        }
      }
    };
  }
  get flipX() {
    return {
      setAt: (e, t) => {
        this.setUniformAt("flipX", e, t ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipX.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipX");
      }
    };
  }
  get flipY() {
    return {
      setAt: (e, t) => {
        this.setUniformAt("flipY", e, t ? 1 : 0);
      },
      setGlobal: (e) => {
        this._spriteMaterial.uniforms.flipY.value = e ? 1 : 0;
      },
      unsetAll: () => {
        this.unsetUniform("flipY");
      }
    };
  }
  play(e, t = !0, n = "FORWARD") {
    return {
      at: (i) => {
        this.compute.utils.updateAnimationAt(
          i,
          this._animationMap.get(e) || 0
        ), this.compute.utils.updatePlaymodeAt(
          i,
          qm[n] + (t ? 0 : 10)
        );
      }
    };
  }
  /** HSV shift tinting */
  get hueShift() {
    const e = new Xt();
    return {
      // TODO - per instance tinting doesnt work - artifacts
      // setAt: (
      //   instanceId: number,
      //   tint?: { h: number; s: number; v: number }
      // ) => {
      //   if (tint) {
      //     tVector.set(tint.h, tint.s, tint.v, 1);
      //   } else {
      //     tVector.setW(0);
      //   }
      //   this.setUniformAt("tint", instanceId, tVector);
      // },
      setGlobal: (t) => {
        t ? e.set(t.h, t.s, t.v, 1) : e.setW(0), this._spriteMaterial.uniforms.tint.value = e;
      }
      // unsetAll: () => {
      //   this.unsetUniform("tint");
      // },
    };
  }
  get fps() {
    return this._fps;
  }
  set fps(e) {
    this._fps = e, this.compute.animationRunner.material.uniforms.fps.value = e;
  }
  update() {
    this._timer.update();
    const e = this._timer.getDelta();
    this.compute.animationRunner.material.uniforms.deltaTime.value = e, this.compute.update();
  }
}
var ZE = { exports: {} };
ZE.exports = Vd;
ZE.exports.default = Vd;
function Vd(s, e, t) {
  t = t || 2;
  var n = e && e.length, i = n ? e[0] * t : s.length, r = eC(s, 0, i, t, !0), a = [];
  if (!r || r.next === r.prev)
    return a;
  var o, l, c, u, f, h, d;
  if (n && (r = JQ(s, e, r, t)), s.length > 80 * t) {
    o = c = s[0], l = u = s[1];
    for (var m = t; m < i; m += t)
      f = s[m], h = s[m + 1], f < o && (o = f), h < l && (l = h), f > c && (c = f), h > u && (u = h);
    d = Math.max(c - o, u - l), d = d !== 0 ? 32767 / d : 0;
  }
  return Mu(r, a, t, o, l, d, 0), a;
}
function eC(s, e, t, n, i) {
  var r, a;
  if (i === tA(s, e, t, n) > 0)
    for (r = e; r < t; r += n)
      a = i1(r, s[r], s[r + 1], a);
  else
    for (r = t - n; r >= e; r -= n)
      a = i1(r, s[r], s[r + 1], a);
  return a && Hd(a, a.next) && (Tu(a), a = a.next), a;
}
function ya(s, e) {
  if (!s)
    return s;
  e || (e = s);
  var t = s, n;
  do
    if (n = !1, !t.steiner && (Hd(t, t.next) || Dn(t.prev, t, t.next) === 0)) {
      if (Tu(t), t = e = t.prev, t === t.next)
        break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Mu(s, e, t, n, i, r, a) {
  if (s) {
    !a && r && iz(s, n, i, r);
    for (var o = s, l, c; s.prev !== s.next; ) {
      if (l = s.prev, c = s.next, r ? XQ(s, n, i, r) : qQ(s)) {
        e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), Tu(s), s = c.next, o = c.next;
        continue;
      }
      if (s = c, s === o) {
        a ? a === 1 ? (s = YQ(ya(s), e, t), Mu(s, e, t, n, i, r, 2)) : a === 2 && KQ(s, e, t, n, i, r) : Mu(ya(s), e, t, n, i, r, 1);
        break;
      }
    }
  }
}
function qQ(s) {
  var e = s.prev, t = s, n = s.next;
  if (Dn(e, t, n) >= 0)
    return !1;
  for (var i = e.x, r = t.x, a = n.x, o = e.y, l = t.y, c = n.y, u = i < r ? i < a ? i : a : r < a ? r : a, f = o < l ? o < c ? o : c : l < c ? l : c, h = i > r ? i > a ? i : a : r > a ? r : a, d = o > l ? o > c ? o : c : l > c ? l : c, m = n.next; m !== e; ) {
    if (m.x >= u && m.x <= h && m.y >= f && m.y <= d && Sl(i, o, r, l, a, c, m.x, m.y) && Dn(m.prev, m, m.next) >= 0)
      return !1;
    m = m.next;
  }
  return !0;
}
function XQ(s, e, t, n) {
  var i = s.prev, r = s, a = s.next;
  if (Dn(i, r, a) >= 0)
    return !1;
  for (var o = i.x, l = r.x, c = a.x, u = i.y, f = r.y, h = a.y, d = o < l ? o < c ? o : c : l < c ? l : c, m = u < f ? u < h ? u : h : f < h ? f : h, _ = o > l ? o > c ? o : c : l > c ? l : c, g = u > f ? u > h ? u : h : f > h ? f : h, A = Zg(d, m, e, t, n), v = Zg(_, g, e, t, n), y = s.prevZ, w = s.nextZ; y && y.z >= A && w && w.z <= v; ) {
    if (y.x >= d && y.x <= _ && y.y >= m && y.y <= g && y !== i && y !== a && Sl(o, u, l, f, c, h, y.x, y.y) && Dn(y.prev, y, y.next) >= 0 || (y = y.prevZ, w.x >= d && w.x <= _ && w.y >= m && w.y <= g && w !== i && w !== a && Sl(o, u, l, f, c, h, w.x, w.y) && Dn(w.prev, w, w.next) >= 0))
      return !1;
    w = w.nextZ;
  }
  for (; y && y.z >= A; ) {
    if (y.x >= d && y.x <= _ && y.y >= m && y.y <= g && y !== i && y !== a && Sl(o, u, l, f, c, h, y.x, y.y) && Dn(y.prev, y, y.next) >= 0)
      return !1;
    y = y.prevZ;
  }
  for (; w && w.z <= v; ) {
    if (w.x >= d && w.x <= _ && w.y >= m && w.y <= g && w !== i && w !== a && Sl(o, u, l, f, c, h, w.x, w.y) && Dn(w.prev, w, w.next) >= 0)
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function YQ(s, e, t) {
  var n = s;
  do {
    var i = n.prev, r = n.next.next;
    !Hd(i, r) && tC(i, n, n.next, r) && Iu(i, r) && Iu(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), Tu(n), Tu(n.next), n = s = r), n = n.next;
  } while (n !== s);
  return ya(n);
}
function KQ(s, e, t, n, i, r) {
  var a = s;
  do {
    for (var o = a.next.next; o !== a.prev; ) {
      if (a.i !== o.i && oz(a, o)) {
        var l = nC(a, o);
        a = ya(a, a.next), l = ya(l, l.next), Mu(a, e, t, n, i, r, 0), Mu(l, e, t, n, i, r, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== s);
}
function JQ(s, e, t, n) {
  var i = [], r, a, o, l, c;
  for (r = 0, a = e.length; r < a; r++)
    o = e[r] * n, l = r < a - 1 ? e[r + 1] * n : s.length, c = eC(s, o, l, n, !1), c === c.next && (c.steiner = !0), i.push(sz(c));
  for (i.sort(ZQ), r = 0; r < i.length; r++)
    t = ez(i[r], t);
  return t;
}
function ZQ(s, e) {
  return s.x - e.x;
}
function ez(s, e) {
  var t = tz(s, e);
  if (!t)
    return e;
  var n = nC(t, s);
  return ya(n, n.next), ya(t, t.next);
}
function tz(s, e) {
  var t = e, n = s.x, i = s.y, r = -1 / 0, a;
  do {
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      var o = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (o <= n && o > r && (r = o, a = t.x < t.next.x ? t : t.next, o === n))
        return a;
    }
    t = t.next;
  } while (t !== e);
  if (!a)
    return null;
  var l = a, c = a.x, u = a.y, f = 1 / 0, h;
  t = a;
  do
    n >= t.x && t.x >= c && n !== t.x && Sl(i < u ? n : r, i, c, u, i < u ? r : n, i, t.x, t.y) && (h = Math.abs(i - t.y) / (n - t.x), Iu(t, s) && (h < f || h === f && (t.x > a.x || t.x === a.x && nz(a, t))) && (a = t, f = h)), t = t.next;
  while (t !== l);
  return a;
}
function nz(s, e) {
  return Dn(s.prev, s, e.prev) < 0 && Dn(e.next, s, s.next) < 0;
}
function iz(s, e, t, n) {
  var i = s;
  do
    i.z === 0 && (i.z = Zg(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== s);
  i.prevZ.nextZ = null, i.prevZ = null, rz(i);
}
function rz(s) {
  var e, t, n, i, r, a, o, l, c = 1;
  do {
    for (t = s, s = null, r = null, a = 0; t; ) {
      for (a++, n = t, o = 0, e = 0; e < c && (o++, n = n.nextZ, !!n); e++)
        ;
      for (l = c; o > 0 || l > 0 && n; )
        o !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, o--) : (i = n, n = n.nextZ, l--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
      t = n;
    }
    r.nextZ = null, c *= 2;
  } while (a > 1);
  return s;
}
function Zg(s, e, t, n, i) {
  return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function sz(s) {
  var e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function Sl(s, e, t, n, i, r, a, o) {
  return (i - a) * (e - o) >= (s - a) * (r - o) && (s - a) * (n - o) >= (t - a) * (e - o) && (t - a) * (r - o) >= (i - a) * (n - o);
}
function oz(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !az(s, e) && // dones't intersect other edges
  (Iu(s, e) && Iu(e, s) && lz(s, e) && // locally visible
  (Dn(s.prev, s, e.prev) || Dn(s, e.prev, e)) || // does not create opposite-facing sectors
  Hd(s, e) && Dn(s.prev, s, s.next) > 0 && Dn(e.prev, e, e.next) > 0);
}
function Dn(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function Hd(s, e) {
  return s.x === e.x && s.y === e.y;
}
function tC(s, e, t, n) {
  var i = wh(Dn(s, e, t)), r = wh(Dn(s, e, n)), a = wh(Dn(t, n, s)), o = wh(Dn(t, n, e));
  return !!(i !== r && a !== o || i === 0 && xh(s, t, e) || r === 0 && xh(s, n, e) || a === 0 && xh(t, s, n) || o === 0 && xh(t, e, n));
}
function xh(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function wh(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function az(s, e) {
  var t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && tC(t, t.next, s, e))
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function Iu(s, e) {
  return Dn(s.prev, s, s.next) < 0 ? Dn(s, e, s.next) >= 0 && Dn(s, s.prev, e) >= 0 : Dn(s, e, s.prev) < 0 || Dn(s, s.next, e) < 0;
}
function lz(s, e) {
  var t = s, n = !1, i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== s);
  return n;
}
function nC(s, e) {
  var t = new eA(s.i, s.x, s.y), n = new eA(e.i, e.x, e.y), i = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
}
function i1(s, e, t, n) {
  var i = new eA(s, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Tu(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function eA(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Vd.deviation = function(s, e, t, n) {
  var i = e && e.length, r = i ? e[0] * t : s.length, a = Math.abs(tA(s, 0, r, t));
  if (i)
    for (var o = 0, l = e.length; o < l; o++) {
      var c = e[o] * t, u = o < l - 1 ? e[o + 1] * t : s.length;
      a -= Math.abs(tA(s, c, u, t));
    }
  var f = 0;
  for (o = 0; o < n.length; o += 3) {
    var h = n[o] * t, d = n[o + 1] * t, m = n[o + 2] * t;
    f += Math.abs(
      (s[h] - s[m]) * (s[d + 1] - s[h + 1]) - (s[h] - s[d]) * (s[m + 1] - s[h + 1])
    );
  }
  return a === 0 && f === 0 ? 0 : Math.abs((f - a) / a);
};
function tA(s, e, t, n) {
  for (var i = 0, r = e, a = t - n; r < t; r += n)
    i += (s[a] - s[r]) * (s[r + 1] + s[a + 1]), a = r;
  return i;
}
Vd.flatten = function(s) {
  for (var e = s[0][0].length, t = { vertices: [], holes: [], dimensions: e }, n = 0, i = 0; i < s.length; i++) {
    for (var r = 0; r < s[i].length; r++)
      for (var a = 0; a < e; a++)
        t.vertices.push(s[i][r][a]);
    i > 0 && (n += s[i - 1].length, t.holes.push(n));
  }
  return t;
};
new ke();
new ke();
var r1;
((s) => {
  function e(i) {
    let r = i.slice();
    return r.sort(s.POINT_COMPARATOR), s.makeHullPresorted(r);
  }
  s.makeHull = e;
  function t(i) {
    if (i.length <= 1)
      return i.slice();
    let r = [];
    for (let o = 0; o < i.length; o++) {
      const l = i[o];
      for (; r.length >= 2; ) {
        const c = r[r.length - 1], u = r[r.length - 2];
        if ((c.x - u.x) * (l.y - u.y) >= (c.y - u.y) * (l.x - u.x))
          r.pop();
        else
          break;
      }
      r.push(l);
    }
    r.pop();
    let a = [];
    for (let o = i.length - 1; o >= 0; o--) {
      const l = i[o];
      for (; a.length >= 2; ) {
        const c = a[a.length - 1], u = a[a.length - 2];
        if ((c.x - u.x) * (l.y - u.y) >= (c.y - u.y) * (l.x - u.x))
          a.pop();
        else
          break;
      }
      a.push(l);
    }
    return a.pop(), r.length == 1 && a.length == 1 && r[0].x == a[0].x && r[0].y == a[0].y ? r : r.concat(a);
  }
  s.makeHullPresorted = t;
  function n(i, r) {
    return i.x < r.x ? -1 : i.x > r.x ? 1 : i.y < r.y ? -1 : i.y > r.y ? 1 : 0;
  }
  s.POINT_COMPARATOR = n;
})(r1 || (r1 = {}));
function cz(s, e, t) {
  const n = wi("instanced-sprite-ctx"), { updatePosition: i, sprite: r } = n;
  let { id: a = 0 } = e, { position: o = [0, 0, 0] } = e, { scale: l = [1, 1] } = e, { animationName: c = void 0 } = e, { playmode: u = void 0 } = e, { billboarding: f = void 0 } = e, { offset: h = void 0 } = e, { loop: d = void 0 } = e, { flipX: m = void 0 } = e, { flipY: _ = void 0 } = e, { frameId: g = void 0 } = e;
  return s.$$set = (A) => {
    "id" in A && t(0, a = A.id), "position" in A && t(1, o = A.position), "scale" in A && t(2, l = A.scale), "animationName" in A && t(3, c = A.animationName), "playmode" in A && t(4, u = A.playmode), "billboarding" in A && t(5, f = A.billboarding), "offset" in A && t(6, h = A.offset), "loop" in A && t(7, d = A.loop), "flipX" in A && t(8, m = A.flipX), "flipY" in A && t(9, _ = A.flipY), "frameId" in A && t(10, g = A.frameId);
  }, s.$$.update = () => {
    s.$$.dirty & /*position, id, scale*/
    7 && o !== void 0 && i(a, o, l), s.$$.dirty & /*animationName, id*/
    9 && c !== void 0 && r.animation.setAt(a, c), s.$$.dirty & /*playmode, id*/
    17 && u !== void 0 && r.playmode.setAt(a, u), s.$$.dirty & /*billboarding, id*/
    33 && f !== void 0 && r.billboarding.setAt(a, f), s.$$.dirty & /*offset, id*/
    65 && h !== void 0 && r.offset.setAt(a, h), s.$$.dirty & /*loop, id*/
    129 && d !== void 0 && r.loop.setAt(a, d), s.$$.dirty & /*flipX, id*/
    257 && m !== void 0 && r.flipX.setAt(a, m), s.$$.dirty & /*flipY, id*/
    513 && _ !== void 0 && r.flipY.setAt(a, _), s.$$.dirty & /*frameId, id, animationName*/
    1033 && g !== void 0 && r.frame.setAt(a, g, c);
  }, [
    a,
    o,
    l,
    c,
    u,
    f,
    h,
    d,
    m,
    _,
    g
  ];
}
class nA extends Mt {
  constructor(e) {
    super(), Ct(this, e, cz, null, _t, {
      id: 0,
      position: 1,
      scale: 2,
      animationName: 3,
      playmode: 4,
      billboarding: 5,
      offset: 6,
      loop: 7,
      flipX: 8,
      flipY: 9,
      frameId: 10
    });
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(e) {
    this.$$set({ id: e }), ne();
  }
  get position() {
    return this.$$.ctx[1];
  }
  set position(e) {
    this.$$set({ position: e }), ne();
  }
  get scale() {
    return this.$$.ctx[2];
  }
  set scale(e) {
    this.$$set({ scale: e }), ne();
  }
  get animationName() {
    return this.$$.ctx[3];
  }
  set animationName(e) {
    this.$$set({ animationName: e }), ne();
  }
  get playmode() {
    return this.$$.ctx[4];
  }
  set playmode(e) {
    this.$$set({ playmode: e }), ne();
  }
  get billboarding() {
    return this.$$.ctx[5];
  }
  set billboarding(e) {
    this.$$set({ billboarding: e }), ne();
  }
  get offset() {
    return this.$$.ctx[6];
  }
  set offset(e) {
    this.$$set({ offset: e }), ne();
  }
  get loop() {
    return this.$$.ctx[7];
  }
  set loop(e) {
    this.$$set({ loop: e }), ne();
  }
  get flipX() {
    return this.$$.ctx[8];
  }
  set flipX(e) {
    this.$$set({ flipX: e }), ne();
  }
  get flipY() {
    return this.$$.ctx[9];
  }
  set flipY(e) {
    this.$$set({ flipY: e }), ne();
  }
  get frameId() {
    return this.$$.ctx[10];
  }
  set frameId(e) {
    this.$$set({ frameId: e }), ne();
  }
}
St(nA, { id: {}, position: {}, scale: {}, animationName: {}, playmode: {}, billboarding: {}, offset: {}, loop: {}, flipX: {}, flipY: {}, frameId: {} }, [], [], !0);
const uz = (s) => ({}), s1 = (s) => ({
  Instance: (
    /*proxySpritefileComponent*/
    s[3]
  )
});
function fz(s) {
  let e;
  const t = (
    /*#slots*/
    s[16].default
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[17],
    s1
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      131072) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[17],
        e ? xt(
          t,
          /*$$scope*/
          i[17],
          r,
          uz
        ) : Et(
          /*$$scope*/
          i[17]
        ),
        s1
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function hz(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    { frustumCulled: !1 },
    /*$$restProps*/
    s[4]
  ];
  let i = {
    $$slots: { default: [fz] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      17 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        n[1],
        a & /*$$restProps*/
        16 && Kt(
          /*$$restProps*/
          r[4]
        )
      ]) : {};
      a & /*$$scope*/
      131072 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      J(e, r);
    }
  };
}
function dz(s, e, t) {
  const n = [
    "autoUpdate",
    "baseMaterial",
    "fps",
    "billboarding",
    "playmode",
    "count",
    "alphaTest",
    "transparent",
    "hueShift",
    "randomPlaybackOffset",
    "spritesheet",
    "ref"
  ];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e;
  new tt().material;
  let { autoUpdate: u = !0 } = e, { baseMaterial: f = $n } = e, { fps: h = 15 } = e, { billboarding: d } = e, { playmode: m = "FORWARD" } = e, { count: _ = 1e3 } = e, { alphaTest: g = 0.1 } = e, { transparent: A = !0 } = e, { hueShift: v = void 0 } = e, { randomPlaybackOffset: y = !1 } = e, { spritesheet: w } = e;
  const E = new f({
    transparent: A,
    alphaTest: g,
    // needs to be double side for shading
    side: zn
  }), { renderer: I } = un();
  let { ref: C = new WQ(E, _, I) } = e;
  const B = Ft(/* @__PURE__ */ new Map()), T = Ft(void 0);
  lt(s, T, (Q) => t(21, a = Q)), tn([T], () => {
    if (a === void 0) {
      C.billboarding.unsetAll();
      return;
    } else
      C.billboarding.setAll(a);
  });
  const S = Ft(void 0);
  lt(s, S, (Q) => t(20, r = Q)), tn([S], () => {
    if (r === void 0) {
      C.playmode.setAll("PAUSE");
      return;
    } else
      C.playmode.setAll(r);
  });
  const D = Ft(y);
  let R = !1;
  tn([D], ([Q]) => {
    if (R === !1 && Q && C.offset.randomizeAll(Q === !0 ? 100 : Q), R === !0 && !Q)
      for (let q = 0; q < _; q++)
        C.offset.setAt(q, 0);
    R = !!Q;
  });
  let P = !1;
  const L = new st();
  xi("instanced-sprite-ctx", {
    sprite: C,
    count: _,
    animationMap: B,
    updatePosition: (Q, q, oe = [1, 1]) => {
      L.makeScale(oe[0], oe[1], 1), L.setPosition(...q), C.setMatrixAt(Q, L), P = !0;
    }
  }), On(() => {
    u && C.update(), P && (t(0, C.instanceMatrix.needsUpdate = !0, C), P = !1);
  });
  const U = new Proxy(
    nA,
    {
      construct(Q, [q]) {
        return new nA(q);
      }
    }
  );
  return s.$$set = (Q) => {
    e = We(We({}, e), rn(Q)), t(4, i = ft(e, n)), "autoUpdate" in Q && t(5, u = Q.autoUpdate), "baseMaterial" in Q && t(6, f = Q.baseMaterial), "fps" in Q && t(7, h = Q.fps), "billboarding" in Q && t(8, d = Q.billboarding), "playmode" in Q && t(9, m = Q.playmode), "count" in Q && t(10, _ = Q.count), "alphaTest" in Q && t(11, g = Q.alphaTest), "transparent" in Q && t(12, A = Q.transparent), "hueShift" in Q && t(13, v = Q.hueShift), "randomPlaybackOffset" in Q && t(14, y = Q.randomPlaybackOffset), "spritesheet" in Q && t(15, w = Q.spritesheet), "ref" in Q && t(0, C = Q.ref), "$$scope" in Q && t(17, l = Q.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*spritesheet, ref*/
    32769 && w && (t(0, C.spritesheet = w.spritesheet, C), B.set(C.animationMap), t(0, C.material.map = w.texture, C), t(0, C.material.needsUpdate = !0, C)), s.$$.dirty & /*alphaTest*/
    2048 && t(0, C.material.alphaTest = g, C), s.$$.dirty & /*transparent*/
    4096 && t(0, C.material.transparent = A, C), s.$$.dirty & /*fps*/
    128 && t(0, C.fps = h, C), s.$$.dirty & /*ref, hueShift*/
    8193 && C.hueShift.setGlobal(v), s.$$.dirty & /*billboarding*/
    256 && T.set(d), s.$$.dirty & /*playmode*/
    512 && S.set(m), s.$$.dirty & /*randomPlaybackOffset*/
    16384 && D.set(y);
  }, [
    C,
    T,
    S,
    U,
    i,
    u,
    f,
    h,
    d,
    m,
    _,
    g,
    A,
    v,
    y,
    w,
    o,
    l
  ];
}
class pz extends Mt {
  constructor(e) {
    super(), Ct(this, e, dz, hz, _t, {
      autoUpdate: 5,
      baseMaterial: 6,
      fps: 7,
      billboarding: 8,
      playmode: 9,
      count: 10,
      alphaTest: 11,
      transparent: 12,
      hueShift: 13,
      randomPlaybackOffset: 14,
      spritesheet: 15,
      ref: 0
    });
  }
  get autoUpdate() {
    return this.$$.ctx[5];
  }
  set autoUpdate(e) {
    this.$$set({ autoUpdate: e }), ne();
  }
  get baseMaterial() {
    return this.$$.ctx[6];
  }
  set baseMaterial(e) {
    this.$$set({ baseMaterial: e }), ne();
  }
  get fps() {
    return this.$$.ctx[7];
  }
  set fps(e) {
    this.$$set({ fps: e }), ne();
  }
  get billboarding() {
    return this.$$.ctx[8];
  }
  set billboarding(e) {
    this.$$set({ billboarding: e }), ne();
  }
  get playmode() {
    return this.$$.ctx[9];
  }
  set playmode(e) {
    this.$$set({ playmode: e }), ne();
  }
  get count() {
    return this.$$.ctx[10];
  }
  set count(e) {
    this.$$set({ count: e }), ne();
  }
  get alphaTest() {
    return this.$$.ctx[11];
  }
  set alphaTest(e) {
    this.$$set({ alphaTest: e }), ne();
  }
  get transparent() {
    return this.$$.ctx[12];
  }
  set transparent(e) {
    this.$$set({ transparent: e }), ne();
  }
  get hueShift() {
    return this.$$.ctx[13];
  }
  set hueShift(e) {
    this.$$set({ hueShift: e }), ne();
  }
  get randomPlaybackOffset() {
    return this.$$.ctx[14];
  }
  set randomPlaybackOffset(e) {
    this.$$set({ randomPlaybackOffset: e }), ne();
  }
  get spritesheet() {
    return this.$$.ctx[15];
  }
  set spritesheet(e) {
    this.$$set({ spritesheet: e }), ne();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), ne();
  }
}
St(pz, { autoUpdate: { type: "Boolean" }, baseMaterial: {}, fps: {}, billboarding: {}, playmode: {}, count: {}, alphaTest: {}, transparent: { type: "Boolean" }, hueShift: {}, randomPlaybackOffset: { type: "Boolean" }, spritesheet: {}, ref: {} }, ["default"], [], !0);
const mz = (s) => ({}), o1 = (s) => ({ ref: (
  /*ref*/
  s[0]
) }), gz = (s) => ({}), a1 = (s) => ({ error: (
  /*error*/
  s[10]
) }), Az = (s) => ({}), l1 = (s) => ({});
function _z(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].error
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[9],
    a1
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? xt(
          t,
          /*$$scope*/
          i[9],
          r,
          gz
        ) : Et(
          /*$$scope*/
          i[9]
        ),
        a1
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function bz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "Sketchfab_Scene",
      $$slots: { default: [pV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function vz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_4",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_4.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_5",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_5.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_6",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_6.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function yz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_49",
      $$slots: { default: [vz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function xz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_9",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_9.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_10",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_10.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_11",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_11.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function wz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_48",
      $$slots: { default: [xz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Ez(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_14",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_14.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_15",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_15.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_16",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_16.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Cz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_47",
      $$slots: { default: [Ez] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Sz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_19",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_19.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_20",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_20.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_21",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_21.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Mz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_46",
      $$slots: { default: [Sz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Iz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_24",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_24.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_25",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_25.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_26",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_26.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Tz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_45",
      $$slots: { default: [Iz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Bz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_29",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_29.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_30",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_30.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_31",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_31.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Pz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_44",
      $$slots: { default: [Bz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Rz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_34",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_34.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_35",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_35.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_36",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_36.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Dz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_43",
      $$slots: { default: [Rz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Lz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_39",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_39.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_40",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_40.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_41",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_41.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function kz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_42",
      $$slots: { default: [Lz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Uz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_44",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_44.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_45",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_45.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_46",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_46.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Fz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_41",
      $$slots: { default: [Uz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Oz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_49",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_49.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_50",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_50.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_51",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_51.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Nz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_40",
      $$slots: { default: [Oz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Gz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_54",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_54.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_55",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_55.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_56",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_56.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Qz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_39",
      $$slots: { default: [Gz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function zz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_59",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_59.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_60",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_60.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_61",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_61.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function $z(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_38",
      $$slots: { default: [zz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Vz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_64",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_64.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_65",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_65.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_66",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_66.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Hz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_37",
      $$slots: { default: [Vz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function jz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_69",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_69.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_70",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_70.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_71",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_71.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Wz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_36",
      $$slots: { default: [jz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function qz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_74",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_74.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_75",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_75.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_76",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_76.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Xz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_35",
      $$slots: { default: [qz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Yz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_79",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_79.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_80",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_80.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_81",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_81.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Kz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_34",
      $$slots: { default: [Yz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Jz(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_84",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_84.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_85",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_85.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_86",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_86.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Zz(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_33",
      $$slots: { default: [Jz] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function e$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_89",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_89.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_90",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_90.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_91",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_91.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function t$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_32",
      $$slots: { default: [e$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function n$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_94",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_94.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_95",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_95.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_96",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_96.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function i$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_31",
      $$slots: { default: [n$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function r$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_99",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_99.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_100",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_100.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_101",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_101.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function s$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_30",
      $$slots: { default: [r$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function o$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_104",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_104.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_105",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_105.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_106",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_106.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function a$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_29",
      $$slots: { default: [o$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function l$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_109",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_109.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_110",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_110.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_111",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_111.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function c$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_28",
      $$slots: { default: [l$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function u$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_114",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_114.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_115",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_115.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_116",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_116.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function f$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_27",
      $$slots: { default: [u$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function h$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_119",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_119.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_120",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_120.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_121",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_121.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function d$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_26",
      $$slots: { default: [h$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function p$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_124",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_124.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_125",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_125.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_126",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_126.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function m$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_25",
      $$slots: { default: [p$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function g$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_129",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_129.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_130",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_130.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_131",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_131.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function A$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_24",
      $$slots: { default: [g$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function _$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_134",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_134.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_135",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_135.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_136",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_136.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function b$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_23",
      $$slots: { default: [_$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function v$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_139",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_139.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_140",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_140.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_141",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_141.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function y$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_22",
      $$slots: { default: [v$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function x$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_144",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_144.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_145",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_145.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_146",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_146.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function w$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_21",
      $$slots: { default: [x$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function E$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_149",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_149.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_150",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_150.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_151",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_151.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function C$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_20",
      $$slots: { default: [E$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function S$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_154",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_154.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_155",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_155.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_156",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_156.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function M$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_19",
      $$slots: { default: [S$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function I$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_159",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_159.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_160",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_160.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_161",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_161.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function T$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_18",
      $$slots: { default: [I$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function B$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_164",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_164.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_165",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_165.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_166",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_166.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function P$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_17",
      $$slots: { default: [B$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function R$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_169",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_169.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_170",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_170.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_171",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_171.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function D$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_16",
      $$slots: { default: [R$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function L$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_174",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_174.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_175",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_175.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_176",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_176.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function k$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_15",
      $$slots: { default: [L$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function U$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_179",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_179.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_180",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_180.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_181",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_181.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function F$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_14",
      $$slots: { default: [U$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function O$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_184",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_184.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_185",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_185.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_186",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_186.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function N$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_13",
      $$slots: { default: [O$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function G$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_189",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_189.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_190",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_190.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_191",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_191.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Q$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_12",
      $$slots: { default: [G$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function z$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_194",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_194.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_195",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_195.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_196",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_196.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function $$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_11",
      $$slots: { default: [z$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function V$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_199",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_199.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_200",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_200.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_201",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_201.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function H$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_10",
      $$slots: { default: [V$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function j$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_204",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_204.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_205",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_205.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_206",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_206.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function W$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_9",
      $$slots: { default: [j$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function q$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_209",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_209.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_210",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_210.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_211",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_211.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function X$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_8",
      $$slots: { default: [q$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function Y$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_214",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_214.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_215",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_215.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_216",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_216.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function K$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_7",
      $$slots: { default: [Y$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function J$(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_219",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_219.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_220",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_220.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_221",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_221.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function Z$(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_6",
      $$slots: { default: [J$] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function eV(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_224",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_224.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_225",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_225.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_226",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_226.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function tV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_5",
      $$slots: { default: [eV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function nV(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_229",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_229.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_230",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_230.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_231",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_231.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function iV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_4",
      $$slots: { default: [nV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function rV(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_234",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_234.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_235",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_235.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_236",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_236.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function sV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_3",
      $$slots: { default: [rV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function oV(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_239",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_239.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_240",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_240.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_241",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_241.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function aV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_2",
      $$slots: { default: [oV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function lV(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_244",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_244.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_245",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_245.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_246",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_246.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function cV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_1",
      $$slots: { default: [lV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function uV(s) {
  let e, t, n, i, r, a;
  return e = new ee.Points({
    props: {
      name: "Object_249",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_249.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), n = new ee.Points({
    props: {
      name: "Object_250",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_250.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), r = new ee.Points({
    props: {
      name: "Object_251",
      geometry: (
        /*gltf*/
        s[4].nodes.Object_251.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Scene_-_Root"]
      )
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p: rt,
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function fV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "frame_0",
      $$slots: { default: [uV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function hV(s) {
  let e, t, n, i, r, a, o, l, c, u, f, h, d, m, _, g, A, v, y, w, E, I, C, B, T, S, D, R, P, L, V, U, Q, q, oe, le, k, X, fe, te, j, Ae, Y, pe, me, re, ye, ae, De, Ee, Ie, Ce, ze, Fe, W, G, se, _e, ve, ue, Te, Ge, Pe, he, Se, Ve, Ye, $e, Ne, He, Qe, Ze, Ke, $, ge, be, Ue, je, it, nt, mt, bt, Xe, dt, at, At, It, Qt, Tt, $t, Jt, on, Wt, an, Mn, Zn, ie, Be, Oe, Le;
  return e = new ee.Group({
    props: {
      name: "Object_2",
      scale: 0,
      $$slots: { default: [yz] },
      $$scope: { ctx: s }
    }
  }), n = new ee.Group({
    props: {
      name: "Object_7",
      scale: 0,
      $$slots: { default: [wz] },
      $$scope: { ctx: s }
    }
  }), r = new ee.Group({
    props: {
      name: "Object_12",
      scale: 0,
      $$slots: { default: [Cz] },
      $$scope: { ctx: s }
    }
  }), o = new ee.Group({
    props: {
      name: "Object_17",
      scale: 0,
      $$slots: { default: [Mz] },
      $$scope: { ctx: s }
    }
  }), c = new ee.Group({
    props: {
      name: "Object_22",
      scale: 0,
      $$slots: { default: [Tz] },
      $$scope: { ctx: s }
    }
  }), f = new ee.Group({
    props: {
      name: "Object_27",
      scale: 0,
      $$slots: { default: [Pz] },
      $$scope: { ctx: s }
    }
  }), d = new ee.Group({
    props: {
      name: "Object_32",
      scale: 0,
      $$slots: { default: [Dz] },
      $$scope: { ctx: s }
    }
  }), _ = new ee.Group({
    props: {
      name: "Object_37",
      scale: 0,
      $$slots: { default: [kz] },
      $$scope: { ctx: s }
    }
  }), A = new ee.Group({
    props: {
      name: "Object_42",
      scale: 0,
      $$slots: { default: [Fz] },
      $$scope: { ctx: s }
    }
  }), y = new ee.Group({
    props: {
      name: "Object_47",
      scale: 0,
      $$slots: { default: [Nz] },
      $$scope: { ctx: s }
    }
  }), E = new ee.Group({
    props: {
      name: "Object_52",
      scale: 0,
      $$slots: { default: [Qz] },
      $$scope: { ctx: s }
    }
  }), C = new ee.Group({
    props: {
      name: "Object_57",
      scale: 0,
      $$slots: { default: [$z] },
      $$scope: { ctx: s }
    }
  }), T = new ee.Group({
    props: {
      name: "Object_62",
      scale: 0,
      $$slots: { default: [Hz] },
      $$scope: { ctx: s }
    }
  }), D = new ee.Group({
    props: {
      name: "Object_67",
      scale: 0,
      $$slots: { default: [Wz] },
      $$scope: { ctx: s }
    }
  }), P = new ee.Group({
    props: {
      name: "Object_72",
      scale: 0,
      $$slots: { default: [Xz] },
      $$scope: { ctx: s }
    }
  }), V = new ee.Group({
    props: {
      name: "Object_77",
      scale: 0,
      $$slots: { default: [Kz] },
      $$scope: { ctx: s }
    }
  }), Q = new ee.Group({
    props: {
      name: "Object_82",
      scale: 0,
      $$slots: { default: [Zz] },
      $$scope: { ctx: s }
    }
  }), oe = new ee.Group({
    props: {
      name: "Object_87",
      scale: 0,
      $$slots: { default: [t$] },
      $$scope: { ctx: s }
    }
  }), k = new ee.Group({
    props: {
      name: "Object_92",
      scale: 0,
      $$slots: { default: [i$] },
      $$scope: { ctx: s }
    }
  }), fe = new ee.Group({
    props: {
      name: "Object_97",
      scale: 0,
      $$slots: { default: [s$] },
      $$scope: { ctx: s }
    }
  }), j = new ee.Group({
    props: {
      name: "Object_102",
      scale: 0,
      $$slots: { default: [a$] },
      $$scope: { ctx: s }
    }
  }), Y = new ee.Group({
    props: {
      name: "Object_107",
      scale: 0,
      $$slots: { default: [c$] },
      $$scope: { ctx: s }
    }
  }), me = new ee.Group({
    props: {
      name: "Object_112",
      scale: 0,
      $$slots: { default: [f$] },
      $$scope: { ctx: s }
    }
  }), ye = new ee.Group({
    props: {
      name: "Object_117",
      scale: 0,
      $$slots: { default: [d$] },
      $$scope: { ctx: s }
    }
  }), De = new ee.Group({
    props: {
      name: "Object_122",
      scale: 0,
      $$slots: { default: [m$] },
      $$scope: { ctx: s }
    }
  }), Ie = new ee.Group({
    props: {
      name: "Object_127",
      scale: 0,
      $$slots: { default: [A$] },
      $$scope: { ctx: s }
    }
  }), ze = new ee.Group({
    props: {
      name: "Object_132",
      scale: 0,
      $$slots: { default: [b$] },
      $$scope: { ctx: s }
    }
  }), W = new ee.Group({
    props: {
      name: "Object_137",
      scale: 0,
      $$slots: { default: [y$] },
      $$scope: { ctx: s }
    }
  }), se = new ee.Group({
    props: {
      name: "Object_142",
      scale: 0,
      $$slots: { default: [w$] },
      $$scope: { ctx: s }
    }
  }), ve = new ee.Group({
    props: {
      name: "Object_147",
      scale: 0,
      $$slots: { default: [C$] },
      $$scope: { ctx: s }
    }
  }), Te = new ee.Group({
    props: {
      name: "Object_152",
      scale: 0,
      $$slots: { default: [M$] },
      $$scope: { ctx: s }
    }
  }), Pe = new ee.Group({
    props: {
      name: "Object_157",
      scale: 0,
      $$slots: { default: [T$] },
      $$scope: { ctx: s }
    }
  }), Se = new ee.Group({
    props: {
      name: "Object_162",
      scale: 0,
      $$slots: { default: [P$] },
      $$scope: { ctx: s }
    }
  }), Ye = new ee.Group({
    props: {
      name: "Object_167",
      scale: 0,
      $$slots: { default: [D$] },
      $$scope: { ctx: s }
    }
  }), Ne = new ee.Group({
    props: {
      name: "Object_172",
      scale: 0,
      $$slots: { default: [k$] },
      $$scope: { ctx: s }
    }
  }), Qe = new ee.Group({
    props: {
      name: "Object_177",
      scale: 0,
      $$slots: { default: [F$] },
      $$scope: { ctx: s }
    }
  }), Ke = new ee.Group({
    props: {
      name: "Object_182",
      scale: 0,
      $$slots: { default: [N$] },
      $$scope: { ctx: s }
    }
  }), ge = new ee.Group({
    props: {
      name: "Object_187",
      scale: 0,
      $$slots: { default: [Q$] },
      $$scope: { ctx: s }
    }
  }), Ue = new ee.Group({
    props: {
      name: "Object_192",
      scale: 0,
      $$slots: { default: [$$] },
      $$scope: { ctx: s }
    }
  }), it = new ee.Group({
    props: {
      name: "Object_197",
      scale: 0,
      $$slots: { default: [H$] },
      $$scope: { ctx: s }
    }
  }), mt = new ee.Group({
    props: {
      name: "Object_202",
      scale: 0,
      $$slots: { default: [W$] },
      $$scope: { ctx: s }
    }
  }), Xe = new ee.Group({
    props: {
      name: "Object_207",
      scale: 0,
      $$slots: { default: [X$] },
      $$scope: { ctx: s }
    }
  }), at = new ee.Group({
    props: {
      name: "Object_212",
      scale: 0,
      $$slots: { default: [K$] },
      $$scope: { ctx: s }
    }
  }), It = new ee.Group({
    props: {
      name: "Object_217",
      scale: 0,
      $$slots: { default: [Z$] },
      $$scope: { ctx: s }
    }
  }), Tt = new ee.Group({
    props: {
      name: "Object_222",
      scale: 0,
      $$slots: { default: [tV] },
      $$scope: { ctx: s }
    }
  }), Jt = new ee.Group({
    props: {
      name: "Object_227",
      scale: 0,
      $$slots: { default: [iV] },
      $$scope: { ctx: s }
    }
  }), Wt = new ee.Group({
    props: {
      name: "Object_232",
      scale: 0,
      $$slots: { default: [sV] },
      $$scope: { ctx: s }
    }
  }), Mn = new ee.Group({
    props: {
      name: "Object_237",
      scale: 0,
      $$slots: { default: [aV] },
      $$scope: { ctx: s }
    }
  }), ie = new ee.Group({
    props: {
      name: "Object_242",
      scale: 0,
      $$slots: { default: [cV] },
      $$scope: { ctx: s }
    }
  }), Oe = new ee.Group({
    props: {
      name: "Object_247",
      $$slots: { default: [fV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment), a = Me(), Z(o.$$.fragment), l = Me(), Z(c.$$.fragment), u = Me(), Z(f.$$.fragment), h = Me(), Z(d.$$.fragment), m = Me(), Z(_.$$.fragment), g = Me(), Z(A.$$.fragment), v = Me(), Z(y.$$.fragment), w = Me(), Z(E.$$.fragment), I = Me(), Z(C.$$.fragment), B = Me(), Z(T.$$.fragment), S = Me(), Z(D.$$.fragment), R = Me(), Z(P.$$.fragment), L = Me(), Z(V.$$.fragment), U = Me(), Z(Q.$$.fragment), q = Me(), Z(oe.$$.fragment), le = Me(), Z(k.$$.fragment), X = Me(), Z(fe.$$.fragment), te = Me(), Z(j.$$.fragment), Ae = Me(), Z(Y.$$.fragment), pe = Me(), Z(me.$$.fragment), re = Me(), Z(ye.$$.fragment), ae = Me(), Z(De.$$.fragment), Ee = Me(), Z(Ie.$$.fragment), Ce = Me(), Z(ze.$$.fragment), Fe = Me(), Z(W.$$.fragment), G = Me(), Z(se.$$.fragment), _e = Me(), Z(ve.$$.fragment), ue = Me(), Z(Te.$$.fragment), Ge = Me(), Z(Pe.$$.fragment), he = Me(), Z(Se.$$.fragment), Ve = Me(), Z(Ye.$$.fragment), $e = Me(), Z(Ne.$$.fragment), He = Me(), Z(Qe.$$.fragment), Ze = Me(), Z(Ke.$$.fragment), $ = Me(), Z(ge.$$.fragment), be = Me(), Z(Ue.$$.fragment), je = Me(), Z(it.$$.fragment), nt = Me(), Z(mt.$$.fragment), bt = Me(), Z(Xe.$$.fragment), dt = Me(), Z(at.$$.fragment), At = Me(), Z(It.$$.fragment), Qt = Me(), Z(Tt.$$.fragment), $t = Me(), Z(Jt.$$.fragment), on = Me(), Z(Wt.$$.fragment), an = Me(), Z(Mn.$$.fragment), Zn = Me(), Z(ie.$$.fragment), Be = Me(), Z(Oe.$$.fragment);
    },
    m(F, ce) {
      K(e, F, ce), we(F, t, ce), K(n, F, ce), we(F, i, ce), K(r, F, ce), we(F, a, ce), K(o, F, ce), we(F, l, ce), K(c, F, ce), we(F, u, ce), K(f, F, ce), we(F, h, ce), K(d, F, ce), we(F, m, ce), K(_, F, ce), we(F, g, ce), K(A, F, ce), we(F, v, ce), K(y, F, ce), we(F, w, ce), K(E, F, ce), we(F, I, ce), K(C, F, ce), we(F, B, ce), K(T, F, ce), we(F, S, ce), K(D, F, ce), we(F, R, ce), K(P, F, ce), we(F, L, ce), K(V, F, ce), we(F, U, ce), K(Q, F, ce), we(F, q, ce), K(oe, F, ce), we(F, le, ce), K(k, F, ce), we(F, X, ce), K(fe, F, ce), we(F, te, ce), K(j, F, ce), we(F, Ae, ce), K(Y, F, ce), we(F, pe, ce), K(me, F, ce), we(F, re, ce), K(ye, F, ce), we(F, ae, ce), K(De, F, ce), we(F, Ee, ce), K(Ie, F, ce), we(F, Ce, ce), K(ze, F, ce), we(F, Fe, ce), K(W, F, ce), we(F, G, ce), K(se, F, ce), we(F, _e, ce), K(ve, F, ce), we(F, ue, ce), K(Te, F, ce), we(F, Ge, ce), K(Pe, F, ce), we(F, he, ce), K(Se, F, ce), we(F, Ve, ce), K(Ye, F, ce), we(F, $e, ce), K(Ne, F, ce), we(F, He, ce), K(Qe, F, ce), we(F, Ze, ce), K(Ke, F, ce), we(F, $, ce), K(ge, F, ce), we(F, be, ce), K(Ue, F, ce), we(F, je, ce), K(it, F, ce), we(F, nt, ce), K(mt, F, ce), we(F, bt, ce), K(Xe, F, ce), we(F, dt, ce), K(at, F, ce), we(F, At, ce), K(It, F, ce), we(F, Qt, ce), K(Tt, F, ce), we(F, $t, ce), K(Jt, F, ce), we(F, on, ce), K(Wt, F, ce), we(F, an, ce), K(Mn, F, ce), we(F, Zn, ce), K(ie, F, ce), we(F, Be, ce), K(Oe, F, ce), Le = !0;
    },
    p(F, ce) {
      const ct = {};
      ce & /*$$scope*/
      512 && (ct.$$scope = { dirty: ce, ctx: F }), e.$set(ct);
      const ut = {};
      ce & /*$$scope*/
      512 && (ut.$$scope = { dirty: ce, ctx: F }), n.$set(ut);
      const pt = {};
      ce & /*$$scope*/
      512 && (pt.$$scope = { dirty: ce, ctx: F }), r.$set(pt);
      const Bt = {};
      ce & /*$$scope*/
      512 && (Bt.$$scope = { dirty: ce, ctx: F }), o.$set(Bt);
      const qe = {};
      ce & /*$$scope*/
      512 && (qe.$$scope = { dirty: ce, ctx: F }), c.$set(qe);
      const Lt = {};
      ce & /*$$scope*/
      512 && (Lt.$$scope = { dirty: ce, ctx: F }), f.$set(Lt);
      const pn = {};
      ce & /*$$scope*/
      512 && (pn.$$scope = { dirty: ce, ctx: F }), d.$set(pn);
      const mn = {};
      ce & /*$$scope*/
      512 && (mn.$$scope = { dirty: ce, ctx: F }), _.$set(mn);
      const _n = {};
      ce & /*$$scope*/
      512 && (_n.$$scope = { dirty: ce, ctx: F }), A.$set(_n);
      const pi = {};
      ce & /*$$scope*/
      512 && (pi.$$scope = { dirty: ce, ctx: F }), y.$set(pi);
      const zt = {};
      ce & /*$$scope*/
      512 && (zt.$$scope = { dirty: ce, ctx: F }), E.$set(zt);
      const vt = {};
      ce & /*$$scope*/
      512 && (vt.$$scope = { dirty: ce, ctx: F }), C.$set(vt);
      const Ei = {};
      ce & /*$$scope*/
      512 && (Ei.$$scope = { dirty: ce, ctx: F }), T.$set(Ei);
      const sn = {};
      ce & /*$$scope*/
      512 && (sn.$$scope = { dirty: ce, ctx: F }), D.$set(sn);
      const li = {};
      ce & /*$$scope*/
      512 && (li.$$scope = { dirty: ce, ctx: F }), P.$set(li);
      const Hr = {};
      ce & /*$$scope*/
      512 && (Hr.$$scope = { dirty: ce, ctx: F }), V.$set(Hr);
      const ci = {};
      ce & /*$$scope*/
      512 && (ci.$$scope = { dirty: ce, ctx: F }), Q.$set(ci);
      const Cr = {};
      ce & /*$$scope*/
      512 && (Cr.$$scope = { dirty: ce, ctx: F }), oe.$set(Cr);
      const gn = {};
      ce & /*$$scope*/
      512 && (gn.$$scope = { dirty: ce, ctx: F }), k.$set(gn);
      const ui = {};
      ce & /*$$scope*/
      512 && (ui.$$scope = { dirty: ce, ctx: F }), fe.$set(ui);
      const Oi = {};
      ce & /*$$scope*/
      512 && (Oi.$$scope = { dirty: ce, ctx: F }), j.$set(Oi);
      const Nn = {};
      ce & /*$$scope*/
      512 && (Nn.$$scope = { dirty: ce, ctx: F }), Y.$set(Nn);
      const fr = {};
      ce & /*$$scope*/
      512 && (fr.$$scope = { dirty: ce, ctx: F }), me.$set(fr);
      const jr = {};
      ce & /*$$scope*/
      512 && (jr.$$scope = { dirty: ce, ctx: F }), ye.$set(jr);
      const ei = {};
      ce & /*$$scope*/
      512 && (ei.$$scope = { dirty: ce, ctx: F }), De.$set(ei);
      const Ma = {};
      ce & /*$$scope*/
      512 && (Ma.$$scope = { dirty: ce, ctx: F }), Ie.$set(Ma);
      const fs = {};
      ce & /*$$scope*/
      512 && (fs.$$scope = { dirty: ce, ctx: F }), ze.$set(fs);
      const Wr = {};
      ce & /*$$scope*/
      512 && (Wr.$$scope = { dirty: ce, ctx: F }), W.$set(Wr);
      const Eo = {};
      ce & /*$$scope*/
      512 && (Eo.$$scope = { dirty: ce, ctx: F }), se.$set(Eo);
      const Zi = {};
      ce & /*$$scope*/
      512 && (Zi.$$scope = { dirty: ce, ctx: F }), ve.$set(Zi);
      const mi = {};
      ce & /*$$scope*/
      512 && (mi.$$scope = { dirty: ce, ctx: F }), Te.$set(mi);
      const er = {};
      ce & /*$$scope*/
      512 && (er.$$scope = { dirty: ce, ctx: F }), Pe.$set(er);
      const Sr = {};
      ce & /*$$scope*/
      512 && (Sr.$$scope = { dirty: ce, ctx: F }), Se.$set(Sr);
      const Fs = {};
      ce & /*$$scope*/
      512 && (Fs.$$scope = { dirty: ce, ctx: F }), Ye.$set(Fs);
      const Mr = {};
      ce & /*$$scope*/
      512 && (Mr.$$scope = { dirty: ce, ctx: F }), Ne.$set(Mr);
      const hr = {};
      ce & /*$$scope*/
      512 && (hr.$$scope = { dirty: ce, ctx: F }), Qe.$set(hr);
      const Co = {};
      ce & /*$$scope*/
      512 && (Co.$$scope = { dirty: ce, ctx: F }), Ke.$set(Co);
      const tr = {};
      ce & /*$$scope*/
      512 && (tr.$$scope = { dirty: ce, ctx: F }), ge.$set(tr);
      const dr = {};
      ce & /*$$scope*/
      512 && (dr.$$scope = { dirty: ce, ctx: F }), Ue.$set(dr);
      const Ir = {};
      ce & /*$$scope*/
      512 && (Ir.$$scope = { dirty: ce, ctx: F }), it.$set(Ir);
      const Tr = {};
      ce & /*$$scope*/
      512 && (Tr.$$scope = { dirty: ce, ctx: F }), mt.$set(Tr);
      const Os = {};
      ce & /*$$scope*/
      512 && (Os.$$scope = { dirty: ce, ctx: F }), Xe.$set(Os);
      const qr = {};
      ce & /*$$scope*/
      512 && (qr.$$scope = { dirty: ce, ctx: F }), at.$set(qr);
      const Br = {};
      ce & /*$$scope*/
      512 && (Br.$$scope = { dirty: ce, ctx: F }), It.$set(Br);
      const Ns = {};
      ce & /*$$scope*/
      512 && (Ns.$$scope = { dirty: ce, ctx: F }), Tt.$set(Ns);
      const Gs = {};
      ce & /*$$scope*/
      512 && (Gs.$$scope = { dirty: ce, ctx: F }), Jt.$set(Gs);
      const Xr = {};
      ce & /*$$scope*/
      512 && (Xr.$$scope = { dirty: ce, ctx: F }), Wt.$set(Xr);
      const Qs = {};
      ce & /*$$scope*/
      512 && (Qs.$$scope = { dirty: ce, ctx: F }), Mn.$set(Qs);
      const So = {};
      ce & /*$$scope*/
      512 && (So.$$scope = { dirty: ce, ctx: F }), ie.$set(So);
      const Ci = {};
      ce & /*$$scope*/
      512 && (Ci.$$scope = { dirty: ce, ctx: F }), Oe.$set(Ci);
    },
    i(F) {
      Le || (O(e.$$.fragment, F), O(n.$$.fragment, F), O(r.$$.fragment, F), O(o.$$.fragment, F), O(c.$$.fragment, F), O(f.$$.fragment, F), O(d.$$.fragment, F), O(_.$$.fragment, F), O(A.$$.fragment, F), O(y.$$.fragment, F), O(E.$$.fragment, F), O(C.$$.fragment, F), O(T.$$.fragment, F), O(D.$$.fragment, F), O(P.$$.fragment, F), O(V.$$.fragment, F), O(Q.$$.fragment, F), O(oe.$$.fragment, F), O(k.$$.fragment, F), O(fe.$$.fragment, F), O(j.$$.fragment, F), O(Y.$$.fragment, F), O(me.$$.fragment, F), O(ye.$$.fragment, F), O(De.$$.fragment, F), O(Ie.$$.fragment, F), O(ze.$$.fragment, F), O(W.$$.fragment, F), O(se.$$.fragment, F), O(ve.$$.fragment, F), O(Te.$$.fragment, F), O(Pe.$$.fragment, F), O(Se.$$.fragment, F), O(Ye.$$.fragment, F), O(Ne.$$.fragment, F), O(Qe.$$.fragment, F), O(Ke.$$.fragment, F), O(ge.$$.fragment, F), O(Ue.$$.fragment, F), O(it.$$.fragment, F), O(mt.$$.fragment, F), O(Xe.$$.fragment, F), O(at.$$.fragment, F), O(It.$$.fragment, F), O(Tt.$$.fragment, F), O(Jt.$$.fragment, F), O(Wt.$$.fragment, F), O(Mn.$$.fragment, F), O(ie.$$.fragment, F), O(Oe.$$.fragment, F), Le = !0);
    },
    o(F) {
      N(e.$$.fragment, F), N(n.$$.fragment, F), N(r.$$.fragment, F), N(o.$$.fragment, F), N(c.$$.fragment, F), N(f.$$.fragment, F), N(d.$$.fragment, F), N(_.$$.fragment, F), N(A.$$.fragment, F), N(y.$$.fragment, F), N(E.$$.fragment, F), N(C.$$.fragment, F), N(T.$$.fragment, F), N(D.$$.fragment, F), N(P.$$.fragment, F), N(V.$$.fragment, F), N(Q.$$.fragment, F), N(oe.$$.fragment, F), N(k.$$.fragment, F), N(fe.$$.fragment, F), N(j.$$.fragment, F), N(Y.$$.fragment, F), N(me.$$.fragment, F), N(ye.$$.fragment, F), N(De.$$.fragment, F), N(Ie.$$.fragment, F), N(ze.$$.fragment, F), N(W.$$.fragment, F), N(se.$$.fragment, F), N(ve.$$.fragment, F), N(Te.$$.fragment, F), N(Pe.$$.fragment, F), N(Se.$$.fragment, F), N(Ye.$$.fragment, F), N(Ne.$$.fragment, F), N(Qe.$$.fragment, F), N(Ke.$$.fragment, F), N(ge.$$.fragment, F), N(Ue.$$.fragment, F), N(it.$$.fragment, F), N(mt.$$.fragment, F), N(Xe.$$.fragment, F), N(at.$$.fragment, F), N(It.$$.fragment, F), N(Tt.$$.fragment, F), N(Jt.$$.fragment, F), N(Wt.$$.fragment, F), N(Mn.$$.fragment, F), N(ie.$$.fragment, F), N(Oe.$$.fragment, F), Le = !1;
    },
    d(F) {
      F && (xe(t), xe(i), xe(a), xe(l), xe(u), xe(h), xe(m), xe(g), xe(v), xe(w), xe(I), xe(B), xe(S), xe(R), xe(L), xe(U), xe(q), xe(le), xe(X), xe(te), xe(Ae), xe(pe), xe(re), xe(ae), xe(Ee), xe(Ce), xe(Fe), xe(G), xe(_e), xe(ue), xe(Ge), xe(he), xe(Ve), xe($e), xe(He), xe(Ze), xe($), xe(be), xe(je), xe(nt), xe(bt), xe(dt), xe(At), xe(Qt), xe($t), xe(on), xe(an), xe(Zn), xe(Be)), J(e, F), J(n, F), J(r, F), J(o, F), J(c, F), J(f, F), J(d, F), J(_, F), J(A, F), J(y, F), J(E, F), J(C, F), J(T, F), J(D, F), J(P, F), J(V, F), J(Q, F), J(oe, F), J(k, F), J(fe, F), J(j, F), J(Y, F), J(me, F), J(ye, F), J(De, F), J(Ie, F), J(ze, F), J(W, F), J(se, F), J(ve, F), J(Te, F), J(Pe, F), J(Se, F), J(Ye, F), J(Ne, F), J(Qe, F), J(Ke, F), J(ge, F), J(Ue, F), J(it, F), J(mt, F), J(Xe, F), J(at, F), J(It, F), J(Tt, F), J(Jt, F), J(Wt, F), J(Mn, F), J(ie, F), J(Oe, F);
    }
  };
}
function dV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "sketchfabtimeframe",
      $$slots: { default: [hV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function pV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      name: "Sketchfab_model",
      rotation: [-Math.PI / 2, 0, 0],
      $$slots: { default: [dV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function mV(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].fallback
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[9],
    l1
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? xt(
          t,
          /*$$scope*/
          i[9],
          r,
          Az
        ) : Et(
          /*$$scope*/
          i[9]
        ),
        l1
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function gV(s) {
  let e, t, n = {
    ctx: s,
    current: null,
    token: null,
    hasCatch: !0,
    pending: mV,
    then: bz,
    catch: _z,
    value: 4,
    error: 10,
    blocks: [, , ,]
  };
  rA(
    /*gltf*/
    s[4],
    n
  );
  const i = (
    /*#slots*/
    s[7].default
  ), r = yt(
    i,
    s,
    /*$$scope*/
    s[9],
    o1
  );
  return {
    c() {
      n.block.c(), e = Me(), r && r.c();
    },
    m(a, o) {
      n.block.m(a, n.anchor = o), n.mount = () => e.parentNode, n.anchor = e, we(a, e, o), r && r.m(a, o), t = !0;
    },
    p(a, o) {
      s = a, sA(n, s, o), r && r.p && (!t || o & /*$$scope*/
      512) && wt(
        r,
        i,
        s,
        /*$$scope*/
        s[9],
        t ? xt(
          i,
          /*$$scope*/
          s[9],
          o,
          mz
        ) : Et(
          /*$$scope*/
          s[9]
        ),
        o1
      );
    },
    i(a) {
      t || (O(n.block), O(r, a), t = !0);
    },
    o(a) {
      for (let o = 0; o < 3; o += 1) {
        const l = n.blocks[o];
        N(l);
      }
      N(r, a), t = !1;
    },
    d(a) {
      a && xe(e), n.block.d(a), n.token = null, n = null, r && r.d(a);
    }
  };
}
function AV(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    { dispose: !1 },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [gV] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[8](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        n[1],
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope*/
      512 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), J(e, r);
    }
  };
}
function _V(s, e, t) {
  const n = ["ref", "actions", "mixer"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e;
  const l = new Xn(), c = Ud("/src/assets/scene.gltf"), { actions: u, mixer: f } = fk(c, l), h = An();
  lt(s, h, (m) => t(1, r = m));
  function d(m) {
    Ut[m ? "unshift" : "push"](() => {
      r = m, h.set(r);
    });
  }
  return s.$$set = (m) => {
    e = We(We({}, e), rn(m)), t(3, i = ft(e, n)), "$$scope" in m && t(9, o = m.$$scope);
  }, [
    l,
    r,
    h,
    i,
    c,
    u,
    f,
    a,
    d,
    o
  ];
}
class bV extends Mt {
  constructor(e) {
    super(), Ct(this, e, _V, AV, _t, { ref: 0, actions: 5, mixer: 6 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get actions() {
    return this.$$.ctx[5];
  }
  get mixer() {
    return this.$$.ctx[6];
  }
}
St(bV, {}, ["fallback", "error", "default"], ["ref", "actions", "mixer"], !0);
const vV = (s) => ({}), c1 = (s) => ({ ref: (
  /*ref*/
  s[0]
) }), yV = (s) => ({}), u1 = (s) => ({ error: (
  /*error*/
  s[8]
) }), xV = (s) => ({}), f1 = (s) => ({});
function wV(s) {
  let e;
  const t = (
    /*#slots*/
    s[5].error
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    u1
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      128) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          yV
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        u1
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function EV(s) {
  let e, t;
  return e = new ee.Mesh({
    props: {
      geometry: (
        /*gltf*/
        s[4].nodes.Object_2.geometry
      ),
      material: (
        /*gltf*/
        s[4].materials["Material.001"]
      ),
      rotation: [-Math.PI / 2, 0, 0]
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p: rt,
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function CV(s) {
  let e;
  const t = (
    /*#slots*/
    s[5].fallback
  ), n = yt(
    t,
    s,
    /*$$scope*/
    s[7],
    f1
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      128) && wt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? xt(
          t,
          /*$$scope*/
          i[7],
          r,
          xV
        ) : Et(
          /*$$scope*/
          i[7]
        ),
        f1
      );
    },
    i(i) {
      e || (O(n, i), e = !0);
    },
    o(i) {
      N(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function SV(s) {
  let e, t, n = {
    ctx: s,
    current: null,
    token: null,
    hasCatch: !0,
    pending: CV,
    then: EV,
    catch: wV,
    value: 4,
    error: 8,
    blocks: [, , ,]
  };
  rA(
    /*gltf*/
    s[4],
    n
  );
  const i = (
    /*#slots*/
    s[5].default
  ), r = yt(
    i,
    s,
    /*$$scope*/
    s[7],
    c1
  );
  return {
    c() {
      n.block.c(), e = Me(), r && r.c();
    },
    m(a, o) {
      n.block.m(a, n.anchor = o), n.mount = () => e.parentNode, n.anchor = e, we(a, e, o), r && r.m(a, o), t = !0;
    },
    p(a, o) {
      s = a, sA(n, s, o), r && r.p && (!t || o & /*$$scope*/
      128) && wt(
        r,
        i,
        s,
        /*$$scope*/
        s[7],
        t ? xt(
          i,
          /*$$scope*/
          s[7],
          o,
          vV
        ) : Et(
          /*$$scope*/
          s[7]
        ),
        c1
      );
    },
    i(a) {
      t || (O(n.block), O(r, a), t = !0);
    },
    o(a) {
      for (let o = 0; o < 3; o += 1) {
        const l = n.blocks[o];
        N(l);
      }
      N(r, a), t = !1;
    },
    d(a) {
      a && xe(e), n.block.d(a), n.token = null, n = null, r && r.d(a);
    }
  };
}
function MV(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    { dispose: !1 },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [SV] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[6](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? jt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        n[1],
        a & /*$$restProps*/
        8 && Kt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope*/
      128 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[6](null), J(e, r);
    }
  };
}
function IV(s, e, t) {
  const n = ["ref"];
  let i = ft(e, n), r, { $$slots: a = {}, $$scope: o } = e;
  const l = new Xn(), c = Ud("/src/assets/solar_impulse_flight_path/scene.gltf"), u = An();
  lt(s, u, (h) => t(1, r = h));
  function f(h) {
    Ut[h ? "unshift" : "push"](() => {
      r = h, u.set(r);
    });
  }
  return s.$$set = (h) => {
    e = We(We({}, e), rn(h)), t(3, i = ft(e, n)), "$$scope" in h && t(7, o = h.$$scope);
  }, [l, r, u, i, c, a, f, o];
}
class TV extends Mt {
  constructor(e) {
    super(), Ct(this, e, IV, MV, _t, { ref: 0 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
St(TV, {}, ["fallback", "error", "default"], ["ref"], !0);
function h1(s) {
  return Object.prototype.toString.call(s) === "[object Date]";
}
function iA(s, e, t, n) {
  if (typeof t == "number" || h1(t)) {
    const i = n - t, r = (t - e) / (s.dt || 1 / 60), a = s.opts.stiffness * i, o = s.opts.damping * r, l = (a - o) * s.inv_mass, c = (r + l) * s.dt;
    return Math.abs(c) < s.opts.precision && Math.abs(i) < s.opts.precision ? n : (s.settled = !1, h1(t) ? new Date(t.getTime() + c) : t + c);
  } else {
    if (Array.isArray(t))
      return t.map(
        (i, r) => iA(s, e[r], t[r], n[r])
      );
    if (typeof t == "object") {
      const i = {};
      for (const r in t)
        i[r] = iA(s, e[r], t[r], n[r]);
      return i;
    } else
      throw new Error(`Cannot spring ${typeof t} values`);
  }
}
function BV(s, e = {}) {
  const t = Ft(s), { stiffness: n = 0.15, damping: i = 0.8, precision: r = 0.01 } = e;
  let a, o, l, c = s, u = s, f = 1, h = 0, d = !1;
  function m(g, A = {}) {
    u = g;
    const v = l = {};
    return s == null || A.hard || _.stiffness >= 1 && _.damping >= 1 ? (d = !0, a = i_(), c = g, t.set(s = u), Promise.resolve()) : (A.soft && (h = 1 / ((A.soft === !0 ? 0.5 : +A.soft) * 60), f = 0), o || (a = i_(), d = !1, o = CM((y) => {
      if (d)
        return d = !1, o = null, !1;
      f = Math.min(f + h, 1);
      const w = {
        inv_mass: f,
        opts: _,
        settled: !0,
        dt: (y - a) * 60 / 1e3
      }, E = iA(w, c, s, u);
      return a = y, c = s, t.set(s = E), w.settled && (o = null), !w.settled;
    })), new Promise((y) => {
      o.promise.then(() => {
        v === l && y();
      });
    }));
  }
  const _ = {
    set: m,
    update: (g, A) => m(g(u, s), A),
    subscribe: t.subscribe,
    stiffness: n,
    damping: i,
    precision: r
  };
  return _;
}
const PV = (s) => ({}), d1 = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function p1(s) {
  let e, t;
  const n = [
    { type: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[5]
  ];
  let i = {
    $$slots: { default: [LV] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = We(i, n[r]);
  return e = new ee({ props: i }), s[7](e), {
    c() {
      Z(e.$$.fragment);
    },
    m(r, a) {
      K(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*ref, $$restProps*/
      33 ? jt(n, [
        a & /*ref*/
        1 && { type: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        32 && Kt(
          /*$$restProps*/
          r[5]
        )
      ]) : {};
      a & /*$$scope, $gltf*/
      258 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (O(e.$$.fragment, r), t = !0);
    },
    o(r) {
      N(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[7](null), J(e, r);
    }
  };
}
function RV(s) {
  let e, t;
  return e = new ee.Mesh({
    props: {
      geometry: (
        /*$gltf*/
        s[1].nodes.Earth_Surfacemat_0.geometry
      ),
      material: (
        /*$gltf*/
        s[1].materials["Surface.mat"]
      ),
      scale: 100
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$gltf*/
      2 && (r.geometry = /*$gltf*/
      n[1].nodes.Earth_Surfacemat_0.geometry), i & /*$gltf*/
      2 && (r.material = /*$gltf*/
      n[1].materials["Surface.mat"]), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function DV(s) {
  let e, t;
  return e = new ee.Group({
    props: {
      rotation: [Math.PI / 2, 0, 0],
      $$slots: { default: [RV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, $gltf*/
      258 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function LV(s) {
  let e, t, n;
  e = new ee.Group({
    props: {
      rotation: [-Math.PI / 2, 0, 0],
      scale: 0,
      $$slots: { default: [DV] },
      $$scope: { ctx: s }
    }
  });
  const i = (
    /*#slots*/
    s[6].default
  ), r = yt(
    i,
    s,
    /*$$scope*/
    s[8],
    d1
  );
  return {
    c() {
      Z(e.$$.fragment), t = Me(), r && r.c();
    },
    m(a, o) {
      K(e, a, o), we(a, t, o), r && r.m(a, o), n = !0;
    },
    p(a, o) {
      const l = {};
      o & /*$$scope, $gltf*/
      258 && (l.$$scope = { dirty: o, ctx: a }), e.$set(l), r && r.p && (!n || o & /*$$scope*/
      256) && wt(
        r,
        i,
        a,
        /*$$scope*/
        a[8],
        n ? xt(
          i,
          /*$$scope*/
          a[8],
          o,
          PV
        ) : Et(
          /*$$scope*/
          a[8]
        ),
        d1
      );
    },
    i(a) {
      n || (O(e.$$.fragment, a), O(r, a), n = !0);
    },
    o(a) {
      N(e.$$.fragment, a), N(r, a), n = !1;
    },
    d(a) {
      a && xe(t), J(e, a), r && r.d(a);
    }
  };
}
function kV(s) {
  let e, t, n = (
    /*$gltf*/
    s[1] && p1(s)
  );
  return {
    c() {
      n && n.c(), e = ji();
    },
    m(i, r) {
      n && n.m(i, r), we(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*$gltf*/
      i[1] ? n ? (n.p(i, r), r & /*$gltf*/
      2 && O(n, 1)) : (n = p1(i), n.c(), O(n, 1), n.m(e.parentNode, e)) : n && (Li(), N(n, 1, 1, () => {
        n = null;
      }), ki());
    },
    i(i) {
      t || (O(n), t = !0);
    },
    o(i) {
      N(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function UV(s, e, t) {
  const n = ["ref"];
  let i = ft(e, n), r, a, { $$slots: o = {}, $$scope: l } = e;
  const c = new Xn(), { gltf: u } = Ud("/src/assets/around_the_world_in_80_models_posts.glb");
  lt(s, u, (d) => t(1, r = d));
  const f = An();
  lt(s, f, (d) => t(2, a = d));
  function h(d) {
    Ut[d ? "unshift" : "push"](() => {
      a = d, f.set(a);
    });
  }
  return s.$$set = (d) => {
    e = We(We({}, e), rn(d)), t(5, i = ft(e, n)), "$$scope" in d && t(8, l = d.$$scope);
  }, [
    c,
    r,
    a,
    u,
    f,
    i,
    o,
    h,
    l
  ];
}
class iC extends Mt {
  constructor(e) {
    super(), Ct(this, e, UV, kV, _t, { ref: 0 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
St(iC, {}, ["default"], ["ref"], !0);
function FV(s) {
  let e, t;
  return e = new pE({
    props: { enableDamping: !0, target: [0, 0, 0] }
  }), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    p: rt,
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function OV(s) {
  let e, t, n, i, r, a;
  return e = new ee.PerspectiveCamera({
    props: {
      makeDefault: !0,
      position: [6, 0, 0],
      fov: 20,
      $$slots: { default: [FV] },
      $$scope: { ctx: s }
    }
  }), n = new ee.DirectionalLight({
    props: {
      intensity: 1,
      position: [0, 1, 0],
      "shadow-bias": -1e-4
    }
  }), r = new iC({
    props: {
      scale: 10,
      position: [0, 0, 0],
      "rotation.y": (
        /*rotation*/
        s[0]
      )
    }
  }), r.$on(
    "pointerenter",
    /*pointerenter_handler*/
    s[2]
  ), r.$on(
    "pointerleave",
    /*pointerleave_handler*/
    s[3]
  ), {
    c() {
      Z(e.$$.fragment), t = Me(), Z(n.$$.fragment), i = Me(), Z(r.$$.fragment);
    },
    m(o, l) {
      K(e, o, l), we(o, t, l), K(n, o, l), we(o, i, l), K(r, o, l), a = !0;
    },
    p(o, [l]) {
      const c = {};
      l & /*$$scope*/
      16 && (c.$$scope = { dirty: l, ctx: o }), e.$set(c);
      const u = {};
      l & /*rotation*/
      1 && (u["rotation.y"] = /*rotation*/
      o[0]), r.$set(u);
    },
    i(o) {
      a || (O(e.$$.fragment, o), O(n.$$.fragment, o), O(r.$$.fragment, o), a = !0);
    },
    o(o) {
      N(e.$$.fragment, o), N(n.$$.fragment, o), N(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), J(e, o), J(n, o), J(r, o);
    }
  };
}
function NV(s, e, t) {
  let n = 0;
  On((o) => {
    t(0, n += o * 0.1);
  }), vQ();
  const i = BV(1);
  return console.log("---> Scene.svelte"), [n, i, () => i.set(1.5), () => i.set(1)];
}
class rC extends Mt {
  constructor(e) {
    super(), Ct(this, e, NV, OV, _t, {});
  }
}
St(rC, {}, [], [], !0);
function GV(s) {
  v1(s, "rf-hskwq6", "div.rf-hskwq6{width:100%;height:100vh}");
}
function QV(s) {
  let e, t;
  return e = new rC({}), {
    c() {
      Z(e.$$.fragment);
    },
    m(n, i) {
      K(e, n, i), t = !0;
    },
    i(n) {
      t || (O(e.$$.fragment, n), t = !0);
    },
    o(n) {
      N(e.$$.fragment, n), t = !1;
    },
    d(n) {
      J(e, n);
    }
  };
}
function zV(s) {
  let e, t, n;
  return t = new Nw({
    props: {
      $$slots: { default: [QV] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      e = Rs("div"), Z(t.$$.fragment), Fr(e, "class", "rf-hskwq6");
    },
    m(i, r) {
      we(i, e, r), K(t, e, null), n = !0;
    },
    p(i, [r]) {
      const a = {};
      r & /*$$scope*/
      1 && (a.$$scope = { dirty: r, ctx: i }), t.$set(a);
    },
    i(i) {
      n || (O(t.$$.fragment, i), n = !0);
    },
    o(i) {
      N(t.$$.fragment, i), n = !1;
    },
    d(i) {
      i && xe(e), J(t);
    }
  };
}
function $V(s) {
  return console.log("---> PlanetModel.svelte"), [];
}
class VV extends Mt {
  constructor(e) {
    super(), Ct(this, e, $V, zV, _t, {}, GV);
  }
}
customElements.define("planet-model", St(VV, {}, [], [], !0));
